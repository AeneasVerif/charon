//! Implementations for [crate::ullbc_ast]
use crate::ids::Vector;
use crate::meta::Span;
use crate::ullbc_ast::*;
use take_mut::take;

impl SwitchTargets {
    pub fn get_targets(&self) -> Vec<BlockId> {
        match self {
            SwitchTargets::If(then_tgt, else_tgt) => {
                vec![*then_tgt, *else_tgt]
            }
            SwitchTargets::SwitchInt(_, targets, otherwise) => {
                let mut all_targets = vec![];
                for (_, target) in targets {
                    all_targets.push(*target);
                }
                all_targets.push(*otherwise);
                all_targets
            }
        }
    }
}

impl Statement {
    pub fn new(span: Span, content: RawStatement) -> Self {
        Statement { span, content }
    }
}

impl Terminator {
    pub fn new(span: Span, content: RawTerminator) -> Self {
        Terminator { span, content }
    }
}

impl BlockData {
    /// Visit the operands in an rvalue and generate statements.
    /// Used below in [BlockData::transform_operands].
    /// TODO: use visitors
    fn transform_rvalue_operands<F: FnMut(&Span, &mut Vec<Statement>, &mut Operand)>(
        span: &Span,
        nst: &mut Vec<Statement>,
        rval: &mut Rvalue,
        f: &mut F,
    ) {
        match rval {
            Rvalue::Use(op) | Rvalue::UnaryOp(_, op) => f(span, nst, op),
            Rvalue::BinaryOp(_, o1, o2) => {
                f(span, nst, o1);
                f(span, nst, o2);
            }
            Rvalue::Aggregate(_, ops) => {
                for op in ops {
                    f(span, nst, op);
                }
            }
            Rvalue::Repeat(op, _, _) => {
                f(span, nst, op);
            }
            Rvalue::Global(..) | Rvalue::Discriminant(..) | Rvalue::Ref(_, _) | Rvalue::Len(..) => {
                // No operands: nothing to do
            }
        }
    }

    /// See [body_transform_operands]
    pub fn transform_operands<F: FnMut(&Span, &mut Vec<Statement>, &mut Operand)>(
        mut self,
        f: &mut F,
    ) -> Self {
        // The new vector of statements
        let mut nst = vec![];

        // Explore the operands in the statements
        for mut st in self.statements {
            let span = &st.span;
            match &mut st.content {
                RawStatement::Assign(_, rvalue) => {
                    BlockData::transform_rvalue_operands(span, &mut nst, rvalue, f);
                }
                RawStatement::FakeRead(_)
                | RawStatement::SetDiscriminant(_, _)
                | RawStatement::StorageDead(_)
                | RawStatement::Deinit(_)
                | RawStatement::Error(_) => {
                    // No operands: nothing to do
                }
            }
            // Add the statement to the vector of statements
            nst.push(st)
        }

        // Explore the terminator
        let span = &self.terminator.span;
        match &mut self.terminator.content {
            RawTerminator::Switch { discr, targets: _ } => {
                f(span, &mut nst, discr);
            }
            RawTerminator::Call { call, target: _ } => {
                for arg in &mut call.args {
                    f(span, &mut nst, arg);
                }
            }
            RawTerminator::Assert {
                cond,
                expected: _,
                target: _,
            } => {
                f(span, &mut nst, cond);
            }
            RawTerminator::Abort(..)
            | RawTerminator::Return
            | RawTerminator::Goto { .. }
            | RawTerminator::Drop { .. } => {
                // Nothing to do
            }
        };

        // Update the vector of statements
        self.statements = nst;

        // Return
        self
    }
}

/// Transform a body by applying a function to its operands, and
/// inserting the statements generated by the operands at the end of the
/// block.
/// Useful to implement a pass on operands (see e.g., [crate::extract_global_assignments]).
///
/// The span argument given to `f` is the span argument of the [Terminator]
/// containing the operand. `f` should explore the operand it receives, and
/// push statements to the vector it receives as input.
pub fn body_transform_operands<F: FnMut(&Span, &mut Vec<Statement>, &mut Operand)>(
    blocks: &mut Vector<BlockId, BlockData>,
    f: &mut F,
) {
    for block in blocks.iter_mut() {
        take(block, |b| b.transform_operands(f));
    }
}
