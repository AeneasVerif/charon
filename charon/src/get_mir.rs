//! Various utilities to load MIR.
//! Allow to easily load the MIR code generated by a specific pass.

use rustc_hir::def_id::{DefId, LocalDefId};
use rustc_middle::mir::Body;
use rustc_middle::ty::TyCtxt;

/// TODO: maybe we should always target MIR Built, this would make things
/// simpler. In particular, the MIR optimized is very low level and
/// reveals too many types and data-structures that we don't want to manipulate.
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum MirLevel {
    /// Original MIR, directly translated from HIR.
    Built,
    /// Not sure what this is. Not well tested.
    Promoted,
    /// MIR after optimization passes. The last one before codegen.
    Optimized,
}

/// Indicates if the constants should be extracted in their own identifier,
/// or if they must be evaluated to a constant value, depending on the
/// MIR level which we extract.
pub fn extract_constants_at_top_level(level: MirLevel) -> bool {
    match level {
        MirLevel::Built => true,
        MirLevel::Promoted => true,
        MirLevel::Optimized => false,
    }
}

/// Are boxe manipulations desugared to very low-level code using raw pointers,
/// unique and non-null pointers? See [crate::types::Ty::RawPtr] for detailed explanations.
pub fn boxes_are_desugared(level: MirLevel) -> bool {
    match level {
        MirLevel::Built => false,
        MirLevel::Promoted => false,
        MirLevel::Optimized => true,
    }
}

/// Query the MIR for a function at a specific level
pub fn get_mir_for_def_id_and_level(
    tcx: TyCtxt<'_>,
    def_id: LocalDefId,
    level: MirLevel,
) -> Body<'_> {
    // Below: we **clone** the bodies to make sure we don't have issues with
    // locked values (we had in the past).
    match level {
        MirLevel::Built => {
            let body = tcx.mir_built(def_id);
            // We clone to be sure there are no problems with locked values
            body.borrow().clone()
        }
        MirLevel::Promoted => {
            let (body, _) = tcx.mir_promoted(def_id);
            // We clone to be sure there are no problems with locked values
            body.borrow().clone()
        }
        MirLevel::Optimized => {
            let def_id = DefId {
                krate: rustc_hir::def_id::LOCAL_CRATE,
                index: def_id.local_def_index,
            };
            // We clone to be sure there are no problems with locked values
            tcx.optimized_mir(def_id).clone()
        }
    }
}
