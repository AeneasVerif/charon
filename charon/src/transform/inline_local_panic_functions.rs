//! `panic!()` expands to:
//! ```ignore
//! fn panic_cold_explicit() -> ! {
//!     core::panicking::panic_explicit()
//! }
//! panic_cold_explicit()
//! ```
//! Which defines a new function each time. This pass recognizes these functions and replaces calls
//! to them by a `Panic` terminator.

use std::collections::HashSet;

use super::{ctx::LlbcPass, TransformCtx};
use crate::{
    assumed,
    llbc_ast::{
        AbortKind, Call, FnOperand, FnPtr, FunDeclId, FunId, FunIdOrTraitMethodRef, MutExprVisitor,
        RawStatement, Statement,
    },
    llbc_ast_utils::MutAstVisitor,
    names::Name,
    types_utils::MutTypeVisitor,
};

struct ReplacePanics<'a> {
    fns_to_replace: &'a HashSet<FunDeclId>,
    replace_with_statement: &'a RawStatement,
}

impl MutTypeVisitor for ReplacePanics<'_> {}
impl MutAstVisitor for ReplacePanics<'_> {
    fn visit_statement(&mut self, st: &mut Statement) {
        match &mut st.content {
            RawStatement::Call(Call {
                func:
                    FnOperand::Regular(FnPtr {
                        func: FunIdOrTraitMethodRef::Fun(FunId::Regular(fun_id)),
                        ..
                    }),
                ..
            }) if self.fns_to_replace.contains(fun_id) => {
                st.content = self.replace_with_statement.clone();
            }
            _ => {
                self.default_visit_raw_statement(&mut st.content);
            }
        }
    }
}
impl MutExprVisitor for ReplacePanics<'_> {}

pub struct Transform;
impl LlbcPass for Transform {
    fn transform_ctx(&self, ctx: &mut TransformCtx<'_>) {
        // Collect the functions that were generated by the `panic!` macro.
        let mut panic_fns = HashSet::new();
        ctx.for_each_fun_decl(|_ctx, decl, body| {
            if let Ok(body) = body {
                let body = body.as_structured().unwrap();
                // If the whole body is only a call to this specific panic function.
                if let RawStatement::Abort(AbortKind::Panic(name)) = &body.body.content {
                    if name.equals_ref_name(assumed::EXPLICIT_PANIC_NAME) {
                        // FIXME: also check that the name of the function is
                        // `panic_cold_explicit`?
                        panic_fns.insert(decl.def_id);
                    }
                }
            }
        });

        let panic_name = Name::from_path(assumed::EXPLICIT_PANIC_NAME);
        let panic_statement = RawStatement::Abort(AbortKind::Panic(panic_name));

        // Replace each call to one such function with a `Panic`.
        ctx.for_each_structured_body(|_ctx, body| {
            let mut visitor = ReplacePanics {
                fns_to_replace: &panic_fns,
                replace_with_statement: &panic_statement,
            };
            visitor.visit_statement(&mut body.body);
        });

        // Remove these functions from the context.
        for id in &panic_fns {
            ctx.translated.fun_decls.remove(*id);
        }
    }
}
