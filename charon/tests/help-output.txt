Runs charon on a single rust file (and the modules it references, if any)

Usage: charon rustc [OPTIONS] [-- <RUSTC>...]

Arguments:
  [RUSTC]...
          Args that `rustc` accepts

Options:
      --ullbc
          Extract the unstructured LLBC (i.e., don't reconstruct the control-flow)

      --precise-drops
          Whether to precisely translate drops and drop-related code. For this, we add explicit `Destruct` bounds to all generic parameters, set the MIR level to at least `elaborated`, and attempt to retrieve drop glue for all types.
          
          This option is known to cause panics inside rustc, because their drop handling is not design to work on polymorphic types. To silence the warning, pass appropriate `--opaque '{impl core::marker::Destruct for some::Type}'` options.
          
          Without this option, drops may be "conditional" and we may lack information about what code is run on drop in a given polymorphic function body.

      --skip-borrowck
          If activated, this skips borrow-checking of the crate

      --mir <MIR>
          The MIR stage to extract. This is only relevant for the current crate; for dpendencies only MIR optimized is available

          Possible values:
          - built:      The MIR just after MIR lowering
          - promoted:   The MIR after const promotion. This is the MIR used by the borrow-checker
          - elaborated: The MIR after drop elaboration. This is the first MIR to include all the runtime information
          - optimized:  The MIR after optimizations. Charon disables all the optimizations it can, so this is sensibly the same MIR as the elaborated MIR

      --rustc-arg <RUSTC_ARGS>
          Extra flags to pass to rustc

      --monomorphize
          Monomorphize the items encountered when possible. Generic items found in the crate are skipped. To only translate a particular call graph, use `--start-from`. Note: this doesn't currently support `dyn Trait`
          
          [aliases: --mono]

      --monomorphize-mut[=<INCLUDE_TYPES>]
          Partially monomorphize items to make it so that no item is ever monomorphized with a mutable reference (or type containing one); said differently, so that the presence of mutable references in a type is independent of its generics. This is used by Aeneas

          Possible values:
          - all:          Monomorphize any item instantiated with `&mut`
          - except-types: Monomorphize all non-typedecl items instantiated with `&mut`

      --start-from <START_FROM>
          A list of item paths to use as starting points for the translation. We will translate these items and any items they refer to, according to the opacity rules. When absent, we start from the path `crate` (which translates the whole crate)

      --start-from-attribute[=<ATTRIBUTE>]
          Use all the items annotated with the given attribute as starting points for translation (except modules). If an attribute name is not specified, `verify::start_from` is used

      --start-from-pub
          Use all the `pub` items as starting points for translation (except modules)

      --include <INCLUDE>
          Whitelist of items to translate. These use the name-matcher syntax (note: this differs
          a bit from the ocaml NameMatcher).
          
          Note: This is very rough at the moment. E.g. this parses `u64` as a path instead of the
          built-in type. It is also not possible to filter a trait impl (this will only filter
          its methods). Please report bugs or missing features.
          
          Examples:
            - `crate::module1::module2::item`: refers to this item and all its subitems (e.g.
                submodules or trait methods);
            - `crate::module1::module2::item::_`: refers only to the subitems of this item;
            - `core::convert::{impl core::convert::Into<_> for _}`: retrieve the body of this
                very useful impl;
          
          When multiple patterns in the `--include` and `--opaque` options match the same item,
          the most precise pattern wins. E.g.: `charon --opaque crate::module --include
          crate::module::_` makes the `module` opaque (we won't explore its contents), but the
          items in it transparent (we will translate them if we encounter them.)
          

      --opaque <OPAQUE>
          Blacklist of items to keep opaque. Works just like `--include`, see the doc there

      --exclude <EXCLUDE>
          Blacklist of items to not translate at all. Works just like `--include`, see the doc there

      --extract-opaque-bodies
          Usually we skip the bodies of foreign methods and structs with private fields. When this flag is on, we don't

      --translate-all-methods
          Usually we skip the provided methods that aren't used. When this flag is on, we translate them all

      --remove-associated-types <REMOVE_ASSOCIATED_TYPES>
          Transforma the associate types of traits to be type parameters instead. This takes a list of name patterns of the traits to transform, using the same syntax as `--include`

      --hide-marker-traits
          Whether to hide various marker traits such as `Sized`, `Sync`, `Send` and `Destruct` anywhere they show up. This can considerably speed up translation

      --remove-adt-clauses
          Remove trait clauses from type declarations. Must be combined with `--remove-associated-types` for type declarations that use trait associated types in their fields, otherwise this will result in errors

      --hide-allocator
          Hide the `A` type parameter on standard library containers (`Box`, `Vec`, etc)

      --remove-unused-self-clauses
          Trait method declarations take a `Self: Trait` clause as parameter, so that they can be reused by multiple trait impls. This however causes trait definitions to be mutually recursive with their method declarations. This flag removes `Self` clauses that aren't used to break this mutual recursion when possible

      --desugar-drops
          Transform precise drops to the equivalent `drop_in_place(&raw mut p)` call

      --ops-to-function-calls
          Transform array-to-slice unsizing, repeat expressions, and raw pointer construction into builtin functions in ULLBC

      --index-to-function-calls
          Transform array/slice indexing into builtin functions in ULLBC. Note that this may introduce UB since it creates references that were not normally created, including when indexing behind a raw pointer

      --treat-box-as-builtin
          Treat `Box<T>` as if it was a built-in type

      --raw-consts
          Do not inline or evaluate constants

      --unsized-strings
          Replace string literal constants with a constant u8 array that gets unsized, expliciting the fact a string constant has a hidden reference

      --reconstruct-fallible-operations
          Replace "bound checks followed by UB-on-overflow operation" with the corresponding panic-on-overflow operation. This loses unwinding information

      --reconstruct-asserts
          Replace "if x { panic() }" with "assert(x)"

      --unbind-item-vars
          Use `DeBruijnVar::Free` for the variables bound in item signatures, instead of `DeBruijnVar::Bound` everywhere. This simplifies the management of generics for projects that don't intend to manipulate them too much

      --print-original-ullbc
          Pretty-print the ULLBC immediately after extraction from MIR

      --print-ullbc
          Pretty-print the ULLBC after applying the micro-passes (before serialization/control-flow reconstruction)

      --print-built-llbc
          Pretty-print the LLBC just after we built it (i.e., immediately after loop reconstruction)

      --print-llbc
          Pretty-print the final LLBC (after all the cleaning micro-passes)

      --dest <DEST_DIR>
          The destination directory. Files will be generated as `<dest_dir>/<crate_name>.{u}llbc`, unless `dest_file` is set. `dest_dir` defaults to the current directory

      --dest-file <DEST_FILE>
          The destination file. By default `<dest_dir>/<crate_name>.llbc`. If this is set we ignore `dest_dir`

      --no-dedup-serialized-ast
          Don't deduplicate values (types, trait refs) in the .(u)llbc file. This makes the file easier to inspect

      --no-serialize
          Don't serialize the final (U)LLBC to a file

      --abort-on-error
          Panic on the first error. This is useful for debugging

      --error-on-warnings
          Consider any warnings to be errors

      --preset <PRESET>
          Named builtin sets of options

          Possible values:
          - old-defaults: The default translation used before May 2025. After that, many passes were made optional and disabled by default
          - raw-mir:      Emit the MIR as unmodified as possible. This is very imperfect for now, we should make more passes optional
          - aeneas
          - eurydice
          - soteria
          - tests

  -h, --help
          Print help (see a summary with '-h')
