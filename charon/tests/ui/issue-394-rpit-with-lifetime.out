# Final LLBC before serialization:

#[lang_item("sized")]
pub trait core::marker::Sized<Self>

pub opaque type core::iter::sources::from_fn::FromFn<F>
  where
      [@TraitClause0]: core::marker::Sized<F>,

#[lang_item("Option")]
pub enum core::option::Option<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,
 =
|  None()
|  Some(T)


struct test_crate::sparse_transitions::closure<'a> = {}

#[lang_item("tuple_trait")]
pub trait core::marker::Tuple<Self>

#[lang_item("fn_once")]
pub trait core::ops::function::FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: core::marker::Sized<Args>
    parent_clause1 : [@TraitClause1]: core::marker::Tuple<Args>
    parent_clause2 : [@TraitClause2]: core::marker::Sized<Self::Output>
    type Output
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args>
}

#[lang_item("fn_mut")]
pub trait core::ops::function::FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: core::ops::function::FnOnce<Self, Args>
    parent_clause1 : [@TraitClause1]: core::marker::Sized<Args>
    parent_clause2 : [@TraitClause2]: core::marker::Tuple<Args>
    fn call_mut<'_0> = core::ops::function::FnMut::call_mut<'_0_0, Self, Args>
}

pub fn core::iter::sources::from_fn::from_fn<T, F>(@1: F) -> core::iter::sources::from_fn::FromFn<F>[@TraitClause1]
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::ops::function::FnMut<F, ()>,
    @TraitClause2::parent_clause0::Output = core::option::Option<T>[@TraitClause0],

fn test_crate::sparse_transitions::{impl core::ops::function::FnMut<(())> for test_crate::sparse_transitions::closure<'_>}::call_mut<'a, '_1>(@1: &'_1 mut (test_crate::sparse_transitions::closure<'_>), @2: ()) -> core::option::Option<u8>[core::marker::Sized<u8>]
{
    let @0: core::option::Option<u8>[core::marker::Sized<u8>]; // return
    let @1: &'_ mut (test_crate::sparse_transitions::closure<'_>); // arg #1
    let tupled_args@2: (); // arg #2

    @0 := core::option::Option::None {  }
    return
}

fn test_crate::sparse_transitions::{impl core::ops::function::FnOnce<(())> for test_crate::sparse_transitions::closure<'_>}::call_once<'a>(@1: test_crate::sparse_transitions::closure<'_>, @2: ()) -> core::option::Option<u8>[core::marker::Sized<u8>]
{
    let @0: core::option::Option<u8>[core::marker::Sized<u8>]; // return
    let state@1: test_crate::sparse_transitions::closure<'_>; // arg #1
    let args@2: (); // arg #2
    let temp_ref@3: &'_ mut (test_crate::sparse_transitions::closure<'_>); // local

    storage_live(temp_ref@3)
    temp_ref@3 := &mut state@1
    @0 := test_crate::sparse_transitions::{impl core::ops::function::FnMut<(())> for test_crate::sparse_transitions::closure<'_>}::call_mut<'_, '_>(move (temp_ref@3), move (args@2))
    drop state@1
    return
}

impl test_crate::sparse_transitions::{impl core::ops::function::FnOnce<(())> for test_crate::sparse_transitions::closure<'_>}<'a> : core::ops::function::FnOnce<test_crate::sparse_transitions::closure<'_>, (())>
{
    parent_clause0 = core::marker::Sized<(())>
    parent_clause1 = core::marker::Tuple<(())>
    parent_clause2 = core::marker::Sized<core::option::Option<u8>[core::marker::Sized<u8>]>
    type Output = core::option::Option<u8>[core::marker::Sized<u8>]
    fn call_once = test_crate::sparse_transitions::{impl core::ops::function::FnOnce<(())> for test_crate::sparse_transitions::closure<'_>}::call_once
}

impl test_crate::sparse_transitions::{impl core::ops::function::FnMut<(())> for test_crate::sparse_transitions::closure<'_>}<'a> : core::ops::function::FnMut<test_crate::sparse_transitions::closure<'_>, (())>
{
    parent_clause0 = test_crate::sparse_transitions::{impl core::ops::function::FnOnce<(())> for test_crate::sparse_transitions::closure<'_>}<'_>
    parent_clause1 = core::marker::Sized<(())>
    parent_clause2 = core::marker::Tuple<(())>
    fn call_mut<'_0> = test_crate::sparse_transitions::{impl core::ops::function::FnMut<(())> for test_crate::sparse_transitions::closure<'_>}::call_mut<'_>
}

fn test_crate::sparse_transitions<'a>() -> core::iter::sources::from_fn::FromFn<test_crate::sparse_transitions::closure<'a>>[core::marker::Sized<test_crate::sparse_transitions::closure<'_>>]
{
    let @0: core::iter::sources::from_fn::FromFn<test_crate::sparse_transitions::closure<'_>>[core::marker::Sized<test_crate::sparse_transitions::closure<'_>>]; // return
    let @1: test_crate::sparse_transitions::closure<'_>; // anonymous local

    storage_live(@1)
    @1 := test_crate::sparse_transitions::closure {  }
    @0 := core::iter::sources::from_fn::from_fn<u8, test_crate::sparse_transitions::closure<'_>>[core::marker::Sized<u8>, core::marker::Sized<test_crate::sparse_transitions::closure<'_>>, test_crate::sparse_transitions::{impl core::ops::function::FnMut<(())> for test_crate::sparse_transitions::closure<'_>}<'_>](move (@1))
    storage_dead(@1)
    return
}

pub fn core::ops::function::FnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut (Self), @2: Args) -> Self::parent_clause0::Output

pub fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> Self::Output



