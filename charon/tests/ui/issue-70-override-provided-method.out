# Final LLBC before serialization:

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0_1, '_1_1> = core::cmp::PartialEq::eq<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0_1, '_1_1> = core::cmp::PartialOrd::partial_cmp<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

// Full name: core::cmp::impls::{impl PartialEq<i32> for i32}::eq
pub fn {impl PartialEq<i32> for i32}::eq<'_0, '_1>(@1: &'_0 i32, @2: &'_1 i32) -> bool
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<i32> for i32}
impl PartialEq<i32> for i32 {
    fn eq<'_0_1, '_1_1> = {impl PartialEq<i32> for i32}::eq<'_0_1, '_1_1>
    vtable: {impl PartialEq<i32> for i32}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialOrd<u32> for u32}::partial_cmp
pub fn {impl PartialOrd<u32> for u32}::partial_cmp<'_0, '_1>(@1: &'_0 u32, @2: &'_1 u32) -> Option<Ordering>[{built_in impl Sized for Ordering}]
= <opaque>

// Full name: core::marker::StructuralPartialEq
#[lang_item("structural_peq")]
pub trait StructuralPartialEq<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::StructuralPartialEq::{vtable}
}

// Full name: core::option::{impl PartialEq<Option<T>[@TraitClause0]> for Option<T>[@TraitClause0]}::eq
pub fn {impl PartialEq<Option<T>[@TraitClause0]> for Option<T>[@TraitClause0]}::eq<'_0, '_1, T>(@1: &'_0 Option<T>[@TraitClause0], @2: &'_1 Option<T>[@TraitClause0]) -> bool
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: PartialEq<T, T>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let _1: bool; // anonymous local
    let _2: &'0 Option<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _3: &'0 Option<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _4: &'0 Option<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _5: &'0 Option<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _6: &'_ Option<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _7: Option<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _8: &'_ Option<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _9: Option<i32>[{built_in impl Sized for i32}]; // anonymous local

    storage_live(_6)
    storage_live(_7)
    _7 = Option::Some { 0: const 1 : i32 }
    _6 = &_7
    storage_live(_8)
    storage_live(_9)
    _9 = Option::Some { 0: const 1 : i32 }
    _8 = &_9
    storage_live(_4)
    storage_live(_5)
    _0 = ()
    storage_live(_1)
    storage_live(_2)
    _5 = move _6
    _2 = &(*_5)
    storage_live(_3)
    _4 = move _8
    _3 = &(*_4)
    _1 = {impl PartialEq<Option<T>[@TraitClause0]> for Option<T>[@TraitClause0]}::eq<'3, '4, i32>[{built_in impl Sized for i32}, {impl PartialEq<i32> for i32}](move _2, move _3)
    storage_dead(_3)
    storage_dead(_2)
    storage_dead(_1)
    _0 = ()
    return
}

// Full name: test_crate::Foo
struct Foo {
  u32,
}

// Full name: test_crate::{impl StructuralPartialEq for Foo}
impl StructuralPartialEq for Foo {
    parent_clause0 = {built_in impl MetaSized for Foo}
    vtable: {impl StructuralPartialEq for Foo}::{vtable}
}

// Full name: test_crate::{impl PartialEq<Foo> for Foo}::eq
pub fn {impl PartialEq<Foo> for Foo}::eq<'_0, '_1>(@1: &'_0 Foo, @2: &'_1 Foo) -> bool
{
    let _0: bool; // return
    let self_1: &'0 Foo; // arg #1
    let other_2: &'0 Foo; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 = copy ((*self_1)).0
    storage_live(_4)
    _4 = copy ((*other_2)).0
    _0 = move _3 == move _4
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::{impl PartialEq<Foo> for Foo}
impl PartialEq<Foo> for Foo {
    fn eq<'_0_1, '_1_1> = {impl PartialEq<Foo> for Foo}::eq<'_0_1, '_1_1>
    vtable: {impl PartialEq<Foo> for Foo}::{vtable}
}

// Full name: test_crate::{impl PartialOrd<Foo> for Foo}::partial_cmp
pub fn {impl PartialOrd<Foo> for Foo}::partial_cmp<'_0, '_1>(@1: &'_0 Foo, @2: &'_1 Foo) -> Option<Ordering>[{built_in impl Sized for Ordering}]
{
    let _0: Option<Ordering>[{built_in impl Sized for Ordering}]; // return
    let self_1: &'0 Foo; // arg #1
    let other_2: &'0 Foo; // arg #2
    let _3: &'1 u32; // anonymous local
    let _4: &'1 u32; // anonymous local
    let _5: &'1 u32; // anonymous local
    let _6: &'1 u32; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = &((*self_1)).0
    _3 = &(*_4)
    storage_live(_5)
    storage_live(_6)
    _6 = &((*other_2)).0
    _5 = &(*_6)
    _0 = {impl PartialOrd<u32> for u32}::partial_cmp<'4, '5>(move _3, move _5)
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::{impl PartialOrd<Foo> for Foo}
impl PartialOrd<Foo> for Foo {
    parent_clause0 = {impl PartialEq<Foo> for Foo}
    fn partial_cmp<'_0_1, '_1_1> = {impl PartialOrd<Foo> for Foo}::partial_cmp<'_0_1, '_1_1>
    vtable: {impl PartialOrd<Foo> for Foo}::{vtable}
}



