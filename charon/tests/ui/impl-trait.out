# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <opaque>

// Full name: core::clone::impls::{impl Clone for u32}::clone
pub fn {impl Clone for u32}::clone<'_0>(@1: &'_0 u32) -> u32
= <opaque>

// Full name: core::clone::impls::{impl Clone for u32}
impl Clone for u32 {
    parent_clause0 = {built_in impl Sized for u32}
    fn clone<'_0_1> = {impl Clone for u32}::clone<'_0_1>
    non-dyn-compatible
}

// Full name: core::clone::impls::{impl Clone for &'_0 T}::clone
#[lang_item("noop_method_clone")]
pub fn {impl Clone for &'_0 T}::clone<'_0, '_1, T>(@1: &'_1 &'_0 T) -> &'_0 T
= <opaque>

// Full name: core::clone::impls::{impl Clone for &'_0 T}
impl<'_0, T> Clone for &'_0 T {
    parent_clause0 = {built_in impl Sized for &'_ T}
    fn clone<'_0_1> = {impl Clone for &'_0 T}::clone<'_0, '_0_1, T>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args>[Self]
    vtable: core::ops::function::FnOnce::{vtable}<Args, Self::Output>
}

pub fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::Foo
pub trait Foo<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Type>
    parent_clause2 : [@TraitClause2]: Clone<Self::Type>
    type Type
    fn get_ty<'_0_1> = test_crate::Foo::get_ty<'_0_1, Self>[Self]
    vtable: test_crate::Foo::{vtable}<Self::Type>
}

pub fn test_crate::Foo::get_ty<'_0, Self>(@1: &'_0 Self) -> &'_0 @TraitClause0::Type
where
    [@TraitClause0]: Foo<Self>,
= <method_without_default_body>

// Full name: test_crate::{impl Foo for ()}::get_ty
pub fn {impl Foo for ()}::get_ty<'_0>(@1: &'_0 ()) -> &'_0 u32
{
    let _0: &'0 u32; // return
    let self_1: &'1 (); // arg #1
    let _2: &'0 u32; // anonymous local
    let _3: &'0 u32; // anonymous local
    let _4: &'_ u32; // anonymous local
    let _5: u32; // anonymous local

    storage_live(_4)
    storage_live(_5)
    _5 = const 42 : u32
    _4 = &_5
    storage_live(_3)
    storage_live(_2)
    _3 = move _4
    _2 = &(*_3)
    _0 = &(*_2)
    storage_dead(_2)
    return
}

// Full name: test_crate::{impl Foo for ()}
impl Foo for () {
    parent_clause0 = {built_in impl MetaSized for ()}
    parent_clause1 = {built_in impl Sized for u32}
    parent_clause2 = {impl Clone for u32}
    type Type = u32
    fn get_ty<'_0_1> = {impl Foo for ()}::get_ty<'_0_1>
    vtable: {impl Foo for ()}::{vtable}
}

// Full name: test_crate::mk_foo
fn mk_foo()
{
    let _0: (); // return

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::use_foo
fn use_foo()
{
    let _0: (); // return
    let foo_1: (); // local
    let _2: u32; // anonymous local
    let _3: &'0 u32; // anonymous local
    let _4: &'0 u32; // anonymous local
    let _5: &'1 (); // anonymous local

    _0 = ()
    storage_live(foo_1)
    foo_1 = mk_foo()
    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = &foo_1
    _4 = {impl Foo for ()}::get_ty<'_>(move _5)
    _3 = &(*_4)
    storage_dead(_5)
    _2 = {impl Clone for u32}::clone<'_>(move _3)
    storage_dead(_3)
    storage_dead(_4)
    storage_dead(_2)
    _0 = ()
    storage_dead(foo_1)
    return
}

// Full name: test_crate::RPITIT
pub trait RPITIT<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::>
    parent_clause2 : [@TraitClause2]: Foo<Self::>
    type 
    fn make_foo = test_crate::RPITIT::make_foo<Self>[Self]
    non-dyn-compatible
}

pub fn test_crate::RPITIT::make_foo<Self>()
where
    [@TraitClause0]: RPITIT<Self>,
{
    let _0: (); // return

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::{impl RPITIT for ()}::make_foo
pub fn {impl RPITIT for ()}::make_foo()
{
    let _0: (); // return

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::{impl RPITIT for ()}
impl RPITIT for () {
    parent_clause0 = {built_in impl MetaSized for ()}
    parent_clause1 = {built_in impl Sized for ()}
    parent_clause2 = {impl Foo for ()}
    type  = ()
    fn make_foo = {impl RPITIT for ()}::make_foo
    non-dyn-compatible
}

// Full name: test_crate::use_tait
fn use_tait<T>()
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: RPITIT<T>,
{
    let _0: (); // return
    let foo_1: @TraitClause1::; // local
    let _2: @TraitClause1::parent_clause2::Type; // anonymous local
    let _3: &'0 @TraitClause1::parent_clause2::Type; // anonymous local
    let _4: &'0 @TraitClause1::parent_clause2::Type; // anonymous local
    let _5: &'1 @TraitClause1::; // anonymous local

    _0 = ()
    storage_live(foo_1)
    foo_1 = @TraitClause1::make_foo()
    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = &foo_1
    _4 = @TraitClause1::parent_clause2::get_ty<'_>(move _5)
    _3 = &(*_4) with_metadata(copy _4.metadata)
    storage_dead(_5)
    _2 = @TraitClause1::parent_clause2::parent_clause2::clone<'_>(move _3)
    storage_dead(_3)
    conditional_drop[{built_in impl Destruct for @TraitClause1::parent_clause2::Type}] _2
    storage_dead(_4)
    storage_dead(_2)
    _0 = ()
    conditional_drop[{built_in impl Destruct for @TraitClause1::}] foo_1
    storage_dead(foo_1)
    return
}

// Full name: test_crate::WrapClone
pub struct WrapClone<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
  T,
}

// Full name: test_crate::wrap::closure
struct closure<U>
where
    [@TraitClause0]: Sized<U>,
{}

// Full name: test_crate::wrap
pub fn wrap<U>() -> closure<U>[@TraitClause0]
where
    [@TraitClause0]: Sized<U>,
{
    let _0: closure<U>[@TraitClause0]; // return

    _0 = closure {  }
    return
}

// Full name: test_crate::wrap::{impl FnOnce<(&'_ U)> for closure<U>[@TraitClause0]}::call_once
fn {impl FnOnce<(&'_ U)> for closure<U>[@TraitClause0]}::call_once<'_0, U>(@1: closure<U>[@TraitClause0], @2: (&'_0 U)) -> WrapClone<&'_0 U>[{built_in impl Sized for &'_0 U}, {impl Clone for &'_0 T}<'_, U>]
where
    [@TraitClause0]: Sized<U>,
{
    let _0: WrapClone<&'_ U>[{built_in impl Sized for &'0 U}, {impl Clone for &'_0 T}<'2, U>]; // return
    let _1: closure<U>[@TraitClause0]; // arg #1
    let tupled_args_2: (&'_0 U); // arg #2
    let x_3: &'_ U; // local
    let _4: &'_ U; // anonymous local

    storage_live(x_3)
    x_3 = move tupled_args_2.0
    storage_live(_4)
    _4 = &(*x_3)
    _0 = WrapClone { 0: move _4 }
    storage_dead(_4)
    return
}

// Full name: test_crate::wrap::{impl FnOnce<(&'_ U)> for closure<U>[@TraitClause0]}
impl<'_0, U> FnOnce<(&'_ U)> for closure<U>[@TraitClause0]
where
    [@TraitClause0]: Sized<U>,
{
    parent_clause0 = {built_in impl MetaSized for closure<U>[@TraitClause0]}
    parent_clause1 = {built_in impl Sized for (&'_ U)}
    parent_clause2 = {built_in impl Tuple for (&'_ U)}
    parent_clause3 = {built_in impl Sized for WrapClone<&'_ U>[{built_in impl Sized for &'_ U}, {impl Clone for &'_0 T}<'_, U>]}
    type Output = WrapClone<&'_ U>[{built_in impl Sized for &'_ U}, {impl Clone for &'_0 T}<'_, U>]
    fn call_once = {impl FnOnce<(&'_ U)> for closure<U>[@TraitClause0]}::call_once<'_0, U>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::wrap::closure::{impl Destruct for closure<U>[@TraitClause0]}::drop_in_place
unsafe fn {impl Destruct for closure<U>[@TraitClause0]}::drop_in_place<U>(@1: *mut closure<U>[@TraitClause0])
where
    [@TraitClause0]: Sized<U>,
= <missing>

// Full name: test_crate::wrap::closure::{impl Destruct for closure<U>[@TraitClause0]}
impl<U> Destruct for closure<U>[@TraitClause0]
where
    [@TraitClause0]: Sized<U>,
{
    fn drop_in_place = {impl Destruct for closure<U>[@TraitClause0]}::drop_in_place<U>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::use_wrap
pub fn use_wrap()
{
    let _0: (); // return
    let f_1: closure<u32>[{built_in impl Sized for u32}]; // local
    let _2: WrapClone<&'0 u32>[{built_in impl Sized for &'0 u32}, {impl Clone for &'_0 T}<'0, u32>]; // anonymous local
    let _3: closure<u32>[{built_in impl Sized for u32}]; // anonymous local
    let _4: (&'0 u32); // anonymous local
    let _5: &'0 u32; // anonymous local
    let _6: &'0 u32; // anonymous local
    let _7: &'0 u32; // anonymous local
    let _8: &'_ u32; // anonymous local
    let _9: u32; // anonymous local

    storage_live(_7)
    _0 = ()
    storage_live(f_1)
    f_1 = wrap<u32>[{built_in impl Sized for u32}]()
    storage_live(_8)
    storage_live(_9)
    _9 = const 42 : u32
    _8 = &_9
    storage_live(_2)
    storage_live(_3)
    _3 = move f_1
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _7 = move _8
    _6 = &(*_7)
    _5 = &(*_6)
    _4 = (move _5)
    _2 = {impl FnOnce<(&'_ U)> for closure<U>[@TraitClause0]}::call_once<'_, u32>[{built_in impl Sized for u32}](move _3, move _4)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    storage_dead(_6)
    storage_dead(_2)
    _0 = ()
    conditional_drop[{impl Destruct for closure<U>[@TraitClause0]}<u32>[{built_in impl Sized for u32}]] f_1
    storage_dead(f_1)
    return
}



