# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args>[Self]
    vtable: core::ops::function::FnOnce::{vtable}<Args, Self::Output>
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0_1> = core::ops::function::FnMut::call_mut<'_0_1, Self, Args>[Self]
    vtable: core::ops::function::FnMut::{vtable}<Args, Self::parent_clause1::Output>
}

pub fn core::array::{[T; N]}::map<T, F, U, const N : usize>(@1: [T; N], @2: F) -> [U; N]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<F>,
    [@TraitClause2]: Sized<U>,
    [@TraitClause3]: FnMut<F, (T,)>,
    @TraitClause3::parent_clause1::Output = U,
= <opaque>

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <opaque>

// Full name: core::clone::impls::{impl Clone for u8}::clone
pub fn {impl Clone for u8}::clone<'_0>(@1: &'_0 u8) -> u8
= <opaque>

// Full name: core::clone::impls::{impl Clone for u8}
impl Clone for u8 {
    parent_clause0 = {built_in impl Sized for u8}
    fn clone<'_0_1> = {impl Clone for u8}::clone<'_0_1>
    non-dyn-compatible
}

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0_1, '_1_1> = core::cmp::PartialEq::eq<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

#[lang_item("cmp_partialeq_eq")]
pub fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,
= <opaque>

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0_1, '_1_1> = core::cmp::PartialOrd::partial_cmp<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

#[lang_item("cmp_partialord_cmp")]
pub fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> Option<Ordering>[{built_in impl Sized for Ordering}]
where
    [@TraitClause0]: PartialOrd<Self, Rhs>,
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<u8> for u8}::eq
pub fn {impl PartialEq<u8> for u8}::eq<'_0, '_1>(@1: &'_0 u8, @2: &'_1 u8) -> bool
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<u8> for u8}
impl PartialEq<u8> for u8 {
    fn eq<'_0_1, '_1_1> = {impl PartialEq<u8> for u8}::eq<'_0_1, '_1_1>
    vtable: {impl PartialEq<u8> for u8}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialOrd<u8> for u8}::partial_cmp
pub fn {impl PartialOrd<u8> for u8}::partial_cmp<'_0, '_1>(@1: &'_0 u8, @2: &'_1 u8) -> Option<Ordering>[{built_in impl Sized for Ordering}]
= <opaque>

// Full name: core::cmp::impls::{impl PartialOrd<u8> for u8}
impl PartialOrd<u8> for u8 {
    parent_clause0 = {impl PartialEq<u8> for u8}
    fn partial_cmp<'_0_1, '_1_1> = {impl PartialOrd<u8> for u8}::partial_cmp<'_0_1, '_1_1>
    vtable: {impl PartialOrd<u8> for u8}::{vtable}
}

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>

// Full name: core::iter::range::Step
#[lang_item("range_step")]
pub trait Step<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    parent_clause2 : [@TraitClause2]: PartialOrd<Self, Self>
    fn steps_between<'_0_1, '_1_1> = core::iter::range::Step::steps_between<'_0_1, '_1_1, Self>[Self]
    fn forward_checked = core::iter::range::Step::forward_checked<Self>[Self]
    fn backward_checked = core::iter::range::Step::backward_checked<Self>[Self]
    non-dyn-compatible
}

pub fn core::iter::range::Step::steps_between<'_0, '_1, Self>(@1: &'_0 Self, @2: &'_1 Self) -> (usize, Option<usize>[{built_in impl Sized for usize}])
where
    [@TraitClause0]: Step<Self>,
= <opaque>

pub fn core::iter::range::Step::forward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,
= <opaque>

pub fn core::iter::range::Step::backward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,
= <opaque>

// Full name: core::iter::range::{impl Step for u8}::backward_checked
pub fn {impl Step for u8}::backward_checked(@1: u8, @2: usize) -> Option<u8>[{built_in impl Sized for u8}]
= <opaque>

// Full name: core::iter::range::{impl Step for u8}::forward_checked
pub fn {impl Step for u8}::forward_checked(@1: u8, @2: usize) -> Option<u8>[{built_in impl Sized for u8}]
= <opaque>

// Full name: core::iter::range::{impl Step for u8}::steps_between
pub fn {impl Step for u8}::steps_between<'_0, '_1>(@1: &'_0 u8, @2: &'_1 u8) -> (usize, Option<usize>[{built_in impl Sized for usize}])
= <opaque>

// Full name: core::iter::range::{impl Step for u8}
impl Step for u8 {
    parent_clause0 = {built_in impl Sized for u8}
    parent_clause1 = {impl Clone for u8}
    parent_clause2 = {impl PartialOrd<u8> for u8}
    fn steps_between<'_0_1, '_1_1> = {impl Step for u8}::steps_between<'_0_1, '_1_1>
    fn forward_checked = {impl Step for u8}::forward_checked
    fn backward_checked = {impl Step for u8}::backward_checked
    non-dyn-compatible
}

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0_1> = core::iter::traits::iterator::Iterator::next<'_0_1, Self>[Self]
    vtable: core::iter::traits::iterator::Iterator::{vtable}<Self::Item>
}

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}::next
pub fn {impl Iterator for Range<A>[@TraitClause0]}::next<'_0, A>(@1: &'_0 mut Range<A>[@TraitClause0]) -> Option<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,
= <opaque>

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}
impl<A> Iterator for Range<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,
{
    parent_clause0 = {built_in impl MetaSized for Range<A>[@TraitClause0]}
    parent_clause1 = @TraitClause0
    type Item = A
    fn next<'_0_1> = {impl Iterator for Range<A>[@TraitClause0]}::next<'_0_1, A>[@TraitClause0, @TraitClause1]
    vtable: {impl Iterator for Range<A>[@TraitClause0]}::{vtable}<A>[@TraitClause0, @TraitClause1]
}

// Full name: core::iter::traits::collect::{impl IntoIterator for I}::into_iter
pub fn {impl IntoIterator for I}::into_iter<I>(@1: I) -> I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
= <opaque>

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut Self) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,
= <opaque>

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

pub fn core::ops::function::FnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut Self, @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,
= <opaque>

pub fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,
= <opaque>

// Full name: core::panicking::AssertKind
pub enum AssertKind {
  Eq,
  Ne,
  Match,
}

#[lang_item("slice_len_fn")]
pub fn core::slice::{[T]}::len<'_0, T>(@1: &'_0 [T]) -> usize
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::map::closure
struct closure {}

// Full name: test_crate::map::{impl FnMut<(i32,)> for closure}::call_mut
fn {impl FnMut<(i32,)> for closure}::call_mut<'_0>(@1: &'_0 mut closure, @2: (i32,)) -> i32
{
    let _0: i32; // return
    let _1: &'1 mut closure; // arg #1
    let tupled_args_2: (i32,); // arg #2
    let v_3: i32; // local

    storage_live(v_3)
    v_3 = move tupled_args_2.0
    _0 = copy v_3
    return
}

// Full name: test_crate::map::closure::{impl Destruct for closure}::drop_in_place
unsafe fn {impl Destruct for closure}::drop_in_place(@1: *mut closure)
= <missing>

// Full name: test_crate::map::closure::{impl Destruct for closure}
impl Destruct for closure {
    fn drop_in_place = {impl Destruct for closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::map::{impl FnOnce<(i32,)> for closure}::call_once
fn {impl FnOnce<(i32,)> for closure}::call_once(@1: closure, @2: (i32,)) -> i32
{
    let _0: i32; // return
    let _1: closure; // arg #1
    let _2: (i32,); // arg #2
    let _3: &'1 mut closure; // anonymous local

    storage_live(_3)
    _3 = &mut _1
    _0 = {impl FnMut<(i32,)> for closure}::call_mut<'3>(move _3, move _2)
    drop[{impl Destruct for closure}] _1
    return
}

// Full name: test_crate::map::{impl FnOnce<(i32,)> for closure}
impl FnOnce<(i32,)> for closure {
    parent_clause0 = {built_in impl MetaSized for closure}
    parent_clause1 = {built_in impl Sized for (i32,)}
    parent_clause2 = {built_in impl Tuple for (i32,)}
    parent_clause3 = {built_in impl Sized for i32}
    type Output = i32
    fn call_once = {impl FnOnce<(i32,)> for closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::map::{impl FnMut<(i32,)> for closure}
impl FnMut<(i32,)> for closure {
    parent_clause0 = {built_in impl MetaSized for closure}
    parent_clause1 = {impl FnOnce<(i32,)> for closure}
    parent_clause2 = {built_in impl Sized for (i32,)}
    parent_clause3 = {built_in impl Tuple for (i32,)}
    fn call_mut<'_0_1> = {impl FnMut<(i32,)> for closure}::call_mut<'_0_1>
    non-dyn-compatible
}

pub fn test_crate::map(@1: [i32; 256 : usize]) -> [i32; 256 : usize]
{
    let _0: [i32; 256 : usize]; // return
    let x_1: [i32; 256 : usize]; // arg #1
    let _2: [i32; 256 : usize]; // anonymous local
    let _3: closure; // anonymous local

    storage_live(_2)
    _2 = copy x_1
    storage_live(_3)
    _3 = closure {  }
    _0 = core::array::{[T; N]}::map<i32, closure, i32, 256 : usize>[{built_in impl Sized for i32}, {built_in impl Sized for closure}, {built_in impl Sized for i32}, {impl FnMut<(i32,)> for closure}](move _2, move _3)
    storage_dead(_3)
    storage_dead(_2)
    return
}

// Full name: test_crate::array
pub fn array<const LEN : usize>() -> [u8; LEN]
{
    let _0: [u8; LEN]; // return

    _0 = @ArrayRepeat<u8, LEN>(const 0 : u8)
    return
}

// Full name: test_crate::cbd
fn cbd(@1: [u8; 33 : usize])
{
    let _0: (); // return
    let prf_input_1: [u8; 33 : usize]; // arg #1
    let _2: Range<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _3: Range<u8>[{built_in impl Sized for u8}]; // anonymous local
    let iter_4: Range<u8>[{built_in impl Sized for u8}]; // local
    let _5: Option<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _6: &'1 mut Range<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _7: &'2 mut Range<u8>[{built_in impl Sized for u8}]; // anonymous local
    let i_8: u8; // local
    let _9: u8; // anonymous local
    let _10: usize; // anonymous local
    let _11: &'_ mut [u8; 33 : usize]; // anonymous local
    let _12: &'_ mut u8; // anonymous local

    _0 = ()
    storage_live(_2)
    storage_live(_3)
    _3 = Range { start: const 0 : u8, end: const 3 : u8 }
    _2 = {impl IntoIterator for I}::into_iter<Range<u8>[{built_in impl Sized for u8}]>[{built_in impl Sized for Range<u8>[{built_in impl Sized for u8}]}, {impl Iterator for Range<A>[@TraitClause0]}<u8>[{built_in impl Sized for u8}, {impl Step for u8}]](move _3)
    storage_dead(_3)
    _ = _2
    storage_live(iter_4)
    iter_4 = move _2
    loop {
        storage_live(_5)
        storage_live(_6)
        storage_live(_7)
        _7 = &mut iter_4
        _6 = &two-phase-mut (*_7)
        _5 = {impl Iterator for Range<A>[@TraitClause0]}::next<'4, u8>[{built_in impl Sized for u8}, {impl Step for u8}](move _6)
        storage_dead(_6)
        _ = _5
        match _5 {
            Option::None => {
                break 0
            },
            Option::Some => {
            },
        }
        storage_live(i_8)
        i_8 = copy (_5 as variant Option::Some).0
        storage_live(_9)
        _9 = copy i_8
        storage_live(_10)
        _10 = const 0 : usize
        storage_live(_11)
        _11 = &mut prf_input_1
        storage_live(_12)
        _12 = @ArrayIndexMut<'_, u8, 33 : usize>(move _11, copy _10)
        (*_12) = move _9
        storage_dead(_9)
        storage_dead(_10)
        storage_dead(i_8)
        storage_dead(_7)
        storage_dead(_5)
        continue 0
    }
    _0 = ()
    storage_dead(_7)
    storage_dead(_5)
    storage_dead(iter_4)
    storage_dead(_2)
    return
}

// Full name: test_crate::select
fn select<'_0, '_1>(@1: &'_0 [u8], @2: &'_1 [u8])
{
    let _0: (); // return
    let lhs_1: &'1 [u8]; // arg #1
    let rhs_2: &'2 [u8]; // arg #2
    let _3: bool; // anonymous local
    let _4: (&'6 usize, &'7 usize); // anonymous local
    let _5: &'8 usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: &'9 [u8]; // anonymous local
    let _8: &'10 usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: &'11 [u8]; // anonymous local
    let left_val_11: &'12 usize; // local
    let right_val_12: &'13 usize; // local
    let _13: bool; // anonymous local
    let _14: usize; // anonymous local
    let _15: usize; // anonymous local
    let kind_16: AssertKind; // local
    let _17: AssertKind; // anonymous local
    let _18: &'14 usize; // anonymous local
    let _19: &'15 usize; // anonymous local
    let _20: &'16 usize; // anonymous local
    let _21: &'17 usize; // anonymous local
    let _22: Option<Arguments<'24>>[{built_in impl Sized for Arguments<'24>}]; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = const true
    if move _3 {
        storage_live(_4)
        storage_live(_5)
        storage_live(_6)
        storage_live(_7)
        _7 = &(*lhs_1) with_metadata(copy lhs_1.metadata)
        _6 = core::slice::{[T]}::len<'28, u8>[{built_in impl Sized for u8}](move _7)
        storage_dead(_7)
        _5 = &_6
        storage_live(_8)
        storage_live(_9)
        storage_live(_10)
        _10 = &(*rhs_2) with_metadata(copy rhs_2.metadata)
        _9 = core::slice::{[T]}::len<'30, u8>[{built_in impl Sized for u8}](move _10)
        storage_dead(_10)
        _8 = &_9
        _4 = (move _5, move _8)
        storage_dead(_8)
        storage_dead(_5)
        _ = _4
        storage_live(left_val_11)
        left_val_11 = copy _4.0
        storage_live(right_val_12)
        right_val_12 = copy _4.1
        storage_live(_13)
        storage_live(_14)
        _14 = copy (*left_val_11)
        storage_live(_15)
        _15 = copy (*right_val_12)
        _13 = move _14 == move _15
        if move _13 {
        } else {
            storage_dead(_15)
            storage_dead(_14)
            storage_live(kind_16)
            kind_16 = AssertKind::Eq {  }
            storage_live(_17)
            _17 = move kind_16
            storage_live(_18)
            storage_live(_19)
            _19 = &(*left_val_11)
            _18 = &(*_19)
            storage_live(_20)
            storage_live(_21)
            _21 = &(*right_val_12)
            _20 = &(*_21)
            storage_live(_22)
            _22 = Option::None {  }
            panic(core::panicking::assert_failed)
        }
        storage_dead(_15)
        storage_dead(_14)
        storage_dead(_13)
        storage_dead(right_val_12)
        storage_dead(left_val_11)
        storage_dead(_9)
        storage_dead(_6)
        storage_dead(_4)
    } else {
    }
    storage_dead(_3)
    _0 = ()
    return
}



