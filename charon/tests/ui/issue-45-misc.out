# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args>[Self]
    vtable: core::ops::function::FnOnce::{vtable}<Args, Self::Output>
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0_1> = core::ops::function::FnMut::call_mut<'_0_1, Self, Args>[Self]
    vtable: core::ops::function::FnMut::{vtable}<Args, Self::parent_clause1::Output>
}

pub fn core::array::{[T; N]}::map<T, F, U, const N : usize>(@1: [T; N], @2: F) -> [U; N]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<F>,
    [@TraitClause2]: Sized<U>,
    [@TraitClause3]: FnMut<F, (T)>,
    @TraitClause3::parent_clause1::Output = U,
= <opaque>

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <opaque>

// Full name: core::clone::impls::{impl Clone for u8}::clone
pub fn {impl Clone for u8}::clone<'_0>(@1: &'_0 u8) -> u8
= <opaque>

// Full name: core::clone::impls::{impl Clone for u8}
impl Clone for u8 {
    parent_clause0 = {built_in impl Sized for u8}
    fn clone<'_0_1> = {impl Clone for u8}::clone<'_0_1>
    non-dyn-compatible
}

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0_1, '_1_1> = core::cmp::PartialEq::eq<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

#[lang_item("cmp_partialeq_eq")]
pub fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,
= <opaque>

// Full name: core::cmp::Eq
#[lang_item("Eq")]
pub trait Eq<Self>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Self>
    non-dyn-compatible
}

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0_1, '_1_1> = core::cmp::PartialOrd::partial_cmp<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

// Full name: core::cmp::Ord
#[lang_item("Ord")]
pub trait Ord<Self>
{
    parent_clause0 : [@TraitClause0]: Eq<Self>
    parent_clause1 : [@TraitClause1]: PartialOrd<Self, Self>
    fn cmp<'_0_1, '_1_1> = core::cmp::Ord::cmp<'_0_1, '_1_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("ord_cmp_method")]
pub fn core::cmp::Ord::cmp<'_0, '_1, Self>(@1: &'_0 Self, @2: &'_1 Self) -> Ordering
where
    [@TraitClause0]: Ord<Self>,
= <opaque>

#[lang_item("cmp_partialord_cmp")]
pub fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> Option<Ordering>[{built_in impl Sized for Ordering}]
where
    [@TraitClause0]: PartialOrd<Self, Rhs>,
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<u8> for u8}::eq
pub fn {impl PartialEq<u8> for u8}::eq<'_0, '_1>(@1: &'_0 u8, @2: &'_1 u8) -> bool
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<u8> for u8}
impl PartialEq<u8> for u8 {
    fn eq<'_0_1, '_1_1> = {impl PartialEq<u8> for u8}::eq<'_0_1, '_1_1>
    vtable: {impl PartialEq<u8> for u8}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialOrd<u8> for u8}::partial_cmp
pub fn {impl PartialOrd<u8> for u8}::partial_cmp<'_0, '_1>(@1: &'_0 u8, @2: &'_1 u8) -> Option<Ordering>[{built_in impl Sized for Ordering}]
= <opaque>

// Full name: core::cmp::impls::{impl PartialOrd<u8> for u8}
impl PartialOrd<u8> for u8 {
    parent_clause0 = {impl PartialEq<u8> for u8}
    fn partial_cmp<'_0_1, '_1_1> = {impl PartialOrd<u8> for u8}::partial_cmp<'_0_1, '_1_1>
    vtable: {impl PartialOrd<u8> for u8}::{vtable}
}

// Full name: core::default::Default
#[lang_item("Default")]
pub trait Default<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn default = default<Self>[Self]
    non-dyn-compatible
}

// Full name: core::default::Default::default
#[lang_item("default_fn")]
pub fn default<Self>() -> Self
where
    [@TraitClause0]: Default<Self>,
= <opaque>

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>

// Full name: core::iter::adapters::zip::TrustedRandomAccessNoCoerce
pub trait TrustedRandomAccessNoCoerce<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const MAY_HAVE_SIDE_EFFECT : bool
    non-dyn-compatible
}

// Full name: core::iter::range::Step
#[lang_item("range_step")]
pub trait Step<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    parent_clause2 : [@TraitClause2]: PartialOrd<Self, Self>
    fn steps_between<'_0_1, '_1_1> = core::iter::range::Step::steps_between<'_0_1, '_1_1, Self>[Self]
    fn forward_checked = core::iter::range::Step::forward_checked<Self>[Self]
    fn backward_checked = core::iter::range::Step::backward_checked<Self>[Self]
    non-dyn-compatible
}

pub fn core::iter::range::Step::steps_between<'_0, '_1, Self>(@1: &'_0 Self, @2: &'_1 Self) -> (usize, Option<usize>[{built_in impl Sized for usize}])
where
    [@TraitClause0]: Step<Self>,
= <opaque>

pub fn core::iter::range::Step::forward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,
= <opaque>

pub fn core::iter::range::Step::backward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,
= <opaque>

// Full name: core::iter::range::{impl Step for u8}::steps_between
pub fn {impl Step for u8}::steps_between<'_0, '_1>(@1: &'_0 u8, @2: &'_1 u8) -> (usize, Option<usize>[{built_in impl Sized for usize}])
= <opaque>

// Full name: core::iter::range::{impl Step for u8}::forward_checked
pub fn {impl Step for u8}::forward_checked(@1: u8, @2: usize) -> Option<u8>[{built_in impl Sized for u8}]
= <opaque>

// Full name: core::iter::range::{impl Step for u8}::backward_checked
pub fn {impl Step for u8}::backward_checked(@1: u8, @2: usize) -> Option<u8>[{built_in impl Sized for u8}]
= <opaque>

// Full name: core::iter::range::{impl Step for u8}
impl Step for u8 {
    parent_clause0 = {built_in impl Sized for u8}
    parent_clause1 = {impl Clone for u8}
    parent_clause2 = {impl PartialOrd<u8> for u8}
    fn steps_between<'_0_1, '_1_1> = {impl Step for u8}::steps_between<'_0_1, '_1_1>
    fn forward_checked = {impl Step for u8}::forward_checked
    fn backward_checked = {impl Step for u8}::backward_checked
    non-dyn-compatible
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0_1> = core::iter::traits::iterator::Iterator::next<'_0_1, Self>[Self]
    vtable: core::iter::traits::iterator::Iterator::{vtable}<Self::Item>
}

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}::next
pub fn {impl Iterator for Range<A>[@TraitClause0]}::next<'_0, A>(@1: &'_0 mut Range<A>[@TraitClause0]) -> Option<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,
= <opaque>

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}
impl<A> Iterator for Range<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,
{
    parent_clause0 = {built_in impl MetaSized for Range<A>[@TraitClause0]}
    parent_clause1 = @TraitClause0
    type Item = A
    fn next<'_0_1> = {impl Iterator for Range<A>[@TraitClause0]}::next<'_0_1, A>[@TraitClause0, @TraitClause1]
    vtable: {impl Iterator for Range<A>[@TraitClause0]}::{vtable}<A>[@TraitClause0, @TraitClause1]
}

// Full name: core::iter::traits::accum::Sum
pub trait Sum<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn sum<I, [@TraitClause0_1]: Sized<I>, [@TraitClause1_1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Sum::sum<Self, A, I>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

pub fn core::iter::traits::accum::Sum::sum<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Sum<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,
= <opaque>

// Full name: core::iter::traits::accum::Product
pub trait Product<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn product<I, [@TraitClause0_1]: Sized<I>, [@TraitClause1_1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Product::product<Self, A, I>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

pub fn core::iter::traits::accum::Product::product<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Product<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,
= <opaque>

// Full name: core::iter::traits::collect::IntoIterator
#[lang_item("IntoIterator")]
pub trait IntoIterator<Self>
where
    Self::parent_clause3::Item = Self::Item,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: Sized<Self::IntoIter>
    parent_clause3 : [@TraitClause3]: Iterator<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter = core::iter::traits::collect::IntoIterator::into_iter<Self>[Self]
    vtable: core::iter::traits::collect::IntoIterator::{vtable}<Self::Item, Self::IntoIter>
}

// Full name: core::iter::traits::collect::FromIterator
#[lang_item("FromIterator")]
pub trait FromIterator<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn from_iter<T, [@TraitClause0_1]: Sized<T>, [@TraitClause1_1]: IntoIterator<T>, @TraitClause1_1::Item = A> = from_iter<Self, A, T>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::FromIterator::from_iter
#[lang_item("from_iter_fn")]
pub fn from_iter<Self, A, T>(@1: T) -> Self
where
    [@TraitClause0]: FromIterator<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,
= <opaque>

#[lang_item("into_iter")]
pub fn core::iter::traits::collect::IntoIterator::into_iter<Self>(@1: Self) -> @TraitClause0::IntoIter
where
    [@TraitClause0]: IntoIterator<Self>,
= <opaque>

// Full name: core::iter::traits::collect::{impl IntoIterator for I}::into_iter
pub fn {impl IntoIterator for I}::into_iter<I>(@1: I) -> I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
= <opaque>

// Full name: core::iter::traits::collect::{impl IntoIterator for I}
impl<I> IntoIterator for I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
{
    parent_clause0 = @TraitClause0::parent_clause0
    parent_clause1 = @TraitClause1::parent_clause1
    parent_clause2 = @TraitClause0
    parent_clause3 = @TraitClause1
    type Item = @TraitClause1::Item
    type IntoIter = I
    fn into_iter = {impl IntoIterator for I}::into_iter<I>[@TraitClause0, @TraitClause1]
    vtable: {impl IntoIterator for I}::{vtable}<I>[@TraitClause0, @TraitClause1]
}

// Full name: core::iter::traits::collect::Extend
pub trait Extend<Self, A>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn extend<'_0_1, T, [@TraitClause0_1]: Sized<T>, [@TraitClause1_1]: IntoIterator<T>, @TraitClause1_1::Item = A> = extend<'_0_1, Self, A, T>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::Extend::extend
pub fn extend<'_0, Self, A, T>(@1: &'_0 mut Self, @2: T)
where
    [@TraitClause0]: Extend<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,
= <opaque>

// Full name: core::iter::traits::double_ended::DoubleEndedIterator
#[lang_item("DoubleEndedIterator")]
pub trait DoubleEndedIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    fn next_back<'_0_1> = next_back<'_0_1, Self>[Self]
    vtable: core::iter::traits::double_ended::DoubleEndedIterator::{vtable}<Self::parent_clause1::Item>
}

// Full name: core::iter::traits::double_ended::DoubleEndedIterator::next_back
pub fn next_back<'_0, Self>(@1: &'_0 mut Self) -> Option<@TraitClause0::parent_clause1::Item>[@TraitClause0::parent_clause1::parent_clause1]
where
    [@TraitClause0]: DoubleEndedIterator<Self>,
= <opaque>

// Full name: core::iter::traits::exact_size::ExactSizeIterator
pub trait ExactSizeIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    vtable: core::iter::traits::exact_size::ExactSizeIterator::{vtable}<Self::parent_clause1::Item>
}

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut Self) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,
= <opaque>

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::ops::control_flow::ControlFlow
#[lang_item("ControlFlow")]
pub enum ControlFlow<B, C>
where
    [@TraitClause0]: Sized<B>,
    [@TraitClause1]: Sized<C>,
{
  Continue(C),
  Break(B),
}

pub fn core::ops::function::FnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut Self, @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,
= <opaque>

pub fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,
= <opaque>

// Full name: core::ops::try_trait::FromResidual
#[lang_item("FromResidual")]
pub trait FromResidual<Self, R>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<R>
    fn from_residual = from_residual<Self, R>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try
#[lang_item("Try")]
pub trait Try<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FromResidual<Self, Self::Residual>
    parent_clause2 : [@TraitClause2]: Sized<Self::Output>
    parent_clause3 : [@TraitClause3]: Sized<Self::Residual>
    type Output
    type Residual
    fn from_output = from_output<Self>[Self]
    fn branch = branch<Self>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try::from_output
#[lang_item("from_output")]
pub fn from_output<Self>(@1: @TraitClause0::Output) -> Self
where
    [@TraitClause0]: Try<Self>,
= <opaque>

// Full name: core::ops::try_trait::Try::branch
#[lang_item("branch")]
pub fn branch<Self>(@1: Self) -> ControlFlow<@TraitClause0::Residual, @TraitClause0::Output>[@TraitClause0::parent_clause1::parent_clause1, @TraitClause0::parent_clause2]
where
    [@TraitClause0]: Try<Self>,
= <opaque>

// Full name: core::ops::try_trait::FromResidual::from_residual
#[lang_item("from_residual")]
pub fn from_residual<Self, R>(@1: R) -> Self
where
    [@TraitClause0]: FromResidual<Self, R>,
= <opaque>

// Full name: core::ops::try_trait::Residual
pub trait Residual<Self, O>
where
    Self::parent_clause3::Output = O,
    Self::parent_clause3::Residual = Self,
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<O>
    parent_clause2 : [@TraitClause2]: Sized<Self::TryType>
    parent_clause3 : [@TraitClause3]: Try<Self::TryType>
    type TryType
    non-dyn-compatible
}

// Full name: core::panicking::AssertKind
pub enum AssertKind {
  Eq,
  Ne,
  Match,
}

#[lang_item("slice_len_fn")]
pub fn core::slice::{[T]}::len<'_0, T>(@1: &'_0 [T]) -> usize
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::map::closure
struct closure {}

// Full name: test_crate::map::{impl FnMut<(i32)> for closure}::call_mut
fn {impl FnMut<(i32)> for closure}::call_mut<'_0>(@1: &'_0 mut closure, @2: (i32)) -> i32
{
    let _0: i32; // return
    let _1: &'0 mut closure; // arg #1
    let tupled_args_2: (i32); // arg #2
    let v_3: i32; // local

    storage_live(v_3)
    v_3 = move tupled_args_2.0
    _0 = copy v_3
    return
}

// Full name: test_crate::map::closure::{impl Destruct for closure}::drop_in_place
unsafe fn {impl Destruct for closure}::drop_in_place(@1: *mut closure)
= <missing>

// Full name: test_crate::map::closure::{impl Destruct for closure}
impl Destruct for closure {
    fn drop_in_place = {impl Destruct for closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::map::{impl FnOnce<(i32)> for closure}::call_once
fn {impl FnOnce<(i32)> for closure}::call_once(@1: closure, @2: (i32)) -> i32
{
    let _0: i32; // return
    let _1: closure; // arg #1
    let _2: (i32); // arg #2
    let _3: &'0 mut closure; // anonymous local

    storage_live(_3)
    _3 = &mut _1
    _0 = {impl FnMut<(i32)> for closure}::call_mut<'_>(move _3, move _2)
    drop[{impl Destruct for closure}] _1
    return
}

// Full name: test_crate::map::{impl FnOnce<(i32)> for closure}
impl FnOnce<(i32)> for closure {
    parent_clause0 = {built_in impl MetaSized for closure}
    parent_clause1 = {built_in impl Sized for (i32)}
    parent_clause2 = {built_in impl Tuple for (i32)}
    parent_clause3 = {built_in impl Sized for i32}
    type Output = i32
    fn call_once = {impl FnOnce<(i32)> for closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::map::{impl FnMut<(i32)> for closure}
impl FnMut<(i32)> for closure {
    parent_clause0 = {built_in impl MetaSized for closure}
    parent_clause1 = {impl FnOnce<(i32)> for closure}
    parent_clause2 = {built_in impl Sized for (i32)}
    parent_clause3 = {built_in impl Tuple for (i32)}
    fn call_mut<'_0_1> = {impl FnMut<(i32)> for closure}::call_mut<'_0_1>
    non-dyn-compatible
}

pub fn test_crate::map(@1: [i32; 256 : usize]) -> [i32; 256 : usize]
{
    let _0: [i32; 256 : usize]; // return
    let x_1: [i32; 256 : usize]; // arg #1
    let _2: [i32; 256 : usize]; // anonymous local
    let _3: closure; // anonymous local

    storage_live(_2)
    _2 = copy x_1
    storage_live(_3)
    _3 = closure {  }
    _0 = core::array::{[T; N]}::map<i32, closure, i32, 256 : usize>[{built_in impl Sized for i32}, {built_in impl Sized for closure}, {built_in impl Sized for i32}, {impl FnMut<(i32)> for closure}](move _2, move _3)
    storage_dead(_3)
    storage_dead(_2)
    return
}

// Full name: test_crate::array
pub fn array<const LEN : usize>() -> [u8; LEN]
{
    let _0: [u8; LEN]; // return

    _0 = @ArrayRepeat<u8, LEN>(const 0 : u8)
    return
}

// Full name: test_crate::cbd
fn cbd(@1: [u8; 33 : usize])
{
    let _0: (); // return
    let prf_input_1: [u8; 33 : usize]; // arg #1
    let _2: Range<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _3: Range<u8>[{built_in impl Sized for u8}]; // anonymous local
    let iter_4: Range<u8>[{built_in impl Sized for u8}]; // local
    let _5: Option<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _6: &'0 mut Range<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _7: &'0 mut Range<u8>[{built_in impl Sized for u8}]; // anonymous local
    let i_8: u8; // local
    let _9: u8; // anonymous local
    let _10: usize; // anonymous local
    let _11: &'_ mut [u8; 33 : usize]; // anonymous local
    let _12: &'_ mut u8; // anonymous local

    _0 = ()
    storage_live(_2)
    storage_live(_3)
    _3 = Range { start: const 0 : u8, end: const 3 : u8 }
    _2 = {impl IntoIterator for I}::into_iter<Range<u8>[{built_in impl Sized for u8}]>[{built_in impl Sized for Range<u8>[{built_in impl Sized for u8}]}, {impl Iterator for Range<A>[@TraitClause0]}<u8>[{built_in impl Sized for u8}, {impl Step for u8}]](move _3)
    storage_dead(_3)
    storage_live(iter_4)
    iter_4 = move _2
    loop {
        storage_live(_5)
        storage_live(_6)
        storage_live(_7)
        _7 = &mut iter_4
        _6 = &two-phase-mut (*_7)
        _5 = {impl Iterator for Range<A>[@TraitClause0]}::next<'_, u8>[{built_in impl Sized for u8}, {impl Step for u8}](move _6)
        storage_dead(_6)
        match _5 {
            Option::None => {
            },
            Option::Some => {
                storage_live(i_8)
                i_8 = copy (_5 as variant Option::Some).0
                storage_live(_9)
                _9 = copy i_8
                storage_live(_10)
                _10 = const 0 : usize
                storage_live(_11)
                _11 = &mut prf_input_1
                storage_live(_12)
                _12 = @ArrayIndexMut<'_, u8, 33 : usize>(move _11, copy _10)
                (*_12) = move _9
                storage_dead(_9)
                storage_dead(_10)
                storage_dead(i_8)
                storage_dead(_7)
                storage_dead(_5)
                continue 0
            },
        }
        break 0
    }
    _0 = ()
    storage_dead(_7)
    storage_dead(_5)
    storage_dead(iter_4)
    storage_dead(_2)
    return
}

// Full name: test_crate::select
fn select<'_0, '_1>(@1: &'_0 [u8], @2: &'_1 [u8])
{
    let _0: (); // return
    let lhs_1: &'0 [u8]; // arg #1
    let rhs_2: &'0 [u8]; // arg #2
    let _3: bool; // anonymous local
    let _4: (&'1 usize, &'1 usize); // anonymous local
    let _5: &'1 usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: &'0 [u8]; // anonymous local
    let _8: &'1 usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: &'0 [u8]; // anonymous local
    let left_val_11: &'1 usize; // local
    let right_val_12: &'1 usize; // local
    let _13: bool; // anonymous local
    let _14: usize; // anonymous local
    let _15: usize; // anonymous local
    let kind_16: AssertKind; // local
    let _17: AssertKind; // anonymous local
    let _18: &'1 usize; // anonymous local
    let _19: &'1 usize; // anonymous local
    let _20: &'1 usize; // anonymous local
    let _21: &'1 usize; // anonymous local
    let _22: Option<Arguments<'2>>[{built_in impl Sized for Arguments<'2>}]; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = const true
    if move _3 {
        storage_live(_4)
        storage_live(_5)
        storage_live(_6)
        storage_live(_7)
        _7 = &(*lhs_1) with_metadata(copy lhs_1.metadata)
        _6 = core::slice::{[T]}::len<'_, u8>[{built_in impl Sized for u8}](move _7)
        storage_dead(_7)
        _5 = &_6
        storage_live(_8)
        storage_live(_9)
        storage_live(_10)
        _10 = &(*rhs_2) with_metadata(copy rhs_2.metadata)
        _9 = core::slice::{[T]}::len<'_, u8>[{built_in impl Sized for u8}](move _10)
        storage_dead(_10)
        _8 = &_9
        _4 = (move _5, move _8)
        storage_dead(_8)
        storage_dead(_5)
        storage_live(left_val_11)
        left_val_11 = copy _4.0
        storage_live(right_val_12)
        right_val_12 = copy _4.1
        storage_live(_13)
        storage_live(_14)
        _14 = copy (*left_val_11)
        storage_live(_15)
        _15 = copy (*right_val_12)
        _13 = move _14 == move _15
        if move _13 {
        } else {
            storage_dead(_15)
            storage_dead(_14)
            storage_live(kind_16)
            kind_16 = AssertKind::Eq {  }
            storage_live(_17)
            _17 = move kind_16
            storage_live(_18)
            storage_live(_19)
            _19 = &(*left_val_11)
            _18 = &(*_19)
            storage_live(_20)
            storage_live(_21)
            _21 = &(*right_val_12)
            _20 = &(*_21)
            storage_live(_22)
            _22 = Option::None {  }
            panic(core::panicking::assert_failed)
        }
        storage_dead(_15)
        storage_dead(_14)
        storage_dead(_13)
        storage_dead(right_val_12)
        storage_dead(left_val_11)
        storage_dead(_9)
        storage_dead(_6)
        storage_dead(_4)
    } else {
    }
    storage_dead(_3)
    _0 = ()
    return
}



