# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::option::Option::Some
fn Some<T>(@1: T) -> Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: alloc::string::String::{impl Destruct for String}::drop_in_place
unsafe fn {impl Destruct for String}::drop_in_place(@1: *mut String)
= <opaque>

// Full name: alloc::string::String::{impl Destruct for String}
impl Destruct for String {
    fn drop_in_place = {impl Destruct for String}::drop_in_place
    non-dyn-compatible
}

// Full name: alloc::string::{String}::new
#[lang_item("string_new")]
pub fn new() -> String
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::F
fn F() -> fn(u8) -> Option<u8>[{built_in impl Sized for u8}]
{
    let _0: fn(u8) -> Option<u8>[{built_in impl Sized for u8}]; // return

    _0 := cast<Some<u8>[{built_in impl Sized for u8}], fn(u8) -> Option<u8>[{built_in impl Sized for u8}]>(const (Some<u8>[{built_in impl Sized for u8}]))
    return
}

// Full name: test_crate::F
static F: fn(u8) -> Option<u8>[{built_in impl Sized for u8}] = F()

// Full name: test_crate::Foo
struct Foo {
  u32,
  String,
}

// Full name: test_crate::Foo::{impl Destruct for Foo}::drop_in_place
unsafe fn {impl Destruct for Foo}::drop_in_place(@1: *mut Foo)
{
    let _0: (); // return
    let _1: *mut Foo; // arg #1
    let _2: &'0 mut Foo; // anonymous local

    storage_live(_2)
    _0 := ()
    _2 := &mut *(_1)
    drop[{impl Destruct for String}] (*(_2)).1
    return
}

// Full name: test_crate::Foo::{impl Destruct for Foo}
impl Destruct for Foo {
    fn drop_in_place = {impl Destruct for Foo}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::Foo
fn Foo(@1: u32, @2: String) -> Foo
{
    let _0: Foo; // return
    let _1: u32; // arg #1
    let _2: String; // arg #2

    _0 := Foo { 0: move (_1), 1: move (_2) }
    return
}

// Full name: test_crate::Bar
enum Bar<'a, T>
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
{
  Variant(&'a T),
}

// Full name: test_crate::Bar::Variant
fn Variant<'a, T>(@1: &'a T) -> Bar<'a, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
{
    let _0: Bar<'a, T>[@TraitClause0]; // return
    let _1: &'a T; // arg #1

    _0 := Bar::Variant { 0: move (_1) }
    return
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let f_1: Some<u8>[{built_in impl Sized for u8}]; // local
    let _2: Option<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _3: Some<u8>[{built_in impl Sized for u8}]; // anonymous local
    let f_4: fn(u8) -> Option<u8>[{built_in impl Sized for u8}]; // local
    let _5: Some<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _6: Option<u8>[{built_in impl Sized for u8}]; // anonymous local
    let _7: fn(u8) -> Option<u8>[{built_in impl Sized for u8}]; // anonymous local
    let f_8: Foo; // local
    let _9: Foo; // anonymous local
    let _10: Foo; // anonymous local
    let _11: String; // anonymous local
    let f_12: Variant<'0, i32>[{built_in impl Sized for i32}]; // local
    let _13: Bar<'1, i32>[{built_in impl Sized for i32}]; // anonymous local
    let _14: Variant<'0, i32>[{built_in impl Sized for i32}]; // anonymous local
    let _15: &'2 i32; // anonymous local
    let _16: &'2 i32; // anonymous local
    let _17: &'2 i32; // anonymous local
    let _18: &'_ i32; // anonymous local
    let _19: i32; // anonymous local

    storage_live(_17)
    _0 := ()
    storage_live(f_1)
    f_1 := const (Some<u8>[{built_in impl Sized for u8}])
    storage_live(_2)
    storage_live(_3)
    _3 := copy (f_1)
    _2 := Some<u8>[{built_in impl Sized for u8}](const (42 : u8))
    storage_dead(_3)
    storage_dead(_2)
    storage_live(f_4)
    storage_live(_5)
    _5 := copy (f_1)
    f_4 := cast<Some<u8>[{built_in impl Sized for u8}], fn(u8) -> Option<u8>[{built_in impl Sized for u8}]>(move (_5))
    storage_dead(_5)
    storage_live(_6)
    storage_live(_7)
    _7 := copy (f_4)
    _6 := (move (_7))(const (42 : u8))
    storage_dead(_7)
    storage_dead(_6)
    storage_live(f_8)
    f_8 := const (Foo)
    storage_live(_9)
    storage_live(_10)
    _10 := copy (f_8)
    storage_live(_11)
    _11 := new()
    _9 := Foo(const (42 : u32), move (_11))
    storage_dead(_11)
    storage_dead(_10)
    conditional_drop[{impl Destruct for Foo}] _9
    storage_live(_18)
    storage_live(_19)
    _19 := const (42 : i32)
    _18 := &_19
    storage_dead(_9)
    storage_live(f_12)
    f_12 := const (Variant<'3, i32>[{built_in impl Sized for i32}])
    storage_live(_13)
    storage_live(_14)
    _14 := copy (f_12)
    storage_live(_15)
    storage_live(_16)
    _17 := move (_18)
    _16 := &*(_17)
    _15 := &*(_16)
    _13 := Variant<'4, i32>[{built_in impl Sized for i32}](move (_15))
    storage_dead(_15)
    storage_dead(_14)
    storage_dead(_16)
    storage_dead(_13)
    _0 := ()
    storage_dead(f_12)
    storage_dead(f_8)
    storage_dead(f_4)
    storage_dead(f_1)
    return
}



