# Final LLBC before serialization:

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: core::marker::Destruct::<String>
#[lang_item("destruct")]
pub trait Destruct::<String>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place::<String>
    vtable: core::marker::Destruct::{vtable}::<String>
}

unsafe fn core::marker::Destruct::drop_in_place::<String>(@1: *mut String)
= <opaque>

// Full name: alloc::string::String::{impl Destruct::<String>}::drop_in_place
unsafe fn {impl Destruct::<String>}::drop_in_place(@1: *mut String)
= <opaque>

// Full name: alloc::string::String::{impl Destruct::<String>}
impl Destruct::<String> {
    fn drop_in_place = {impl Destruct::<String>}::drop_in_place
    non-dyn-compatible
}

// Full name: alloc::string::{impl#0}::to_string::<Str>
pub fn {impl#0}::to_string::<Str><'_0>(@1: &'_0 Str) -> String
= <opaque>

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let a_1: String; // local
    let _2: &'0 Str; // anonymous local
    let _3: &'0 Str; // anonymous local

    _0 = ()
    storage_live(a_1)
    storage_live(_2)
    storage_live(_3)
    _3 = const "Hello, world!"
    _2 = &(*_3) with_metadata(copy _3.metadata)
    a_1 = {impl#0}::to_string::<Str><'2>(move _2)
    storage_dead(_2)
    storage_dead(_3)
    _0 = ()
    conditional_drop[{impl Destruct::<String>}] a_1
    storage_dead(a_1)
    return
}



