# Final LLBC before serialization:

fn test_crate::six::{promoted_const}#1() -> &'_ (u32)
{
    let @0: &'_ (u32); // return
    let @1: u32; // anonymous local
    let @2: (u32, bool); // anonymous local

    storage_live(@1)
    storage_live(@2)
    @2 := const (0 : u32) checked.+ const (1 : u32)
    @1 := move ((@2).0)
    @0 := &@1
    return
}

const test_crate::six::{promoted_const}#1: &'_ (u32) = test_crate::six::{promoted_const}#1()

fn test_crate::six::{promoted_const}() -> &'_ (u32)
{
    let @0: &'_ (u32); // return
    let @1: u32; // anonymous local
    let @2: (u32, bool); // anonymous local

    storage_live(@1)
    storage_live(@2)
    @2 := const (2 : u32) checked.+ const (3 : u32)
    @1 := move ((@2).0)
    @0 := &@1
    return
}

const test_crate::six::{promoted_const}: &'_ (u32) = test_crate::six::{promoted_const}()

pub fn core::ops::arith::{impl core::ops::arith::Add<&'_0 (u32)> for &'_1 (u32)}#27::add<'_0, '_1>(@1: &'_1 (u32), @2: &'_0 (u32)) -> u32

fn test_crate::six() -> u32
{
    let @0: u32; // return
    let x@1: &'_ (u32); // local
    let y@2: &'_ (u32); // local
    let @3: &'_ (u32); // anonymous local
    let @4: &'_ (u32); // anonymous local
    let @5: &'_ (u32); // anonymous local
    let @6: &'_ (u32); // anonymous local
    let @7: &'_ (u32); // anonymous local
    let @8: &'_ (u32); // anonymous local

    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(x@1)
    @7 := test_crate::six::{promoted_const}#1
    @6 := move (@7)
    x@1 := &*(@6)
    storage_live(y@2)
    @8 := test_crate::six::{promoted_const}
    @5 := move (@8)
    y@2 := &*(@5)
    storage_live(@3)
    @3 := copy (x@1)
    storage_live(@4)
    @4 := copy (y@2)
    @0 := core::ops::arith::{impl core::ops::arith::Add<&'_0 (u32)> for &'_1 (u32)}#27::add<'_, '_>(move (@3), move (@4))
    storage_dead(@4)
    storage_dead(@3)
    storage_dead(y@2)
    storage_dead(x@1)
    return
}

#[lang_item("sized")]
pub trait core::marker::Sized<Self>

#[lang_item("add")]
pub trait core::ops::arith::Add<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: core::marker::Sized<Rhs>
    parent_clause1 : [@TraitClause1]: core::marker::Sized<Self::Output>
    type Output
    fn add = core::ops::arith::Add::add<Self, Rhs>
}

#[lang_item("add")]
pub fn core::ops::arith::Add::add<Self, Rhs>(@1: Self, @2: Rhs) -> Self::Output

impl core::ops::arith::{impl core::ops::arith::Add<&'_0 (u32)> for &'_1 (u32)}#27<'_0, '_1> : core::ops::arith::Add<&'_1 (u32), &'_0 (u32)>
{
    parent_clause0 = core::marker::Sized<&'_ (u32)>
    parent_clause1 = core::marker::Sized<u32>
    type Output = u32
    fn add = core::ops::arith::{impl core::ops::arith::Add<&'_0 (u32)> for &'_1 (u32)}#27::add<'_0, '_1>
}

pub fn core::ops::arith::{impl core::ops::arith::Add<u32> for u32}#3::add(@1: u32, @2: u32) -> u32

impl core::ops::arith::{impl core::ops::arith::Add<u32> for u32}#3 : core::ops::arith::Add<u32, u32>
{
    parent_clause0 = core::marker::Sized<u32>
    parent_clause1 = core::marker::Sized<u32>
    type Output = u32
    fn add = core::ops::arith::{impl core::ops::arith::Add<u32> for u32}#3::add
}



