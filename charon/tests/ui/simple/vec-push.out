# Final LLBC before serialization:

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub opaque type Layout

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::marker::Destruct::drop_in_place
fn drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::num::niche_types::UsizeNoHighBit
pub opaque type UsizeNoHighBit

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub opaque type NonNull<T>

// Full name: core::ptr::unique::Unique
pub opaque type Unique<T>

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::raw_vec::RawVec
opaque type RawVec<T, A>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,

// Full name: alloc::raw_vec::RawVecInner
opaque type RawVecInner<A>
where
    [@TraitClause0]: Sized<A>,

// Full name: alloc::raw_vec::{RawVec<T, A>[@TraitClause0, @TraitClause1]}::grow_one
fn grow_one<'_0, T, A>(@1: &'_0 mut (RawVec<T, A>[@TraitClause0, @TraitClause1]))
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
= <opaque>

// Full name: alloc::vec::Vec
#[lang_item("Vec")]
pub struct Vec<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<type_error("removed allocator parameter")>,
{
  buf: RawVec<T, type_error("removed allocator parameter")>[@TraitClause0, @TraitClause1],
  len: usize,
}

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: alloc::vec::{Vec<T>[@TraitClause0, @TraitClause1]}::push_mut
pub fn push_mut<'_0, T, A>(@1: &'_0 mut (Vec<T>[@TraitClause0, @TraitClause1]), @2: T) -> &'_0 mut (T)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
{
    let @0: &'_ mut (T); // return
    let self@1: &'_ mut (Vec<T>[@TraitClause0, @TraitClause1]); // arg #1
    let value@2: T; // arg #2
    let len@3: usize; // local
    let @4: bool; // anonymous local
    let @5: usize; // anonymous local
    let @6: (); // anonymous local
    let @7: &'_ mut (RawVec<T, A>[@TraitClause0, @TraitClause1]); // anonymous local
    let end@8: *mut T; // local
    let self@9: *mut T; // local
    let src@10: T; // local
    let self@11: UsizeNoHighBit; // local
    let @12: NonNull<u8>; // anonymous local

    loop {
        storage_live(len@3)
        storage_live(@6)
        storage_live(end@8)
        len@3 := copy ((*(self@1)).len)
        storage_live(@4)
        storage_live(@5)
        switch const ({impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE) {
            0 : usize => {
                @5 := const (18446744073709551615 : usize)
            },
            _ => {
                storage_live(self@11)
                self@11 := copy ((((*(self@1)).buf).0).1)
                @5 := transmute<UsizeNoHighBit, usize>(copy (self@11))
                storage_dead(self@11)
            },
        }
        break 0
    }
    loop {
        @4 := copy (len@3) == move (@5)
        if move (@4) {
            storage_dead(@5)
            storage_live(@7)
            @7 := &two-phase-mut (*(self@1)).buf
            @6 := grow_one<'_, T, A>[@TraitClause0, @TraitClause1](move (@7))
            storage_dead(@7)
        }
        else {
            storage_dead(@5)
        }
        break 0
    }
    storage_dead(@4)
    storage_live(self@9)
    storage_live(@12)
    @12 := copy (((((*(self@1)).buf).0).0).0)
    self@9 := transmute<NonNull<u8>, *mut T>(copy (@12))
    storage_dead(@12)
    end@8 := copy (self@9) offset copy (len@3)
    storage_dead(self@9)
    storage_live(src@10)
    src@10 := move (value@2)
    *(end@8) := copy (src@10)
    storage_dead(src@10)
    (*(self@1)).len := copy (len@3) wrap.+ const (1 : usize)
    @0 := &mut *(end@8)
    return
}

// Full name: alloc::vec::{Vec<T>[@TraitClause0, @TraitClause1]}::push
pub fn push<'_0, T, A>(@1: &'_0 mut (Vec<T>[@TraitClause0, @TraitClause1]), @2: T)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
{
    let @0: (); // return
    let self@1: &'_ mut (Vec<T>[@TraitClause0, @TraitClause1]); // arg #1
    let value@2: T; // arg #2
    let @3: &'_ mut (T); // anonymous local

    @0 := ()
    storage_live(@3)
    @3 := push_mut<'_, T, A>[@TraitClause0, @TraitClause1](move (self@1), move (value@2))
    storage_dead(@3)
    return
}

// Full name: test_crate::vec
fn vec<'_0>(@1: &'_0 mut (Vec<u32>[{built_in impl Sized for u32}, {built_in impl Sized for Global}]))
{
    let @0: (); // return
    let x@1: &'_ mut (Vec<u32>[{built_in impl Sized for u32}, {built_in impl Sized for Global}]); // arg #1
    let @2: &'_ mut (Vec<u32>[{built_in impl Sized for u32}, {built_in impl Sized for Global}]); // anonymous local

    @0 := ()
    storage_live(@2)
    @2 := &two-phase-mut *(x@1)
    @0 := push<'_, u32, Global>[{built_in impl Sized for u32}, {built_in impl Sized for Global}](move (@2), const (42 : u32))
    storage_dead(@2)
    return
}



