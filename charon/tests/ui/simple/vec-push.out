# Final LLBC before serialization:

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub opaque type Layout

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::marker::Destruct::drop_in_place
unsafe fn drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::num::niche_types::UsizeNoHighBit
pub opaque type UsizeNoHighBit

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub opaque type NonNull<T>

// Full name: core::ptr::unique::Unique
pub opaque type Unique<T>

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::raw_vec::RawVec
opaque type RawVec<T, A>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,

// Full name: alloc::raw_vec::RawVecInner
opaque type RawVecInner<A>
where
    [@TraitClause0]: Sized<A>,

// Full name: alloc::raw_vec::{RawVec<T, A>[@TraitClause0, @TraitClause1]}::grow_one
fn grow_one<'_0, T, A>(@1: &'_0 mut RawVec<T, A>[@TraitClause0, @TraitClause1])
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
= <opaque>

// Full name: alloc::vec::Vec
#[lang_item("Vec")]
pub struct Vec<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<type_error("removed allocator parameter")>,
{
  buf: RawVec<T, type_error("removed allocator parameter")>[@TraitClause0, @TraitClause1],
  len: usize,
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: alloc::vec::{Vec<T>[@TraitClause0, @TraitClause1]}::push_mut
pub fn push_mut<'_0, T, A>(@1: &'_0 mut Vec<T>[@TraitClause0, @TraitClause1], @2: T) -> &'_0 mut T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
{
    let _0: &'0 mut T; // return
    let self_1: &'1 mut Vec<T>[@TraitClause0, @TraitClause1]; // arg #1
    let value_2: T; // arg #2
    let len_3: usize; // local
    let _4: bool; // anonymous local
    let _5: usize; // anonymous local
    let _6: (); // anonymous local
    let _7: &'3 mut RawVec<T, A>[@TraitClause0, @TraitClause1]; // anonymous local
    let end_8: *mut T; // local
    let self_9: *mut T; // local
    let src_10: T; // local
    let self_11: UsizeNoHighBit; // local
    let _12: NonNull<u8>; // anonymous local

    storage_live(len_3)
    storage_live(_6)
    storage_live(end_8)
    len_3 := copy ((*(self_1)).len)
    storage_live(_4)
    storage_live(_5)
    switch const ({impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE) {
        0 : usize => {
            _5 := const (18446744073709551615 : usize)
        },
        _ => {
            storage_live(self_11)
            self_11 := copy ((((*(self_1)).buf).0).1)
            _5 := transmute<UsizeNoHighBit, usize>(copy (self_11))
            storage_dead(self_11)
        },
    }
    _4 := copy (len_3) == move (_5)
    if move (_4) {
        storage_dead(_5)
        storage_live(_7)
        _7 := &two-phase-mut (*(self_1)).buf
        _6 := grow_one<'_, T, A>[@TraitClause0, @TraitClause1](move (_7))
        storage_dead(_7)
    } else {
        storage_dead(_5)
    }
    storage_dead(_4)
    storage_live(self_9)
    storage_live(_12)
    _12 := copy (((((*(self_1)).buf).0).0).0)
    self_9 := transmute<NonNull<u8>, *mut T>(copy (_12))
    storage_dead(_12)
    end_8 := copy (self_9) offset copy (len_3)
    storage_dead(self_9)
    storage_live(src_10)
    src_10 := move (value_2)
    *(end_8) := copy (src_10)
    storage_dead(src_10)
    (*(self_1)).len := copy (len_3) wrap.+ const (1 : usize)
    _0 := &mut *(end_8)
    return
}

// Full name: alloc::vec::{Vec<T>[@TraitClause0, @TraitClause1]}::push
pub fn push<'_0, T, A>(@1: &'_0 mut Vec<T>[@TraitClause0, @TraitClause1], @2: T)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
{
    let _0: (); // return
    let self_1: &'0 mut Vec<T>[@TraitClause0, @TraitClause1]; // arg #1
    let value_2: T; // arg #2
    let _3: &'1 mut T; // anonymous local

    _0 := ()
    storage_live(_3)
    _3 := push_mut<'_, T, A>[@TraitClause0, @TraitClause1](move (self_1), move (value_2))
    storage_dead(_3)
    return
}

// Full name: test_crate::vec
fn vec<'_0>(@1: &'_0 mut Vec<u32>[{built_in impl Sized for u32}, {built_in impl Sized for Global}])
{
    let _0: (); // return
    let x_1: &'0 mut Vec<u32>[{built_in impl Sized for u32}, {built_in impl Sized for Global}]; // arg #1
    let _2: &'0 mut Vec<u32>[{built_in impl Sized for u32}, {built_in impl Sized for Global}]; // anonymous local

    _0 := ()
    storage_live(_2)
    _2 := &two-phase-mut *(x_1)
    _0 := push<'_, u32, Global>[{built_in impl Sized for u32}, {built_in impl Sized for Global}](move (_2), const (42 : u32))
    storage_dead(_2)
    return
}



