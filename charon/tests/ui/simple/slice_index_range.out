# Final LLBC before serialization:

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub struct NonNull<T> {
  pointer: *const T,
}

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::marker::PhantomData
#[lang_item("phantom_data")]
pub struct PhantomData<T> {}

// Full name: core::fmt::rt::ArgumentType
enum ArgumentType<'a> {
  Placeholder(value: NonNull<()>, formatter: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], _lifetime: PhantomData<&'a ()>),
  Count(u16),
}

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub struct Argument<'a> {
  ty: ArgumentType<'a>,
}

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub struct Arguments<'a> {
  template: NonNull<u8>,
  args: NonNull<Argument<'a>>,
}

fn core::slice::index::slice_index_fail::do_panic::runtime(@1: usize, @2: usize) -> !
= <missing>

fn core::slice::index::slice_index_fail::do_panic#1::runtime(@1: usize, @2: usize) -> !
= <missing>

fn core::slice::index::slice_index_fail::do_panic#2::runtime(@1: usize, @2: usize) -> !
= <missing>

fn core::slice::index::slice_index_fail::do_panic#3::runtime(@1: usize, @2: usize) -> !
= <missing>

// Full name: core::panicking::panic_nounwind_fmt::compiletime
fn compiletime<'_0>(@1: Arguments<'_0>, @2: bool) -> !
{
    let _0: !; // return
    let fmt_1: Arguments<'0>; // arg #1
    let force_no_backtrace_2: bool; // arg #2

    panic(core::panicking::panic_fmt)
}

// Full name: core::num::{usize}::MAX
pub fn MAX() -> usize
{
    let _0: usize; // return

    _0 = ~(const (0 : usize))
    return
}

// Full name: core::num::{usize}::MAX
pub const MAX: usize = MAX()

// Full name: core::ops::index::Index
#[lang_item("index")]
pub trait Index<Self, Idx>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: MetaSized<Idx>
    parent_clause2 : [@TraitClause2]: MetaSized<Self::Output>
    type Output
    fn index<'_0_1> = core::ops::index::Index::index<'_0_1, Self, Idx>[Self]
    vtable: core::ops::index::Index::{vtable}<Idx, Self::Output>
}

pub fn core::ops::index::Index::index<'_0, Self, Idx>(@1: &'_0 Self, @2: Idx) -> &'_0 @TraitClause0::Output
where
    [@TraitClause0]: Index<Self, Idx>,
= <method_without_default_body>

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::ops::range::RangeInclusive
#[lang_item("RangeInclusive")]
pub struct RangeInclusive<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
  exhausted: bool,
}

// Full name: core::ops::range::{RangeInclusive<Idx>[@TraitClause0]}::new
#[lang_item("range_inclusive_new")]
pub fn new<Idx>(@1: Idx, @2: Idx) -> RangeInclusive<Idx>[@TraitClause0]
where
    [@TraitClause0]: Sized<Idx>,
{
    let _0: RangeInclusive<Idx>[@TraitClause0]; // return
    let start_1: Idx; // arg #1
    let end_2: Idx; // arg #2

    _0 = RangeInclusive { start: copy (start_1), end: copy (end_2), exhausted: const (false) }
    return
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

fn core::slice::index::slice_index_fail::do_panic(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic::runtime(move (start_1), move (len_2))
}

fn core::slice::index::slice_index_fail::do_panic#1(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let end_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#1::runtime(move (end_1), move (len_2))
}

fn core::slice::index::slice_index_fail::do_panic#2(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#2::runtime(move (start_1), move (end_2))
}

fn core::slice::index::slice_index_fail::do_panic#3(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let end_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#3::runtime(move (end_1), move (len_2))
}

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
{
    let _0: !; // return
    let fmt_1: Arguments<'0>; // arg #1
    let force_no_backtrace_2: bool; // arg #2
    let _3: (Arguments<'0>, bool); // anonymous local
    let _4: Arguments<'0>; // anonymous local
    let _5: bool; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy (fmt_1)
    storage_live(_5)
    _5 = copy (force_no_backtrace_2)
    _3 = (move (_4), move (_5))
    storage_dead(_5)
    storage_dead(_4)
    _0 = compiletime<'_>(move ((_3).0), move ((_3).1))
}

// Full name: core::slice::index::private_slice_index::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::slice::index::private_slice_index::Sealed::{vtable}
}

// Full name: core::slice::index::SliceIndex
#[lang_item("SliceIndex")]
pub trait SliceIndex<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sealed<Self>
    parent_clause2 : [@TraitClause2]: MetaSized<T>
    parent_clause3 : [@TraitClause3]: MetaSized<Self::Output>
    type Output
    fn get<'_0_1> = core::slice::index::SliceIndex::get<'_0_1, Self, T>[Self]
    fn get_mut<'_0_1> = core::slice::index::SliceIndex::get_mut<'_0_1, Self, T>[Self]
    fn get_unchecked = core::slice::index::SliceIndex::get_unchecked<Self, T>[Self]
    fn get_unchecked_mut = core::slice::index::SliceIndex::get_unchecked_mut<Self, T>[Self]
    fn index<'_0_1> = core::slice::index::SliceIndex::index<'_0_1, Self, T>[Self]
    fn index_mut<'_0_1> = core::slice::index::SliceIndex::index_mut<'_0_1, Self, T>[Self]
    vtable: core::slice::index::SliceIndex::{vtable}<T, Self::Output>
}

pub fn core::slice::index::SliceIndex::index<'_0, Self, T>(@1: Self, @2: &'_0 T) -> &'_0 @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

// Full name: core::slice::index::{impl Index<I> for [T]}::index
pub fn {impl Index<I> for [T]}::index<'_0, T, I>(@1: &'_0 [T], @2: I) -> &'_0 @TraitClause2::Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T]>,
{
    let _0: &'0 @TraitClause2::Output; // return
    let self_1: &'1 [T]; // arg #1
    let index_2: I; // arg #2

    _0 = @TraitClause2::index<'_>(move (index_2), move (self_1))
    return
}

// Full name: core::slice::index::{impl Index<I> for [T]}
impl<T, I> Index<I> for [T]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T]>,
{
    parent_clause0 = {built_in impl MetaSized for [T]}
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause3
    type Output = @TraitClause2::Output
    fn index<'_0_1> = {impl Index<I> for [T]}::index<'_0_1, T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl Index<I> for [T]}::{vtable}<T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::slice::index::slice_index_fail
fn slice_index_fail(@1: usize, @2: usize, @3: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: !; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: bool; // anonymous local
    let _11: usize; // anonymous local
    let _12: usize; // anonymous local
    let _13: !; // anonymous local
    let _14: usize; // anonymous local
    let _15: usize; // anonymous local
    let _16: bool; // anonymous local
    let _17: usize; // anonymous local
    let _18: usize; // anonymous local
    let _19: !; // anonymous local
    let _20: usize; // anonymous local
    let _21: usize; // anonymous local
    let _22: usize; // anonymous local
    let _23: usize; // anonymous local

    storage_live(_4)
    storage_live(_5)
    _5 = copy (start_1)
    storage_live(_6)
    _6 = copy (len_3)
    _4 = move (_5) > move (_6)
    if move (_4) {
    } else {
        storage_dead(_6)
        storage_dead(_5)
        storage_dead(_4)
        storage_live(_10)
        storage_live(_11)
        _11 = copy (end_2)
        storage_live(_12)
        _12 = copy (len_3)
        _10 = move (_11) > move (_12)
        if move (_10) {
        } else {
            storage_dead(_12)
            storage_dead(_11)
            storage_dead(_10)
            storage_live(_16)
            storage_live(_17)
            _17 = copy (start_1)
            storage_live(_18)
            _18 = copy (end_2)
            _16 = move (_17) > move (_18)
            if move (_16) {
            } else {
                storage_dead(_18)
                storage_dead(_17)
                storage_dead(_16)
                storage_live(_22)
                _22 = copy (end_2)
                storage_live(_23)
                _23 = copy (len_3)
                _0 = core::slice::index::slice_index_fail::do_panic#3(move (_22), move (_23))
            }
            storage_dead(_18)
            storage_dead(_17)
            storage_live(_19)
            storage_live(_20)
            _20 = copy (start_1)
            storage_live(_21)
            _21 = copy (end_2)
            _19 = core::slice::index::slice_index_fail::do_panic#2(move (_20), move (_21))
        }
        storage_dead(_12)
        storage_dead(_11)
        storage_live(_13)
        storage_live(_14)
        _14 = copy (end_2)
        storage_live(_15)
        _15 = copy (len_3)
        _13 = core::slice::index::slice_index_fail::do_panic#1(move (_14), move (_15))
    }
    storage_dead(_6)
    storage_dead(_5)
    storage_live(_7)
    storage_live(_8)
    _8 = copy (start_1)
    storage_live(_9)
    _9 = copy (len_3)
    _7 = core::slice::index::slice_index_fail::do_panic(move (_8), move (_9))
}

// Full name: core::slice::index::private_slice_index::{impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
impl Sealed for Range<usize>[{built_in impl Sized for usize}] {
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    vtable: {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}::{vtable}
}

// Full name: core::slice::index::private_slice_index::{impl Sealed for RangeInclusive<usize>[{built_in impl Sized for usize}]}
impl Sealed for RangeInclusive<usize>[{built_in impl Sized for usize}] {
    parent_clause0 = {built_in impl MetaSized for RangeInclusive<usize>[{built_in impl Sized for usize}]}
    vtable: {impl Sealed for RangeInclusive<usize>[{built_in impl Sized for usize}]}::{vtable}
}

pub fn core::slice::index::SliceIndex::get<'_0, Self, T>(@1: Self, @2: &'_0 T) -> Option<&'_0 @TraitClause0::Output>[{built_in impl Sized for &'_0 @TraitClause0::Output}]
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub fn core::slice::index::SliceIndex::get_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut T) -> Option<&'_0 mut @TraitClause0::Output>[{built_in impl Sized for &'_0 mut @TraitClause0::Output}]
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T>(@1: Self, @2: *const T) -> *const @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T>(@1: Self, @2: *mut T) -> *mut @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub fn core::slice::index::SliceIndex::index_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut T) -> &'_0 mut @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> Option<&'_0 [T]>[{built_in impl Sized for &'_0 [T]}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<&'0 [T]>[{built_in impl Sized for &'0 [T]}]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'0 [T]; // anonymous local
    let _10: *const [T]; // anonymous local
    let _11: *const [T]; // anonymous local
    let _12: bool; // anonymous local
    let _13: usize; // anonymous local
    let _14: *const T; // anonymous local
    let _15: *const T; // anonymous local
    let _16: Option<&'0 [T]>[{built_in impl Sized for &'0 [T]}]; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_9)
    storage_live(_3)
    self_4 = copy ((self_1).end)
    rhs_5 = copy ((self_1).start)
    storage_live(_12)
    _12 = copy (self_4) < copy (rhs_5)
    if move (_12) {
        storage_dead(_12)
        storage_dead(_3)
        storage_live(_16)
        _16 = Option::None {  }
        _0 = move (_16)
    } else {
        storage_live(_13)
        _13 = copy (self_4) ub.- copy (rhs_5)
        _3 = Option::Some { 0: move (_13) }
        storage_dead(_13)
        storage_dead(_12)
        new_len_6 = copy ((_3 as variant Option::Some).0)
        storage_live(_7)
        storage_live(_8)
        _8 = copy (slice_2.metadata)
        _7 = copy (self_4) <= move (_8)
        if move (_7) {
            storage_dead(_8)
            storage_live(_10)
            storage_live(_11)
            _11 = &raw const *(slice_2) with_metadata(copy (slice_2.metadata))
            storage_live(_14)
            storage_live(_15)
            _14 = cast<*const [T], *const T>(copy (_11))
            _15 = copy (_14) offset copy (rhs_5)
            _10 = @PtrFromPartsShared<'_, [T]>(copy (_15), copy (new_len_6))
            storage_dead(_15)
            storage_dead(_14)
            storage_dead(_11)
            _9 = &*(_10) with_metadata(copy (_10.metadata))
            _0 = Option::Some { 0: copy (_9) }
            storage_dead(_10)
            storage_dead(_3)
        } else {
            storage_dead(_8)
            storage_dead(_3)
            storage_live(_16)
            _16 = Option::None {  }
            _0 = move (_16)
        }
    }
    storage_dead(_7)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> Option<&'_0 mut [T]>[{built_in impl Sized for &'_0 mut [T]}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<&'0 mut [T]>[{built_in impl Sized for &'0 mut [T]}]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 mut [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'0 mut [T]; // anonymous local
    let _10: *mut [T]; // anonymous local
    let ptr_11: *mut [T]; // local
    let _12: bool; // anonymous local
    let _13: usize; // anonymous local
    let _14: *mut T; // anonymous local
    let _15: *mut T; // anonymous local
    let _16: Option<&'0 mut [T]>[{built_in impl Sized for &'0 mut [T]}]; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_9)
    storage_live(_3)
    self_4 = copy ((self_1).end)
    rhs_5 = copy ((self_1).start)
    storage_live(_12)
    _12 = copy (self_4) < copy (rhs_5)
    if move (_12) {
        storage_dead(_12)
        storage_dead(_3)
        storage_live(_16)
        _16 = Option::None {  }
        _0 = move (_16)
    } else {
        storage_live(_13)
        _13 = copy (self_4) ub.- copy (rhs_5)
        _3 = Option::Some { 0: move (_13) }
        storage_dead(_13)
        storage_dead(_12)
        new_len_6 = copy ((_3 as variant Option::Some).0)
        storage_live(_7)
        storage_live(_8)
        _8 = copy (slice_2.metadata)
        _7 = copy (self_4) <= move (_8)
        if move (_7) {
            storage_dead(_8)
            storage_live(_10)
            storage_live(ptr_11)
            ptr_11 = &raw mut *(slice_2) with_metadata(copy (slice_2.metadata))
            storage_live(_14)
            storage_live(_15)
            _14 = cast<*mut [T], *mut T>(copy (ptr_11))
            _15 = copy (_14) offset copy (rhs_5)
            _10 = @PtrFromPartsMut<'_, [T]>(copy (_15), copy (new_len_6))
            storage_dead(_15)
            storage_dead(_14)
            storage_dead(ptr_11)
            _9 = &mut *(_10) with_metadata(copy (_10.metadata))
            _0 = Option::Some { 0: copy (_9) }
            storage_dead(_10)
            storage_dead(_3)
        } else {
            storage_dead(_8)
            storage_dead(_3)
            storage_live(_16)
            _16 = Option::None {  }
            _0 = move (_16)
        }
    }
    storage_dead(_7)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check
fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check(@1: usize, @2: usize, @3: usize)
{
    let _0: (); // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: bool; // anonymous local
    let msg_6: &'0 Str; // local
    let _7: !; // anonymous local
    let _8: Arguments<'1>; // anonymous local
    let _9: NonNull<u8>; // anonymous local
    let _10: *const u8; // anonymous local
    let _11: NonNull<Argument<'2>>; // anonymous local
    let _12: usize; // anonymous local
    let _13: usize; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const Str; // anonymous local
    let _16: &'3 [u8]; // anonymous local

    storage_live(msg_6)
    storage_live(_7)
    _0 = ()
    storage_live(_4)
    _4 = copy (end_2) >= copy (start_1)
    if move (_4) {
        storage_live(_5)
        _5 = copy (end_2) <= copy (len_3)
        if move (_5) {
            storage_dead(_5)
            storage_dead(_4)
            return
        } else {
        }
    } else {
    }
    msg_6 = const ("unsafe precondition(s) violated: slice::get_unchecked requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    storage_live(_15)
    _15 = &raw const *(msg_6) with_metadata(copy (msg_6.metadata))
    _10 = cast<*const Str, *const u8>(copy (_15))
    storage_dead(_15)
    _9 = transmute<*const u8, NonNull<u8>>(copy (_10))
    storage_dead(_10)
    storage_live(_11)
    storage_live(_12)
    storage_live(_13)
    storage_live(_14)
    storage_live(_16)
    _16 = transmute<&'0 Str, &'3 [u8]>(const ("unsafe precondition(s) violated: slice::get_unchecked requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
    _14 = copy (_16.metadata)
    storage_dead(_16)
    _13 = move (_14) wrap.<< const (1 : i32)
    storage_dead(_14)
    _12 = move (_13) | const (1 : usize)
    storage_dead(_13)
    _11 = transmute<usize, NonNull<Argument<'2>>>(move (_12))
    storage_dead(_12)
    _8 = Arguments { template: move (_9), args: move (_11) }
    storage_dead(_11)
    storage_dead(_9)
    _7 = panic_nounwind_fmt<'_>(move (_8), const (false))
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked
pub unsafe fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *const [T]) -> *const [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *const [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: *const [T]; // arg #2
    let _3: bool; // anonymous local
    let _4: (); // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let new_len_8: usize; // local
    let _9: usize; // anonymous local
    let offset_10: usize; // local
    let _11: *const T; // anonymous local
    let _12: *const T; // anonymous local

    storage_live(_4)
    storage_live(new_len_8)
    storage_live(offset_10)
    storage_live(_3)
    _3 = ub_checks<bool>
    if move (_3) {
        storage_live(_5)
        _5 = copy ((self_1).start)
        storage_live(_6)
        _6 = copy ((self_1).end)
        storage_live(_7)
        _7 = copy (slice_2.metadata)
        _4 = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check(move (_5), move (_6), move (_7))
        storage_dead(_7)
        storage_dead(_6)
        storage_dead(_5)
    } else {
    }
    storage_dead(_3)
    storage_live(_9)
    _9 = copy ((self_1).end)
    offset_10 = copy ((self_1).start)
    new_len_8 = move (_9) ub.- copy (offset_10)
    storage_dead(_9)
    storage_live(_11)
    storage_live(_12)
    _11 = cast<*const [T], *const T>(copy (slice_2))
    _12 = copy (_11) offset copy (offset_10)
    _0 = @PtrFromPartsShared<'_, [T]>(copy (_12), copy (new_len_8))
    storage_dead(_12)
    storage_dead(_11)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check
fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check(@1: usize, @2: usize, @3: usize)
{
    let _0: (); // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: bool; // anonymous local
    let msg_6: &'0 Str; // local
    let _7: !; // anonymous local
    let _8: Arguments<'1>; // anonymous local
    let _9: NonNull<u8>; // anonymous local
    let _10: *const u8; // anonymous local
    let _11: NonNull<Argument<'2>>; // anonymous local
    let _12: usize; // anonymous local
    let _13: usize; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const Str; // anonymous local
    let _16: &'3 [u8]; // anonymous local

    storage_live(msg_6)
    storage_live(_7)
    _0 = ()
    storage_live(_4)
    _4 = copy (end_2) >= copy (start_1)
    if move (_4) {
        storage_live(_5)
        _5 = copy (end_2) <= copy (len_3)
        if move (_5) {
            storage_dead(_5)
            storage_dead(_4)
            return
        } else {
        }
    } else {
    }
    msg_6 = const ("unsafe precondition(s) violated: slice::get_unchecked_mut requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    storage_live(_15)
    _15 = &raw const *(msg_6) with_metadata(copy (msg_6.metadata))
    _10 = cast<*const Str, *const u8>(copy (_15))
    storage_dead(_15)
    _9 = transmute<*const u8, NonNull<u8>>(copy (_10))
    storage_dead(_10)
    storage_live(_11)
    storage_live(_12)
    storage_live(_13)
    storage_live(_14)
    storage_live(_16)
    _16 = transmute<&'0 Str, &'3 [u8]>(const ("unsafe precondition(s) violated: slice::get_unchecked_mut requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
    _14 = copy (_16.metadata)
    storage_dead(_16)
    _13 = move (_14) wrap.<< const (1 : i32)
    storage_dead(_14)
    _12 = move (_13) | const (1 : usize)
    storage_dead(_13)
    _11 = transmute<usize, NonNull<Argument<'2>>>(move (_12))
    storage_dead(_12)
    _8 = Arguments { template: move (_9), args: move (_11) }
    storage_dead(_11)
    storage_dead(_9)
    _7 = panic_nounwind_fmt<'_>(move (_8), const (false))
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut
pub unsafe fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *mut [T]) -> *mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *mut [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: *mut [T]; // arg #2
    let _3: bool; // anonymous local
    let _4: (); // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let new_len_8: usize; // local
    let _9: usize; // anonymous local
    let offset_10: usize; // local
    let _11: *mut T; // anonymous local
    let _12: *mut T; // anonymous local

    storage_live(_4)
    storage_live(new_len_8)
    storage_live(offset_10)
    storage_live(_3)
    _3 = ub_checks<bool>
    if move (_3) {
        storage_live(_5)
        _5 = copy ((self_1).start)
        storage_live(_6)
        _6 = copy ((self_1).end)
        storage_live(_7)
        _7 = copy (slice_2.metadata)
        _4 = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check(move (_5), move (_6), move (_7))
        storage_dead(_7)
        storage_dead(_6)
        storage_dead(_5)
    } else {
    }
    storage_dead(_3)
    storage_live(_9)
    _9 = copy ((self_1).end)
    offset_10 = copy ((self_1).start)
    new_len_8 = move (_9) ub.- copy (offset_10)
    storage_dead(_9)
    storage_live(_11)
    storage_live(_12)
    _11 = cast<*mut [T], *mut T>(copy (slice_2))
    _12 = copy (_11) offset copy (offset_10)
    _0 = @PtrFromPartsMut<'_, [T]>(copy (_12), copy (new_len_8))
    storage_dead(_12)
    storage_dead(_11)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> &'_0 [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: *const [T]; // anonymous local
    let _10: *const [T]; // anonymous local
    let _11: !; // anonymous local
    let _12: usize; // anonymous local
    let _13: bool; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const T; // anonymous local
    let _16: *const T; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_11)
    storage_live(_3)
    self_4 = copy ((self_1).end)
    rhs_5 = copy ((self_1).start)
    storage_live(_13)
    _13 = copy (self_4) < copy (rhs_5)
    if move (_13) {
        storage_dead(_13)
    } else {
        storage_live(_14)
        _14 = copy (self_4) ub.- copy (rhs_5)
        _3 = Option::Some { 0: move (_14) }
        storage_dead(_14)
        storage_dead(_13)
        new_len_6 = copy ((_3 as variant Option::Some).0)
        storage_live(_7)
        storage_live(_8)
        _8 = copy (slice_2.metadata)
        _7 = copy (self_4) <= move (_8)
        if move (_7) {
            storage_dead(_8)
            storage_live(_9)
            storage_live(_10)
            _10 = &raw const *(slice_2) with_metadata(copy (slice_2.metadata))
            storage_live(_15)
            storage_live(_16)
            _15 = cast<*const [T], *const T>(copy (_10))
            _16 = copy (_15) offset copy (rhs_5)
            _9 = @PtrFromPartsShared<'_, [T]>(copy (_16), copy (new_len_6))
            storage_dead(_16)
            storage_dead(_15)
            storage_dead(_10)
            _0 = &*(_9) with_metadata(copy (_9.metadata))
            storage_dead(_9)
            storage_dead(_3)
            storage_dead(_7)
            return
        } else {
            storage_dead(_8)
        }
    }
    storage_dead(_3)
    storage_live(_12)
    _12 = copy (slice_2.metadata)
    _11 = slice_index_fail(move (rhs_5), move (self_4), move (_12))
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> &'_0 mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 mut [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: *mut [T]; // anonymous local
    let ptr_10: *mut [T]; // local
    let _11: !; // anonymous local
    let _12: usize; // anonymous local
    let _13: bool; // anonymous local
    let _14: usize; // anonymous local
    let _15: *mut T; // anonymous local
    let _16: *mut T; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_11)
    storage_live(_3)
    self_4 = copy ((self_1).end)
    rhs_5 = copy ((self_1).start)
    storage_live(_13)
    _13 = copy (self_4) < copy (rhs_5)
    if move (_13) {
        storage_dead(_13)
    } else {
        storage_live(_14)
        _14 = copy (self_4) ub.- copy (rhs_5)
        _3 = Option::Some { 0: move (_14) }
        storage_dead(_14)
        storage_dead(_13)
        new_len_6 = copy ((_3 as variant Option::Some).0)
        storage_live(_7)
        storage_live(_8)
        _8 = copy (slice_2.metadata)
        _7 = copy (self_4) <= move (_8)
        if move (_7) {
            storage_dead(_8)
            storage_live(_9)
            storage_live(ptr_10)
            ptr_10 = &raw mut *(slice_2) with_metadata(copy (slice_2.metadata))
            storage_live(_15)
            storage_live(_16)
            _15 = cast<*mut [T], *mut T>(copy (ptr_10))
            _16 = copy (_15) offset copy (rhs_5)
            _9 = @PtrFromPartsMut<'_, [T]>(copy (_16), copy (new_len_6))
            storage_dead(_16)
            storage_dead(_15)
            storage_dead(ptr_10)
            _0 = &mut *(_9) with_metadata(copy (_9.metadata))
            storage_dead(_9)
            storage_dead(_3)
            storage_dead(_7)
            return
        } else {
            storage_dead(_8)
        }
    }
    storage_dead(_3)
    storage_live(_12)
    _12 = copy (slice_2.metadata)
    _11 = slice_index_fail(move (rhs_5), move (self_4), move (_12))
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}
impl<T> SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause1 = {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause2 = {built_in impl MetaSized for [T]}
    parent_clause3 = {built_in impl MetaSized for [T]}
    type Output = [T]
    fn get<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0_1, T>[@TraitClause0]
    fn get_mut<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0_1, T>[@TraitClause0]
    fn get_unchecked = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0_1, T>[@TraitClause0]
    fn index_mut<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0_1, T>[@TraitClause0]
    vtable: {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::{vtable}<T>[@TraitClause0]
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get
pub fn {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get<'_0, T>(@1: RangeInclusive<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> Option<&'_0 [T]>[{built_in impl Sized for &'_0 [T]}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<&'0 [T]>[{built_in impl Sized for &'0 [T]}]; // return
    let self_1: RangeInclusive<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 [T]; // arg #2
    let _3: bool; // anonymous local
    let self_4: usize; // local
    let exclusive_end_5: usize; // local
    let _6: bool; // anonymous local
    let _7: usize; // anonymous local
    let _8: &'0 [T]; // anonymous local
    let _9: *const [T]; // anonymous local
    let _10: *const [T]; // anonymous local
    let _11: bool; // anonymous local
    let new_len_12: usize; // local
    let _13: *const T; // anonymous local
    let _14: *const T; // anonymous local
    let self_15: usize; // local
    let self_16: bool; // local
    let _17: Option<&'0 [T]>[{built_in impl Sized for &'0 [T]}]; // anonymous local
    let _18: Option<&'0 [T]>[{built_in impl Sized for &'0 [T]}]; // anonymous local

    storage_live(self_4)
    storage_live(exclusive_end_5)
    storage_live(new_len_12)
    storage_live(self_15)
    storage_live(self_16)
    storage_live(_3)
    self_4 = copy ((self_1).end)
    _3 = copy (self_4) == copy (MAX)
    if move (_3) {
        storage_live(_17)
        _17 = Option::None {  }
        _0 = move (_17)
    } else {
        self_15 = move ((self_1).start)
        self_16 = move ((self_1).exhausted)
        exclusive_end_5 = copy (self_4) wrap.+ const (1 : usize)
        if copy (self_16) {
            self_15 = copy (exclusive_end_5)
        } else {
        }
        storage_live(_8)
        storage_live(_11)
        _11 = copy (exclusive_end_5) < copy (self_15)
        if move (_11) {
            storage_dead(_11)
            storage_live(_18)
            _18 = Option::None {  }
            _0 = move (_18)
            storage_dead(_6)
            storage_dead(_8)
        } else {
            new_len_12 = copy (exclusive_end_5) ub.- copy (self_15)
            storage_dead(_11)
            storage_live(_6)
            storage_live(_7)
            _7 = copy (slice_2.metadata)
            _6 = copy (exclusive_end_5) <= move (_7)
            if move (_6) {
                storage_dead(_7)
                storage_live(_9)
                storage_live(_10)
                _10 = &raw const *(slice_2) with_metadata(copy (slice_2.metadata))
                storage_live(_13)
                storage_live(_14)
                _13 = cast<*const [T], *const T>(copy (_10))
                _14 = copy (_13) offset copy (self_15)
                _9 = @PtrFromPartsShared<'_, [T]>(copy (_14), copy (new_len_12))
                storage_dead(_14)
                storage_dead(_13)
                storage_dead(_10)
                _8 = &*(_9) with_metadata(copy (_9.metadata))
                _0 = Option::Some { 0: copy (_8) }
                storage_dead(_9)
            } else {
                storage_dead(_7)
                storage_live(_18)
                _18 = Option::None {  }
                _0 = move (_18)
            }
            storage_dead(_6)
            storage_dead(_8)
        }
    }
    storage_dead(_3)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_mut
pub fn {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_mut<'_0, T>(@1: RangeInclusive<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> Option<&'_0 mut [T]>[{built_in impl Sized for &'_0 mut [T]}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<&'0 mut [T]>[{built_in impl Sized for &'0 mut [T]}]; // return
    let self_1: RangeInclusive<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 mut [T]; // arg #2
    let _3: bool; // anonymous local
    let self_4: usize; // local
    let exclusive_end_5: usize; // local
    let _6: bool; // anonymous local
    let _7: usize; // anonymous local
    let _8: &'0 mut [T]; // anonymous local
    let _9: *mut [T]; // anonymous local
    let ptr_10: *mut [T]; // local
    let _11: bool; // anonymous local
    let new_len_12: usize; // local
    let _13: *mut T; // anonymous local
    let _14: *mut T; // anonymous local
    let self_15: usize; // local
    let self_16: bool; // local
    let _17: Option<&'0 mut [T]>[{built_in impl Sized for &'0 mut [T]}]; // anonymous local
    let _18: Option<&'0 mut [T]>[{built_in impl Sized for &'0 mut [T]}]; // anonymous local

    storage_live(self_4)
    storage_live(exclusive_end_5)
    storage_live(new_len_12)
    storage_live(self_15)
    storage_live(self_16)
    storage_live(_3)
    self_4 = copy ((self_1).end)
    _3 = copy (self_4) == copy (MAX)
    if move (_3) {
        storage_live(_17)
        _17 = Option::None {  }
        _0 = move (_17)
    } else {
        self_15 = move ((self_1).start)
        self_16 = move ((self_1).exhausted)
        exclusive_end_5 = copy (self_4) wrap.+ const (1 : usize)
        if copy (self_16) {
            self_15 = copy (exclusive_end_5)
        } else {
        }
        storage_live(_8)
        storage_live(_11)
        _11 = copy (exclusive_end_5) < copy (self_15)
        if move (_11) {
            storage_dead(_11)
            storage_live(_18)
            _18 = Option::None {  }
            _0 = move (_18)
            storage_dead(_6)
            storage_dead(_8)
        } else {
            new_len_12 = copy (exclusive_end_5) ub.- copy (self_15)
            storage_dead(_11)
            storage_live(_6)
            storage_live(_7)
            _7 = copy (slice_2.metadata)
            _6 = copy (exclusive_end_5) <= move (_7)
            if move (_6) {
                storage_dead(_7)
                storage_live(_9)
                storage_live(ptr_10)
                ptr_10 = &raw mut *(slice_2) with_metadata(copy (slice_2.metadata))
                storage_live(_13)
                storage_live(_14)
                _13 = cast<*mut [T], *mut T>(copy (ptr_10))
                _14 = copy (_13) offset copy (self_15)
                _9 = @PtrFromPartsMut<'_, [T]>(copy (_14), copy (new_len_12))
                storage_dead(_14)
                storage_dead(_13)
                storage_dead(ptr_10)
                _8 = &mut *(_9) with_metadata(copy (_9.metadata))
                _0 = Option::Some { 0: copy (_8) }
                storage_dead(_9)
            } else {
                storage_dead(_7)
                storage_live(_18)
                _18 = Option::None {  }
                _0 = move (_18)
            }
            storage_dead(_6)
            storage_dead(_8)
        }
    }
    storage_dead(_3)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_unchecked
pub unsafe fn {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>(@1: RangeInclusive<usize>[{built_in impl Sized for usize}], @2: *const [T]) -> *const [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *const [T]; // return
    let self_1: RangeInclusive<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: *const [T]; // arg #2
    let exclusive_end_3: usize; // local
    let _4: bool; // anonymous local
    let _5: (); // anonymous local
    let _6: usize; // anonymous local
    let new_len_7: usize; // local
    let _8: *const T; // anonymous local
    let _9: *const T; // anonymous local
    let self_10: usize; // local
    let self_11: usize; // local
    let self_12: bool; // local

    storage_live(exclusive_end_3)
    storage_live(_5)
    storage_live(self_10)
    storage_live(self_11)
    storage_live(self_12)
    self_10 = move ((self_1).start)
    self_11 = move ((self_1).end)
    self_12 = move ((self_1).exhausted)
    exclusive_end_3 = copy (self_11) wrap.+ const (1 : usize)
    if copy (self_12) {
        self_10 = copy (exclusive_end_3)
    } else {
    }
    storage_live(new_len_7)
    storage_live(_4)
    _4 = ub_checks<bool>
    if move (_4) {
        storage_live(_6)
        _6 = copy (slice_2.metadata)
        _5 = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check(copy (self_10), copy (exclusive_end_3), move (_6))
        storage_dead(_6)
    } else {
    }
    storage_dead(_4)
    new_len_7 = copy (exclusive_end_3) ub.- copy (self_10)
    storage_live(_8)
    storage_live(_9)
    _8 = cast<*const [T], *const T>(copy (slice_2))
    _9 = copy (_8) offset copy (self_10)
    _0 = @PtrFromPartsShared<'_, [T]>(copy (_9), copy (new_len_7))
    storage_dead(_9)
    storage_dead(_8)
    storage_dead(new_len_7)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut
pub unsafe fn {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>(@1: RangeInclusive<usize>[{built_in impl Sized for usize}], @2: *mut [T]) -> *mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *mut [T]; // return
    let self_1: RangeInclusive<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: *mut [T]; // arg #2
    let exclusive_end_3: usize; // local
    let _4: bool; // anonymous local
    let _5: (); // anonymous local
    let _6: usize; // anonymous local
    let new_len_7: usize; // local
    let _8: *mut T; // anonymous local
    let _9: *mut T; // anonymous local
    let self_10: usize; // local
    let self_11: usize; // local
    let self_12: bool; // local

    storage_live(exclusive_end_3)
    storage_live(_5)
    storage_live(self_10)
    storage_live(self_11)
    storage_live(self_12)
    self_10 = move ((self_1).start)
    self_11 = move ((self_1).end)
    self_12 = move ((self_1).exhausted)
    exclusive_end_3 = copy (self_11) wrap.+ const (1 : usize)
    if copy (self_12) {
        self_10 = copy (exclusive_end_3)
    } else {
    }
    storage_live(new_len_7)
    storage_live(_4)
    _4 = ub_checks<bool>
    if move (_4) {
        storage_live(_6)
        _6 = copy (slice_2.metadata)
        _5 = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check(copy (self_10), copy (exclusive_end_3), move (_6))
        storage_dead(_6)
    } else {
    }
    storage_dead(_4)
    new_len_7 = copy (exclusive_end_3) ub.- copy (self_10)
    storage_live(_8)
    storage_live(_9)
    _8 = cast<*mut [T], *mut T>(copy (slice_2))
    _9 = copy (_8) offset copy (self_10)
    _0 = @PtrFromPartsMut<'_, [T]>(copy (_9), copy (new_len_7))
    storage_dead(_9)
    storage_dead(_8)
    storage_dead(new_len_7)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::index
pub fn {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::index<'_0, T>(@1: RangeInclusive<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> &'_0 [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 [T]; // return
    let self_1: RangeInclusive<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 [T]; // arg #2
    let start_3: usize; // local
    let end_4: usize; // local
    let exhausted_5: bool; // local
    let len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_11: usize; // local
    let rhs_12: usize; // local
    let new_len_13: usize; // local
    let _14: *const [T]; // anonymous local
    let _15: *const [T]; // anonymous local
    let _16: !; // anonymous local
    let _17: bool; // anonymous local
    let _18: usize; // anonymous local
    let _19: *const T; // anonymous local
    let _20: *const T; // anonymous local

    storage_live(start_3)
    storage_live(end_4)
    storage_live(exhausted_5)
    storage_live(len_6)
    storage_live(new_len_13)
    storage_live(_16)
    start_3 = copy ((self_1).start)
    end_4 = copy ((self_1).end)
    exhausted_5 = copy ((self_1).exhausted)
    len_6 = copy (slice_2.metadata)
    storage_live(_7)
    storage_live(_8)
    _8 = copy (end_4)
    _7 = move (_8) < copy (len_6)
    if move (_7) {
        storage_dead(_8)
        storage_live(_9)
        _9 = copy (end_4)
        end_4 = move (_9) wrap.+ const (1 : usize)
        storage_dead(_9)
        if copy (exhausted_5) {
            start_3 = copy (end_4)
        } else {
        }
        storage_live(_10)
        storage_live(self_11)
        self_11 = copy (end_4)
        storage_live(rhs_12)
        rhs_12 = copy (start_3)
        storage_live(_17)
        _17 = copy (self_11) < copy (rhs_12)
        if move (_17) {
            storage_dead(_17)
            storage_dead(rhs_12)
            storage_dead(self_11)
            storage_dead(_10)
        } else {
            storage_live(_18)
            _18 = copy (self_11) ub.- copy (rhs_12)
            _10 = Option::Some { 0: move (_18) }
            storage_dead(_18)
            storage_dead(_17)
            storage_dead(rhs_12)
            storage_dead(self_11)
            new_len_13 = copy ((_10 as variant Option::Some).0)
            storage_live(_14)
            storage_live(_15)
            _15 = &raw const *(slice_2) with_metadata(copy (slice_2.metadata))
            storage_live(_19)
            storage_live(_20)
            _19 = cast<*const [T], *const T>(copy (_15))
            _20 = copy (_19) offset copy (start_3)
            _14 = @PtrFromPartsShared<'_, [T]>(copy (_20), copy (new_len_13))
            storage_dead(_20)
            storage_dead(_19)
            storage_dead(_15)
            _0 = &*(_14) with_metadata(copy (_14.metadata))
            storage_dead(_14)
            storage_dead(_10)
            storage_dead(_7)
            return
        }
    } else {
        storage_dead(_8)
    }
    storage_dead(_7)
    _16 = slice_index_fail(move (start_3), move (end_4), move (len_6))
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::index_mut
pub fn {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::index_mut<'_0, T>(@1: RangeInclusive<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> &'_0 mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut [T]; // return
    let self_1: RangeInclusive<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 mut [T]; // arg #2
    let start_3: usize; // local
    let end_4: usize; // local
    let exhausted_5: bool; // local
    let len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_11: usize; // local
    let rhs_12: usize; // local
    let new_len_13: usize; // local
    let _14: *mut [T]; // anonymous local
    let ptr_15: *mut [T]; // local
    let _16: !; // anonymous local
    let _17: bool; // anonymous local
    let _18: usize; // anonymous local
    let _19: *mut T; // anonymous local
    let _20: *mut T; // anonymous local

    storage_live(start_3)
    storage_live(end_4)
    storage_live(exhausted_5)
    storage_live(len_6)
    storage_live(new_len_13)
    storage_live(_16)
    start_3 = copy ((self_1).start)
    end_4 = copy ((self_1).end)
    exhausted_5 = copy ((self_1).exhausted)
    len_6 = copy (slice_2.metadata)
    storage_live(_7)
    storage_live(_8)
    _8 = copy (end_4)
    _7 = move (_8) < copy (len_6)
    if move (_7) {
        storage_dead(_8)
        storage_live(_9)
        _9 = copy (end_4)
        end_4 = move (_9) wrap.+ const (1 : usize)
        storage_dead(_9)
        if copy (exhausted_5) {
            start_3 = copy (end_4)
        } else {
        }
        storage_live(_10)
        storage_live(self_11)
        self_11 = copy (end_4)
        storage_live(rhs_12)
        rhs_12 = copy (start_3)
        storage_live(_17)
        _17 = copy (self_11) < copy (rhs_12)
        if move (_17) {
            storage_dead(_17)
            storage_dead(rhs_12)
            storage_dead(self_11)
            storage_dead(_10)
        } else {
            storage_live(_18)
            _18 = copy (self_11) ub.- copy (rhs_12)
            _10 = Option::Some { 0: move (_18) }
            storage_dead(_18)
            storage_dead(_17)
            storage_dead(rhs_12)
            storage_dead(self_11)
            new_len_13 = copy ((_10 as variant Option::Some).0)
            storage_live(_14)
            storage_live(ptr_15)
            ptr_15 = &raw mut *(slice_2) with_metadata(copy (slice_2.metadata))
            storage_live(_19)
            storage_live(_20)
            _19 = cast<*mut [T], *mut T>(copy (ptr_15))
            _20 = copy (_19) offset copy (start_3)
            _14 = @PtrFromPartsMut<'_, [T]>(copy (_20), copy (new_len_13))
            storage_dead(_20)
            storage_dead(_19)
            storage_dead(ptr_15)
            _0 = &mut *(_14) with_metadata(copy (_14.metadata))
            storage_dead(_14)
            storage_dead(_10)
            storage_dead(_7)
            return
        }
    } else {
        storage_dead(_8)
    }
    storage_dead(_7)
    _16 = slice_index_fail(move (start_3), move (end_4), move (len_6))
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}
impl<T> SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for RangeInclusive<usize>[{built_in impl Sized for usize}]}
    parent_clause1 = {impl Sealed for RangeInclusive<usize>[{built_in impl Sized for usize}]}
    parent_clause2 = {built_in impl MetaSized for [T]}
    parent_clause3 = {built_in impl MetaSized for [T]}
    type Output = [T]
    fn get<'_0_1> = {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get<'_0_1, T>[@TraitClause0]
    fn get_mut<'_0_1> = {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_mut<'_0_1, T>[@TraitClause0]
    fn get_unchecked = {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0_1> = {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::index<'_0_1, T>[@TraitClause0]
    fn index_mut<'_0_1> = {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::index_mut<'_0_1, T>[@TraitClause0]
    vtable: {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}::{vtable}<T>[@TraitClause0]
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::slice_index_range
pub fn slice_index_range<'_0>(@1: &'_0 [u8]) -> &'_0 [u8]
{
    let _0: &'0 [u8]; // return
    let slice_1: &'0 [u8]; // arg #1
    let _2: &'0 [u8]; // anonymous local
    let _3: &'0 [u8]; // anonymous local
    let _4: &'0 [u8]; // anonymous local
    let _5: RangeInclusive<usize>[{built_in impl Sized for usize}]; // anonymous local

    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    _4 = &*(slice_1) with_metadata(copy (slice_1.metadata))
    storage_live(_5)
    _5 = new<usize>[{built_in impl Sized for usize}](const (0 : usize), const (10 : usize))
    _3 = {impl Index<I> for [T]}::index<'_, u8, RangeInclusive<usize>[{built_in impl Sized for usize}]>[{built_in impl Sized for u8}, {built_in impl Sized for RangeInclusive<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T]> for RangeInclusive<usize>[{built_in impl Sized for usize}]}<u8>[{built_in impl Sized for u8}]](move (_4), move (_5))
    storage_dead(_5)
    storage_dead(_4)
    _2 = &*(_3) with_metadata(copy (_3.metadata))
    _0 = &*(_2) with_metadata(copy (_2.metadata))
    storage_dead(_3)
    storage_dead(_2)
    return
}



