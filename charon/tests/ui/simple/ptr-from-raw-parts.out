# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = clone<'_0_1, Self>[Self]
    non-dyn-compatible
}

// Full name: core::clone::Clone::clone
#[lang_item("clone_fn")]
pub fn clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <opaque>

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0_1, '_1_1> = core::cmp::PartialEq::eq<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

#[lang_item("cmp_partialeq_eq")]
pub fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,
= <opaque>

// Full name: core::cmp::Eq
#[lang_item("Eq")]
pub trait Eq<Self>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Self>
    non-dyn-compatible
}

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0_1, '_1_1> = core::cmp::PartialOrd::partial_cmp<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

// Full name: core::cmp::Ord
#[lang_item("Ord")]
pub trait Ord<Self>
{
    parent_clause0 : [@TraitClause0]: Eq<Self>
    parent_clause1 : [@TraitClause1]: PartialOrd<Self, Self>
    fn cmp<'_0_1, '_1_1> = core::cmp::Ord::cmp<'_0_1, '_1_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("ord_cmp_method")]
pub fn core::cmp::Ord::cmp<'_0, '_1, Self>(@1: &'_0 Self, @2: &'_1 Self) -> Ordering
where
    [@TraitClause0]: Ord<Self>,
= <opaque>

#[lang_item("cmp_partialord_cmp")]
pub fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> Option<Ordering>[{built_in impl Sized for Ordering}]
where
    [@TraitClause0]: PartialOrd<Self, Rhs>,
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<()> for ()}::eq
pub fn {impl PartialEq<()> for ()}::eq<'_0, '_1>(@1: &'_0 (), @2: &'_1 ()) -> bool
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<()> for ()}
impl PartialEq<()> for () {
    fn eq<'_0_1, '_1_1> = {impl PartialEq<()> for ()}::eq<'_0_1, '_1_1>
    vtable: {impl PartialEq<()> for ()}::{vtable}
}

// Full name: core::cmp::impls::{impl Eq for ()}
impl Eq for () {
    parent_clause0 = {impl PartialEq<()> for ()}
    non-dyn-compatible
}

// Full name: core::cmp::impls::{impl PartialOrd<()> for ()}::partial_cmp
pub fn {impl PartialOrd<()> for ()}::partial_cmp<'_0, '_1>(@1: &'_0 (), @2: &'_1 ()) -> Option<Ordering>[{built_in impl Sized for Ordering}]
= <opaque>

// Full name: core::cmp::impls::{impl PartialOrd<()> for ()}
impl PartialOrd<()> for () {
    parent_clause0 = {impl PartialEq<()> for ()}
    fn partial_cmp<'_0_1, '_1_1> = {impl PartialOrd<()> for ()}::partial_cmp<'_0_1, '_1_1>
    vtable: {impl PartialOrd<()> for ()}::{vtable}
}

// Full name: core::cmp::impls::{impl Ord for ()}::cmp
pub fn {impl Ord for ()}::cmp<'_0, '_1>(@1: &'_0 (), @2: &'_1 ()) -> Ordering
= <opaque>

// Full name: core::cmp::impls::{impl Ord for ()}
impl Ord for () {
    parent_clause0 = {impl Eq for ()}
    parent_clause1 = {impl PartialOrd<()> for ()}
    fn cmp<'_0_1, '_1_1> = {impl Ord for ()}::cmp<'_0_1, '_1_1>
    non-dyn-compatible
}

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::Debug
#[lang_item("Debug")]
pub trait Debug<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::Debug::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::Debug::{vtable}
}

pub fn core::fmt::Debug::fmt<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: Debug<Self>,
= <opaque>

// Full name: core::fmt::{impl Debug for ()}::fmt
pub fn {impl Debug for ()}::fmt<'_0, '_1, '_2>(@1: &'_0 (), @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <opaque>

// Full name: core::fmt::{impl Debug for ()}
impl Debug for () {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl Debug for ()}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl Debug for ()}::{vtable}
}

// Full name: core::hash::Hasher
pub trait Hasher<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn finish<'_0_1> = finish<'_0_1, Self>[Self]
    fn write<'_0_1, '_1_1> = write<'_0_1, '_1_1, Self>[Self]
    vtable: core::hash::Hasher::{vtable}
}

// Full name: core::hash::Hash
#[lang_item("Hash")]
pub trait Hash<Self>
{
    fn hash<'_0_1, '_1_1, H, [@TraitClause0_1]: Sized<H>, [@TraitClause1_1]: Hasher<H>> = core::hash::Hash::hash<'_0_1, '_1_1, Self, H>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

pub fn core::hash::Hash::hash<'_0, '_1, Self, H>(@1: &'_0 Self, @2: &'_1 mut H)
where
    [@TraitClause0]: Hash<Self>,
    [@TraitClause1]: Sized<H>,
    [@TraitClause2]: Hasher<H>,
= <opaque>

// Full name: core::hash::Hasher::finish
pub fn finish<'_0, Self>(@1: &'_0 Self) -> u64
where
    [@TraitClause0]: Hasher<Self>,
= <opaque>

// Full name: core::hash::Hasher::write
pub fn write<'_0, '_1, Self>(@1: &'_0 mut Self, @2: &'_1 [u8])
where
    [@TraitClause0]: Hasher<Self>,
= <opaque>

// Full name: core::hash::impls::{impl Hash for ()}::hash
pub fn {impl Hash for ()}::hash<'_0, '_1, H>(@1: &'_0 (), @2: &'_1 mut H)
where
    [@TraitClause0]: Sized<H>,
    [@TraitClause1]: Hasher<H>,
= <opaque>

// Full name: core::hash::impls::{impl Hash for ()}
impl Hash for () {
    fn hash<'_0_1, '_1_1, H, [@TraitClause0_1]: Sized<H>, [@TraitClause1_1]: Hasher<H>> = {impl Hash for ()}::hash<'_0_1, '_1_1, H>[@TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

// Full name: core::marker::Send
#[lang_item("Send")]
pub trait Send<Self>

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::marker::Sync
#[lang_item("sync")]
pub trait Sync<Self>

// Full name: core::marker::Freeze
#[lang_item("freeze")]
pub trait Freeze<Self>

// Full name: core::marker::Unpin
#[lang_item("unpin")]
pub trait Unpin<Self>

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::marker::Destruct::drop_in_place
unsafe fn drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::ptr::metadata::from_raw_parts
pub fn from_raw_parts<T, impl Thin>(@1: *const impl Thin, @2: {built_in impl Pointee for T}::Metadata) -> *const T
where
    [@TraitClause0]: Sized<impl Thin>,
    [@TraitClause1]: Thin<impl Thin>,
{
    let _0: *const T; // return
    let data_pointer_1: *const impl Thin; // arg #1
    let metadata_2: {built_in impl Pointee for T}::Metadata; // arg #2

    _0 = @PtrFromPartsShared<'_, T>(copy data_pointer_1, copy metadata_2)
    return
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let a_1: [u32; 2 : usize]; // local
    let _2: *const [u32]; // anonymous local
    let _3: *const [u32; 2 : usize]; // anonymous local

    _0 = ()
    storage_live(a_1)
    a_1 = @ArrayRepeat<u32, 2 : usize>(const 1 : u32)
    storage_live(_2)
    storage_live(_3)
    _3 = &raw const a_1
    _2 = from_raw_parts<[u32], [u32; 2 : usize]>[{built_in impl Sized for [u32; 2 : usize]}, {impl#0}<[u32; 2 : usize]>[{built_in impl Pointee for [u32; 2 : usize] where Metadata  = ()}]](move _3, const 2 : usize)
    storage_dead(_3)
    storage_dead(_2)
    _0 = ()
    storage_dead(a_1)
    return
}



