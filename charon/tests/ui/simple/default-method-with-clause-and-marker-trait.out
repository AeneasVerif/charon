# Final LLBC before serialization:

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::HasAssoc
trait HasAssoc<Self>
{
    type Assoc
    vtable: {vtable}<Self::Assoc>
}

// Full name: test_crate::Trait
trait Trait<Self>
{
    fn default_method<T, [@TraitClause0_1]: HasAssoc<T>> = test_crate::Trait::default_method<Self, T>[Self, @TraitClause0_1]
    non-dyn-compatible
}

fn test_crate::Trait::default_method<Self, T>() -> @TraitClause1::Assoc
where
    [@TraitClause0]: Trait<Self>,
    [@TraitClause1]: HasAssoc<T>,
{
    let _0: @TraitClause1::Assoc; // return

    panic(core::panicking::panic)
}

// Full name: test_crate::{impl Trait for T}::default_method
fn {impl Trait for T}::default_method<T, T>() -> @TraitClause0::Assoc
where
    [@TraitClause0]: HasAssoc<T>,
{
    let _0: @TraitClause0::Assoc; // return

    panic(core::panicking::panic)
}

// Full name: test_crate::{impl Trait for T}
impl<T> Trait for T {
    fn default_method<T, [@TraitClause0_1]: HasAssoc<T>> = {impl Trait for T}::default_method<T, T>[@TraitClause0_1]
    non-dyn-compatible
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return

    _0 := ()
    _0 := ()
    return
}



