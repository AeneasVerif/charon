# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::num::{u32}::MAX
pub fn MAX() -> u32
= <opaque>

// Full name: core::num::{u32}::MAX
pub const MAX: u32 = MAX()

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::X0
pub fn X0() -> u32
{
    let _0: u32; // return

    _0 := const (0 : u32)
    return
}

// Full name: test_crate::X0
pub const X0: u32 = X0()

// Full name: test_crate::X1
pub fn X1() -> u32
{
    let _0: u32; // return

    _0 := copy (MAX)
    return
}

// Full name: test_crate::X1
pub const X1: u32 = X1()

// Full name: test_crate::X2
pub fn X2() -> u32
{
    let _0: u32; // return
    let x_1: u32; // local

    storage_live(x_1)
    x_1 := const (3 : u32)
    _0 := copy (x_1)
    storage_dead(x_1)
    return
}

// Full name: test_crate::X2
pub const X2: u32 = X2()

// Full name: test_crate::incr
pub fn incr(@1: u32) -> u32
{
    let _0: u32; // return
    let n_1: u32; // arg #1
    let _2: u32; // anonymous local
    let _3: u32; // anonymous local

    storage_live(_3)
    storage_live(_2)
    _2 := copy (n_1)
    _3 := copy (_2) panic.+ const (1 : u32)
    _0 := move (_3)
    storage_dead(_2)
    return
}

// Full name: test_crate::X3
pub fn X3() -> u32
{
    let _0: u32; // return

    _0 := incr(const (32 : u32))
    return
}

// Full name: test_crate::X3
pub const X3: u32 = X3()

// Full name: test_crate::mk_pair0
pub fn mk_pair0(@1: u32, @2: u32) -> (u32, u32)
{
    let _0: (u32, u32); // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 := copy (x_1)
    storage_live(_4)
    _4 := copy (y_2)
    _0 := (move (_3), move (_4))
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::Pair
pub struct Pair<T1, T2>
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
{
  x: T1,
  y: T2,
}

// Full name: test_crate::mk_pair1
pub fn mk_pair1(@1: u32, @2: u32) -> Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]
{
    let _0: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 := copy (x_1)
    storage_live(_4)
    _4 := copy (y_2)
    _0 := Pair { x: move (_3), y: move (_4) }
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::P0
pub fn P0() -> (u32, u32)
{
    let _0: (u32, u32); // return

    _0 := mk_pair0(const (0 : u32), const (1 : u32))
    return
}

// Full name: test_crate::P0
pub const P0: (u32, u32) = P0()

// Full name: test_crate::P1
pub fn P1() -> Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]
{
    let _0: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // return

    _0 := mk_pair1(const (0 : u32), const (1 : u32))
    return
}

// Full name: test_crate::P1
pub const P1: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}] = P1()

// Full name: test_crate::P2
pub fn P2() -> (u32, u32)
{
    let _0: (u32, u32); // return

    _0 := (const (0 : u32), const (1 : u32))
    return
}

// Full name: test_crate::P2
pub const P2: (u32, u32) = P2()

// Full name: test_crate::P3
pub fn P3() -> Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]
{
    let _0: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // return

    _0 := Pair { x: const (0 : u32), y: const (1 : u32) }
    return
}

// Full name: test_crate::P3
pub const P3: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}] = P3()

// Full name: test_crate::Wrap
pub struct Wrap<T>
where
    [@TraitClause0]: Sized<T>,
{
  value: T,
}

// Full name: test_crate::{Wrap<T>[@TraitClause0]}::new
pub fn new<T>(@1: T) -> Wrap<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Wrap<T>[@TraitClause0]; // return
    let value_1: T; // arg #1
    let _2: T; // anonymous local

    storage_live(_2)
    _2 := move (value_1)
    _0 := Wrap { value: move (_2) }
    storage_dead(_2)
    return
}

// Full name: test_crate::Y
pub fn Y() -> Wrap<i32>[{built_in impl Sized for i32}]
{
    let _0: Wrap<i32>[{built_in impl Sized for i32}]; // return

    _0 := new<i32>[{built_in impl Sized for i32}](const (2 : i32))
    return
}

// Full name: test_crate::Y
pub const Y: Wrap<i32>[{built_in impl Sized for i32}] = Y()

// Full name: test_crate::unwrap_y
pub fn unwrap_y() -> i32
{
    let _0: i32; // return
    let _1: Wrap<i32>[{built_in impl Sized for i32}]; // anonymous local

    storage_live(_1)
    _1 := copy (Y)
    _0 := copy ((_1).value)
    storage_dead(_1)
    return
}

// Full name: test_crate::YVAL
pub fn YVAL() -> i32
{
    let _0: i32; // return

    _0 := unwrap_y()
    return
}

// Full name: test_crate::YVAL
pub const YVAL: i32 = YVAL()

// Full name: test_crate::get_z1::Z1
fn Z1() -> i32
{
    let _0: i32; // return

    _0 := const (3 : i32)
    return
}

// Full name: test_crate::get_z1::Z1
const Z1: i32 = Z1()

// Full name: test_crate::get_z1
pub fn get_z1() -> i32
{
    let _0: i32; // return

    _0 := copy (Z1)
    return
}

// Full name: test_crate::add
pub fn add(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let a_1: i32; // arg #1
    let b_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local

    storage_live(_5)
    storage_live(_3)
    _3 := copy (a_1)
    storage_live(_4)
    _4 := copy (b_2)
    _5 := copy (_3) panic.+ copy (_4)
    _0 := move (_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::Q1
pub fn Q1() -> i32
{
    let _0: i32; // return

    _0 := const (5 : i32)
    return
}

// Full name: test_crate::Q1
pub const Q1: i32 = Q1()

// Full name: test_crate::Q2
pub fn Q2() -> i32
{
    let _0: i32; // return

    _0 := copy (Q1)
    return
}

// Full name: test_crate::Q2
pub const Q2: i32 = Q2()

// Full name: test_crate::Q3
pub fn Q3() -> i32
{
    let _0: i32; // return

    _0 := add(copy (Q2), const (3 : i32))
    return
}

// Full name: test_crate::Q3
pub const Q3: i32 = Q3()

// Full name: test_crate::get_z2
pub fn get_z2() -> i32
{
    let _0: i32; // return
    let _1: i32; // anonymous local
    let _2: i32; // anonymous local

    storage_live(_1)
    storage_live(_2)
    _2 := get_z1()
    _1 := add(move (_2), copy (Q3))
    storage_dead(_2)
    _0 := add(copy (Q1), move (_1))
    storage_dead(_1)
    return
}

// Full name: test_crate::S1
pub fn S1() -> u32
{
    let _0: u32; // return

    _0 := const (6 : u32)
    return
}

// Full name: test_crate::S1
pub static S1: u32 = S1()

// Full name: test_crate::S2
pub fn S2() -> u32
{
    let _0: u32; // return
    let _1: u32; // anonymous local
    let _2: &'0 u32; // anonymous local
    let _3: &'0 u32; // anonymous local

    storage_live(_1)
    storage_live(_2)
    storage_live(_3)
    _3 := &S1
    _2 := move (_3)
    _1 := copy (*(_2))
    _0 := incr(move (_1))
    storage_dead(_2)
    storage_dead(_1)
    return
}

// Full name: test_crate::S2
pub static S2: u32 = S2()

// Full name: test_crate::S3
pub fn S3() -> Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]
{
    let _0: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // return

    _0 := copy (P3)
    return
}

// Full name: test_crate::S3
pub static S3: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}] = S3()

// Full name: test_crate::S4
pub fn S4() -> Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]
{
    let _0: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // return

    _0 := mk_pair1(const (7 : u32), const (8 : u32))
    return
}

// Full name: test_crate::S4
pub static S4: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}] = S4()

// Full name: test_crate::V
pub struct V<T, const N : usize>
where
    [@TraitClause0]: Sized<T>,
{
  x: [T; N],
}

// Full name: test_crate::{V<T, N>[@TraitClause0]}::LEN
pub fn LEN<T, const N : usize>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    _0 := const (N)
    return
}

// Full name: test_crate::{V<T, N>[@TraitClause0]}::LEN
pub const LEN<T, const N : usize>: usize
where
    [@TraitClause0]: Sized<T>,
 = LEN()

// Full name: test_crate::use_v
pub fn use_v<T, const N : usize>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    _0 := copy (LEN<T, N>[@TraitClause0])
    return
}



