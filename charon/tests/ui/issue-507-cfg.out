# Final LLBC before serialization:

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::CONST
fn CONST() -> u8
{
    let @0: u8; // return

    @0 := const (0 : u8)
    return
}

// Full name: test_crate::CONST
const CONST: u8 = CONST()

// Full name: test_crate::f0
fn f0()
{
    let @0: (); // return
    let @1: bool; // anonymous local
    let @2: bool; // anonymous local
    let x@3: u8; // local

    @0 := ()
    storage_live(@1)
    @1 := const (0 : i32) < const (1 : i32)
    if move (@1) {
        storage_live(@2)
        @2 := const (0 : i32) < const (1 : i32)
        if move (@2) {
        }
        else {
        }
        storage_dead(@2)
        storage_live(x@3)
        x@3 := copy (CONST)
        @0 := ()
        storage_dead(x@3)
    }
    else {
        @0 := ()
    }
    storage_dead(@1)
    return
}

// Full name: test_crate::f1
fn f1<'_0>(@1: &'_0 (Array<u8, 1 : usize>))
{
    let @0: (); // return
    let serialized@1: &'_ (Array<u8, 1 : usize>); // arg #1
    let previous_true_hints_seen@2: usize; // local
    let i@3: i32; // local
    let @4: bool; // anonymous local
    let @5: i32; // anonymous local
    let @6: bool; // anonymous local
    let @7: bool; // anonymous local
    let j@8: i32; // local
    let @9: bool; // anonymous local
    let @10: i32; // anonymous local
    let x@11: u8; // local

    @0 := ()
    storage_live(previous_true_hints_seen@2)
    previous_true_hints_seen@2 := const (0 : usize)
    storage_live(i@3)
    i@3 := const (0 : i32)
    loop {
        storage_live(@4)
        storage_live(@5)
        @5 := copy (i@3)
        @4 := move (@5) < const (1 : i32)
        if move (@4) {
            storage_dead(@5)
            storage_live(@6)
            @6 := const (0 : i32) < const (1 : i32)
            if move (@6) {
            }
            else {
                storage_live(@7)
                @7 := const (1 : i32) > const (1 : i32)
                if move (@7) {
                }
                else {
                }
            }
            storage_dead(@7)
            storage_dead(@6)
            storage_live(j@8)
            j@8 := const (0 : i32)
            loop {
                storage_live(@9)
                storage_live(@10)
                @10 := copy (j@8)
                @9 := move (@10) < const (1 : i32)
                if move (@9) {
                    storage_dead(@10)
                    storage_live(x@11)
                    x@11 := copy (CONST)
                    storage_dead(x@11)
                    storage_dead(@9)
                    continue 0
                }
                else {
                    break 0
                }
            }
            storage_dead(@10)
            storage_dead(@9)
            storage_dead(j@8)
            storage_dead(@4)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@5)
    @0 := ()
    storage_dead(@4)
    storage_dead(i@3)
    storage_dead(previous_true_hints_seen@2)
    return
}



