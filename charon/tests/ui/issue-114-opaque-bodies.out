# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::bool::{bool}::then_some
pub fn then_some<T>(@1: bool, @2: T) -> Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<T>[@TraitClause0]; // return
    let self_1: bool; // arg #1
    let t_2: T; // arg #2
    let _3: T; // anonymous local

    if copy self_1 {
    } else {
        _0 = Option::None {  }
        drop[{built_in impl Destruct for T}] t_2
        return
    }
    storage_live(_3)
    _3 = move t_2
    _0 = Option::Some { 0: move _3 }
    storage_dead(_3)
    return
}

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0_1, '_1_1> = eq<'_0_1, '_1_1, Self, Rhs>[Self]
    fn ne<'_0_1, '_1_1> = ne<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

// Full name: core::cmp::PartialEq::eq
#[lang_item("cmp_partialeq_eq")]
pub fn eq<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,
= <method_without_default_body>

// Full name: core::cmp::PartialEq::ne
#[lang_item("cmp_partialeq_ne")]
pub fn ne<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,
{
    let _0: bool; // return
    let self_1: &'0 Self; // arg #1
    let other_2: &'1 Rhs; // arg #2
    let _3: bool; // anonymous local

    storage_live(_3)
    _3 = @TraitClause0::eq<'_, '_>(move self_1, move other_2)
    _0 = ~(move _3)
    storage_dead(_3)
    return
}

// Full name: core::convert::From
#[lang_item("From")]
pub trait From<Self, T>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn from = core::convert::From::from<Self, T>[Self]
    non-dyn-compatible
}

#[lang_item("from_fn")]
pub fn core::convert::From::from<Self, T>(@1: T) -> Self
where
    [@TraitClause0]: From<Self, T>,
= <method_without_default_body>

// Full name: core::convert::num::{impl From<i32> for i64}::from
pub fn {impl From<i32> for i64}::from(@1: i32) -> i64
{
    let _0: i64; // return
    let small_1: i32; // arg #1

    _0 = cast<i32, i64>(copy small_1)
    return
}

// Full name: core::convert::num::{impl From<i32> for i64}
impl From<i32> for i64 {
    parent_clause0 = {built_in impl Sized for i64}
    parent_clause1 = {built_in impl Sized for i32}
    fn from = {impl From<i32> for i64}::from
    non-dyn-compatible
}

// Full name: core::marker::PhantomData
#[lang_item("phantom_data")]
pub struct PhantomData<T> {}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <missing>

// Full name: core::num::niche_types::UsizeNoHighBit
pub struct UsizeNoHighBit {
  usize,
}

// Full name: core::num::{usize}::MAX
pub fn MAX() -> usize
{
    let _0: usize; // return

    _0 = ~(const 0 : usize)
    return
}

// Full name: core::num::{usize}::MAX
pub const MAX: usize = MAX()

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub struct NonNull<T> {
  pointer: *const T,
}

// Full name: core::ptr::unique::Unique
pub struct Unique<T> {
  pointer: NonNull<T>,
  _marker: PhantomData<T>,
}

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::raw_vec::RawVecInner
struct RawVecInner<A>
where
    [@TraitClause0]: Sized<A>,
{
  ptr: Unique<u8>,
  cap: UsizeNoHighBit,
  alloc: A,
}

// Full name: alloc::raw_vec::RawVec
struct RawVec<T, A>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
{
  inner: RawVecInner<A>[@TraitClause1],
  _marker: PhantomData<T>,
}

// Full name: alloc::vec::Vec
#[lang_item("Vec")]
pub struct Vec<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<type_error("removed allocator parameter")>,
{
  buf: RawVec<T, type_error("removed allocator parameter")>[@TraitClause0, @TraitClause1],
  len: usize,
}

// Full name: alloc::vec::Vec::{impl Destruct for Vec<T>[@TraitClause0, @TraitClause1]}::drop_in_place
unsafe fn {impl Destruct for Vec<T>[@TraitClause0, @TraitClause1]}::drop_in_place<T, A>(@1: *mut Vec<T>[@TraitClause0, @TraitClause1])
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
= <opaque>

// Full name: alloc::vec::Vec::{impl Destruct for Vec<T>[@TraitClause0, @TraitClause1]}
impl<T, A> Destruct for Vec<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,
{
    fn drop_in_place = {impl Destruct for Vec<T>[@TraitClause0, @TraitClause1]}::drop_in_place<T, A>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: issue_114_opaque_bodies_aux::inline_always
pub fn inline_always() -> u32
{
    let _0: u32; // return

    _0 = const 42 : u32
    return
}

// Full name: issue_114_opaque_bodies_aux::inline_sometimes
pub fn inline_sometimes() -> u32
{
    let _0: u32; // return

    _0 = const 42 : u32
    return
}

// Full name: issue_114_opaque_bodies_aux::inline_never
pub fn inline_never() -> u32
{
    let _0: u32; // return

    _0 = const 42 : u32
    return
}

// Full name: issue_114_opaque_bodies_aux::inline_generic
pub fn inline_generic<T>() -> u32
where
    [@TraitClause0]: Sized<T>,
{
    let _0: u32; // return

    _0 = const 42 : u32
    return
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::use_inlines
fn use_inlines() -> u32
{
    let _0: u32; // return
    let _1: u32; // anonymous local
    let _2: u32; // anonymous local
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local
    let _7: u32; // anonymous local
    let _8: u32; // anonymous local
    let _9: u32; // anonymous local

    storage_live(_5)
    storage_live(_7)
    storage_live(_9)
    storage_live(_1)
    storage_live(_2)
    storage_live(_3)
    _3 = inline_always()
    storage_live(_4)
    _4 = inline_sometimes()
    _5 = copy _3 panic.+ copy _4
    _2 = move _5
    storage_dead(_4)
    storage_dead(_3)
    storage_live(_6)
    _6 = inline_never()
    _7 = copy _2 panic.+ copy _6
    _1 = move _7
    storage_dead(_6)
    storage_dead(_2)
    storage_live(_8)
    _8 = inline_generic<bool>[{built_in impl Sized for bool}]()
    _9 = copy _1 panic.+ copy _8
    _0 = move _9
    storage_dead(_8)
    storage_dead(_1)
    return
}

// Full name: test_crate::bool_to_opt
fn bool_to_opt(@1: bool) -> Option<()>[{built_in impl Sized for ()}]
{
    let _0: Option<()>[{built_in impl Sized for ()}]; // return
    let b_1: bool; // arg #1
    let _2: bool; // anonymous local
    let _3: (); // anonymous local

    storage_live(_2)
    _2 = copy b_1
    storage_live(_3)
    _3 = ()
    _0 = then_some<()>[{built_in impl Sized for ()}](move _2, move _3)
    storage_dead(_3)
    storage_dead(_2)
    return
}

// Full name: test_crate::convert
fn convert(@1: i32) -> i64
{
    let _0: i64; // return
    let x_1: i32; // arg #1
    let _2: i32; // anonymous local

    storage_live(_2)
    _2 = copy x_1
    _0 = {impl From<i32> for i64}::from(move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::vec
fn vec(@1: Vec<u32>[{built_in impl Sized for u32}, {built_in impl Sized for Global}])
{
    let _0: (); // return
    let _x_1: Vec<u32>[{built_in impl Sized for u32}, {built_in impl Sized for Global}]; // arg #1

    _0 = ()
    _0 = ()
    conditional_drop[{impl Destruct for Vec<T>[@TraitClause0, @TraitClause1]}<u32, Global>[{built_in impl Sized for u32}, {built_in impl Sized for Global}]] _x_1
    return
}

// Full name: test_crate::max
fn max() -> usize
{
    let _0: usize; // return

    _0 = copy MAX
    return
}

// Full name: test_crate::partial_eq
fn partial_eq<T>(@1: T)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: PartialEq<T, T>,
{
    let _0: (); // return
    let _x_1: T; // arg #1

    _0 = ()
    _0 = ()
    conditional_drop[{built_in impl Destruct for T}] _x_1
    return
}



