# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args, Self_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self_Output>
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args, Self_Output>[Self]
    vtable: core::ops::function::FnOnce::{vtable}<Args, Self_Output>
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args, Self_Clause1_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args, Self_Clause1_Output>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0_1> = core::ops::function::FnMut::call_mut<'_0_1, Self, Args, Self_Clause1_Output>[Self]
    vtable: core::ops::function::FnMut::{vtable}<Args, Self_Clause1_Output>
}

// Full name: core::array::{[T; N]}::map
pub fn map<T, F, U, const N : usize>(@1: [T; N], @2: F) -> [U; N]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<F>,
    [@TraitClause2]: Sized<U>,
    [@TraitClause3]: FnMut<F, (T), U>,
= <opaque>

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <opaque>

// Full name: core::clone::impls::{impl Clone for u32}::clone
pub fn {impl Clone for u32}::clone<'_0>(@1: &'_0 u32) -> u32
= <opaque>

// Full name: core::clone::impls::{impl Clone for u32}
impl Clone for u32 {
    parent_clause0 = {built_in impl Sized for u32}
    fn clone<'_0_1> = {impl Clone for u32}::clone<'_0_1>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::ops::function::Fn
#[lang_item("r#fn")]
pub trait Fn<Self, Args, Self_Clause1_Clause1_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnMut<Self, Args, Self_Clause1_Clause1_Output>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call<'_0_1> = core::ops::function::Fn::call<'_0_1, Self, Args, Self_Clause1_Clause1_Output>[Self]
    vtable: core::ops::function::Fn::{vtable}<Args, Self_Clause1_Clause1_Output>
}

pub fn core::ops::function::Fn::call<'_0, Self, Args, Clause0_Clause1_Clause1_Output>(@1: &'_0 Self, @2: Args) -> Clause0_Clause1_Clause1_Output
where
    [@TraitClause0]: Fn<Self, Args, Clause0_Clause1_Clause1_Output>,
= <opaque>

pub fn core::ops::function::FnMut::call_mut<'_0, Self, Args, Clause0_Clause1_Output>(@1: &'_0 mut Self, @2: Args) -> Clause0_Clause1_Output
where
    [@TraitClause0]: FnMut<Self, Args, Clause0_Clause1_Output>,
= <opaque>

pub fn core::ops::function::FnOnce::call_once<Self, Args, Clause0_Output>(@1: Self, @2: Args) -> Clause0_Output
where
    [@TraitClause0]: FnOnce<Self, Args, Clause0_Output>,
= <opaque>

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::option::Option::{impl Destruct for Option<T>[@TraitClause0]}::drop_in_place
unsafe fn {impl Destruct for Option<T>[@TraitClause0]}::drop_in_place<T>(@1: *mut Option<T>[@TraitClause0])
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::option::Option::{impl Destruct for Option<T>[@TraitClause0]}
impl<T> Destruct for Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    fn drop_in_place = {impl Destruct for Option<T>[@TraitClause0]}::drop_in_place<T>[@TraitClause0]
    non-dyn-compatible
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::<tuple_1>::{impl Destruct for (A)}::drop_in_place
unsafe fn {impl Destruct for (A)}::drop_in_place<A>(@1: *mut (A))
{
    let _0: (); // return
    let _1: *mut (A); // arg #1
    let _2: &'0 mut (A); // anonymous local

    storage_live(_2)
    _0 := ()
    _2 := &mut *(_1) with_metadata(copy (_1.metadata))
    drop[{built_in impl Destruct for A}] (*(_2)).0
    return
}

// Full name: test_crate::<tuple_1>::{impl Destruct for (A)}
impl<A> Destruct for (A) {
    fn drop_in_place = {impl Destruct for (A)}::drop_in_place<A>
    non-dyn-compatible
}

// Full name: test_crate::incr_u32
pub fn incr_u32(@1: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let _2: u32; // anonymous local
    let _3: u32; // anonymous local

    storage_live(_3)
    storage_live(_2)
    _2 := copy (x_1)
    _3 := copy (_2) panic.+ const (1 : u32)
    _0 := move (_3)
    storage_dead(_2)
    return
}

// Full name: test_crate::map_option
pub fn map_option<T, F>(@1: Option<T>[@TraitClause0], @2: F) -> Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<F>,
    [@TraitClause2]: Fn<F, (T), T>,
{
    let _0: Option<T>[@TraitClause0]; // return
    let x_1: Option<T>[@TraitClause0]; // arg #1
    let f_2: F; // arg #2
    let x_3: T; // local
    let _4: T; // anonymous local
    let _5: &'0 F; // anonymous local
    let _6: (T); // anonymous local
    let _7: T; // anonymous local

    match x_1 {
        Option::None => {
            _0 := Option::None {  }
        },
        Option::Some => {
            storage_live(x_3)
            x_3 := move ((x_1 as variant Option::Some).0)
            storage_live(_4)
            storage_live(_5)
            _5 := &f_2
            storage_live(_6)
            storage_live(_7)
            _7 := move (x_3)
            _6 := (move (_7))
            _4 := @TraitClause2::call<'_>(move (_5), move (_6))
            conditional_drop[{built_in impl Destruct for T}] _7
            storage_dead(_7)
            storage_dead(_6)
            storage_dead(_5)
            _0 := Option::Some { 0: move (_4) }
            conditional_drop[{built_in impl Destruct for T}] _4
            storage_dead(_4)
            conditional_drop[{built_in impl Destruct for T}] x_3
            storage_dead(x_3)
        },
    }
    conditional_drop[{built_in impl Destruct for F}] f_2
    conditional_drop[{impl Destruct for Option<T>[@TraitClause0]}<T>[@TraitClause0]] x_1
    return
}

// Full name: test_crate::map_option_pointer_ref
pub fn map_option_pointer_ref<'a, T, F>(@1: &'a Option<T>[@TraitClause0], @2: fn<'_0_1>(&'_0_1 T) -> T) -> Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<F>,
{
    let _0: Option<T>[@TraitClause0]; // return
    let x_1: &'0 Option<T>[@TraitClause0]; // arg #1
    let f_2: fn<'_0_1>(&'_0_1 T) -> T; // arg #2
    let x_3: &'1 T; // local
    let _4: T; // anonymous local
    let _5: fn<'_0_1>(&'_0_1 T) -> T; // anonymous local
    let _6: &'1 T; // anonymous local

    match *(x_1) {
        Option::None => {
        },
        Option::Some => {
            storage_live(x_3)
            x_3 := &(*(x_1) as variant Option::Some).0
            storage_live(_4)
            storage_live(_5)
            _5 := copy (f_2)
            storage_live(_6)
            _6 := &*(x_3)
            _4 := (move (_5))(move (_6))
            storage_dead(_6)
            storage_dead(_5)
            _0 := Option::Some { 0: move (_4) }
            conditional_drop[{built_in impl Destruct for T}] _4
            storage_dead(_4)
            storage_dead(x_3)
            return
        },
    }
    _0 := Option::None {  }
    return
}

// Full name: test_crate::test_map_option1
pub fn test_map_option1(@1: Option<u32>[{built_in impl Sized for u32}]) -> Option<u32>[{built_in impl Sized for u32}]
{
    let _0: Option<u32>[{built_in impl Sized for u32}]; // return
    let x_1: Option<u32>[{built_in impl Sized for u32}]; // arg #1
    let _2: Option<u32>[{built_in impl Sized for u32}]; // anonymous local

    storage_live(_2)
    _2 := copy (x_1)
    _0 := map_option<u32, incr_u32>[{built_in impl Sized for u32}, {built_in impl Sized for incr_u32}, {built_in impl Fn<(u32), u32> for incr_u32}](move (_2), const (incr_u32))
    storage_dead(_2)
    return
}

struct test_crate::test_closure_u32::closure {}

// Full name: test_crate::test_closure_u32::{impl Fn<(u32), u32> for test_crate::test_closure_u32::closure}::call
fn {impl Fn<(u32), u32> for test_crate::test_closure_u32::closure}::call<'_0>(@1: &'_0 test_crate::test_closure_u32::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let _1: &'0 test_crate::test_closure_u32::closure; // arg #1
    let tupled_args_2: (u32); // arg #2
    let x_3: u32; // local

    storage_live(x_3)
    x_3 := move ((tupled_args_2).0)
    _0 := copy (x_3)
    return
}

// Full name: test_crate::test_closure_u32::{impl FnMut<(u32), u32> for test_crate::test_closure_u32::closure}::call_mut
fn {impl FnMut<(u32), u32> for test_crate::test_closure_u32::closure}::call_mut<'_0>(@1: &'_0 mut test_crate::test_closure_u32::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let state_1: &'_0 mut test_crate::test_closure_u32::closure; // arg #1
    let args_2: (u32); // arg #2
    let _3: &'0 test_crate::test_closure_u32::closure; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(u32), u32> for test_crate::test_closure_u32::closure}::call<'2>(move (_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_u32::closure::{impl Destruct for test_crate::test_closure_u32::closure}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_closure_u32::closure}::drop_in_place(@1: *mut test_crate::test_closure_u32::closure)
= <missing>

// Full name: test_crate::test_closure_u32::closure::{impl Destruct for test_crate::test_closure_u32::closure}
impl Destruct for test_crate::test_closure_u32::closure {
    fn drop_in_place = {impl Destruct for test_crate::test_closure_u32::closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::test_closure_u32::{impl FnOnce<(u32), u32> for test_crate::test_closure_u32::closure}::call_once
fn {impl FnOnce<(u32), u32> for test_crate::test_closure_u32::closure}::call_once(@1: test_crate::test_closure_u32::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let _1: test_crate::test_closure_u32::closure; // arg #1
    let _2: (u32); // arg #2
    let _3: &'0 mut test_crate::test_closure_u32::closure; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(u32), u32> for test_crate::test_closure_u32::closure}::call_mut<'_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_closure_u32::closure}] _1
    return
}

fn test_crate::test_closure_u32::closure::as_fn(@1: u32) -> u32
{
    let _0: u32; // return
    let arg1_1: u32; // arg #1
    let args_2: (u32); // local
    let state_3: test_crate::test_closure_u32::closure; // local

    storage_live(args_2)
    storage_live(state_3)
    args_2 := (move (arg1_1))
    state_3 := test_crate::test_closure_u32::closure {  }
    _0 := {impl FnOnce<(u32), u32> for test_crate::test_closure_u32::closure}::call_once(move (state_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_u32
pub fn test_closure_u32(@1: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let f_2: fn(u32) -> u32; // local
    let _3: test_crate::test_closure_u32::closure; // anonymous local
    let _4: fn(u32) -> u32; // anonymous local
    let _5: u32; // anonymous local

    storage_live(f_2)
    storage_live(_3)
    _3 := test_crate::test_closure_u32::closure {  }
    f_2 := cast<test_crate::test_closure_u32::closure::as_fn, fn(u32) -> u32>(const (test_crate::test_closure_u32::closure::as_fn))
    storage_dead(_3)
    storage_live(_4)
    _4 := copy (f_2)
    storage_live(_5)
    _5 := copy (x_1)
    _0 := (move (_4))(move (_5))
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(f_2)
    return
}

// Full name: test_crate::test_closure_u32::{impl FnOnce<(u32), u32> for test_crate::test_closure_u32::closure}
impl FnOnce<(u32), u32> for test_crate::test_closure_u32::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_u32::closure}
    parent_clause1 = {built_in impl Sized for (u32)}
    parent_clause2 = {built_in impl Tuple for (u32)}
    parent_clause3 = {built_in impl Sized for u32}
    fn call_once = {impl FnOnce<(u32), u32> for test_crate::test_closure_u32::closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::test_closure_u32::{impl FnMut<(u32), u32> for test_crate::test_closure_u32::closure}
impl FnMut<(u32), u32> for test_crate::test_closure_u32::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_u32::closure}
    parent_clause1 = {impl FnOnce<(u32), u32> for test_crate::test_closure_u32::closure}
    parent_clause2 = {built_in impl Sized for (u32)}
    parent_clause3 = {built_in impl Tuple for (u32)}
    fn call_mut<'_0_1> = {impl FnMut<(u32), u32> for test_crate::test_closure_u32::closure}::call_mut<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_closure_u32::{impl Fn<(u32), u32> for test_crate::test_closure_u32::closure}
impl Fn<(u32), u32> for test_crate::test_closure_u32::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_u32::closure}
    parent_clause1 = {impl FnMut<(u32), u32> for test_crate::test_closure_u32::closure}
    parent_clause2 = {built_in impl Sized for (u32)}
    parent_clause3 = {built_in impl Tuple for (u32)}
    fn call<'_0_1> = {impl Fn<(u32), u32> for test_crate::test_closure_u32::closure}::call<'_0_1>
    non-dyn-compatible
}

struct test_crate::test_closure_u32s::closure {}

// Full name: test_crate::test_closure_u32s::{impl Fn<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call
fn {impl Fn<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call<'_0>(@1: &'_0 test_crate::test_closure_u32s::closure, @2: (u32, u32)) -> u32
{
    let _0: u32; // return
    let _1: &'0 test_crate::test_closure_u32s::closure; // arg #1
    let tupled_args_2: (u32, u32); // arg #2
    let x_3: u32; // local
    let y_4: u32; // local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local
    let _7: u32; // anonymous local

    storage_live(x_3)
    storage_live(y_4)
    storage_live(_7)
    x_3 := move ((tupled_args_2).0)
    y_4 := move ((tupled_args_2).1)
    storage_live(_5)
    _5 := copy (x_3)
    storage_live(_6)
    _6 := copy (y_4)
    _7 := copy (_5) panic.+ copy (_6)
    _0 := move (_7)
    storage_dead(_6)
    storage_dead(_5)
    return
}

// Full name: test_crate::test_closure_u32s::{impl FnMut<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call_mut
fn {impl FnMut<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call_mut<'_0>(@1: &'_0 mut test_crate::test_closure_u32s::closure, @2: (u32, u32)) -> u32
{
    let _0: u32; // return
    let state_1: &'_0 mut test_crate::test_closure_u32s::closure; // arg #1
    let args_2: (u32, u32); // arg #2
    let _3: &'0 test_crate::test_closure_u32s::closure; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call<'2>(move (_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_u32s::closure::{impl Destruct for test_crate::test_closure_u32s::closure}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_closure_u32s::closure}::drop_in_place(@1: *mut test_crate::test_closure_u32s::closure)
= <missing>

// Full name: test_crate::test_closure_u32s::closure::{impl Destruct for test_crate::test_closure_u32s::closure}
impl Destruct for test_crate::test_closure_u32s::closure {
    fn drop_in_place = {impl Destruct for test_crate::test_closure_u32s::closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::test_closure_u32s::{impl FnOnce<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call_once
fn {impl FnOnce<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call_once(@1: test_crate::test_closure_u32s::closure, @2: (u32, u32)) -> u32
{
    let _0: u32; // return
    let _1: test_crate::test_closure_u32s::closure; // arg #1
    let _2: (u32, u32); // arg #2
    let _3: &'0 mut test_crate::test_closure_u32s::closure; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call_mut<'_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_closure_u32s::closure}] _1
    return
}

fn test_crate::test_closure_u32s::closure::as_fn(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let arg1_1: u32; // arg #1
    let arg2_2: u32; // arg #2
    let args_3: (u32, u32); // local
    let state_4: test_crate::test_closure_u32s::closure; // local

    storage_live(args_3)
    storage_live(state_4)
    args_3 := (move (arg1_1), move (arg2_2))
    state_4 := test_crate::test_closure_u32s::closure {  }
    _0 := {impl FnOnce<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call_once(move (state_4), move (args_3))
    return
}

// Full name: test_crate::test_closure_u32s
pub fn test_closure_u32s(@1: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let f_2: fn(u32, u32) -> u32; // local
    let _3: test_crate::test_closure_u32s::closure; // anonymous local
    let _4: fn(u32, u32) -> u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(f_2)
    storage_live(_3)
    _3 := test_crate::test_closure_u32s::closure {  }
    f_2 := cast<test_crate::test_closure_u32s::closure::as_fn, fn(u32, u32) -> u32>(const (test_crate::test_closure_u32s::closure::as_fn))
    storage_dead(_3)
    storage_live(_4)
    _4 := copy (f_2)
    storage_live(_5)
    _5 := copy (x_1)
    storage_live(_6)
    _6 := copy (x_1)
    _0 := (move (_4))(move (_5), move (_6))
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(f_2)
    return
}

// Full name: test_crate::test_closure_u32s::{impl FnOnce<(u32, u32), u32> for test_crate::test_closure_u32s::closure}
impl FnOnce<(u32, u32), u32> for test_crate::test_closure_u32s::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_u32s::closure}
    parent_clause1 = {built_in impl Sized for (u32, u32)}
    parent_clause2 = {built_in impl Tuple for (u32, u32)}
    parent_clause3 = {built_in impl Sized for u32}
    fn call_once = {impl FnOnce<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::test_closure_u32s::{impl FnMut<(u32, u32), u32> for test_crate::test_closure_u32s::closure}
impl FnMut<(u32, u32), u32> for test_crate::test_closure_u32s::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_u32s::closure}
    parent_clause1 = {impl FnOnce<(u32, u32), u32> for test_crate::test_closure_u32s::closure}
    parent_clause2 = {built_in impl Sized for (u32, u32)}
    parent_clause3 = {built_in impl Tuple for (u32, u32)}
    fn call_mut<'_0_1> = {impl FnMut<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call_mut<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_closure_u32s::{impl Fn<(u32, u32), u32> for test_crate::test_closure_u32s::closure}
impl Fn<(u32, u32), u32> for test_crate::test_closure_u32s::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_u32s::closure}
    parent_clause1 = {impl FnMut<(u32, u32), u32> for test_crate::test_closure_u32s::closure}
    parent_clause2 = {built_in impl Sized for (u32, u32)}
    parent_clause3 = {built_in impl Tuple for (u32, u32)}
    fn call<'_0_1> = {impl Fn<(u32, u32), u32> for test_crate::test_closure_u32s::closure}::call<'_0_1>
    non-dyn-compatible
}

struct test_crate::test_closure_ref_u32::closure {}

// Full name: test_crate::test_closure_ref_u32::{impl Fn<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call
fn {impl Fn<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call<'_0, '_1>(@1: &'_1 test_crate::test_closure_ref_u32::closure, @2: (&'_0 u32)) -> &'_0 u32
{
    let _0: &'_ u32; // return
    let _1: &'0 test_crate::test_closure_ref_u32::closure; // arg #1
    let tupled_args_2: (&'_0 u32); // arg #2
    let y_3: &'_ u32; // local

    storage_live(y_3)
    y_3 := move ((tupled_args_2).0)
    _0 := copy (y_3)
    return
}

// Full name: test_crate::test_closure_ref_u32::{impl FnMut<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call_mut
fn {impl FnMut<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call_mut<'_0, '_1>(@1: &'_1 mut test_crate::test_closure_ref_u32::closure, @2: (&'_0 u32)) -> &'_0 u32
{
    let _0: &'_0 u32; // return
    let state_1: &'_1 mut test_crate::test_closure_ref_u32::closure; // arg #1
    let args_2: (&'_0 u32); // arg #2
    let _3: &'0 test_crate::test_closure_ref_u32::closure; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call<'_0, '2>(move (_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_ref_u32::closure::{impl Destruct for test_crate::test_closure_ref_u32::closure}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_closure_ref_u32::closure}::drop_in_place(@1: *mut test_crate::test_closure_ref_u32::closure)
= <missing>

// Full name: test_crate::test_closure_ref_u32::closure::{impl Destruct for test_crate::test_closure_ref_u32::closure}
impl Destruct for test_crate::test_closure_ref_u32::closure {
    fn drop_in_place = {impl Destruct for test_crate::test_closure_ref_u32::closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_u32::{impl FnOnce<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call_once
fn {impl FnOnce<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call_once<'_0>(@1: test_crate::test_closure_ref_u32::closure, @2: (&'_0 u32)) -> &'_0 u32
{
    let _0: &'_ u32; // return
    let _1: test_crate::test_closure_ref_u32::closure; // arg #1
    let _2: (&'_ u32); // arg #2
    let _3: &'0 mut test_crate::test_closure_ref_u32::closure; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call_mut<'_0, '_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_closure_ref_u32::closure}] _1
    return
}

fn test_crate::test_closure_ref_u32::closure::as_fn<'_0>(@1: &'_0 u32) -> &'_0 u32
{
    let _0: &'_0 u32; // return
    let arg1_1: &'_0 u32; // arg #1
    let args_2: (&'_0 u32); // local
    let state_3: test_crate::test_closure_ref_u32::closure; // local

    storage_live(args_2)
    storage_live(state_3)
    args_2 := (move (arg1_1))
    state_3 := test_crate::test_closure_ref_u32::closure {  }
    _0 := {impl FnOnce<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call_once<'_0>(move (state_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_ref_u32
pub fn test_closure_ref_u32<'a>(@1: &'a u32) -> &'a u32
{
    let _0: &'0 u32; // return
    let x_1: &'0 u32; // arg #1
    let f_2: fn<'_0_1>(&'_0_1 u32) -> &'_0_1 u32; // local
    let _3: test_crate::test_closure_ref_u32::closure; // anonymous local
    let _4: &'0 u32; // anonymous local
    let _5: fn<'_0_1>(&'_0_1 u32) -> &'_0_1 u32; // anonymous local
    let _6: &'0 u32; // anonymous local

    storage_live(f_2)
    storage_live(_3)
    _3 := test_crate::test_closure_ref_u32::closure {  }
    f_2 := cast<for<'_0_1> test_crate::test_closure_ref_u32::closure::as_fn<'_0_1>, fn<'_0_1>(&'_0_1 u32) -> &'_0_1 u32>(const (test_crate::test_closure_ref_u32::closure::as_fn<'_>))
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    _5 := copy (f_2)
    storage_live(_6)
    _6 := &*(x_1)
    _4 := (move (_5))(move (_6))
    _0 := &*(_4)
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(f_2)
    storage_dead(_4)
    return
}

// Full name: test_crate::test_closure_ref_u32::{impl FnOnce<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}
impl<'_0> FnOnce<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_u32::closure}
    parent_clause1 = {built_in impl Sized for (&'_ u32)}
    parent_clause2 = {built_in impl Tuple for (&'_ u32)}
    parent_clause3 = {built_in impl Sized for &'_ u32}
    fn call_once = {impl FnOnce<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call_once<'_0>
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_u32::{impl FnMut<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}
impl<'_0> FnMut<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_u32::closure}
    parent_clause1 = {impl FnOnce<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}<'_0>
    parent_clause2 = {built_in impl Sized for (&'_ u32)}
    parent_clause3 = {built_in impl Tuple for (&'_ u32)}
    fn call_mut<'_0_1> = {impl FnMut<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call_mut<'_0, '_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_u32::{impl Fn<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}
impl<'_0> Fn<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_u32::closure}
    parent_clause1 = {impl FnMut<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}<'_0>
    parent_clause2 = {built_in impl Sized for (&'_ u32)}
    parent_clause3 = {built_in impl Tuple for (&'_ u32)}
    fn call<'_0_1> = {impl Fn<(&'_ u32), &'_ u32> for test_crate::test_closure_ref_u32::closure}::call<'_0, '_0_1>
    non-dyn-compatible
}

struct test_crate::test_closure_ref_param::closure<T>
where
    [@TraitClause0]: Sized<T>,
{}

// Full name: test_crate::test_closure_ref_param::{impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call
fn {impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call<'_0, '_1, T>(@1: &'_1 test_crate::test_closure_ref_param::closure<T>[@TraitClause0], @2: (&'_0 T)) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'_ T; // return
    let _1: &'0 test_crate::test_closure_ref_param::closure<T>[@TraitClause0]; // arg #1
    let tupled_args_2: (&'_0 T); // arg #2
    let x_3: &'_ T; // local

    storage_live(x_3)
    x_3 := move ((tupled_args_2).0)
    _0 := copy (x_3)
    return
}

// Full name: test_crate::test_closure_ref_param::{impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call_mut
fn {impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call_mut<'_0, '_1, T>(@1: &'_1 mut test_crate::test_closure_ref_param::closure<T>[@TraitClause0], @2: (&'_0 T)) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'_0 T; // return
    let state_1: &'_1 mut test_crate::test_closure_ref_param::closure<T>[@TraitClause0]; // arg #1
    let args_2: (&'_0 T); // arg #2
    let _3: &'0 test_crate::test_closure_ref_param::closure<T>[@TraitClause0]; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call<'_0, '2, T>[@TraitClause0](move (_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_ref_param::closure::{impl Destruct for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::drop_in_place<T>(@1: *mut test_crate::test_closure_ref_param::closure<T>[@TraitClause0])
where
    [@TraitClause0]: Sized<T>,
= <missing>

// Full name: test_crate::test_closure_ref_param::closure::{impl Destruct for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}
impl<T> Destruct for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    fn drop_in_place = {impl Destruct for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::drop_in_place<T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_param::{impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call_once
fn {impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call_once<'_0, T>(@1: test_crate::test_closure_ref_param::closure<T>[@TraitClause0], @2: (&'_0 T)) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'_ T; // return
    let _1: test_crate::test_closure_ref_param::closure<T>[@TraitClause0]; // arg #1
    let _2: (&'_ T); // arg #2
    let _3: &'0 mut test_crate::test_closure_ref_param::closure<T>[@TraitClause0]; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call_mut<'_0, '_, T>[@TraitClause0](move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}<T>[@TraitClause0]] _1
    return
}

fn test_crate::test_closure_ref_param::closure::as_fn<'_0, T>(@1: &'_0 T) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'_0 T; // return
    let arg1_1: &'_0 T; // arg #1
    let args_2: (&'_0 T); // local
    let state_3: test_crate::test_closure_ref_param::closure<T>[@TraitClause0]; // local

    storage_live(args_2)
    storage_live(state_3)
    args_2 := (move (arg1_1))
    state_3 := test_crate::test_closure_ref_param::closure {  }
    _0 := {impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call_once<'_0, T>[@TraitClause0](move (state_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_ref_param
pub fn test_closure_ref_param<'_0, T>(@1: &'_0 T) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 T; // return
    let x_1: &'0 T; // arg #1
    let f_2: fn<'_0_1>(&'_0_1 T) -> &'_0_1 T; // local
    let _3: test_crate::test_closure_ref_param::closure<T>[@TraitClause0]; // anonymous local
    let _4: &'0 T; // anonymous local
    let _5: fn<'_0_1>(&'_0_1 T) -> &'_0_1 T; // anonymous local
    let _6: &'0 T; // anonymous local

    storage_live(f_2)
    storage_live(_3)
    _3 := test_crate::test_closure_ref_param::closure {  }
    f_2 := cast<for<'_0_1> test_crate::test_closure_ref_param::closure::as_fn<'_0_1, T>[@TraitClause0], fn<'_0_1>(&'_0_1 T) -> &'_0_1 T>(const (test_crate::test_closure_ref_param::closure::as_fn<'_, T>[@TraitClause0]))
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    _5 := copy (f_2)
    storage_live(_6)
    _6 := &*(x_1)
    _4 := (move (_5))(move (_6))
    _0 := &*(_4)
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(f_2)
    storage_dead(_4)
    return
}

// Full name: test_crate::test_closure_ref_param::{impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}
impl<'_0, T> FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}
    parent_clause1 = {built_in impl Sized for (&'_ T)}
    parent_clause2 = {built_in impl Tuple for (&'_ T)}
    parent_clause3 = {built_in impl Sized for &'_ T}
    fn call_once = {impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call_once<'_0, T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_param::{impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}
impl<'_0, T> FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}
    parent_clause1 = {impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}<'_0, T>[@TraitClause0]
    parent_clause2 = {built_in impl Sized for (&'_ T)}
    parent_clause3 = {built_in impl Tuple for (&'_ T)}
    fn call_mut<'_0_1> = {impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call_mut<'_0, '_0_1, T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_param::{impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}
impl<'_0, T> Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}
    parent_clause1 = {impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}<'_0, T>[@TraitClause0]
    parent_clause2 = {built_in impl Sized for (&'_ T)}
    parent_clause3 = {built_in impl Tuple for (&'_ T)}
    fn call<'_0_1> = {impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_param::closure<T>[@TraitClause0]}::call<'_0, '_0_1, T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::Trait
pub trait Trait<'a, Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: test_crate::Trait::{vtable}<'a>
}

struct test_crate::test_closure_ref_early_bound::closure<'a, T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{}

// Full name: test_crate::test_closure_ref_early_bound::{impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call
fn {impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call<'a, '_1, '_2, T>(@1: &'_2 test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1], @2: (&'_1 T)) -> &'_1 T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    let _0: &'_ T; // return
    let _1: &'0 test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]; // arg #1
    let tupled_args_2: (&'_1 T); // arg #2
    let y_3: &'_ T; // local

    storage_live(y_3)
    y_3 := move ((tupled_args_2).0)
    _0 := copy (y_3)
    return
}

// Full name: test_crate::test_closure_ref_early_bound::{impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call_mut
fn {impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call_mut<'a, '_1, '_2, T>(@1: &'_2 mut test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1], @2: (&'_1 T)) -> &'_1 T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    let _0: &'_1 T; // return
    let state_1: &'_2 mut test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]; // arg #1
    let args_2: (&'_1 T); // arg #2
    let _3: &'1 test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call<'a, '_1, '7, T>[@TraitClause0, @TraitClause1](move (_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_ref_early_bound::closure::{impl Destruct for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::drop_in_place<'a, T>(@1: *mut test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1])
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
= <missing>

// Full name: test_crate::test_closure_ref_early_bound::closure::{impl Destruct for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}
impl<'a, T> Destruct for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    fn drop_in_place = {impl Destruct for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::drop_in_place<'a, T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_early_bound::{impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call_once
fn {impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call_once<'a, '_1, T>(@1: test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1], @2: (&'_1 T)) -> &'_1 T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    let _0: &'_ T; // return
    let _1: test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]; // arg #1
    let _2: (&'_ T); // arg #2
    let _3: &'0 mut test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call_mut<'a, '_1, '_, T>[@TraitClause0, @TraitClause1](move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}<'8, T>[@TraitClause0, @TraitClause1]] _1
    return
}

fn test_crate::test_closure_ref_early_bound::closure::as_fn<'a, '_1, T>(@1: &'_1 T) -> &'_1 T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    let _0: &'_1 T; // return
    let arg1_1: &'_1 T; // arg #1
    let args_2: (&'_1 T); // local
    let state_3: test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]; // local

    storage_live(args_2)
    storage_live(state_3)
    args_2 := (move (arg1_1))
    state_3 := test_crate::test_closure_ref_early_bound::closure {  }
    _0 := {impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call_once<'a, '_1, T>[@TraitClause0, @TraitClause1](move (state_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_ref_early_bound
pub fn test_closure_ref_early_bound<'a, T>(@1: &'a T) -> &'a T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    let _0: &'0 T; // return
    let x_1: &'0 T; // arg #1
    let f_2: fn<'_0_1>(&'_0_1 T) -> &'_0_1 T; // local
    let _3: test_crate::test_closure_ref_early_bound::closure<'1, T>[@TraitClause0, @TraitClause1]; // anonymous local
    let _4: &'0 T; // anonymous local
    let _5: fn<'_0_1>(&'_0_1 T) -> &'_0_1 T; // anonymous local
    let _6: &'0 T; // anonymous local

    storage_live(f_2)
    storage_live(_3)
    _3 := test_crate::test_closure_ref_early_bound::closure {  }
    f_2 := cast<for<'_0_1> test_crate::test_closure_ref_early_bound::closure::as_fn<'5, '_0_1, T>[@TraitClause0, @TraitClause1], fn<'_0_1>(&'_0_1 T) -> &'_0_1 T>(const (test_crate::test_closure_ref_early_bound::closure::as_fn<'5, '_, T>[@TraitClause0, @TraitClause1]))
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    _5 := copy (f_2)
    storage_live(_6)
    _6 := &*(x_1)
    _4 := (move (_5))(move (_6))
    _0 := &*(_4)
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(f_2)
    storage_dead(_4)
    return
}

// Full name: test_crate::test_closure_ref_early_bound::{impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}
impl<'a, '_1, T> FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}
    parent_clause1 = {built_in impl Sized for (&'_ T)}
    parent_clause2 = {built_in impl Tuple for (&'_ T)}
    parent_clause3 = {built_in impl Sized for &'_ T}
    fn call_once = {impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call_once<'a, '_1, T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_early_bound::{impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}
impl<'a, '_1, T> FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}
    parent_clause1 = {impl FnOnce<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}<'a, '_1, T>[@TraitClause0, @TraitClause1]
    parent_clause2 = {built_in impl Sized for (&'_ T)}
    parent_clause3 = {built_in impl Tuple for (&'_ T)}
    fn call_mut<'_0_1> = {impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call_mut<'a, '_1, '_0_1, T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_ref_early_bound::{impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}
impl<'a, '_1, T> Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<'a, T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}
    parent_clause1 = {impl FnMut<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}<'a, '_1, T>[@TraitClause0, @TraitClause1]
    parent_clause2 = {built_in impl Sized for (&'_ T)}
    parent_clause3 = {built_in impl Tuple for (&'_ T)}
    fn call<'_0_1> = {impl Fn<(&'_ T), &'_ T> for test_crate::test_closure_ref_early_bound::closure<'a, T>[@TraitClause0, @TraitClause1]}::call<'a, '_1, '_0_1, T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

struct test_crate::test_map_option2::closure {}

// Full name: test_crate::test_map_option2::{impl Fn<(u32), u32> for test_crate::test_map_option2::closure}::call
fn {impl Fn<(u32), u32> for test_crate::test_map_option2::closure}::call<'_0>(@1: &'_0 test_crate::test_map_option2::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let _1: &'0 test_crate::test_map_option2::closure; // arg #1
    let tupled_args_2: (u32); // arg #2
    let x_3: u32; // local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local

    storage_live(x_3)
    storage_live(_5)
    x_3 := move ((tupled_args_2).0)
    storage_live(_4)
    _4 := copy (x_3)
    _5 := copy (_4) panic.+ const (1 : u32)
    _0 := move (_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::test_map_option2::{impl FnMut<(u32), u32> for test_crate::test_map_option2::closure}::call_mut
fn {impl FnMut<(u32), u32> for test_crate::test_map_option2::closure}::call_mut<'_0>(@1: &'_0 mut test_crate::test_map_option2::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let state_1: &'_0 mut test_crate::test_map_option2::closure; // arg #1
    let args_2: (u32); // arg #2
    let _3: &'0 test_crate::test_map_option2::closure; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(u32), u32> for test_crate::test_map_option2::closure}::call<'2>(move (_3), move (args_2))
    return
}

// Full name: test_crate::test_map_option2::closure::{impl Destruct for test_crate::test_map_option2::closure}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_map_option2::closure}::drop_in_place(@1: *mut test_crate::test_map_option2::closure)
= <missing>

// Full name: test_crate::test_map_option2::closure::{impl Destruct for test_crate::test_map_option2::closure}
impl Destruct for test_crate::test_map_option2::closure {
    fn drop_in_place = {impl Destruct for test_crate::test_map_option2::closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::test_map_option2::{impl FnOnce<(u32), u32> for test_crate::test_map_option2::closure}::call_once
fn {impl FnOnce<(u32), u32> for test_crate::test_map_option2::closure}::call_once(@1: test_crate::test_map_option2::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let _1: test_crate::test_map_option2::closure; // arg #1
    let _2: (u32); // arg #2
    let _3: &'0 mut test_crate::test_map_option2::closure; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(u32), u32> for test_crate::test_map_option2::closure}::call_mut<'_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_map_option2::closure}] _1
    return
}

fn test_crate::test_map_option2::closure::as_fn(@1: u32) -> u32
{
    let _0: u32; // return
    let arg1_1: u32; // arg #1
    let args_2: (u32); // local
    let state_3: test_crate::test_map_option2::closure; // local

    storage_live(args_2)
    storage_live(state_3)
    args_2 := (move (arg1_1))
    state_3 := test_crate::test_map_option2::closure {  }
    _0 := {impl FnOnce<(u32), u32> for test_crate::test_map_option2::closure}::call_once(move (state_3), move (args_2))
    return
}

// Full name: test_crate::test_map_option2
pub fn test_map_option2(@1: Option<u32>[{built_in impl Sized for u32}]) -> Option<u32>[{built_in impl Sized for u32}]
{
    let _0: Option<u32>[{built_in impl Sized for u32}]; // return
    let x_1: Option<u32>[{built_in impl Sized for u32}]; // arg #1
    let f_2: fn(u32) -> u32; // local
    let _3: test_crate::test_map_option2::closure; // anonymous local
    let _4: Option<u32>[{built_in impl Sized for u32}]; // anonymous local
    let _5: fn(u32) -> u32; // anonymous local

    storage_live(f_2)
    storage_live(_3)
    _3 := test_crate::test_map_option2::closure {  }
    f_2 := cast<test_crate::test_map_option2::closure::as_fn, fn(u32) -> u32>(const (test_crate::test_map_option2::closure::as_fn))
    storage_dead(_3)
    storage_live(_4)
    _4 := copy (x_1)
    storage_live(_5)
    _5 := copy (f_2)
    _0 := map_option<u32, fn(u32) -> u32>[{built_in impl Sized for u32}, {built_in impl Sized for fn(u32) -> u32}, {built_in impl Fn<(u32), u32> for fn(u32) -> u32}](move (_4), move (_5))
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(f_2)
    return
}

// Full name: test_crate::test_map_option2::{impl FnOnce<(u32), u32> for test_crate::test_map_option2::closure}
impl FnOnce<(u32), u32> for test_crate::test_map_option2::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_map_option2::closure}
    parent_clause1 = {built_in impl Sized for (u32)}
    parent_clause2 = {built_in impl Tuple for (u32)}
    parent_clause3 = {built_in impl Sized for u32}
    fn call_once = {impl FnOnce<(u32), u32> for test_crate::test_map_option2::closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::test_map_option2::{impl FnMut<(u32), u32> for test_crate::test_map_option2::closure}
impl FnMut<(u32), u32> for test_crate::test_map_option2::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_map_option2::closure}
    parent_clause1 = {impl FnOnce<(u32), u32> for test_crate::test_map_option2::closure}
    parent_clause2 = {built_in impl Sized for (u32)}
    parent_clause3 = {built_in impl Tuple for (u32)}
    fn call_mut<'_0_1> = {impl FnMut<(u32), u32> for test_crate::test_map_option2::closure}::call_mut<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_map_option2::{impl Fn<(u32), u32> for test_crate::test_map_option2::closure}
impl Fn<(u32), u32> for test_crate::test_map_option2::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_map_option2::closure}
    parent_clause1 = {impl FnMut<(u32), u32> for test_crate::test_map_option2::closure}
    parent_clause2 = {built_in impl Sized for (u32)}
    parent_clause3 = {built_in impl Tuple for (u32)}
    fn call<'_0_1> = {impl Fn<(u32), u32> for test_crate::test_map_option2::closure}::call<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::id
pub fn id<T>(@1: T) -> T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: T; // return
    let x_1: T; // arg #1

    _0 := move (x_1)
    conditional_drop[{built_in impl Destruct for T}] x_1
    return
}

// Full name: test_crate::test_map_option_id1
pub fn test_map_option_id1(@1: Option<u32>[{built_in impl Sized for u32}]) -> Option<u32>[{built_in impl Sized for u32}]
{
    let _0: Option<u32>[{built_in impl Sized for u32}]; // return
    let x_1: Option<u32>[{built_in impl Sized for u32}]; // arg #1
    let _2: Option<u32>[{built_in impl Sized for u32}]; // anonymous local

    storage_live(_2)
    _2 := copy (x_1)
    _0 := map_option<u32, id<u32>[{built_in impl Sized for u32}]>[{built_in impl Sized for u32}, {built_in impl Sized for id<u32>[{built_in impl Sized for u32}]}, {built_in impl Fn<(u32), u32> for id<u32>[{built_in impl Sized for u32}]}](move (_2), const (id<u32>[{built_in impl Sized for u32}]))
    storage_dead(_2)
    return
}

// Full name: test_crate::test_map_option_id2
pub fn test_map_option_id2(@1: Option<u32>[{built_in impl Sized for u32}]) -> Option<u32>[{built_in impl Sized for u32}]
{
    let _0: Option<u32>[{built_in impl Sized for u32}]; // return
    let x_1: Option<u32>[{built_in impl Sized for u32}]; // arg #1
    let f_2: id<u32>[{built_in impl Sized for u32}]; // local
    let _3: Option<u32>[{built_in impl Sized for u32}]; // anonymous local
    let _4: id<u32>[{built_in impl Sized for u32}]; // anonymous local

    storage_live(f_2)
    f_2 := const (id<u32>[{built_in impl Sized for u32}])
    storage_live(_3)
    _3 := copy (x_1)
    storage_live(_4)
    _4 := copy (f_2)
    _0 := map_option<u32, id<u32>[{built_in impl Sized for u32}]>[{built_in impl Sized for u32}, {built_in impl Sized for id<u32>[{built_in impl Sized for u32}]}, {built_in impl Fn<(u32), u32> for id<u32>[{built_in impl Sized for u32}]}](move (_3), move (_4))
    storage_dead(_4)
    storage_dead(_3)
    storage_dead(f_2)
    return
}

// Full name: test_crate::id_clone
pub fn id_clone<T>(@1: T) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let x_1: T; // arg #1
    let _2: &'0 T; // anonymous local

    storage_live(_2)
    _2 := &x_1
    _0 := @TraitClause1::clone<'_>(move (_2))
    storage_dead(_2)
    conditional_drop[{built_in impl Destruct for T}] x_1
    return
}

// Full name: test_crate::test_id_clone
pub fn test_id_clone(@1: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let f_2: fn(u32) -> u32; // local
    let _3: fn(u32) -> u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(f_2)
    f_2 := cast<id_clone<u32>[{built_in impl Sized for u32}, {impl Clone for u32}], fn(u32) -> u32>(const (id_clone<u32>[{built_in impl Sized for u32}, {impl Clone for u32}]))
    storage_live(_3)
    _3 := copy (f_2)
    storage_live(_4)
    _4 := copy (x_1)
    _0 := (move (_3))(move (_4))
    storage_dead(_4)
    storage_dead(_3)
    storage_dead(f_2)
    return
}

// Full name: test_crate::test_id_clone_param
pub fn test_id_clone_param<T>(@1: T) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let x_1: T; // arg #1
    let f_2: fn(T) -> T; // local
    let _3: fn(T) -> T; // anonymous local
    let _4: T; // anonymous local

    storage_live(f_2)
    f_2 := cast<id_clone<T>[@TraitClause0, @TraitClause1], fn(T) -> T>(const (id_clone<T>[@TraitClause0, @TraitClause1]))
    storage_live(_3)
    _3 := copy (f_2)
    storage_live(_4)
    _4 := move (x_1)
    _0 := (move (_3))(move (_4))
    storage_dead(_4)
    storage_dead(_3)
    storage_dead(f_2)
    conditional_drop[{built_in impl Destruct for T}] x_1
    return
}

// Full name: test_crate::test_map_option_id_clone
pub fn test_map_option_id_clone(@1: Option<u32>[{built_in impl Sized for u32}]) -> Option<u32>[{built_in impl Sized for u32}]
{
    let _0: Option<u32>[{built_in impl Sized for u32}]; // return
    let x_1: Option<u32>[{built_in impl Sized for u32}]; // arg #1
    let _2: Option<u32>[{built_in impl Sized for u32}]; // anonymous local

    storage_live(_2)
    _2 := copy (x_1)
    _0 := map_option<u32, id_clone<u32>[{built_in impl Sized for u32}, {impl Clone for u32}]>[{built_in impl Sized for u32}, {built_in impl Sized for id_clone<u32>[{built_in impl Sized for u32}, {impl Clone for u32}]}, {built_in impl Fn<(u32), u32> for id_clone<u32>[{built_in impl Sized for u32}, {impl Clone for u32}]}](move (_2), const (id_clone<u32>[{built_in impl Sized for u32}, {impl Clone for u32}]))
    storage_dead(_2)
    return
}

struct test_crate::test_map_option3::closure {}

// Full name: test_crate::test_map_option3::{impl Fn<(u32), u32> for test_crate::test_map_option3::closure}::call
fn {impl Fn<(u32), u32> for test_crate::test_map_option3::closure}::call<'_0>(@1: &'_0 test_crate::test_map_option3::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let _1: &'0 test_crate::test_map_option3::closure; // arg #1
    let tupled_args_2: (u32); // arg #2
    let x_3: u32; // local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local

    storage_live(x_3)
    storage_live(_5)
    x_3 := move ((tupled_args_2).0)
    storage_live(_4)
    _4 := copy (x_3)
    _5 := copy (_4) panic.+ const (1 : u32)
    _0 := move (_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::test_map_option3::{impl FnMut<(u32), u32> for test_crate::test_map_option3::closure}::call_mut
fn {impl FnMut<(u32), u32> for test_crate::test_map_option3::closure}::call_mut<'_0>(@1: &'_0 mut test_crate::test_map_option3::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let state_1: &'_0 mut test_crate::test_map_option3::closure; // arg #1
    let args_2: (u32); // arg #2
    let _3: &'0 test_crate::test_map_option3::closure; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(u32), u32> for test_crate::test_map_option3::closure}::call<'2>(move (_3), move (args_2))
    return
}

// Full name: test_crate::test_map_option3::closure::{impl Destruct for test_crate::test_map_option3::closure}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_map_option3::closure}::drop_in_place(@1: *mut test_crate::test_map_option3::closure)
= <missing>

// Full name: test_crate::test_map_option3::closure::{impl Destruct for test_crate::test_map_option3::closure}
impl Destruct for test_crate::test_map_option3::closure {
    fn drop_in_place = {impl Destruct for test_crate::test_map_option3::closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::test_map_option3::{impl FnOnce<(u32), u32> for test_crate::test_map_option3::closure}::call_once
fn {impl FnOnce<(u32), u32> for test_crate::test_map_option3::closure}::call_once(@1: test_crate::test_map_option3::closure, @2: (u32)) -> u32
{
    let _0: u32; // return
    let _1: test_crate::test_map_option3::closure; // arg #1
    let _2: (u32); // arg #2
    let _3: &'0 mut test_crate::test_map_option3::closure; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(u32), u32> for test_crate::test_map_option3::closure}::call_mut<'_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_map_option3::closure}] _1
    return
}

// Full name: test_crate::test_map_option3::{impl FnOnce<(u32), u32> for test_crate::test_map_option3::closure}
impl FnOnce<(u32), u32> for test_crate::test_map_option3::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_map_option3::closure}
    parent_clause1 = {built_in impl Sized for (u32)}
    parent_clause2 = {built_in impl Tuple for (u32)}
    parent_clause3 = {built_in impl Sized for u32}
    fn call_once = {impl FnOnce<(u32), u32> for test_crate::test_map_option3::closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::test_map_option3::{impl FnMut<(u32), u32> for test_crate::test_map_option3::closure}
impl FnMut<(u32), u32> for test_crate::test_map_option3::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_map_option3::closure}
    parent_clause1 = {impl FnOnce<(u32), u32> for test_crate::test_map_option3::closure}
    parent_clause2 = {built_in impl Sized for (u32)}
    parent_clause3 = {built_in impl Tuple for (u32)}
    fn call_mut<'_0_1> = {impl FnMut<(u32), u32> for test_crate::test_map_option3::closure}::call_mut<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_map_option3::{impl Fn<(u32), u32> for test_crate::test_map_option3::closure}
impl Fn<(u32), u32> for test_crate::test_map_option3::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_map_option3::closure}
    parent_clause1 = {impl FnMut<(u32), u32> for test_crate::test_map_option3::closure}
    parent_clause2 = {built_in impl Sized for (u32)}
    parent_clause3 = {built_in impl Tuple for (u32)}
    fn call<'_0_1> = {impl Fn<(u32), u32> for test_crate::test_map_option3::closure}::call<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_map_option3
pub fn test_map_option3(@1: Option<u32>[{built_in impl Sized for u32}]) -> Option<u32>[{built_in impl Sized for u32}]
{
    let _0: Option<u32>[{built_in impl Sized for u32}]; // return
    let x_1: Option<u32>[{built_in impl Sized for u32}]; // arg #1
    let _2: Option<u32>[{built_in impl Sized for u32}]; // anonymous local
    let _3: test_crate::test_map_option3::closure; // anonymous local

    storage_live(_2)
    _2 := copy (x_1)
    storage_live(_3)
    _3 := test_crate::test_map_option3::closure {  }
    _0 := map_option<u32, test_crate::test_map_option3::closure>[{built_in impl Sized for u32}, {built_in impl Sized for test_crate::test_map_option3::closure}, {impl Fn<(u32), u32> for test_crate::test_map_option3::closure}](move (_2), move (_3))
    storage_dead(_3)
    storage_dead(_2)
    return
}

struct test_crate::test_regions::closure {}

// Full name: test_crate::test_regions::{impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call
fn {impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call<'_0, '_1>(@1: &'_1 test_crate::test_regions::closure, @2: (&'_0 &'_ u32)) -> u32
{
    let _0: u32; // return
    let _1: &'0 test_crate::test_regions::closure; // arg #1
    let tupled_args_2: (&'_0 &'_ u32); // arg #2
    let x_3: &'_ &'_ u32; // local

    storage_live(x_3)
    x_3 := move ((tupled_args_2).0)
    _0 := copy (*(*(x_3)))
    return
}

// Full name: test_crate::test_regions
pub fn test_regions<'a>(@1: &'a u32) -> u32
{
    let _0: u32; // return
    let x_1: &'0 u32; // arg #1
    let f_2: test_crate::test_regions::closure; // local
    let _3: &'1 test_crate::test_regions::closure; // anonymous local
    let _4: (&'2 &'0 u32); // anonymous local
    let _5: &'2 &'0 u32; // anonymous local
    let _6: &'2 &'0 u32; // anonymous local

    storage_live(f_2)
    f_2 := test_crate::test_regions::closure {  }
    storage_live(_3)
    _3 := &f_2
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _6 := &x_1
    _5 := &*(_6)
    _4 := (move (_5))
    _0 := {impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call<'_, '_>(move (_3), move (_4))
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    storage_dead(f_2)
    storage_dead(_6)
    return
}

// Full name: test_crate::test_regions::{impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call_mut
fn {impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call_mut<'_0, '_1>(@1: &'_1 mut test_crate::test_regions::closure, @2: (&'_0 &'_ u32)) -> u32
{
    let _0: u32; // return
    let state_1: &'_1 mut test_crate::test_regions::closure; // arg #1
    let args_2: (&'_0 &'0 u32); // arg #2
    let _3: &'1 test_crate::test_regions::closure; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call<'_0, '3>(move (_3), move (args_2))
    return
}

// Full name: test_crate::test_regions::closure::{impl Destruct for test_crate::test_regions::closure}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_regions::closure}::drop_in_place(@1: *mut test_crate::test_regions::closure)
= <missing>

// Full name: test_crate::test_regions::closure::{impl Destruct for test_crate::test_regions::closure}
impl Destruct for test_crate::test_regions::closure {
    fn drop_in_place = {impl Destruct for test_crate::test_regions::closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::test_regions::{impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call_once
fn {impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call_once<'_0>(@1: test_crate::test_regions::closure, @2: (&'_0 &'_ u32)) -> u32
{
    let _0: u32; // return
    let _1: test_crate::test_regions::closure; // arg #1
    let _2: (&'_ &'_ u32); // arg #2
    let _3: &'0 mut test_crate::test_regions::closure; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call_mut<'_0, '_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_regions::closure}] _1
    return
}

// Full name: test_crate::test_regions::{impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}
impl<'_0> FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_regions::closure}
    parent_clause1 = {built_in impl Sized for (&'_ &'_ u32)}
    parent_clause2 = {built_in impl Tuple for (&'_ &'_ u32)}
    parent_clause3 = {built_in impl Sized for u32}
    fn call_once = {impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call_once<'_0>
    non-dyn-compatible
}

// Full name: test_crate::test_regions::{impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}
impl<'_0> FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_regions::closure}
    parent_clause1 = {impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}<'_0>
    parent_clause2 = {built_in impl Sized for (&'_ &'_ u32)}
    parent_clause3 = {built_in impl Tuple for (&'_ &'_ u32)}
    fn call_mut<'_0_1> = {impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call_mut<'_0, '_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_regions::{impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}
impl<'_0> Fn<(&'_ &'_ u32), u32> for test_crate::test_regions::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_regions::closure}
    parent_clause1 = {impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}<'_0>
    parent_clause2 = {built_in impl Sized for (&'_ &'_ u32)}
    parent_clause3 = {built_in impl Tuple for (&'_ &'_ u32)}
    fn call<'_0_1> = {impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions::closure}::call<'_0, '_0_1>
    non-dyn-compatible
}

struct test_crate::test_regions_casted::closure {}

// Full name: test_crate::test_regions_casted::{impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call
fn {impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call<'_0, '_1>(@1: &'_1 test_crate::test_regions_casted::closure, @2: (&'_0 &'_ u32)) -> u32
{
    let _0: u32; // return
    let _1: &'0 test_crate::test_regions_casted::closure; // arg #1
    let tupled_args_2: (&'_0 &'_ u32); // arg #2
    let x_3: &'_ &'_ u32; // local

    storage_live(x_3)
    x_3 := move ((tupled_args_2).0)
    _0 := copy (*(*(x_3)))
    return
}

// Full name: test_crate::test_regions_casted::{impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call_mut
fn {impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call_mut<'_0, '_1>(@1: &'_1 mut test_crate::test_regions_casted::closure, @2: (&'_0 &'_ u32)) -> u32
{
    let _0: u32; // return
    let state_1: &'_1 mut test_crate::test_regions_casted::closure; // arg #1
    let args_2: (&'_0 &'0 u32); // arg #2
    let _3: &'1 test_crate::test_regions_casted::closure; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call<'_0, '3>(move (_3), move (args_2))
    return
}

// Full name: test_crate::test_regions_casted::closure::{impl Destruct for test_crate::test_regions_casted::closure}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_regions_casted::closure}::drop_in_place(@1: *mut test_crate::test_regions_casted::closure)
= <missing>

// Full name: test_crate::test_regions_casted::closure::{impl Destruct for test_crate::test_regions_casted::closure}
impl Destruct for test_crate::test_regions_casted::closure {
    fn drop_in_place = {impl Destruct for test_crate::test_regions_casted::closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::test_regions_casted::{impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call_once
fn {impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call_once<'_0>(@1: test_crate::test_regions_casted::closure, @2: (&'_0 &'_ u32)) -> u32
{
    let _0: u32; // return
    let _1: test_crate::test_regions_casted::closure; // arg #1
    let _2: (&'_ &'_ u32); // arg #2
    let _3: &'0 mut test_crate::test_regions_casted::closure; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call_mut<'_0, '_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_regions_casted::closure}] _1
    return
}

fn test_crate::test_regions_casted::closure::as_fn<'_0>(@1: &'_0 &'_ u32) -> u32
{
    let _0: u32; // return
    let arg1_1: &'_0 &'0 u32; // arg #1
    let args_2: (&'_0 &'1 u32); // local
    let state_3: test_crate::test_regions_casted::closure; // local

    storage_live(args_2)
    storage_live(state_3)
    args_2 := (move (arg1_1))
    state_3 := test_crate::test_regions_casted::closure {  }
    _0 := {impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call_once<'_0>(move (state_3), move (args_2))
    return
}

// Full name: test_crate::test_regions_casted
pub fn test_regions_casted<'a>(@1: &'a u32) -> u32
{
    let _0: u32; // return
    let x_1: &'0 u32; // arg #1
    let f_2: fn<'_0_1>(&'_0_1 &'1 u32) -> u32; // local
    let _3: test_crate::test_regions_casted::closure; // anonymous local
    let _4: fn<'_0_1>(&'_0_1 &'1 u32) -> u32; // anonymous local
    let _5: &'2 &'0 u32; // anonymous local
    let _6: &'2 &'0 u32; // anonymous local

    storage_live(f_2)
    storage_live(_3)
    _3 := test_crate::test_regions_casted::closure {  }
    f_2 := cast<for<'_0_1> test_crate::test_regions_casted::closure::as_fn<'_0_1>, fn<'_0_1>(&'_0_1 &'1 u32) -> u32>(const (test_crate::test_regions_casted::closure::as_fn<'_>))
    storage_dead(_3)
    storage_live(_4)
    _4 := copy (f_2)
    storage_live(_5)
    storage_live(_6)
    _6 := &x_1
    _5 := &*(_6)
    _0 := (move (_4))(move (_5))
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(f_2)
    storage_dead(_6)
    return
}

// Full name: test_crate::test_regions_casted::{impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}
impl<'_0> FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_regions_casted::closure}
    parent_clause1 = {built_in impl Sized for (&'_ &'_ u32)}
    parent_clause2 = {built_in impl Tuple for (&'_ &'_ u32)}
    parent_clause3 = {built_in impl Sized for u32}
    fn call_once = {impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call_once<'_0>
    non-dyn-compatible
}

// Full name: test_crate::test_regions_casted::{impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}
impl<'_0> FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_regions_casted::closure}
    parent_clause1 = {impl FnOnce<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}<'_0>
    parent_clause2 = {built_in impl Sized for (&'_ &'_ u32)}
    parent_clause3 = {built_in impl Tuple for (&'_ &'_ u32)}
    fn call_mut<'_0_1> = {impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call_mut<'_0, '_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_regions_casted::{impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}
impl<'_0> Fn<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_regions_casted::closure}
    parent_clause1 = {impl FnMut<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}<'_0>
    parent_clause2 = {built_in impl Sized for (&'_ &'_ u32)}
    parent_clause3 = {built_in impl Tuple for (&'_ &'_ u32)}
    fn call<'_0_1> = {impl Fn<(&'_ &'_ u32), u32> for test_crate::test_regions_casted::closure}::call<'_0, '_0_1>
    non-dyn-compatible
}

struct test_crate::test_closure_capture::closure<'_0, '_1> {
  &'_0 u32,
  &'_1 u32,
}

// Full name: test_crate::test_closure_capture::{impl Fn<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call
fn {impl Fn<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call<'_0, '_1, '_2>(@1: &'_2 test_crate::test_closure_capture::closure<'_0, '_1>, @2: (u32)) -> u32
{
    let _0: u32; // return
    let _1: &'0 test_crate::test_closure_capture::closure<'_0, '_1>; // arg #1
    let tupled_args_2: (u32); // arg #2
    let z_3: u32; // local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local
    let _7: u32; // anonymous local
    let _8: u32; // anonymous local
    let _9: u32; // anonymous local

    storage_live(z_3)
    storage_live(_7)
    storage_live(_9)
    z_3 := move ((tupled_args_2).0)
    storage_live(_4)
    storage_live(_5)
    _5 := copy (*((*(_1)).0))
    storage_live(_6)
    _6 := copy (*((*(_1)).1))
    _7 := copy (_5) panic.+ copy (_6)
    _4 := move (_7)
    storage_dead(_6)
    storage_dead(_5)
    storage_live(_8)
    _8 := copy (z_3)
    _9 := copy (_4) panic.+ copy (_8)
    _0 := move (_9)
    storage_dead(_8)
    storage_dead(_4)
    return
}

// Full name: test_crate::test_closure_capture
pub fn test_closure_capture(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let f_3: &'0 test_crate::test_closure_capture::closure<'_, '_>; // local
    let _4: test_crate::test_closure_capture::closure<'_, '_>; // anonymous local
    let _5: &'1 u32; // anonymous local
    let _6: &'1 u32; // anonymous local
    let _7: &'0 test_crate::test_closure_capture::closure<'_, '_>; // anonymous local
    let _8: (u32); // anonymous local

    storage_live(f_3)
    storage_live(_4)
    storage_live(_5)
    _5 := &x_1
    storage_live(_6)
    _6 := &y_2
    _4 := test_crate::test_closure_capture::closure { 0: move (_5), 1: move (_6) }
    storage_dead(_6)
    storage_dead(_5)
    f_3 := &_4
    storage_live(_7)
    _7 := &*(f_3)
    storage_live(_8)
    _8 := (const (0 : u32))
    _0 := {impl Fn<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call<'_, '_, '_>(move (_7), move (_8))
    storage_dead(_8)
    storage_dead(_7)
    storage_dead(_4)
    storage_dead(f_3)
    return
}

// Full name: test_crate::test_closure_capture::{impl FnMut<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call_mut
fn {impl FnMut<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call_mut<'_0, '_1, '_2>(@1: &'_2 mut test_crate::test_closure_capture::closure<'_0, '_1>, @2: (u32)) -> u32
{
    let _0: u32; // return
    let state_1: &'_2 mut test_crate::test_closure_capture::closure<'_0, '_1>; // arg #1
    let args_2: (u32); // arg #2
    let _3: &'0 test_crate::test_closure_capture::closure<'_0, '_1>; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call<'_0, '_1, '2>(move (_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_capture::closure::{impl Destruct for test_crate::test_closure_capture::closure<'_0, '_1>}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_closure_capture::closure<'_0, '_1>}::drop_in_place<'_0, '_1>(@1: *mut test_crate::test_closure_capture::closure<'_0, '_1>)
= <missing>

// Full name: test_crate::test_closure_capture::closure::{impl Destruct for test_crate::test_closure_capture::closure<'_0, '_1>}
impl<'_0, '_1> Destruct for test_crate::test_closure_capture::closure<'_0, '_1> {
    fn drop_in_place = {impl Destruct for test_crate::test_closure_capture::closure<'_0, '_1>}::drop_in_place<'_0, '_1>
    non-dyn-compatible
}

// Full name: test_crate::test_closure_capture::{impl FnOnce<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call_once
fn {impl FnOnce<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call_once<'_0, '_1>(@1: test_crate::test_closure_capture::closure<'_0, '_1>, @2: (u32)) -> u32
{
    let _0: u32; // return
    let _1: test_crate::test_closure_capture::closure<'_0, '_1>; // arg #1
    let _2: (u32); // arg #2
    let _3: &'0 mut test_crate::test_closure_capture::closure<'_0, '_1>; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call_mut<'_0, '_1, '_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_closure_capture::closure<'_0, '_1>}<'_, '_>] _1
    return
}

// Full name: test_crate::test_closure_capture::{impl FnOnce<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}
impl<'_0, '_1> FnOnce<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1> {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_capture::closure<'_0, '_1>}
    parent_clause1 = {built_in impl Sized for (u32)}
    parent_clause2 = {built_in impl Tuple for (u32)}
    parent_clause3 = {built_in impl Sized for u32}
    fn call_once = {impl FnOnce<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call_once<'_0, '_1>
    non-dyn-compatible
}

// Full name: test_crate::test_closure_capture::{impl FnMut<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}
impl<'_0, '_1> FnMut<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1> {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_capture::closure<'_0, '_1>}
    parent_clause1 = {impl FnOnce<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}<'_0, '_1>
    parent_clause2 = {built_in impl Sized for (u32)}
    parent_clause3 = {built_in impl Tuple for (u32)}
    fn call_mut<'_0_1> = {impl FnMut<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call_mut<'_0, '_1, '_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_closure_capture::{impl Fn<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}
impl<'_0, '_1> Fn<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1> {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_capture::closure<'_0, '_1>}
    parent_clause1 = {impl FnMut<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}<'_0, '_1>
    parent_clause2 = {built_in impl Sized for (u32)}
    parent_clause3 = {built_in impl Tuple for (u32)}
    fn call<'_0_1> = {impl Fn<(u32), u32> for test_crate::test_closure_capture::closure<'_0, '_1>}::call<'_0, '_1, '_0_1>
    non-dyn-compatible
}

struct test_crate::test_closure_clone::closure<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{}

// Full name: test_crate::test_closure_clone::{impl Fn<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call
fn {impl Fn<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call<'_0, T>(@1: &'_0 test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1], @2: (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let _1: &'0 test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]; // arg #1
    let tupled_args_2: (T); // arg #2
    let x_3: T; // local
    let _4: &'1 T; // anonymous local

    storage_live(x_3)
    x_3 := move ((tupled_args_2).0)
    storage_live(_4)
    _4 := &x_3
    _0 := @TraitClause1::clone<'_>(move (_4))
    storage_dead(_4)
    conditional_drop[{built_in impl Destruct for T}] x_3
    return
}

// Full name: test_crate::test_closure_clone
pub fn test_closure_clone<T>(@1: T) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let x_1: T; // arg #1
    let f_2: test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]; // local
    let _3: &'0 test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]; // anonymous local
    let _4: &'0 test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]; // anonymous local
    let _5: (T); // anonymous local
    let _6: T; // anonymous local

    storage_live(f_2)
    f_2 := test_crate::test_closure_clone::closure {  }
    storage_live(_3)
    storage_live(_4)
    _4 := &f_2
    _3 := &*(_4)
    storage_live(_5)
    storage_live(_6)
    _6 := move (x_1)
    _5 := (move (_6))
    _0 := {impl Fn<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call<'_, T>[@TraitClause0, @TraitClause1](move (_3), move (_5))
    conditional_drop[{built_in impl Destruct for T}] _6
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_3)
    storage_dead(f_2)
    storage_dead(_4)
    conditional_drop[{built_in impl Destruct for T}] x_1
    return
}

// Full name: test_crate::test_closure_clone::{impl FnMut<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call_mut
fn {impl FnMut<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call_mut<'_0, T>(@1: &'_0 mut test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1], @2: (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let state_1: &'_0 mut test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]; // arg #1
    let args_2: (T); // arg #2
    let _3: &'0 test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]; // anonymous local

    storage_live(_3)
    _3 := &*(state_1)
    _0 := {impl Fn<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call<'2, T>[@TraitClause0, @TraitClause1](move (_3), move (args_2))
    return
}

// Full name: test_crate::test_closure_clone::closure::{impl Destruct for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::drop_in_place<T>(@1: *mut test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1])
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
= <missing>

// Full name: test_crate::test_closure_clone::closure::{impl Destruct for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}
impl<T> Destruct for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    fn drop_in_place = {impl Destruct for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::drop_in_place<T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_clone::{impl FnOnce<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call_once
fn {impl FnOnce<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call_once<T>(@1: test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1], @2: (T)) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let _1: test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]; // arg #1
    let _2: (T); // arg #2
    let _3: &'0 mut test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call_mut<'_, T>[@TraitClause0, @TraitClause1](move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}<T>[@TraitClause0, @TraitClause1]] _1
    return
}

// Full name: test_crate::test_closure_clone::{impl FnOnce<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}
impl<T> FnOnce<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}
    parent_clause1 = {built_in impl Sized for (T)}
    parent_clause2 = {built_in impl Tuple for (T)}
    parent_clause3 = @TraitClause0
    fn call_once = {impl FnOnce<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call_once<T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_clone::{impl FnMut<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}
impl<T> FnMut<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}
    parent_clause1 = {impl FnOnce<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}<T>[@TraitClause0, @TraitClause1]
    parent_clause2 = {built_in impl Sized for (T)}
    parent_clause3 = {built_in impl Tuple for (T)}
    fn call_mut<'_0_1> = {impl FnMut<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call_mut<'_0_1, T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: test_crate::test_closure_clone::{impl Fn<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}
impl<T> Fn<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    parent_clause0 = {built_in impl MetaSized for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}
    parent_clause1 = {impl FnMut<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}<T>[@TraitClause0, @TraitClause1]
    parent_clause2 = {built_in impl Sized for (T)}
    parent_clause3 = {built_in impl Tuple for (T)}
    fn call<'_0_1> = {impl Fn<(T), T> for test_crate::test_closure_clone::closure<T>[@TraitClause0, @TraitClause1]}::call<'_0_1, T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

struct test_crate::test_array_map::closure {}

// Full name: test_crate::test_array_map::{impl FnMut<(i32), i32> for test_crate::test_array_map::closure}::call_mut
fn {impl FnMut<(i32), i32> for test_crate::test_array_map::closure}::call_mut<'_0>(@1: &'_0 mut test_crate::test_array_map::closure, @2: (i32)) -> i32
{
    let _0: i32; // return
    let _1: &'0 mut test_crate::test_array_map::closure; // arg #1
    let tupled_args_2: (i32); // arg #2
    let v_3: i32; // local

    storage_live(v_3)
    v_3 := move ((tupled_args_2).0)
    _0 := copy (v_3)
    return
}

// Full name: test_crate::test_array_map::closure::{impl Destruct for test_crate::test_array_map::closure}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_array_map::closure}::drop_in_place(@1: *mut test_crate::test_array_map::closure)
= <missing>

// Full name: test_crate::test_array_map::closure::{impl Destruct for test_crate::test_array_map::closure}
impl Destruct for test_crate::test_array_map::closure {
    fn drop_in_place = {impl Destruct for test_crate::test_array_map::closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::test_array_map::{impl FnOnce<(i32), i32> for test_crate::test_array_map::closure}::call_once
fn {impl FnOnce<(i32), i32> for test_crate::test_array_map::closure}::call_once(@1: test_crate::test_array_map::closure, @2: (i32)) -> i32
{
    let _0: i32; // return
    let _1: test_crate::test_array_map::closure; // arg #1
    let _2: (i32); // arg #2
    let _3: &'0 mut test_crate::test_array_map::closure; // anonymous local

    storage_live(_3)
    _3 := &mut _1
    _0 := {impl FnMut<(i32), i32> for test_crate::test_array_map::closure}::call_mut<'_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_array_map::closure}] _1
    return
}

// Full name: test_crate::test_array_map::{impl FnOnce<(i32), i32> for test_crate::test_array_map::closure}
impl FnOnce<(i32), i32> for test_crate::test_array_map::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_array_map::closure}
    parent_clause1 = {built_in impl Sized for (i32)}
    parent_clause2 = {built_in impl Tuple for (i32)}
    parent_clause3 = {built_in impl Sized for i32}
    fn call_once = {impl FnOnce<(i32), i32> for test_crate::test_array_map::closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::test_array_map::{impl FnMut<(i32), i32> for test_crate::test_array_map::closure}
impl FnMut<(i32), i32> for test_crate::test_array_map::closure {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_array_map::closure}
    parent_clause1 = {impl FnOnce<(i32), i32> for test_crate::test_array_map::closure}
    parent_clause2 = {built_in impl Sized for (i32)}
    parent_clause3 = {built_in impl Tuple for (i32)}
    fn call_mut<'_0_1> = {impl FnMut<(i32), i32> for test_crate::test_array_map::closure}::call_mut<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::test_array_map
pub fn test_array_map(@1: [i32; 256 : usize]) -> [i32; 256 : usize]
{
    let _0: [i32; 256 : usize]; // return
    let x_1: [i32; 256 : usize]; // arg #1
    let _2: [i32; 256 : usize]; // anonymous local
    let _3: test_crate::test_array_map::closure; // anonymous local

    storage_live(_2)
    _2 := copy (x_1)
    storage_live(_3)
    _3 := test_crate::test_array_map::closure {  }
    _0 := map<i32, test_crate::test_array_map::closure, i32, 256 : usize>[{built_in impl Sized for i32}, {built_in impl Sized for test_crate::test_array_map::closure}, {built_in impl Sized for i32}, {impl FnMut<(i32), i32> for test_crate::test_array_map::closure}](move (_2), move (_3))
    storage_dead(_3)
    storage_dead(_2)
    return
}

struct test_crate::test_fnmut_with_ref::closure<'_0> {
  &'_0 mut usize,
}

// Full name: test_crate::test_fnmut_with_ref::{impl FnMut<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}::call_mut
fn {impl FnMut<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}::call_mut<'_0, '_1, '_2>(@1: &'_2 mut test_crate::test_fnmut_with_ref::closure<'_0>, @2: (&'_1 usize))
{
    let _0: (); // return
    let _1: &'0 mut test_crate::test_fnmut_with_ref::closure<'_0>; // arg #1
    let tupled_args_2: (&'_1 usize); // arg #2
    let x_3: &'_ usize; // local
    let _4: usize; // anonymous local
    let _5: usize; // anonymous local

    storage_live(x_3)
    storage_live(_5)
    _0 := ()
    x_3 := move ((tupled_args_2).0)
    storage_live(_4)
    _4 := copy (*(x_3))
    _5 := copy (*((*(_1)).0)) panic.+ copy (_4)
    *((*(_1)).0) := move (_5)
    _0 := ()
    storage_dead(_4)
    return
}

// Full name: test_crate::test_fnmut_with_ref
fn test_fnmut_with_ref()
{
    let _0: (); // return
    let sum_1: usize; // local
    let closure_2: test_crate::test_fnmut_with_ref::closure<'_>; // local
    let _3: &'0 mut usize; // anonymous local
    let _4: (); // anonymous local
    let _5: &'1 mut test_crate::test_fnmut_with_ref::closure<'_>; // anonymous local
    let _6: (&'2 usize); // anonymous local
    let _7: &'2 usize; // anonymous local
    let _8: &'2 usize; // anonymous local
    let _9: &'2 usize; // anonymous local
    let _10: &'_ usize; // anonymous local
    let _11: usize; // anonymous local

    storage_live(_10)
    storage_live(_11)
    _11 := const (15 : usize)
    _10 := &_11
    storage_live(_9)
    _0 := ()
    storage_live(sum_1)
    sum_1 := const (0 : usize)
    storage_live(closure_2)
    storage_live(_3)
    _3 := &mut sum_1
    closure_2 := test_crate::test_fnmut_with_ref::closure { 0: move (_3) }
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    _5 := &mut closure_2
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    _9 := move (_10)
    _8 := &*(_9)
    _7 := &*(_8)
    _6 := (move (_7))
    _4 := {impl FnMut<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}::call_mut<'_, '_, '_>(move (_5), move (_6))
    storage_dead(_7)
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_8)
    storage_dead(_4)
    _0 := ()
    storage_dead(closure_2)
    storage_dead(sum_1)
    return
}

// Full name: test_crate::test_fnmut_with_ref::closure::{impl Destruct for test_crate::test_fnmut_with_ref::closure<'_0>}::drop_in_place
unsafe fn {impl Destruct for test_crate::test_fnmut_with_ref::closure<'_0>}::drop_in_place<'_0>(@1: *mut test_crate::test_fnmut_with_ref::closure<'_0>)
= <missing>

// Full name: test_crate::test_fnmut_with_ref::closure::{impl Destruct for test_crate::test_fnmut_with_ref::closure<'_0>}
impl<'_0> Destruct for test_crate::test_fnmut_with_ref::closure<'_0> {
    fn drop_in_place = {impl Destruct for test_crate::test_fnmut_with_ref::closure<'_0>}::drop_in_place<'_0>
    non-dyn-compatible
}

// Full name: test_crate::test_fnmut_with_ref::{impl FnOnce<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}::call_once
fn {impl FnOnce<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}::call_once<'_0, '_1>(@1: test_crate::test_fnmut_with_ref::closure<'_0>, @2: (&'_1 usize))
{
    let _0: (); // return
    let _1: test_crate::test_fnmut_with_ref::closure<'_0>; // arg #1
    let _2: (&'_ usize); // arg #2
    let _3: &'0 mut test_crate::test_fnmut_with_ref::closure<'_0>; // anonymous local

    storage_live(_3)
    _0 := ()
    _3 := &mut _1
    _0 := {impl FnMut<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}::call_mut<'_0, '_1, '_>(move (_3), move (_2))
    drop[{impl Destruct for test_crate::test_fnmut_with_ref::closure<'_0>}<'_>] _1
    return
}

// Full name: test_crate::test_fnmut_with_ref::{impl FnOnce<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}
impl<'_0, '_1> FnOnce<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0> {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_fnmut_with_ref::closure<'_0>}
    parent_clause1 = {built_in impl Sized for (&'_ usize)}
    parent_clause2 = {built_in impl Tuple for (&'_ usize)}
    parent_clause3 = {built_in impl Sized for ()}
    fn call_once = {impl FnOnce<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}::call_once<'_0, '_1>
    non-dyn-compatible
}

// Full name: test_crate::test_fnmut_with_ref::{impl FnMut<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}
impl<'_0, '_1> FnMut<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0> {
    parent_clause0 = {built_in impl MetaSized for test_crate::test_fnmut_with_ref::closure<'_0>}
    parent_clause1 = {impl FnOnce<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}<'_0, '_1>
    parent_clause2 = {built_in impl Sized for (&'_ usize)}
    parent_clause3 = {built_in impl Tuple for (&'_ usize)}
    fn call_mut<'_0_1> = {impl FnMut<(&'_ usize), ()> for test_crate::test_fnmut_with_ref::closure<'_0>}::call_mut<'_0, '_1, '_0_1>
    non-dyn-compatible
}



