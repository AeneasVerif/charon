# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0> = core::clone::Clone::clone<'_0_0, Self>[Self]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 (Self)) -> Self
where
    [@TraitClause0]: Clone<Self>,

// Full name: core::clone::impls::{impl Clone for u32}::clone
pub fn {impl Clone for u32}::clone<'_0>(@1: &'_0 (u32)) -> u32

// Full name: core::clone::impls::{impl Clone for u32}
impl Clone for u32 {
    parent_clause0 = Sized<u32>
    fn clone<'_0> = {impl Clone for u32}::clone<'_0_0>
    non-dyn-compatible
}

// Full name: core::clone::impls::{impl Clone for i32}::clone
pub fn {impl Clone for i32}::clone<'_0>(@1: &'_0 (i32)) -> i32

// Full name: core::clone::impls::{impl Clone for i32}
impl Clone for i32 {
    parent_clause0 = Sized<i32>
    fn clone<'_0> = {impl Clone for i32}::clone<'_0_0>
    non-dyn-compatible
}

// Full name: core::clone::impls::{impl Clone for usize}::clone
pub fn {impl Clone for usize}::clone<'_0>(@1: &'_0 (usize)) -> usize

// Full name: core::clone::impls::{impl Clone for usize}
impl Clone for usize {
    parent_clause0 = Sized<usize>
    fn clone<'_0> = {impl Clone for usize}::clone<'_0_0>
    non-dyn-compatible
}

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0, '_1> = core::cmp::PartialEq::eq<'_0_0, '_0_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

#[lang_item("cmp_partialeq_eq")]
pub fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,

// Full name: core::cmp::Eq
#[lang_item("Eq")]
pub trait Eq<Self>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Self>
    non-dyn-compatible
}

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0, '_1> = core::cmp::PartialOrd::partial_cmp<'_0_0, '_0_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

// Full name: core::cmp::Ord
#[lang_item("Ord")]
pub trait Ord<Self>
{
    parent_clause0 : [@TraitClause0]: Eq<Self>
    parent_clause1 : [@TraitClause1]: PartialOrd<Self, Self>
    fn cmp<'_0, '_1> = core::cmp::Ord::cmp<'_0_0, '_0_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("ord_cmp_method")]
pub fn core::cmp::Ord::cmp<'_0, '_1, Self>(@1: &'_0 (Self), @2: &'_1 (Self)) -> Ordering
where
    [@TraitClause0]: Ord<Self>,

#[lang_item("cmp_partialord_cmp")]
pub fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> Option<Ordering>[Sized<Ordering>]
where
    [@TraitClause0]: PartialOrd<Self, Rhs>,

// Full name: core::cmp::impls::{impl PartialEq<u32> for u32}::eq
pub fn {impl PartialEq<u32> for u32}::eq<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> bool

// Full name: core::cmp::impls::{impl PartialEq<u32> for u32}
impl PartialEq<u32> for u32 {
    fn eq<'_0, '_1> = {impl PartialEq<u32> for u32}::eq<'_0_0, '_0_1>
    vtable: {impl PartialEq<u32> for u32}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialEq<i32> for i32}::eq
pub fn {impl PartialEq<i32> for i32}::eq<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> bool

// Full name: core::cmp::impls::{impl PartialEq<i32> for i32}
impl PartialEq<i32> for i32 {
    fn eq<'_0, '_1> = {impl PartialEq<i32> for i32}::eq<'_0_0, '_0_1>
    vtable: {impl PartialEq<i32> for i32}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialEq<usize> for usize}::eq
pub fn {impl PartialEq<usize> for usize}::eq<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> bool

// Full name: core::cmp::impls::{impl PartialEq<usize> for usize}
impl PartialEq<usize> for usize {
    fn eq<'_0, '_1> = {impl PartialEq<usize> for usize}::eq<'_0_0, '_0_1>
    vtable: {impl PartialEq<usize> for usize}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialOrd<u32> for u32}::partial_cmp
pub fn {impl PartialOrd<u32> for u32}::partial_cmp<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> Option<Ordering>[Sized<Ordering>]

// Full name: core::cmp::impls::{impl PartialOrd<u32> for u32}
impl PartialOrd<u32> for u32 {
    parent_clause0 = {impl PartialEq<u32> for u32}
    fn partial_cmp<'_0, '_1> = {impl PartialOrd<u32> for u32}::partial_cmp<'_0_0, '_0_1>
    vtable: {impl PartialOrd<u32> for u32}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialOrd<i32> for i32}::partial_cmp
pub fn {impl PartialOrd<i32> for i32}::partial_cmp<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> Option<Ordering>[Sized<Ordering>]

// Full name: core::cmp::impls::{impl PartialOrd<i32> for i32}
impl PartialOrd<i32> for i32 {
    parent_clause0 = {impl PartialEq<i32> for i32}
    fn partial_cmp<'_0, '_1> = {impl PartialOrd<i32> for i32}::partial_cmp<'_0_0, '_0_1>
    vtable: {impl PartialOrd<i32> for i32}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialOrd<usize> for usize}::partial_cmp
pub fn {impl PartialOrd<usize> for usize}::partial_cmp<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> Option<Ordering>[Sized<Ordering>]

// Full name: core::cmp::impls::{impl PartialOrd<usize> for usize}
impl PartialOrd<usize> for usize {
    parent_clause0 = {impl PartialEq<usize> for usize}
    fn partial_cmp<'_0, '_1> = {impl PartialOrd<usize> for usize}::partial_cmp<'_0_0, '_0_1>
    vtable: {impl PartialOrd<usize> for usize}::{vtable}
}

// Full name: core::default::Default
#[lang_item("Default")]
pub trait Default<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn default = default<Self>[Self]
    non-dyn-compatible
}

// Full name: core::default::Default::default
#[lang_item("default_fn")]
pub fn default<Self>() -> Self
where
    [@TraitClause0]: Default<Self>,

// Full name: core::iter::adapters::zip::TrustedRandomAccessNoCoerce
pub trait TrustedRandomAccessNoCoerce<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const MAY_HAVE_SIDE_EFFECT : bool
    non-dyn-compatible
}

// Full name: core::iter::range::Step
#[lang_item("range_step")]
pub trait Step<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    parent_clause2 : [@TraitClause2]: PartialOrd<Self, Self>
    fn steps_between<'_0, '_1> = core::iter::range::Step::steps_between<'_0_0, '_0_1, Self>[Self]
    fn forward_checked = core::iter::range::Step::forward_checked<Self>[Self]
    fn backward_checked = core::iter::range::Step::backward_checked<Self>[Self]
    non-dyn-compatible
}

pub fn core::iter::range::Step::steps_between<'_0, '_1, Self>(@1: &'_0 (Self), @2: &'_1 (Self)) -> (usize, Option<usize>[Sized<usize>])
where
    [@TraitClause0]: Step<Self>,

pub fn core::iter::range::Step::forward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,

pub fn core::iter::range::Step::backward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,

// Full name: core::iter::range::{impl Step for usize}::steps_between
pub fn {impl Step for usize}::steps_between<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> (usize, Option<usize>[Sized<usize>])

// Full name: core::iter::range::{impl Step for usize}::forward_checked
pub fn {impl Step for usize}::forward_checked(@1: usize, @2: usize) -> Option<usize>[Sized<usize>]

// Full name: core::iter::range::{impl Step for usize}::backward_checked
pub fn {impl Step for usize}::backward_checked(@1: usize, @2: usize) -> Option<usize>[Sized<usize>]

// Full name: core::iter::range::{impl Step for usize}
impl Step for usize {
    parent_clause0 = Sized<usize>
    parent_clause1 = {impl Clone for usize}
    parent_clause2 = {impl PartialOrd<usize> for usize}
    fn steps_between<'_0, '_1> = {impl Step for usize}::steps_between<'_0_0, '_0_1>
    fn forward_checked = {impl Step for usize}::forward_checked
    fn backward_checked = {impl Step for usize}::backward_checked
    non-dyn-compatible
}

// Full name: core::iter::range::{impl Step for u32}::steps_between
pub fn {impl Step for u32}::steps_between<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> (usize, Option<usize>[Sized<usize>])

// Full name: core::iter::range::{impl Step for u32}::forward_checked
pub fn {impl Step for u32}::forward_checked(@1: u32, @2: usize) -> Option<u32>[Sized<u32>]

// Full name: core::iter::range::{impl Step for u32}::backward_checked
pub fn {impl Step for u32}::backward_checked(@1: u32, @2: usize) -> Option<u32>[Sized<u32>]

// Full name: core::iter::range::{impl Step for u32}
impl Step for u32 {
    parent_clause0 = Sized<u32>
    parent_clause1 = {impl Clone for u32}
    parent_clause2 = {impl PartialOrd<u32> for u32}
    fn steps_between<'_0, '_1> = {impl Step for u32}::steps_between<'_0_0, '_0_1>
    fn forward_checked = {impl Step for u32}::forward_checked
    fn backward_checked = {impl Step for u32}::backward_checked
    non-dyn-compatible
}

// Full name: core::iter::range::{impl Step for i32}::steps_between
pub fn {impl Step for i32}::steps_between<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> (usize, Option<usize>[Sized<usize>])

// Full name: core::iter::range::{impl Step for i32}::forward_checked
pub fn {impl Step for i32}::forward_checked(@1: i32, @2: usize) -> Option<i32>[Sized<i32>]

// Full name: core::iter::range::{impl Step for i32}::backward_checked
pub fn {impl Step for i32}::backward_checked(@1: i32, @2: usize) -> Option<i32>[Sized<i32>]

// Full name: core::iter::range::{impl Step for i32}
impl Step for i32 {
    parent_clause0 = Sized<i32>
    parent_clause1 = {impl Clone for i32}
    parent_clause2 = {impl PartialOrd<i32> for i32}
    fn steps_between<'_0, '_1> = {impl Step for i32}::steps_between<'_0_0, '_0_1>
    fn forward_checked = {impl Step for i32}::forward_checked
    fn backward_checked = {impl Step for i32}::backward_checked
    non-dyn-compatible
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0> = core::iter::traits::iterator::Iterator::next<'_0_0, Self>[Self]
    non-dyn-compatible
}

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}::next
pub fn {impl Iterator for Range<A>[@TraitClause0]}::next<'_0, A>(@1: &'_0 mut (Range<A>[@TraitClause0])) -> Option<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}
impl<A> Iterator for Range<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,
{
    parent_clause0 = MetaSized<Range<A>[@TraitClause0]>
    parent_clause1 = @TraitClause0
    type Item = A
    fn next<'_0> = {impl Iterator for Range<A>[@TraitClause0]}::next<'_0_0, A>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: core::iter::traits::accum::Sum
pub trait Sum<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn sum<I, [@TraitClause0]: Sized<I>, [@TraitClause1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Sum::sum<Self, A, I>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

pub fn core::iter::traits::accum::Sum::sum<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Sum<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::accum::Product
pub trait Product<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn product<I, [@TraitClause0]: Sized<I>, [@TraitClause1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Product::product<Self, A, I>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

pub fn core::iter::traits::accum::Product::product<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Product<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::collect::IntoIterator
#[lang_item("IntoIterator")]
pub trait IntoIterator<Self>
where
    Self::parent_clause3::Item = Self::Item,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: Sized<Self::IntoIter>
    parent_clause3 : [@TraitClause3]: Iterator<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter = core::iter::traits::collect::IntoIterator::into_iter<Self>[Self]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::FromIterator
#[lang_item("FromIterator")]
pub trait FromIterator<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn from_iter<T, [@TraitClause0]: Sized<T>, [@TraitClause1]: IntoIterator<T>, @TraitClause1_1::Item = A> = from_iter<Self, A, T>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::FromIterator::from_iter
#[lang_item("from_iter_fn")]
pub fn from_iter<Self, A, T>(@1: T) -> Self
where
    [@TraitClause0]: FromIterator<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,

#[lang_item("into_iter")]
pub fn core::iter::traits::collect::IntoIterator::into_iter<Self>(@1: Self) -> @TraitClause0::IntoIter
where
    [@TraitClause0]: IntoIterator<Self>,

// Full name: core::iter::traits::collect::{impl IntoIterator for I}::into_iter
pub fn {impl IntoIterator for I}::into_iter<I>(@1: I) -> I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,

// Full name: core::iter::traits::collect::{impl IntoIterator for I}
impl<I> IntoIterator for I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
{
    parent_clause0 = @TraitClause0::parent_clause0
    parent_clause1 = @TraitClause1::parent_clause1
    parent_clause2 = @TraitClause0
    parent_clause3 = @TraitClause1
    type Item = @TraitClause1::Item
    type IntoIter = I
    fn into_iter = {impl IntoIterator for I}::into_iter<I>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::Extend
pub trait Extend<Self, A>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn extend<'_0, T, [@TraitClause0]: Sized<T>, [@TraitClause1]: IntoIterator<T>, @TraitClause1_1::Item = A> = extend<'_0_0, Self, A, T>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::Extend::extend
pub fn extend<'_0, Self, A, T>(@1: &'_0 mut (Self), @2: T)
where
    [@TraitClause0]: Extend<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::double_ended::DoubleEndedIterator
#[lang_item("DoubleEndedIterator")]
pub trait DoubleEndedIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    fn next_back<'_0> = next_back<'_0_0, Self>[Self]
    non-dyn-compatible
}

// Full name: core::iter::traits::double_ended::DoubleEndedIterator::next_back
pub fn next_back<'_0, Self>(@1: &'_0 mut (Self)) -> Option<@TraitClause0::parent_clause1::Item>[@TraitClause0::parent_clause1::parent_clause1]
where
    [@TraitClause0]: DoubleEndedIterator<Self>,

// Full name: core::iter::traits::exact_size::ExactSizeIterator
pub trait ExactSizeIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    non-dyn-compatible
}

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut (Self)) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::control_flow::ControlFlow
#[lang_item("ControlFlow")]
pub enum ControlFlow<B, C>
where
    [@TraitClause0]: Sized<B>,
    [@TraitClause1]: Sized<C>,
{
  Continue(C),
  Break(B),
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = call_once<Self, Args>[Self]
    non-dyn-compatible
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0> = call_mut<'_0_0, Self, Args>[Self]
    non-dyn-compatible
}

// Full name: core::ops::function::FnMut::call_mut
pub fn call_mut<'_0, Self, Args>(@1: &'_0 mut (Self), @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,

// Full name: core::ops::function::FnOnce::call_once
pub fn call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,

// Full name: core::ops::index::Index
#[lang_item("index")]
pub trait Index<Self, Idx>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: MetaSized<Idx>
    parent_clause2 : [@TraitClause2]: MetaSized<Self::Output>
    type Output
    fn index<'_0> = core::ops::index::Index::index<'_0_0, Self, Idx>[Self]
    non-dyn-compatible
}

pub fn core::ops::index::Index::index<'_0, Self, Idx>(@1: &'_0 (Self), @2: Idx) -> &'_0 (@TraitClause0::Output)
where
    [@TraitClause0]: Index<Self, Idx>,

// Full name: core::ops::index::IndexMut
#[lang_item("index_mut")]
pub trait IndexMut<Self, Idx>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Index<Self, Idx>
    parent_clause2 : [@TraitClause2]: MetaSized<Idx>
    fn index_mut<'_0> = core::ops::index::IndexMut::index_mut<'_0_0, Self, Idx>[Self]
    non-dyn-compatible
}

pub fn core::ops::index::IndexMut::index_mut<'_0, Self, Idx>(@1: &'_0 mut (Self), @2: Idx) -> &'_0 mut (@TraitClause0::parent_clause1::Output)
where
    [@TraitClause0]: IndexMut<Self, Idx>,

// Full name: core::ops::try_trait::FromResidual
#[lang_item("FromResidual")]
pub trait FromResidual<Self, R>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<R>
    fn from_residual = from_residual<Self, R>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try
#[lang_item("Try")]
pub trait Try<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FromResidual<Self, Self::Residual>
    parent_clause2 : [@TraitClause2]: Sized<Self::Output>
    parent_clause3 : [@TraitClause3]: Sized<Self::Residual>
    type Output
    type Residual
    fn from_output = from_output<Self>[Self]
    fn branch = branch<Self>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try::from_output
#[lang_item("from_output")]
pub fn from_output<Self>(@1: @TraitClause0::Output) -> Self
where
    [@TraitClause0]: Try<Self>,

// Full name: core::ops::try_trait::Try::branch
#[lang_item("branch")]
pub fn branch<Self>(@1: Self) -> ControlFlow<@TraitClause0::Residual, @TraitClause0::Output>[@TraitClause0::parent_clause1::parent_clause1, @TraitClause0::parent_clause2]
where
    [@TraitClause0]: Try<Self>,

// Full name: core::ops::try_trait::FromResidual::from_residual
#[lang_item("from_residual")]
pub fn from_residual<Self, R>(@1: R) -> Self
where
    [@TraitClause0]: FromResidual<Self, R>,

// Full name: core::ops::try_trait::Residual
pub trait Residual<Self, O>
where
    Self::parent_clause3::Output = O,
    Self::parent_clause3::Residual = Self,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<O>
    parent_clause2 : [@TraitClause2]: Sized<Self::TryType>
    parent_clause3 : [@TraitClause3]: Try<Self::TryType>
    type TryType
    non-dyn-compatible
}

// Full name: core::slice::index::private_slice_index::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::slice::index::private_slice_index::Sealed::{vtable}
}

// Full name: core::slice::index::private_slice_index::{impl Sealed for usize}
impl Sealed for usize {
    parent_clause0 = MetaSized<usize>
    vtable: {impl Sealed for usize}::{vtable}
}

// Full name: core::slice::index::SliceIndex
#[lang_item("SliceIndex")]
pub trait SliceIndex<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sealed<Self>
    parent_clause2 : [@TraitClause2]: MetaSized<T>
    parent_clause3 : [@TraitClause3]: MetaSized<Self::Output>
    type Output
    fn get<'_0> = core::slice::index::SliceIndex::get<'_0_0, Self, T>[Self]
    fn get_mut<'_0> = core::slice::index::SliceIndex::get_mut<'_0_0, Self, T>[Self]
    fn get_unchecked = core::slice::index::SliceIndex::get_unchecked<Self, T>[Self]
    fn get_unchecked_mut = core::slice::index::SliceIndex::get_unchecked_mut<Self, T>[Self]
    fn index<'_0> = core::slice::index::SliceIndex::index<'_0_0, Self, T>[Self]
    fn index_mut<'_0> = core::slice::index::SliceIndex::index_mut<'_0_0, Self, T>[Self]
    non-dyn-compatible
}

pub fn core::slice::index::SliceIndex::get<'_0, Self, T>(@1: Self, @2: &'_0 (T)) -> Option<&'_0 (@TraitClause0::Output)>[Sized<&'_0 (@TraitClause0::Output)>]
where
    [@TraitClause0]: SliceIndex<Self, T>,

pub fn core::slice::index::SliceIndex::get_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut (T)) -> Option<&'_0 mut (@TraitClause0::Output)>[Sized<&'_0 mut (@TraitClause0::Output)>]
where
    [@TraitClause0]: SliceIndex<Self, T>,

pub unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T>(@1: Self, @2: *const T) -> *const @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,

pub unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T>(@1: Self, @2: *mut T) -> *mut @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,

pub fn core::slice::index::SliceIndex::index<'_0, Self, T>(@1: Self, @2: &'_0 (T)) -> &'_0 (@TraitClause0::Output)
where
    [@TraitClause0]: SliceIndex<Self, T>,

pub fn core::slice::index::SliceIndex::index_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut (T)) -> &'_0 mut (@TraitClause0::Output)
where
    [@TraitClause0]: SliceIndex<Self, T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>> for usize}::get
pub fn {impl SliceIndex<Slice<T>> for usize}::get<'_0, T>(@1: usize, @2: &'_0 (Slice<T>)) -> Option<&'_0 (T)>[Sized<&'_0 (T)>]
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>> for usize}::get_mut
pub fn {impl SliceIndex<Slice<T>> for usize}::get_mut<'_0, T>(@1: usize, @2: &'_0 mut (Slice<T>)) -> Option<&'_0 mut (T)>[Sized<&'_0 mut (T)>]
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>> for usize}::get_unchecked
pub unsafe fn {impl SliceIndex<Slice<T>> for usize}::get_unchecked<T>(@1: usize, @2: *const Slice<T>) -> *const T
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>> for usize}::get_unchecked_mut
pub unsafe fn {impl SliceIndex<Slice<T>> for usize}::get_unchecked_mut<T>(@1: usize, @2: *mut Slice<T>) -> *mut T
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>> for usize}::index
pub fn {impl SliceIndex<Slice<T>> for usize}::index<'_0, T>(@1: usize, @2: &'_0 (Slice<T>)) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>> for usize}::index_mut
pub fn {impl SliceIndex<Slice<T>> for usize}::index_mut<'_0, T>(@1: usize, @2: &'_0 mut (Slice<T>)) -> &'_0 mut (T)
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>> for usize}
impl<T> SliceIndex<Slice<T>> for usize
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = MetaSized<usize>
    parent_clause1 = {impl Sealed for usize}
    parent_clause2 = MetaSized<Slice<T>>
    parent_clause3 = @TraitClause0::parent_clause0
    type Output = T
    fn get<'_0> = {impl SliceIndex<Slice<T>> for usize}::get<'_0_0, T>[@TraitClause0]
    fn get_mut<'_0> = {impl SliceIndex<Slice<T>> for usize}::get_mut<'_0_0, T>[@TraitClause0]
    fn get_unchecked = {impl SliceIndex<Slice<T>> for usize}::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = {impl SliceIndex<Slice<T>> for usize}::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0> = {impl SliceIndex<Slice<T>> for usize}::index<'_0_0, T>[@TraitClause0]
    fn index_mut<'_0> = {impl SliceIndex<Slice<T>> for usize}::index_mut<'_0_0, T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::vec::Vec
#[lang_item("Vec")]
pub opaque type Vec<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<type_error("removed allocator parameter")>,

pub fn alloc::vec::{Vec<T>[@TraitClause0, @TraitClause1]}::len<'_0, T, A>(@1: &'_0 (Vec<T>[@TraitClause0, @TraitClause1])) -> usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<A>,

// Full name: alloc::vec::{impl Index<I> for Vec<T>[@TraitClause0, @TraitClause2]}::index
pub fn {impl Index<I> for Vec<T>[@TraitClause0, @TraitClause2]}::index<'_0, T, I, A>(@1: &'_0 (Vec<T>[@TraitClause0, @TraitClause2]), @2: I) -> &'_0 (@TraitClause3::Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Sized<A>,
    [@TraitClause3]: SliceIndex<I, Slice<T>>,

// Full name: alloc::vec::{impl Index<I> for Vec<T>[@TraitClause0, @TraitClause2]}
impl<T, I, A> Index<I> for Vec<T>[@TraitClause0, @TraitClause2]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Sized<A>,
    [@TraitClause3]: SliceIndex<I, Slice<T>>,
{
    parent_clause0 = MetaSized<Vec<T>[@TraitClause0, @TraitClause2]>
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause3::parent_clause3
    type Output = @TraitClause3::Output
    fn index<'_0> = {impl Index<I> for Vec<T>[@TraitClause0, @TraitClause2]}::index<'_0_0, T, I, A>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3]
    non-dyn-compatible
}

// Full name: alloc::vec::{impl IndexMut<I> for Vec<T>[@TraitClause0, @TraitClause2]}::index_mut
pub fn {impl IndexMut<I> for Vec<T>[@TraitClause0, @TraitClause2]}::index_mut<'_0, T, I, A>(@1: &'_0 mut (Vec<T>[@TraitClause0, @TraitClause2]), @2: I) -> &'_0 mut (@TraitClause3::Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Sized<A>,
    [@TraitClause3]: SliceIndex<I, Slice<T>>,

// Full name: alloc::vec::{impl IndexMut<I> for Vec<T>[@TraitClause0, @TraitClause2]}
impl<T, I, A> IndexMut<I> for Vec<T>[@TraitClause0, @TraitClause2]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Sized<A>,
    [@TraitClause3]: SliceIndex<I, Slice<T>>,
{
    parent_clause0 = MetaSized<Vec<T>[@TraitClause0, @TraitClause2]>
    parent_clause1 = {impl Index<I> for Vec<T>[@TraitClause0, @TraitClause2]}<T, I, A>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3]
    parent_clause2 = @TraitClause1::parent_clause0
    fn index_mut<'_0> = {impl IndexMut<I> for Vec<T>[@TraitClause0, @TraitClause2]}::index_mut<'_0_0, T, I, A>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3]
    non-dyn-compatible
}

// Full name: test_crate::test_loop1
pub fn test_loop1(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: u32; // anonymous local
    let @11: (); // anonymous local
    let @12: u32; // anonymous local

    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@12)
    storage_live(i@2)
    i@2 := const (0 : u32)
    storage_live(s@3)
    s@3 := const (0 : u32)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        @7 := copy (max@1)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@8)
            @8 := copy (i@2)
            @9 := copy (s@3) panic.+ copy (@8)
            s@3 := move (@9)
            storage_dead(@8)
            @10 := copy (i@2) panic.+ const (1 : u32)
            i@2 := move (@10)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@11)
    storage_dead(@11)
    storage_dead(@5)
    storage_dead(@4)
    @12 := copy (s@3) panic.* const (2 : u32)
    s@3 := move (@12)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::test_loop2
pub fn test_loop2(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: (); // anonymous local
    let @9: bool; // anonymous local
    let @10: u32; // anonymous local
    let @11: u32; // anonymous local
    let @12: u32; // anonymous local
    let @13: u32; // anonymous local
    let @14: (); // anonymous local

    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(i@2)
    i@2 := const (0 : u32)
    storage_live(s@3)
    s@3 := const (0 : u32)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        @7 := copy (max@1)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@8)
            storage_live(@9)
            storage_live(@10)
            @10 := copy (i@2)
            @9 := move (@10) == const (17 : u32)
            if move (@9) {
            }
            else {
                storage_dead(@10)
                storage_dead(@9)
                storage_dead(@8)
                storage_live(@11)
                @11 := copy (i@2)
                @12 := copy (s@3) panic.+ copy (@11)
                s@3 := move (@12)
                storage_dead(@11)
                @13 := copy (i@2) panic.+ const (1 : u32)
                i@2 := move (@13)
                storage_dead(@5)
                continue 0
            }
            storage_dead(@10)
            storage_dead(@9)
            storage_dead(@8)
            break 0
        }
        else {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@14)
            storage_dead(@14)
            break 0
        }
    }
    storage_dead(@5)
    storage_dead(@4)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::test_loop3
pub fn test_loop3(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let j@3: u32; // local
    let s@4: u32; // local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: (); // anonymous local
    let @10: bool; // anonymous local
    let @11: u32; // anonymous local
    let @12: u32; // anonymous local
    let @13: (); // anonymous local
    let @14: bool; // anonymous local
    let @15: u32; // anonymous local
    let @16: u32; // anonymous local
    let @17: u32; // anonymous local
    let @18: u32; // anonymous local
    let @19: u32; // anonymous local
    let @20: u32; // anonymous local
    let @21: u32; // anonymous local
    let @22: (); // anonymous local
    let @23: u32; // anonymous local
    let @24: u32; // anonymous local
    let @25: u32; // anonymous local
    let @26: (); // anonymous local

    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    storage_live(@20)
    storage_live(@21)
    storage_live(@22)
    storage_live(@23)
    storage_live(@24)
    storage_live(@25)
    storage_live(i@2)
    i@2 := const (0 : u32)
    storage_live(j@3)
    j@3 := const (0 : u32)
    storage_live(s@4)
    s@4 := const (0 : u32)
    storage_live(@5)
    loop {
        storage_live(@6)
        storage_live(@7)
        @7 := copy (i@2)
        storage_live(@8)
        @8 := copy (max@1)
        @6 := move (@7) < move (@8)
        if move (@6) {
            storage_dead(@8)
            storage_dead(@7)
            storage_live(@9)
            loop {
                storage_live(@10)
                storage_live(@11)
                @11 := copy (j@3)
                storage_live(@12)
                @12 := copy (max@1)
                @10 := move (@11) < move (@12)
                if move (@10) {
                    storage_dead(@12)
                    storage_dead(@11)
                    storage_live(@13)
                    storage_live(@14)
                    storage_live(@15)
                    storage_live(@16)
                    @16 := copy (i@2)
                    storage_live(@17)
                    @17 := copy (j@3)
                    @18 := copy (@16) panic.+ copy (@17)
                    @15 := move (@18)
                    storage_dead(@17)
                    storage_dead(@16)
                    @14 := move (@15) == const (17 : u32)
                    if move (@14) {
                    }
                    else {
                        storage_dead(@15)
                        storage_dead(@14)
                        storage_dead(@13)
                        storage_live(@19)
                        @19 := copy (i@2)
                        @20 := copy (s@4) panic.+ copy (@19)
                        s@4 := move (@20)
                        storage_dead(@19)
                        @21 := copy (j@3) panic.+ const (1 : u32)
                        j@3 := move (@21)
                        storage_dead(@10)
                        storage_dead(@9)
                        storage_dead(@6)
                        continue 1
                    }
                    storage_dead(@15)
                    storage_dead(@14)
                    storage_dead(@13)
                    storage_dead(@10)
                    continue 0
                }
                else {
                    break 0
                }
            }
            storage_dead(@12)
            storage_dead(@11)
            storage_live(@22)
            storage_dead(@22)
            storage_dead(@10)
            storage_dead(@9)
            j@3 := const (0 : u32)
            storage_live(@23)
            @23 := copy (i@2)
            @24 := copy (s@4) panic.+ copy (@23)
            s@4 := move (@24)
            storage_dead(@23)
            @25 := copy (i@2) panic.+ const (1 : u32)
            i@2 := move (@25)
            storage_dead(@6)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@8)
    storage_dead(@7)
    storage_live(@26)
    storage_dead(@26)
    storage_dead(@6)
    storage_dead(@5)
    @0 := copy (s@4)
    storage_dead(s@4)
    storage_dead(j@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::test_loop4
pub fn test_loop4(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let j@3: u32; // local
    let s@4: u32; // local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: (); // anonymous local
    let @10: bool; // anonymous local
    let @11: u32; // anonymous local
    let @12: u32; // anonymous local
    let @13: (); // anonymous local
    let @14: bool; // anonymous local
    let @15: u32; // anonymous local
    let @16: u32; // anonymous local
    let @17: u32; // anonymous local
    let @18: u32; // anonymous local
    let @19: u32; // anonymous local
    let @20: u32; // anonymous local
    let @21: u32; // anonymous local
    let @22: (); // anonymous local
    let @23: u32; // anonymous local
    let @24: u32; // anonymous local
    let @25: u32; // anonymous local
    let @26: (); // anonymous local

    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    storage_live(@20)
    storage_live(@21)
    storage_live(@22)
    storage_live(@23)
    storage_live(@24)
    storage_live(@25)
    storage_live(@26)
    storage_live(i@2)
    i@2 := const (1 : u32)
    storage_live(j@3)
    j@3 := const (0 : u32)
    storage_live(s@4)
    s@4 := const (0 : u32)
    storage_live(@5)
    loop {
        storage_live(@6)
        storage_live(@7)
        @7 := copy (i@2)
        storage_live(@8)
        @8 := copy (max@1)
        @6 := move (@7) < move (@8)
        if move (@6) {
            storage_dead(@8)
            storage_dead(@7)
            storage_live(@9)
            loop {
                storage_live(@10)
                storage_live(@11)
                @11 := copy (j@3)
                storage_live(@12)
                @12 := copy (max@1)
                @10 := move (@11) < move (@12)
                if move (@10) {
                    storage_dead(@12)
                    storage_dead(@11)
                    storage_live(@13)
                    storage_live(@14)
                    storage_live(@15)
                    storage_live(@16)
                    @16 := copy (i@2)
                    storage_live(@17)
                    @17 := copy (j@3)
                    @18 := copy (@16) panic.+ copy (@17)
                    @15 := move (@18)
                    storage_dead(@17)
                    storage_dead(@16)
                    @14 := move (@15) == const (17 : u32)
                    if move (@14) {
                        storage_dead(@15)
                        storage_dead(@14)
                        storage_dead(@13)
                        storage_dead(@10)
                        continue 0
                    }
                    else {
                        storage_dead(@15)
                        storage_dead(@14)
                        storage_dead(@13)
                        storage_live(@19)
                        @19 := copy (i@2)
                        @20 := copy (s@4) panic.+ copy (@19)
                        s@4 := move (@20)
                        storage_dead(@19)
                        @21 := copy (j@3) panic.+ const (1 : u32)
                        j@3 := move (@21)
                        storage_dead(@10)
                        storage_dead(@9)
                        break 1
                    }
                }
                else {
                    break 0
                }
            }
            storage_dead(@12)
            storage_dead(@11)
            storage_live(@22)
            storage_dead(@22)
            storage_dead(@10)
            storage_dead(@9)
            j@3 := const (0 : u32)
            storage_live(@23)
            @23 := copy (i@2)
            @24 := copy (s@4) panic.+ copy (@23)
            s@4 := move (@24)
            storage_dead(@23)
            @25 := copy (i@2) panic.+ const (1 : u32)
            i@2 := move (@25)
            storage_dead(@6)
            continue 0
        }
        else {
            storage_dead(@8)
            storage_dead(@7)
            storage_live(@26)
            storage_dead(@26)
            break 0
        }
    }
    storage_dead(@6)
    storage_dead(@5)
    @0 := copy (s@4)
    storage_dead(s@4)
    storage_dead(j@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::test_loop5
pub fn test_loop5(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let j@3: u32; // local
    let s@4: u32; // local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: (); // anonymous local
    let @10: bool; // anonymous local
    let @11: u32; // anonymous local
    let @12: u32; // anonymous local
    let @13: u32; // anonymous local
    let @14: u32; // anonymous local
    let @15: u32; // anonymous local
    let @16: (); // anonymous local
    let @17: u32; // anonymous local
    let @18: u32; // anonymous local
    let @19: u32; // anonymous local
    let @20: (); // anonymous local

    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    storage_live(i@2)
    i@2 := const (0 : u32)
    storage_live(j@3)
    j@3 := const (0 : u32)
    storage_live(s@4)
    s@4 := const (0 : u32)
    storage_live(@5)
    loop {
        storage_live(@6)
        storage_live(@7)
        @7 := copy (i@2)
        storage_live(@8)
        @8 := copy (max@1)
        @6 := move (@7) < move (@8)
        if move (@6) {
            storage_dead(@8)
            storage_dead(@7)
            storage_live(@9)
            loop {
                storage_live(@10)
                storage_live(@11)
                @11 := copy (j@3)
                storage_live(@12)
                @12 := copy (max@1)
                @10 := move (@11) < move (@12)
                if move (@10) {
                    storage_dead(@12)
                    storage_dead(@11)
                    storage_live(@13)
                    @13 := copy (j@3)
                    @14 := copy (s@4) panic.+ copy (@13)
                    s@4 := move (@14)
                    storage_dead(@13)
                    @15 := copy (j@3) panic.+ const (1 : u32)
                    j@3 := move (@15)
                    storage_dead(@10)
                    continue 0
                }
                else {
                    break 0
                }
            }
            storage_dead(@12)
            storage_dead(@11)
            storage_live(@16)
            storage_dead(@16)
            storage_dead(@10)
            storage_dead(@9)
            storage_live(@17)
            @17 := copy (i@2)
            @18 := copy (s@4) panic.+ copy (@17)
            s@4 := move (@18)
            storage_dead(@17)
            @19 := copy (i@2) panic.+ const (1 : u32)
            i@2 := move (@19)
            storage_dead(@6)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@8)
    storage_dead(@7)
    storage_live(@20)
    storage_dead(@20)
    storage_dead(@6)
    storage_dead(@5)
    @0 := copy (s@4)
    storage_dead(s@4)
    storage_dead(j@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::test_loop6
pub fn test_loop6(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: (); // anonymous local
    let @9: bool; // anonymous local
    let @10: u32; // anonymous local
    let @11: u32; // anonymous local
    let @12: u32; // anonymous local
    let @13: u32; // anonymous local
    let @14: (); // anonymous local
    let @15: u32; // anonymous local

    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(i@2)
    i@2 := const (0 : u32)
    storage_live(s@3)
    s@3 := const (0 : u32)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        @7 := copy (max@1)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@8)
            storage_live(@9)
            storage_live(@10)
            @10 := copy (i@2)
            @9 := move (@10) > const (3 : u32)
            if move (@9) {
            }
            else {
                storage_dead(@10)
                storage_dead(@9)
                storage_dead(@8)
                storage_live(@11)
                @11 := copy (i@2)
                @12 := copy (s@3) panic.+ copy (@11)
                s@3 := move (@12)
                storage_dead(@11)
                @13 := copy (i@2) panic.+ const (1 : u32)
                i@2 := move (@13)
                storage_dead(@5)
                continue 0
            }
            storage_dead(@10)
            storage_dead(@9)
            storage_dead(@8)
            break 0
        }
        else {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@14)
            storage_dead(@14)
            break 0
        }
    }
    storage_dead(@5)
    storage_dead(@4)
    // All the below nodes are exit candidates (each of them is referenced twice)
    @15 := copy (s@3) panic.+ const (1 : u32)
    s@3 := move (@15)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::test_loop7
pub fn test_loop7(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: bool; // anonymous local
    let @9: u32; // anonymous local
    let @10: u32; // anonymous local
    let @11: (); // anonymous local
    let @12: bool; // anonymous local
    let @13: u32; // anonymous local
    let @14: u32; // anonymous local
    let @15: u32; // anonymous local
    let @16: u32; // anonymous local
    let @17: (); // anonymous local
    let @18: u32; // anonymous local

    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    storage_live(@17)
    storage_live(@18)
    storage_live(i@2)
    i@2 := const (0 : u32)
    storage_live(s@3)
    s@3 := const (0 : u32)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := copy (i@2)
    storage_live(@7)
    @7 := copy (max@1)
    @5 := move (@6) < move (@7)
    if move (@5) {
        storage_dead(@7)
        storage_dead(@6)
        loop {
            storage_live(@8)
            storage_live(@9)
            @9 := copy (i@2)
            storage_live(@10)
            @10 := copy (max@1)
            @8 := move (@9) < move (@10)
            if move (@8) {
                storage_dead(@10)
                storage_dead(@9)
                storage_live(@11)
                storage_live(@12)
                storage_live(@13)
                @13 := copy (i@2)
                @12 := move (@13) > const (3 : u32)
                if move (@12) {
                }
                else {
                    storage_dead(@13)
                    storage_dead(@12)
                    storage_dead(@11)
                    storage_live(@14)
                    @14 := copy (i@2)
                    @15 := copy (s@3) panic.+ copy (@14)
                    s@3 := move (@15)
                    storage_dead(@14)
                    @16 := copy (i@2) panic.+ const (1 : u32)
                    i@2 := move (@16)
                    storage_dead(@8)
                    continue 0
                }
                storage_dead(@13)
                storage_dead(@12)
                storage_dead(@11)
                break 0
            }
            else {
                storage_dead(@10)
                storage_dead(@9)
                storage_live(@17)
                storage_dead(@17)
                break 0
            }
        }
        storage_dead(@8)
    }
    else {
        storage_dead(@7)
        storage_dead(@6)
        s@3 := const (2 : u32)
    }
    storage_dead(@5)
    storage_dead(@4)
    @18 := copy (s@3) panic.+ const (1 : u32)
    s@3 := move (@18)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::test_loops
pub fn test_loops()
{
    let @0: (); // return
    let x@1: u32; // local
    let @2: (); // anonymous local
    let @3: bool; // anonymous local
    let @4: u32; // anonymous local
    let x@5: u32; // local
    let @6: (); // anonymous local
    let @7: bool; // anonymous local
    let @8: u32; // anonymous local
    let x@9: u32; // local
    let @10: (); // anonymous local
    let @11: bool; // anonymous local
    let @12: u32; // anonymous local
    let x@13: u32; // local
    let @14: (); // anonymous local
    let @15: bool; // anonymous local
    let @16: u32; // anonymous local
    let x@17: u32; // local
    let @18: (); // anonymous local
    let @19: bool; // anonymous local
    let @20: u32; // anonymous local
    let x@21: u32; // local
    let @22: (); // anonymous local
    let @23: bool; // anonymous local
    let @24: u32; // anonymous local

    storage_live(x@1)
    x@1 := test_loop1(const (2 : u32))
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := copy (x@1)
    @3 := move (@4) == const (2 : u32)
    if move (@3) {
    }
    else {
        storage_dead(@4)
        panic(core::panicking::panic)
    }
    storage_dead(@4)
    storage_dead(@3)
    storage_dead(@2)
    storage_live(x@5)
    x@5 := test_loop2(const (2 : u32))
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (x@5)
    @7 := move (@8) == const (1 : u32)
    if move (@7) {
    }
    else {
        storage_dead(@8)
        panic(core::panicking::panic)
    }
    storage_dead(@8)
    storage_dead(@7)
    storage_dead(@6)
    storage_live(x@9)
    x@9 := test_loop3(const (2 : u32))
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := copy (x@9)
    @11 := move (@12) == const (3 : u32)
    if move (@11) {
    }
    else {
        storage_dead(@12)
        panic(core::panicking::panic)
    }
    storage_dead(@12)
    storage_dead(@11)
    storage_dead(@10)
    storage_live(x@13)
    x@13 := test_loop4(const (20 : u32))
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    @16 := copy (x@13)
    @15 := move (@16) == const (1 : u32)
    if move (@15) {
    }
    else {
        storage_dead(@16)
        panic(core::panicking::panic)
    }
    storage_dead(@16)
    storage_dead(@15)
    storage_dead(@14)
    storage_live(x@17)
    x@17 := test_loop5(const (2 : u32))
    storage_live(@18)
    storage_live(@19)
    storage_live(@20)
    @20 := copy (x@17)
    @19 := move (@20) == const (2 : u32)
    if move (@19) {
    }
    else {
        storage_dead(@20)
        panic(core::panicking::panic)
    }
    storage_dead(@20)
    storage_dead(@19)
    storage_dead(@18)
    storage_live(x@21)
    x@21 := test_loop6(const (2 : u32))
    storage_live(@22)
    storage_live(@23)
    storage_live(@24)
    @24 := copy (x@21)
    @23 := move (@24) == const (2 : u32)
    if move (@23) {
    }
    else {
        storage_dead(@24)
        panic(core::panicking::panic)
    }
    storage_dead(@24)
    storage_dead(@23)
    storage_dead(@22)
    @0 := ()
    storage_dead(x@21)
    storage_dead(x@17)
    storage_dead(x@13)
    storage_dead(x@9)
    storage_dead(x@5)
    storage_dead(x@1)
    @0 := ()
    return
}

// Full name: test_crate::nested_loops_enum
pub fn nested_loops_enum(@1: usize, @2: usize) -> usize
{
    let @0: usize; // return
    let step_out@1: usize; // arg #1
    let step_in@2: usize; // arg #2
    let s@3: usize; // local
    let @4: (); // anonymous local
    let @5: Range<i32>[Sized<i32>]; // anonymous local
    let @6: Range<i32>[Sized<i32>]; // anonymous local
    let iter@7: Range<i32>[Sized<i32>]; // local
    let @8: (); // anonymous local
    let @9: Option<i32>[Sized<i32>]; // anonymous local
    let @10: &'_ mut (Range<i32>[Sized<i32>]); // anonymous local
    let @11: &'_ mut (Range<i32>[Sized<i32>]); // anonymous local
    let @12: usize; // anonymous local
    let @13: (); // anonymous local
    let @14: Range<usize>[Sized<usize>]; // anonymous local
    let @15: Range<usize>[Sized<usize>]; // anonymous local
    let @16: usize; // anonymous local
    let iter@17: Range<usize>[Sized<usize>]; // local
    let @18: (); // anonymous local
    let @19: Option<usize>[Sized<usize>]; // anonymous local
    let @20: &'_ mut (Range<usize>[Sized<usize>]); // anonymous local
    let @21: &'_ mut (Range<usize>[Sized<usize>]); // anonymous local
    let @22: Range<usize>[Sized<usize>]; // anonymous local
    let @23: Range<usize>[Sized<usize>]; // anonymous local
    let @24: usize; // anonymous local
    let iter@25: Range<usize>[Sized<usize>]; // local
    let @26: (); // anonymous local
    let @27: Option<usize>[Sized<usize>]; // anonymous local
    let @28: &'_ mut (Range<usize>[Sized<usize>]); // anonymous local
    let @29: &'_ mut (Range<usize>[Sized<usize>]); // anonymous local
    let @30: usize; // anonymous local

    storage_live(@10)
    storage_live(@12)
    storage_live(@20)
    storage_live(@22)
    storage_live(@23)
    storage_live(@24)
    storage_live(iter@25)
    storage_live(@26)
    storage_live(@27)
    storage_live(@28)
    storage_live(@29)
    storage_live(@30)
    storage_live(s@3)
    s@3 := const (0 : usize)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := Range { start: const (0 : i32), end: const (128 : i32) }
    @5 := {impl IntoIterator for I}::into_iter<Range<i32>[Sized<i32>]>[Sized<Range<i32>[Sized<i32>]>, {impl Iterator for Range<A>[@TraitClause0]}<i32>[Sized<i32>, {impl Step for i32}]](move (@6))
    storage_dead(@6)
    storage_live(iter@7)
    iter@7 := move (@5)
    loop {
        storage_live(@8)
        storage_live(@9)
        storage_live(@10)
        storage_live(@11)
        @11 := &mut iter@7
        @10 := &two-phase-mut *(@11)
        @9 := {impl Iterator for Range<A>[@TraitClause0]}::next<'_, i32>[Sized<i32>, {impl Step for i32}](move (@10))
        storage_dead(@10)
        match @9 {
            Option::None => {
                break 0
            },
            Option::Some => {
                @12 := copy (s@3) panic.+ const (1 : usize)
                s@3 := move (@12)
                storage_dead(@11)
                storage_dead(@9)
                storage_dead(@8)
                continue 0
            },
        }
    }
    storage_dead(@11)
    storage_dead(@9)
    storage_dead(@8)
    storage_dead(iter@7)
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    @16 := copy (step_out@1)
    @15 := Range { start: const (0 : usize), end: move (@16) }
    storage_dead(@16)
    @14 := {impl IntoIterator for I}::into_iter<Range<usize>[Sized<usize>]>[Sized<Range<usize>[Sized<usize>]>, {impl Iterator for Range<A>[@TraitClause0]}<usize>[Sized<usize>, {impl Step for usize}]](move (@15))
    storage_dead(@15)
    storage_live(iter@17)
    iter@17 := move (@14)
    loop {
        storage_live(@18)
        storage_live(@19)
        storage_live(@20)
        storage_live(@21)
        @21 := &mut iter@17
        @20 := &two-phase-mut *(@21)
        @19 := {impl Iterator for Range<A>[@TraitClause0]}::next<'_, usize>[Sized<usize>, {impl Step for usize}](move (@20))
        storage_dead(@20)
        match @19 {
            Option::None => {
                break 0
            },
            Option::Some => {
                storage_live(@22)
                storage_live(@23)
                storage_live(@24)
                @24 := copy (step_in@2)
                @23 := Range { start: const (0 : usize), end: move (@24) }
                storage_dead(@24)
                @22 := {impl IntoIterator for I}::into_iter<Range<usize>[Sized<usize>]>[Sized<Range<usize>[Sized<usize>]>, {impl Iterator for Range<A>[@TraitClause0]}<usize>[Sized<usize>, {impl Step for usize}]](move (@23))
                storage_dead(@23)
                storage_live(iter@25)
                iter@25 := move (@22)
                loop {
                    storage_live(@26)
                    storage_live(@27)
                    storage_live(@28)
                    storage_live(@29)
                    @29 := &mut iter@25
                    @28 := &two-phase-mut *(@29)
                    @27 := {impl Iterator for Range<A>[@TraitClause0]}::next<'_, usize>[Sized<usize>, {impl Step for usize}](move (@28))
                    storage_dead(@28)
                    match @27 {
                        Option::None => {
                            break 0
                        },
                        Option::Some => {
                            @30 := copy (s@3) panic.+ const (1 : usize)
                            s@3 := move (@30)
                            storage_dead(@29)
                            storage_dead(@27)
                            storage_dead(@26)
                            continue 0
                        },
                    }
                }
                storage_dead(@29)
                storage_dead(@27)
                storage_dead(@26)
                storage_dead(iter@25)
                storage_dead(@22)
                storage_dead(@21)
                storage_dead(@19)
                storage_dead(@18)
                continue 0
            },
        }
    }
    storage_dead(@21)
    storage_dead(@19)
    storage_dead(@18)
    storage_dead(iter@17)
    storage_dead(@14)
    storage_dead(@13)
    @0 := copy (s@3)
    storage_dead(s@3)
    return
}

// Full name: test_crate::loop_inside_if
pub fn loop_inside_if(@1: bool, @2: u32) -> u32
{
    let @0: u32; // return
    let b@1: bool; // arg #1
    let n@2: u32; // arg #2
    let @3: bool; // anonymous local
    let s@4: u32; // local
    let @5: (); // anonymous local
    let @6: Range<u32>[Sized<u32>]; // anonymous local
    let @7: Range<u32>[Sized<u32>]; // anonymous local
    let @8: u32; // anonymous local
    let iter@9: Range<u32>[Sized<u32>]; // local
    let @10: (); // anonymous local
    let @11: Option<u32>[Sized<u32>]; // anonymous local
    let @12: &'_ mut (Range<u32>[Sized<u32>]); // anonymous local
    let @13: &'_ mut (Range<u32>[Sized<u32>]); // anonymous local
    let i@14: u32; // local
    let @15: u32; // anonymous local
    let @16: u32; // anonymous local

    storage_live(s@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(iter@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    storage_live(i@14)
    storage_live(@15)
    storage_live(@16)
    storage_live(@3)
    @3 := copy (b@1)
    if move (@3) {
        storage_live(s@4)
        s@4 := const (0 : u32)
        storage_live(@5)
        storage_live(@6)
        storage_live(@7)
        storage_live(@8)
        @8 := copy (n@2)
        @7 := Range { start: const (0 : u32), end: move (@8) }
        storage_dead(@8)
        @6 := {impl IntoIterator for I}::into_iter<Range<u32>[Sized<u32>]>[Sized<Range<u32>[Sized<u32>]>, {impl Iterator for Range<A>[@TraitClause0]}<u32>[Sized<u32>, {impl Step for u32}]](move (@7))
        storage_dead(@7)
        storage_live(iter@9)
        iter@9 := move (@6)
        loop {
            storage_live(@10)
            storage_live(@11)
            storage_live(@12)
            storage_live(@13)
            @13 := &mut iter@9
            @12 := &two-phase-mut *(@13)
            @11 := {impl Iterator for Range<A>[@TraitClause0]}::next<'_, u32>[Sized<u32>, {impl Step for u32}](move (@12))
            storage_dead(@12)
            match @11 {
                Option::None => {
                    break 0
                },
                Option::Some => {
                    storage_live(i@14)
                    i@14 := copy ((@11 as variant Option::Some).0)
                    storage_live(@15)
                    @15 := copy (i@14)
                    @16 := copy (s@4) panic.+ copy (@15)
                    s@4 := move (@16)
                    storage_dead(@15)
                    storage_dead(i@14)
                    storage_dead(@13)
                    storage_dead(@11)
                    storage_dead(@10)
                    continue 0
                },
            }
        }
        storage_dead(@13)
        storage_dead(@11)
        storage_dead(@10)
        storage_dead(iter@9)
        storage_dead(@6)
        storage_dead(@5)
        @0 := copy (s@4)
        storage_dead(s@4)
    }
    else {
        @0 := const (0 : u32)
    }
    storage_dead(@3)
    return
}

pub fn test_crate::sum(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: u32; // anonymous local
    let @11: (); // anonymous local
    let @12: u32; // anonymous local

    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@12)
    storage_live(i@2)
    i@2 := const (0 : u32)
    storage_live(s@3)
    s@3 := const (0 : u32)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        @7 := copy (max@1)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@8)
            @8 := copy (i@2)
            @9 := copy (s@3) panic.+ copy (@8)
            s@3 := move (@9)
            storage_dead(@8)
            @10 := copy (i@2) panic.+ const (1 : u32)
            i@2 := move (@10)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@11)
    storage_dead(@11)
    storage_dead(@5)
    storage_dead(@4)
    @12 := copy (s@3) panic.* const (2 : u32)
    s@3 := move (@12)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::sum_array
pub fn sum_array<const N : usize>(@1: Array<u32, const N : usize>) -> u32
{
    let @0: u32; // return
    let a@1: Array<u32, const N : usize>; // arg #1
    let i@2: usize; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: u32; // anonymous local
    let @8: usize; // anonymous local
    let @9: u32; // anonymous local
    let @10: usize; // anonymous local
    let @11: (); // anonymous local
    let @12: &'_ (Array<u32, const N : usize>); // anonymous local
    let @13: &'_ (u32); // anonymous local

    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@12)
    storage_live(@13)
    storage_live(i@2)
    i@2 := const (0 : usize)
    storage_live(s@3)
    s@3 := const (0 : u32)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        @5 := move (@6) < const (const N : usize)
        if move (@5) {
            storage_dead(@6)
            storage_live(@7)
            storage_live(@8)
            @8 := copy (i@2)
            storage_live(@12)
            @12 := &a@1
            storage_live(@13)
            @13 := @ArrayIndexShared<'_, u32, const N : usize>(move (@12), copy (@8))
            @7 := copy (*(@13))
            @9 := copy (s@3) panic.+ copy (@7)
            s@3 := move (@9)
            storage_dead(@7)
            storage_dead(@8)
            @10 := copy (i@2) panic.+ const (1 : usize)
            i@2 := move (@10)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@6)
    storage_live(@11)
    storage_dead(@11)
    storage_dead(@5)
    storage_dead(@4)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::clear
pub fn clear<'_0>(@1: &'_0 mut (Vec<u32>[Sized<u32>, Sized<Global>]))
{
    let @0: (); // return
    let v@1: &'_ mut (Vec<u32>[Sized<u32>, Sized<Global>]); // arg #1
    let i@2: usize; // local
    let @3: bool; // anonymous local
    let @4: usize; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ (Vec<u32>[Sized<u32>, Sized<Global>]); // anonymous local
    let @7: &'_ mut (u32); // anonymous local
    let @8: &'_ mut (Vec<u32>[Sized<u32>, Sized<Global>]); // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local
    let @11: (); // anonymous local

    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(i@2)
    i@2 := const (0 : usize)
    loop {
        storage_live(@3)
        storage_live(@4)
        @4 := copy (i@2)
        storage_live(@5)
        storage_live(@6)
        @6 := &*(v@1)
        @5 := alloc::vec::{Vec<T>[@TraitClause0, @TraitClause1]}::len<'_, u32, Global>[Sized<u32>, Sized<Global>](move (@6))
        storage_dead(@6)
        @3 := move (@4) < move (@5)
        if move (@3) {
        }
        else {
            break 0
        }
        storage_dead(@5)
        storage_dead(@4)
        storage_live(@7)
        storage_live(@8)
        @8 := &mut *(v@1)
        storage_live(@9)
        @9 := copy (i@2)
        @7 := {impl IndexMut<I> for Vec<T>[@TraitClause0, @TraitClause2]}::index_mut<'_, u32, usize, Global>[Sized<u32>, Sized<usize>, Sized<Global>, {impl SliceIndex<Slice<T>> for usize}<u32>[Sized<u32>]](move (@8), move (@9))
        storage_dead(@9)
        storage_dead(@8)
        *(@7) := const (0 : u32)
        storage_dead(@7)
        @10 := copy (i@2) panic.+ const (1 : usize)
        i@2 := move (@10)
        storage_dead(@3)
        continue 0
    }
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@11)
    @0 := ()
    storage_dead(@11)
    storage_dead(@3)
    storage_dead(i@2)
    @0 := ()
    return
}

// Full name: test_crate::List
pub enum List<T>
where
    [@TraitClause0]: Sized<T>,
{
  Cons(T, alloc::boxed::Box<List<T>[@TraitClause0]>[MetaSized<List<T>[@TraitClause0]>, Sized<Global>]),
  Nil,
}

// Full name: test_crate::get_elem_mut
pub fn get_elem_mut<'_0>(@1: &'_0 mut (List<usize>[Sized<usize>]), @2: usize) -> &'_0 mut (usize)
{
    let @0: &'_ mut (usize); // return
    let ls@1: &'_ mut (List<usize>[Sized<usize>]); // arg #1
    let x@2: usize; // arg #2
    let y@3: &'_ mut (usize); // local
    let tl@4: &'_ mut (alloc::boxed::Box<List<usize>[Sized<usize>]>[MetaSized<List<usize>[Sized<usize>]>, Sized<Global>]); // local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: &'_ mut (List<usize>[Sized<usize>]); // anonymous local

    storage_live(y@3)
    storage_live(tl@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    loop {
        match *(ls@1) {
            List::Cons => {
                storage_live(y@3)
                y@3 := &mut (*(ls@1) as variant List::Cons).0
                storage_live(tl@4)
                tl@4 := &mut (*(ls@1) as variant List::Cons).1
                storage_live(@5)
                storage_live(@6)
                @6 := copy (*(y@3))
                storage_live(@7)
                @7 := copy (x@2)
                @5 := move (@6) == move (@7)
                if move (@5) {
                }
                else {
                    storage_dead(@7)
                    storage_dead(@6)
                    storage_live(@8)
                    @8 := &mut *(*(tl@4))
                    ls@1 := move (@8)
                    storage_dead(@8)
                    storage_dead(@5)
                    storage_dead(tl@4)
                    storage_dead(y@3)
                    continue 0
                }
                storage_dead(@7)
                storage_dead(@6)
                @0 := &mut *(y@3)
                storage_dead(@5)
                storage_dead(tl@4)
                storage_dead(y@3)
                return
            },
            List::Nil => {
                panic(core::panicking::panic_explicit)
            },
        }
    }
}

// Full name: test_crate::list_nth_mut_loop_with_id
pub fn list_nth_mut_loop_with_id<'_0, T>(@1: &'_0 mut (List<T>[@TraitClause0]), @2: u32) -> &'_0 mut (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ mut (T); // return
    let ls@1: &'_ mut (List<T>[@TraitClause0]); // arg #1
    let i@2: u32; // arg #2
    let @3: (); // anonymous local
    let x@4: &'_ mut (T); // local
    let tl@5: &'_ mut (alloc::boxed::Box<List<T>[@TraitClause0]>[MetaSized<List<T>[@TraitClause0]>, Sized<Global>]); // local
    let @6: bool; // anonymous local
    let @7: u32; // anonymous local
    let @8: &'_ mut (List<T>[@TraitClause0]); // anonymous local
    let @9: u32; // anonymous local
    let @10: (); // anonymous local

    storage_live(x@4)
    storage_live(tl@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@3)
    loop {
        match *(ls@1) {
            List::Cons => {
                storage_live(x@4)
                x@4 := &mut (*(ls@1) as variant List::Cons).0
                storage_live(tl@5)
                tl@5 := &mut (*(ls@1) as variant List::Cons).1
                storage_live(@6)
                storage_live(@7)
                @7 := copy (i@2)
                @6 := move (@7) == const (0 : u32)
                if move (@6) {
                }
                else {
                    storage_dead(@7)
                    storage_live(@8)
                    @8 := &mut *(*(tl@5))
                    ls@1 := move (@8)
                    storage_dead(@8)
                    @9 := copy (i@2) panic.- const (1 : u32)
                    i@2 := move (@9)
                    storage_dead(@6)
                    storage_dead(tl@5)
                    storage_dead(x@4)
                    continue 0
                }
                storage_dead(@7)
                @0 := &mut *(x@4)
                storage_dead(@6)
                storage_dead(tl@5)
                storage_dead(x@4)
                storage_dead(@3)
                return
            },
            _ => {
                storage_live(@10)
                storage_dead(@10)
                storage_dead(@3)
                panic(core::panicking::panic_explicit)
            },
        }
    }
}



