# Final LLBC before serialization:

fn test_crate::test_loop1(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: (); // anonymous local
    let @11: (); // anonymous local
    let @12: (); // anonymous local

    i@2 := const (0 : u32)
    @fake_read(i@2)
    s@3 := const (0 : u32)
    @fake_read(s@3)
    loop {
        @7 := copy (i@2)
        @8 := copy (max@1)
        @6 := move (@7) < move (@8)
        if move (@6) {
            drop @8
            drop @7
            @9 := copy (i@2)
            s@3 := copy (s@3) + move (@9)
            drop @9
            i@2 := copy (i@2) + const (1 : u32)
            @11 := ()
            @5 := move (@11)
            drop @6
            continue 0
        }
        else {
            break 0
        }
    }
    drop @8
    drop @7
    @12 := ()
    @4 := move (@12)
    drop @10
    drop @6
    drop @4
    s@3 := copy (s@3) * const (2 : u32)
    @0 := copy (s@3)
    drop s@3
    drop i@2
    return
}

fn test_crate::test_loop2(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: (); // anonymous local
    let @10: bool; // anonymous local
    let @11: u32; // anonymous local
    let @12: u32; // anonymous local
    let @13: (); // anonymous local
    let @14: (); // anonymous local
    let @15: (); // anonymous local
    let @16: (); // anonymous local
    let @17: (); // anonymous local

    i@2 := const (0 : u32)
    @fake_read(i@2)
    s@3 := const (0 : u32)
    @fake_read(s@3)
    loop {
        @7 := copy (i@2)
        @8 := copy (max@1)
        @6 := move (@7) < move (@8)
        if move (@6) {
            drop @8
            drop @7
            @11 := copy (i@2)
            @10 := move (@11) == const (17 : u32)
            if move (@10) {
                drop @11
                @15 := ()
                @4 := move (@15)
                drop @10
                drop @9
                break 0
            }
            else {
                drop @11
                @16 := ()
                @9 := move (@16)
                drop @10
                drop @9
                @12 := copy (i@2)
                s@3 := copy (s@3) + move (@12)
                drop @12
                i@2 := copy (i@2) + const (1 : u32)
                @17 := ()
                @5 := move (@17)
                drop @6
                continue 0
            }
        }
        else {
            drop @8
            drop @7
            @14 := ()
            @4 := move (@14)
            drop @13
            break 0
        }
    }
    drop @6
    drop @4
    @0 := copy (s@3)
    drop s@3
    drop i@2
    return
}

fn test_crate::test_loop3(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let j@3: u32; // local
    let s@4: u32; // local
    let @5: (); // anonymous local
    let @6: (); // anonymous local
    let @7: bool; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: (); // anonymous local
    let @11: bool; // anonymous local
    let @12: u32; // anonymous local
    let @13: u32; // anonymous local
    let @14: (); // anonymous local
    let @15: bool; // anonymous local
    let @16: u32; // anonymous local
    let @17: u32; // anonymous local
    let @18: u32; // anonymous local
    let @19: u32; // anonymous local
    let @20: (); // anonymous local
    let @21: u32; // anonymous local
    let @22: (); // anonymous local
    let @23: (); // anonymous local
    let @24: (); // anonymous local
    let @25: (); // anonymous local
    let @26: (); // anonymous local

    i@2 := const (0 : u32)
    @fake_read(i@2)
    j@3 := const (0 : u32)
    @fake_read(j@3)
    s@4 := const (0 : u32)
    @fake_read(s@4)
    loop {
        @8 := copy (i@2)
        @9 := copy (max@1)
        @7 := move (@8) < move (@9)
        if move (@7) {
            drop @9
            drop @8
            loop {
                @12 := copy (j@3)
                @13 := copy (max@1)
                @11 := move (@12) < move (@13)
                if move (@11) {
                    drop @13
                    drop @12
                    @17 := copy (i@2)
                    @18 := copy (j@3)
                    @16 := move (@17) + move (@18)
                    drop @18
                    drop @17
                    @15 := move (@16) == const (17 : u32)
                    if move (@15) {
                    }
                    else {
                        drop @16
                        @26 := ()
                        @14 := move (@26)
                        drop @15
                        drop @14
                        @19 := copy (i@2)
                        s@4 := copy (s@4) + move (@19)
                        drop @19
                        j@3 := copy (j@3) + const (1 : u32)
                        drop @11
                        drop @10
                        drop @7
                        continue 1
                    }
                    drop @16
                    drop @15
                    drop @14
                    drop @11
                    continue 0
                }
                else {
                    break 0
                }
            }
            drop @13
            drop @12
            @24 := ()
            @10 := move (@24)
            drop @20
            drop @11
            drop @10
            j@3 := const (0 : u32)
            @21 := copy (i@2)
            s@4 := copy (s@4) + move (@21)
            drop @21
            i@2 := copy (i@2) + const (1 : u32)
            @25 := ()
            @6 := move (@25)
            drop @7
            continue 0
        }
        else {
            break 0
        }
    }
    drop @9
    drop @8
    @23 := ()
    @5 := move (@23)
    drop @22
    drop @7
    drop @5
    @0 := copy (s@4)
    drop s@4
    drop j@3
    drop i@2
    return
}

fn test_crate::test_loop4(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let j@3: u32; // local
    let s@4: u32; // local
    let @5: (); // anonymous local
    let @6: (); // anonymous local
    let @7: bool; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: (); // anonymous local
    let @11: bool; // anonymous local
    let @12: u32; // anonymous local
    let @13: u32; // anonymous local
    let @14: (); // anonymous local
    let @15: bool; // anonymous local
    let @16: u32; // anonymous local
    let @17: u32; // anonymous local
    let @18: u32; // anonymous local
    let @19: u32; // anonymous local
    let @20: (); // anonymous local
    let @21: u32; // anonymous local
    let @22: (); // anonymous local
    let @23: (); // anonymous local
    let @24: (); // anonymous local
    let @25: (); // anonymous local
    let @26: (); // anonymous local
    let @27: (); // anonymous local

    i@2 := const (1 : u32)
    @fake_read(i@2)
    j@3 := const (0 : u32)
    @fake_read(j@3)
    s@4 := const (0 : u32)
    @fake_read(s@4)
    loop {
        @8 := copy (i@2)
        @9 := copy (max@1)
        @7 := move (@8) < move (@9)
        if move (@7) {
            drop @9
            drop @8
            loop {
                @12 := copy (j@3)
                @13 := copy (max@1)
                @11 := move (@12) < move (@13)
                if move (@11) {
                    drop @13
                    drop @12
                    @17 := copy (i@2)
                    @18 := copy (j@3)
                    @16 := move (@17) + move (@18)
                    drop @18
                    drop @17
                    @15 := move (@16) == const (17 : u32)
                    if move (@15) {
                        drop @16
                        drop @15
                        drop @14
                        drop @11
                        continue 0
                    }
                    else {
                        drop @16
                        @26 := ()
                        @14 := move (@26)
                        drop @15
                        drop @14
                        @19 := copy (i@2)
                        s@4 := copy (s@4) + move (@19)
                        drop @19
                        j@3 := copy (j@3) + const (1 : u32)
                        @27 := ()
                        @5 := move (@27)
                        drop @11
                        drop @10
                        break 1
                    }
                }
                else {
                    break 0
                }
            }
            drop @13
            drop @12
            @24 := ()
            @10 := move (@24)
            drop @20
            drop @11
            drop @10
            j@3 := const (0 : u32)
            @21 := copy (i@2)
            s@4 := copy (s@4) + move (@21)
            drop @21
            i@2 := copy (i@2) + const (1 : u32)
            @25 := ()
            @6 := move (@25)
            drop @7
            continue 0
        }
        else {
            drop @9
            drop @8
            @23 := ()
            @5 := move (@23)
            drop @22
            break 0
        }
    }
    drop @7
    drop @5
    @0 := copy (s@4)
    drop s@4
    drop j@3
    drop i@2
    return
}

fn test_crate::test_loop5(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let j@3: u32; // local
    let s@4: u32; // local
    let @5: (); // anonymous local
    let @6: (); // anonymous local
    let @7: bool; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: (); // anonymous local
    let @11: bool; // anonymous local
    let @12: u32; // anonymous local
    let @13: u32; // anonymous local
    let @14: u32; // anonymous local
    let @15: (); // anonymous local
    let @16: u32; // anonymous local
    let @17: (); // anonymous local
    let @18: (); // anonymous local
    let @19: (); // anonymous local
    let @20: (); // anonymous local
    let @21: (); // anonymous local

    i@2 := const (0 : u32)
    @fake_read(i@2)
    j@3 := const (0 : u32)
    @fake_read(j@3)
    s@4 := const (0 : u32)
    @fake_read(s@4)
    loop {
        @8 := copy (i@2)
        @9 := copy (max@1)
        @7 := move (@8) < move (@9)
        if move (@7) {
            drop @9
            drop @8
            loop {
                @12 := copy (j@3)
                @13 := copy (max@1)
                @11 := move (@12) < move (@13)
                if move (@11) {
                    drop @13
                    drop @12
                    @14 := copy (j@3)
                    s@4 := copy (s@4) + move (@14)
                    drop @14
                    j@3 := copy (j@3) + const (1 : u32)
                    @19 := ()
                    @6 := move (@19)
                    drop @11
                    continue 0
                }
                else {
                    break 0
                }
            }
            drop @13
            drop @12
            @20 := ()
            @10 := move (@20)
            drop @15
            drop @11
            drop @10
            @16 := copy (i@2)
            s@4 := copy (s@4) + move (@16)
            drop @16
            i@2 := copy (i@2) + const (1 : u32)
            @21 := ()
            @6 := move (@21)
            drop @7
            continue 0
        }
        else {
            break 0
        }
    }
    drop @9
    drop @8
    @18 := ()
    @5 := move (@18)
    drop @17
    drop @7
    drop @5
    @0 := copy (s@4)
    drop s@4
    drop j@3
    drop i@2
    return
}

fn test_crate::test_loop6(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: (); // anonymous local
    let @10: bool; // anonymous local
    let @11: u32; // anonymous local
    let @12: u32; // anonymous local
    let @13: (); // anonymous local
    let @14: (); // anonymous local
    let @15: (); // anonymous local
    let @16: (); // anonymous local
    let @17: (); // anonymous local

    i@2 := const (0 : u32)
    @fake_read(i@2)
    s@3 := const (0 : u32)
    @fake_read(s@3)
    loop {
        @7 := copy (i@2)
        @8 := copy (max@1)
        @6 := move (@7) < move (@8)
        if move (@6) {
            drop @8
            drop @7
            @11 := copy (i@2)
            @10 := move (@11) > const (3 : u32)
            if move (@10) {
                drop @11
                @15 := ()
                @4 := move (@15)
                drop @10
                drop @9
                break 0
            }
            else {
                drop @11
                @16 := ()
                @9 := move (@16)
                drop @10
                drop @9
                @12 := copy (i@2)
                s@3 := copy (s@3) + move (@12)
                drop @12
                i@2 := copy (i@2) + const (1 : u32)
                @17 := ()
                @5 := move (@17)
                drop @6
                continue 0
            }
        }
        else {
            drop @8
            drop @7
            @14 := ()
            @4 := move (@14)
            drop @13
            break 0
        }
    }
    drop @6
    drop @4
    // All the below nodes are exit candidates (each of them is referenced twice)
    s@3 := copy (s@3) + const (1 : u32)
    @0 := copy (s@3)
    drop s@3
    drop i@2
    return
}

fn test_crate::test_loop7(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: (); // anonymous local
    let @9: bool; // anonymous local
    let @10: u32; // anonymous local
    let @11: u32; // anonymous local
    let @12: (); // anonymous local
    let @13: bool; // anonymous local
    let @14: u32; // anonymous local
    let @15: u32; // anonymous local
    let @16: (); // anonymous local
    let @17: (); // anonymous local
    let @18: (); // anonymous local
    let @19: (); // anonymous local
    let @20: (); // anonymous local
    let @21: (); // anonymous local

    i@2 := const (0 : u32)
    @fake_read(i@2)
    s@3 := const (0 : u32)
    @fake_read(s@3)
    @6 := copy (i@2)
    @7 := copy (max@1)
    @5 := move (@6) < move (@7)
    if move (@5) {
        drop @7
        drop @6
        loop {
            @10 := copy (i@2)
            @11 := copy (max@1)
            @9 := move (@10) < move (@11)
            if move (@9) {
                drop @11
                drop @10
                @14 := copy (i@2)
                @13 := move (@14) > const (3 : u32)
                if move (@13) {
                    drop @14
                    @19 := ()
                    @4 := move (@19)
                    drop @13
                    drop @12
                    break 0
                }
                else {
                    drop @14
                    @20 := ()
                    @12 := move (@20)
                    drop @13
                    drop @12
                    @15 := copy (i@2)
                    s@3 := copy (s@3) + move (@15)
                    drop @15
                    i@2 := copy (i@2) + const (1 : u32)
                    @21 := ()
                    @8 := move (@21)
                    drop @9
                    continue 0
                }
            }
            else {
                drop @11
                drop @10
                @18 := ()
                @4 := move (@18)
                drop @16
                break 0
            }
        }
        drop @9
    }
    else {
        drop @7
        drop @6
        s@3 := const (2 : u32)
        @17 := ()
        @4 := move (@17)
    }
    drop @5
    drop @4
    s@3 := copy (s@3) + const (1 : u32)
    @0 := copy (s@3)
    drop s@3
    drop i@2
    return
}

fn test_crate::test_loops()
{
    let @0: (); // return
    let x@1: u32; // local
    let @2: (); // anonymous local
    let @3: bool; // anonymous local
    let @4: u32; // anonymous local
    let x@5: u32; // local
    let @6: (); // anonymous local
    let @7: bool; // anonymous local
    let @8: u32; // anonymous local
    let x@9: u32; // local
    let @10: (); // anonymous local
    let @11: bool; // anonymous local
    let @12: u32; // anonymous local
    let x@13: u32; // local
    let @14: (); // anonymous local
    let @15: bool; // anonymous local
    let @16: u32; // anonymous local
    let x@17: u32; // local
    let @18: (); // anonymous local
    let @19: bool; // anonymous local
    let @20: u32; // anonymous local
    let x@21: u32; // local
    let @22: (); // anonymous local
    let @23: bool; // anonymous local
    let @24: u32; // anonymous local
    let @25: (); // anonymous local
    let @26: (); // anonymous local
    let @27: (); // anonymous local
    let @28: (); // anonymous local
    let @29: (); // anonymous local
    let @30: (); // anonymous local
    let @31: (); // anonymous local

    x@1 := test_crate::test_loop1(const (2 : u32))
    @fake_read(x@1)
    @4 := copy (x@1)
    @3 := move (@4) == const (2 : u32)
    if move (@3) {
    }
    else {
        drop @4
        panic(core::panicking::panic)
    }
    drop @4
    @25 := ()
    @2 := move (@25)
    drop @3
    drop @2
    x@5 := test_crate::test_loop2(const (2 : u32))
    @fake_read(x@5)
    @8 := copy (x@5)
    @7 := move (@8) == const (1 : u32)
    if move (@7) {
    }
    else {
        drop @8
        panic(core::panicking::panic)
    }
    drop @8
    @26 := ()
    @6 := move (@26)
    drop @7
    drop @6
    x@9 := test_crate::test_loop3(const (2 : u32))
    @fake_read(x@9)
    @12 := copy (x@9)
    @11 := move (@12) == const (3 : u32)
    if move (@11) {
    }
    else {
        drop @12
        panic(core::panicking::panic)
    }
    drop @12
    @27 := ()
    @10 := move (@27)
    drop @11
    drop @10
    x@13 := test_crate::test_loop4(const (20 : u32))
    @fake_read(x@13)
    @16 := copy (x@13)
    @15 := move (@16) == const (1 : u32)
    if move (@15) {
    }
    else {
        drop @16
        panic(core::panicking::panic)
    }
    drop @16
    @28 := ()
    @14 := move (@28)
    drop @15
    drop @14
    x@17 := test_crate::test_loop5(const (2 : u32))
    @fake_read(x@17)
    @20 := copy (x@17)
    @19 := move (@20) == const (2 : u32)
    if move (@19) {
    }
    else {
        drop @20
        panic(core::panicking::panic)
    }
    drop @20
    @29 := ()
    @18 := move (@29)
    drop @19
    drop @18
    x@21 := test_crate::test_loop6(const (2 : u32))
    @fake_read(x@21)
    @24 := copy (x@21)
    @23 := move (@24) == const (2 : u32)
    if move (@23) {
    }
    else {
        drop @24
        panic(core::panicking::panic)
    }
    drop @24
    @30 := ()
    @22 := move (@30)
    drop @23
    drop @22
    @31 := ()
    @0 := move (@31)
    drop x@21
    drop x@17
    drop x@13
    drop x@9
    drop x@5
    drop x@1
    @0 := ()
    return
}

trait core::marker::Sized<Self>

struct core::ops::range::Range<Idx>
  where
      [@TraitClause0]: core::marker::Sized<Idx>,
 =
{
  start: Idx,
  end: Idx,
}

enum core::option::Option<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,
 =
|  None()
|  Some(T)


enum core::result::Result<T, E>
  where
      [@TraitClause0]: core::marker::Sized<T>,
      [@TraitClause1]: core::marker::Sized<E>,
 =
|  Ok(T)
|  Err(E)


opaque type core::array::iter::IntoIter<T, const N : usize>
  where
      [@TraitClause0]: core::marker::Sized<T>,

trait core::clone::Clone<Self>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self>
    fn clone : core::clone::Clone::clone
    fn clone_from : core::clone::Clone::clone_from
}

trait core::marker::Copy<Self>
{
    parent_clause_0 : [@TraitClause0]: core::clone::Clone<Self>
}

trait core::num::nonzero::private::Sealed<Self>

trait core::num::nonzero::ZeroablePrimitive<Self>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self>
    parent_clause_1 : [@TraitClause1]: core::marker::Copy<Self>
    parent_clause_2 : [@TraitClause2]: core::num::nonzero::private::Sealed<Self>
    parent_clause_3 : [@TraitClause3]: core::marker::Copy<Self::NonZeroInner>
    parent_clause_4 : [@TraitClause4]: core::clone::Clone<Self::NonZeroInner>
    parent_clause_5 : [@TraitClause5]: core::marker::Sized<Self::NonZeroInner>
    type NonZeroInner
}

opaque type core::num::nonzero::NonZero<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,
      [@TraitClause1]: core::num::nonzero::ZeroablePrimitive<T>,

fn core::clone::impls::{impl core::clone::Clone for usize}#5::clone<'_0>(@1: &'_0 (usize)) -> usize

impl core::clone::impls::{impl core::clone::Clone for usize}#5 : core::clone::Clone<usize>
{
    parent_clause0 = core::marker::Sized<usize>
    fn clone = core::clone::impls::{impl core::clone::Clone for usize}#5::clone
}

impl core::marker::{impl core::marker::Copy for usize}#37 : core::marker::Copy<usize>
{
    parent_clause0 = core::clone::impls::{impl core::clone::Clone for usize}#5
}

impl core::num::nonzero::{impl core::num::nonzero::private::Sealed for usize}#25 : core::num::nonzero::private::Sealed<usize>

opaque type core::num::nonzero::private::NonZeroUsizeInner

fn core::num::nonzero::private::{impl core::clone::Clone for core::num::nonzero::private::NonZeroUsizeInner}#26::clone<'_0>(@1: &'_0 (core::num::nonzero::private::NonZeroUsizeInner)) -> core::num::nonzero::private::NonZeroUsizeInner

impl core::num::nonzero::private::{impl core::clone::Clone for core::num::nonzero::private::NonZeroUsizeInner}#26 : core::clone::Clone<core::num::nonzero::private::NonZeroUsizeInner>
{
    parent_clause0 = core::marker::Sized<core::num::nonzero::private::NonZeroUsizeInner>
    fn clone = core::num::nonzero::private::{impl core::clone::Clone for core::num::nonzero::private::NonZeroUsizeInner}#26::clone
}

impl core::num::nonzero::private::{impl core::marker::Copy for core::num::nonzero::private::NonZeroUsizeInner}#27 : core::marker::Copy<core::num::nonzero::private::NonZeroUsizeInner>
{
    parent_clause0 = core::num::nonzero::private::{impl core::clone::Clone for core::num::nonzero::private::NonZeroUsizeInner}#26
}

impl core::num::nonzero::{impl core::num::nonzero::ZeroablePrimitive for usize}#26 : core::num::nonzero::ZeroablePrimitive<usize>
{
    parent_clause0 = core::marker::Sized<usize>
    parent_clause1 = core::marker::{impl core::marker::Copy for usize}#37
    parent_clause2 = core::num::nonzero::{impl core::num::nonzero::private::Sealed for usize}#25
    parent_clause3 = core::num::nonzero::private::{impl core::marker::Copy for core::num::nonzero::private::NonZeroUsizeInner}#27
    parent_clause4 = core::num::nonzero::private::{impl core::clone::Clone for core::num::nonzero::private::NonZeroUsizeInner}#26
    parent_clause5 = core::marker::Sized<core::num::nonzero::private::NonZeroUsizeInner>
    type NonZeroInner = core::num::nonzero::private::NonZeroUsizeInner
}

opaque type core::iter::adapters::step_by::StepBy<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,

opaque type core::iter::adapters::chain::Chain<A, B>
  where
      [@TraitClause0]: core::marker::Sized<A>,
      [@TraitClause1]: core::marker::Sized<B>,

opaque type core::iter::adapters::zip::Zip<A, B>
  where
      [@TraitClause0]: core::marker::Sized<A>,
      [@TraitClause1]: core::marker::Sized<B>,

trait core::marker::Tuple<Self>

trait core::ops::function::FnOnce<Self, Args>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Args>
    parent_clause_1 : [@TraitClause1]: core::marker::Tuple<Args>
    parent_clause_2 : [@TraitClause2]: core::marker::Sized<Self::Output>
    type Output
    fn call_once : core::ops::function::FnOnce::call_once
}

trait core::ops::function::FnMut<Self, Args>
{
    parent_clause_0 : [@TraitClause0]: core::ops::function::FnOnce<Self, Args>
    parent_clause_1 : [@TraitClause1]: core::marker::Sized<Args>
    parent_clause_2 : [@TraitClause2]: core::marker::Tuple<Args>
    fn call_mut : core::ops::function::FnMut::call_mut
}

opaque type core::iter::adapters::map::Map<I, F>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<F>,

opaque type core::iter::adapters::filter::Filter<I, P>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<P>,

opaque type core::iter::adapters::filter_map::FilterMap<I, F>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<F>,

opaque type core::iter::adapters::enumerate::Enumerate<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,

opaque type core::iter::adapters::skip_while::SkipWhile<I, P>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<P>,

opaque type core::iter::adapters::take_while::TakeWhile<I, P>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<P>,

opaque type core::iter::adapters::map_while::MapWhile<I, P>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<P>,

opaque type core::iter::adapters::skip::Skip<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,

opaque type core::iter::adapters::take::Take<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,

opaque type core::iter::adapters::scan::Scan<I, St, F>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<St>,
      [@TraitClause2]: core::marker::Sized<F>,

opaque type core::iter::adapters::fuse::Fuse<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,

opaque type core::iter::adapters::inspect::Inspect<I, F>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<F>,

trait core::ops::try_trait::FromResidual<Self, R>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<R>
    fn from_residual : core::ops::try_trait::FromResidual::from_residual
}

enum core::ops::control_flow::ControlFlow<B, C>
  where
      [@TraitClause0]: core::marker::Sized<B>,
      [@TraitClause1]: core::marker::Sized<C>,
 =
|  Continue(C)
|  Break(B)


trait core::ops::try_trait::Try<Self>
{
    parent_clause_0 : [@TraitClause0]: core::ops::try_trait::FromResidual<Self, Self::Residual>
    parent_clause_1 : [@TraitClause1]: core::marker::Sized<Self::Output>
    parent_clause_2 : [@TraitClause2]: core::marker::Sized<Self::Residual>
    type Output
    type Residual
    fn from_output : core::ops::try_trait::Try::from_output
    fn branch : core::ops::try_trait::Try::branch
}

trait core::ops::try_trait::Residual<Self, O>
where
    (parents(Self)::[@TraitClause1])::Residual = Self,
    (parents(Self)::[@TraitClause1])::Output = O,
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<O>
    parent_clause_1 : [@TraitClause1]: core::ops::try_trait::Try<Self::TryType>
    parent_clause_2 : [@TraitClause2]: core::ops::try_trait::FromResidual<Self::TryType, Self>
    parent_clause_3 : [@TraitClause3]: core::marker::Sized<Self::TryType>
    type TryType
}

trait core::default::Default<Self>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self>
    fn default : core::default::Default::default
}

trait core::cmp::PartialEq<Self, Rhs>
{
    fn eq : core::cmp::PartialEq::eq
    fn ne : core::cmp::PartialEq::ne
}

trait core::cmp::Eq<Self>
{
    parent_clause_0 : [@TraitClause0]: core::cmp::PartialEq<Self, Self>
    fn assert_receiver_is_total_eq : core::cmp::Eq::assert_receiver_is_total_eq
}

enum core::cmp::Ordering =
|  Less()
|  Equal()
|  Greater()


trait core::cmp::PartialOrd<Self, Rhs>
{
    parent_clause_0 : [@TraitClause0]: core::cmp::PartialEq<Self, Rhs>
    fn partial_cmp : core::cmp::PartialOrd::partial_cmp
    fn lt : core::cmp::PartialOrd::lt
    fn le : core::cmp::PartialOrd::le
    fn gt : core::cmp::PartialOrd::gt
    fn ge : core::cmp::PartialOrd::ge
}

trait core::cmp::Ord<Self>
{
    parent_clause_0 : [@TraitClause0]: core::cmp::Eq<Self>
    parent_clause_1 : [@TraitClause1]: core::cmp::PartialOrd<Self, Self>
    fn cmp : core::cmp::Ord::cmp
    fn max : core::cmp::Ord::max
    fn min : core::cmp::Ord::min
    fn clamp : core::cmp::Ord::clamp
}

opaque type core::iter::adapters::rev::Rev<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,

opaque type core::iter::adapters::copied::Copied<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,

opaque type core::iter::adapters::cloned::Cloned<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,

opaque type core::iter::adapters::cycle::Cycle<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,

trait core::iter::traits::iterator::Iterator<Self>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self::Item>
    type Item
    fn next : core::iter::traits::iterator::Iterator::next
    fn next_chunk : core::iter::traits::iterator::Iterator::next_chunk
    fn size_hint : core::iter::traits::iterator::Iterator::size_hint
    fn count : core::iter::traits::iterator::Iterator::count
    fn last : core::iter::traits::iterator::Iterator::last
    fn advance_by : core::iter::traits::iterator::Iterator::advance_by
    fn nth : core::iter::traits::iterator::Iterator::nth
    fn step_by : core::iter::traits::iterator::Iterator::step_by
    fn chain : core::iter::traits::iterator::Iterator::chain
    fn zip : core::iter::traits::iterator::Iterator::zip
    fn intersperse : core::iter::traits::iterator::Iterator::intersperse
    fn intersperse_with : core::iter::traits::iterator::Iterator::intersperse_with
    fn map : core::iter::traits::iterator::Iterator::map
    fn for_each : core::iter::traits::iterator::Iterator::for_each
    fn filter : core::iter::traits::iterator::Iterator::filter
    fn filter_map : core::iter::traits::iterator::Iterator::filter_map
    fn enumerate : core::iter::traits::iterator::Iterator::enumerate
    fn peekable : core::iter::traits::iterator::Iterator::peekable
    fn skip_while : core::iter::traits::iterator::Iterator::skip_while
    fn take_while : core::iter::traits::iterator::Iterator::take_while
    fn map_while : core::iter::traits::iterator::Iterator::map_while
    fn skip : core::iter::traits::iterator::Iterator::skip
    fn take : core::iter::traits::iterator::Iterator::take
    fn scan : core::iter::traits::iterator::Iterator::scan
    fn flat_map : core::iter::traits::iterator::Iterator::flat_map
    fn flatten : core::iter::traits::iterator::Iterator::flatten
    fn map_windows : core::iter::traits::iterator::Iterator::map_windows
    fn fuse : core::iter::traits::iterator::Iterator::fuse
    fn inspect : core::iter::traits::iterator::Iterator::inspect
    fn by_ref : core::iter::traits::iterator::Iterator::by_ref
    fn collect : core::iter::traits::iterator::Iterator::collect
    fn try_collect : core::iter::traits::iterator::Iterator::try_collect
    fn collect_into : core::iter::traits::iterator::Iterator::collect_into
    fn partition : core::iter::traits::iterator::Iterator::partition
    fn partition_in_place : core::iter::traits::iterator::Iterator::partition_in_place
    fn is_partitioned : core::iter::traits::iterator::Iterator::is_partitioned
    fn try_fold : core::iter::traits::iterator::Iterator::try_fold
    fn try_for_each : core::iter::traits::iterator::Iterator::try_for_each
    fn fold : core::iter::traits::iterator::Iterator::fold
    fn reduce : core::iter::traits::iterator::Iterator::reduce
    fn try_reduce : core::iter::traits::iterator::Iterator::try_reduce
    fn all : core::iter::traits::iterator::Iterator::all
    fn any : core::iter::traits::iterator::Iterator::any
    fn find : core::iter::traits::iterator::Iterator::find
    fn find_map : core::iter::traits::iterator::Iterator::find_map
    fn try_find : core::iter::traits::iterator::Iterator::try_find
    fn position : core::iter::traits::iterator::Iterator::position
    fn rposition : core::iter::traits::iterator::Iterator::rposition
    fn max : core::iter::traits::iterator::Iterator::max
    fn min : core::iter::traits::iterator::Iterator::min
    fn max_by_key : core::iter::traits::iterator::Iterator::max_by_key
    fn max_by : core::iter::traits::iterator::Iterator::max_by
    fn min_by_key : core::iter::traits::iterator::Iterator::min_by_key
    fn min_by : core::iter::traits::iterator::Iterator::min_by
    fn rev : core::iter::traits::iterator::Iterator::rev
    fn unzip : core::iter::traits::iterator::Iterator::unzip
    fn copied : core::iter::traits::iterator::Iterator::copied
    fn cloned : core::iter::traits::iterator::Iterator::cloned
    fn cycle : core::iter::traits::iterator::Iterator::cycle
    fn array_chunks : core::iter::traits::iterator::Iterator::array_chunks
    fn sum : core::iter::traits::iterator::Iterator::sum
    fn product : core::iter::traits::iterator::Iterator::product
    fn cmp : core::iter::traits::iterator::Iterator::cmp
    fn cmp_by : core::iter::traits::iterator::Iterator::cmp_by
    fn partial_cmp : core::iter::traits::iterator::Iterator::partial_cmp
    fn partial_cmp_by : core::iter::traits::iterator::Iterator::partial_cmp_by
    fn eq : core::iter::traits::iterator::Iterator::eq
    fn eq_by : core::iter::traits::iterator::Iterator::eq_by
    fn ne : core::iter::traits::iterator::Iterator::ne
    fn lt : core::iter::traits::iterator::Iterator::lt
    fn le : core::iter::traits::iterator::Iterator::le
    fn gt : core::iter::traits::iterator::Iterator::gt
    fn ge : core::iter::traits::iterator::Iterator::ge
    fn is_sorted : core::iter::traits::iterator::Iterator::is_sorted
    fn is_sorted_by : core::iter::traits::iterator::Iterator::is_sorted_by
    fn is_sorted_by_key : core::iter::traits::iterator::Iterator::is_sorted_by_key
    fn __iterator_get_unchecked : core::iter::traits::iterator::Iterator::__iterator_get_unchecked
}

trait core::iter::traits::collect::IntoIterator<Self>
where
    (parents(Self)::[@TraitClause1])::Item = Self::Item,
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self::Item>
    parent_clause_1 : [@TraitClause1]: core::iter::traits::iterator::Iterator<Self::IntoIter>
    parent_clause_2 : [@TraitClause2]: core::marker::Sized<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter : core::iter::traits::collect::IntoIterator::into_iter
}

opaque type core::iter::adapters::intersperse::Intersperse<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::iter::traits::iterator::Iterator<I>,
      [@TraitClause2]: core::clone::Clone<@TraitClause1::Item>,

opaque type core::iter::adapters::intersperse::IntersperseWith<I, G>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<G>,
      [@TraitClause2]: core::iter::traits::iterator::Iterator<I>,

opaque type core::iter::adapters::peekable::Peekable<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::iter::traits::iterator::Iterator<I>,

opaque type core::iter::adapters::flatten::FlatMap<I, U, F>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<U>,
      [@TraitClause2]: core::marker::Sized<F>,
      [@TraitClause3]: core::iter::traits::collect::IntoIterator<U>,

opaque type core::iter::adapters::flatten::Flatten<I>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::iter::traits::iterator::Iterator<I>,
      [@TraitClause2]: core::iter::traits::collect::IntoIterator<@TraitClause1::Item>,

opaque type core::iter::adapters::map_windows::MapWindows<I, F, const N : usize>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::marker::Sized<F>,
      [@TraitClause2]: core::iter::traits::iterator::Iterator<I>,

trait core::iter::traits::collect::FromIterator<Self, A>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self>
    parent_clause_1 : [@TraitClause1]: core::marker::Sized<A>
    fn from_iter : core::iter::traits::collect::FromIterator::from_iter
}

trait core::iter::traits::collect::Extend<Self, A>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<A>
    fn extend : core::iter::traits::collect::Extend::extend
    fn extend_one : core::iter::traits::collect::Extend::extend_one
    fn extend_reserve : core::iter::traits::collect::Extend::extend_reserve
    fn extend_one_unchecked : core::iter::traits::collect::Extend::extend_one_unchecked
}

trait core::iter::traits::double_ended::DoubleEndedIterator<Self>
{
    parent_clause_0 : [@TraitClause0]: core::iter::traits::iterator::Iterator<Self>
    fn next_back : core::iter::traits::double_ended::DoubleEndedIterator::next_back
    fn advance_back_by : core::iter::traits::double_ended::DoubleEndedIterator::advance_back_by
    fn nth_back : core::iter::traits::double_ended::DoubleEndedIterator::nth_back
    fn try_rfold : core::iter::traits::double_ended::DoubleEndedIterator::try_rfold
    fn rfold : core::iter::traits::double_ended::DoubleEndedIterator::rfold
    fn rfind : core::iter::traits::double_ended::DoubleEndedIterator::rfind
}

trait core::iter::traits::exact_size::ExactSizeIterator<Self>
{
    parent_clause_0 : [@TraitClause0]: core::iter::traits::iterator::Iterator<Self>
    fn len : core::iter::traits::exact_size::ExactSizeIterator::len
    fn is_empty : core::iter::traits::exact_size::ExactSizeIterator::is_empty
}

opaque type core::iter::adapters::array_chunks::ArrayChunks<I, const N : usize>
  where
      [@TraitClause0]: core::marker::Sized<I>,
      [@TraitClause1]: core::iter::traits::iterator::Iterator<I>,

trait core::iter::traits::accum::Sum<Self, A>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self>
    parent_clause_1 : [@TraitClause1]: core::marker::Sized<A>
    fn sum : core::iter::traits::accum::Sum::sum
}

trait core::iter::traits::accum::Product<Self, A>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self>
    parent_clause_1 : [@TraitClause1]: core::marker::Sized<A>
    fn product : core::iter::traits::accum::Product::product
}

trait core::iter::adapters::zip::TrustedRandomAccessNoCoerce<Self>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self>
    const MAY_HAVE_SIDE_EFFECT : bool
    fn size : core::iter::adapters::zip::TrustedRandomAccessNoCoerce::size
}

fn core::iter::traits::collect::{impl core::iter::traits::collect::IntoIterator for I}#1::into_iter<I>(@1: I) -> I
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::iterator::Iterator<I>,

impl<I> core::iter::traits::collect::{impl core::iter::traits::collect::IntoIterator for I}#1<I> : core::iter::traits::collect::IntoIterator<I>
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::iterator::Iterator<I>,
{
    parent_clause0 = (parents(@TraitClause1)::[@TraitClause0])
    parent_clause1 = @TraitClause1
    parent_clause2 = @TraitClause0
    type Item = @TraitClause1::Item
    type IntoIter = I
    fn into_iter = core::iter::traits::collect::{impl core::iter::traits::collect::IntoIterator for I}#1::into_iter
}

trait core::iter::range::Step<Self>
{
    parent_clause_0 : [@TraitClause0]: core::marker::Sized<Self>
    parent_clause_1 : [@TraitClause1]: core::clone::Clone<Self>
    parent_clause_2 : [@TraitClause2]: core::cmp::PartialOrd<Self, Self>
    fn steps_between : core::iter::range::Step::steps_between
    fn forward_checked : core::iter::range::Step::forward_checked
    fn backward_checked : core::iter::range::Step::backward_checked
    fn forward : core::iter::range::Step::forward
    fn forward_unchecked : core::iter::range::Step::forward_unchecked
    fn backward : core::iter::range::Step::backward
    fn backward_unchecked : core::iter::range::Step::backward_unchecked
}

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::next<'_0, A>(@1: &'_0 mut (core::ops::range::Range<A, @TraitClause0>)) -> core::option::Option<A, @TraitClause0>
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::size_hint<'_0, A>(@1: &'_0 (core::ops::range::Range<A, @TraitClause0>)) -> (usize, core::option::Option<usize, core::marker::Sized<usize>>)
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::count<A>(@1: core::ops::range::Range<A, @TraitClause0>) -> usize
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::last<A>(@1: core::ops::range::Range<A, @TraitClause0>) -> core::option::Option<A, @TraitClause0>
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::advance_by<'_0, A>(@1: &'_0 mut (core::ops::range::Range<A, @TraitClause0>), @2: usize) -> core::result::Result<(), core::num::nonzero::NonZero<usize, core::marker::Sized<usize>, core::num::nonzero::{impl core::num::nonzero::ZeroablePrimitive for usize}#26>, core::marker::Sized<()>, core::marker::Sized<core::num::nonzero::NonZero<usize, core::marker::Sized<usize>, core::num::nonzero::{impl core::num::nonzero::ZeroablePrimitive for usize}#26>>>
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::nth<'_0, A>(@1: &'_0 mut (core::ops::range::Range<A, @TraitClause0>), @2: usize) -> core::option::Option<A, @TraitClause0>
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::max<A>(@1: core::ops::range::Range<A, @TraitClause0>) -> core::option::Option<A, @TraitClause0>
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,
    // Local clauses:
    [@TraitClause2]: core::cmp::Ord<A>,

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::min<A>(@1: core::ops::range::Range<A, @TraitClause0>) -> core::option::Option<A, @TraitClause0>
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,
    // Local clauses:
    [@TraitClause2]: core::cmp::Ord<A>,

fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::is_sorted<A>(@1: core::ops::range::Range<A, @TraitClause0>) -> bool
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,

unsafe fn core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::__iterator_get_unchecked<'_0, A>(@1: &'_0 mut (core::ops::range::Range<A, @TraitClause0>), @2: usize) -> core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<A>[@TraitClause0, @TraitClause1]::Item
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,
    // Local clauses:
    [@TraitClause2]: core::iter::adapters::zip::TrustedRandomAccessNoCoerce<core::ops::range::Range<A, @TraitClause0>>,

impl<A> core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<A> : core::iter::traits::iterator::Iterator<core::ops::range::Range<A, @TraitClause0>>
where
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::iter::range::Step<A>,
{
    parent_clause0 = @TraitClause0
    type Item = A
    fn next = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::next
    fn size_hint = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::size_hint
    fn count = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::count
    fn last = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::last
    fn advance_by = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::advance_by
    fn nth = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::nth
    fn max = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::max
    fn min = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::min
    fn is_sorted = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::is_sorted
    fn __iterator_get_unchecked = core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6::__iterator_get_unchecked
}

fn core::clone::impls::{impl core::clone::Clone for i32}#14::clone<'_0>(@1: &'_0 (i32)) -> i32

impl core::clone::impls::{impl core::clone::Clone for i32}#14 : core::clone::Clone<i32>
{
    parent_clause0 = core::marker::Sized<i32>
    fn clone = core::clone::impls::{impl core::clone::Clone for i32}#14::clone
}

fn core::cmp::impls::{impl core::cmp::PartialEq<i32> for i32}#30::eq<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialEq<i32> for i32}#30::ne<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> bool

impl core::cmp::impls::{impl core::cmp::PartialEq<i32> for i32}#30 : core::cmp::PartialEq<i32, i32>
{
    fn eq = core::cmp::impls::{impl core::cmp::PartialEq<i32> for i32}#30::eq
    fn ne = core::cmp::impls::{impl core::cmp::PartialEq<i32> for i32}#30::ne
}

fn core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::partial_cmp<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> core::option::Option<core::cmp::Ordering, core::marker::Sized<core::cmp::Ordering>>

fn core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::lt<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::le<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::gt<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::ge<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> bool

impl core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76 : core::cmp::PartialOrd<i32, i32>
{
    parent_clause0 = core::cmp::impls::{impl core::cmp::PartialEq<i32> for i32}#30
    fn partial_cmp = core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::partial_cmp
    fn lt = core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::lt
    fn le = core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::le
    fn gt = core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::gt
    fn ge = core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76::ge
}

fn core::iter::range::{impl core::iter::range::Step for i32}#40::steps_between<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> core::option::Option<usize, core::marker::Sized<usize>>

fn core::iter::range::{impl core::iter::range::Step for i32}#40::forward_checked(@1: i32, @2: usize) -> core::option::Option<i32, core::marker::Sized<i32>>

fn core::iter::range::{impl core::iter::range::Step for i32}#40::backward_checked(@1: i32, @2: usize) -> core::option::Option<i32, core::marker::Sized<i32>>

fn core::iter::range::{impl core::iter::range::Step for i32}#40::forward(@1: i32, @2: usize) -> i32

unsafe fn core::iter::range::{impl core::iter::range::Step for i32}#40::forward_unchecked(@1: i32, @2: usize) -> i32

fn core::iter::range::{impl core::iter::range::Step for i32}#40::backward(@1: i32, @2: usize) -> i32

unsafe fn core::iter::range::{impl core::iter::range::Step for i32}#40::backward_unchecked(@1: i32, @2: usize) -> i32

impl core::iter::range::{impl core::iter::range::Step for i32}#40 : core::iter::range::Step<i32>
{
    parent_clause0 = core::marker::Sized<i32>
    parent_clause1 = core::clone::impls::{impl core::clone::Clone for i32}#14
    parent_clause2 = core::cmp::impls::{impl core::cmp::PartialOrd<i32> for i32}#76
    fn steps_between = core::iter::range::{impl core::iter::range::Step for i32}#40::steps_between
    fn forward_checked = core::iter::range::{impl core::iter::range::Step for i32}#40::forward_checked
    fn backward_checked = core::iter::range::{impl core::iter::range::Step for i32}#40::backward_checked
    fn forward = core::iter::range::{impl core::iter::range::Step for i32}#40::forward
    fn forward_unchecked = core::iter::range::{impl core::iter::range::Step for i32}#40::forward_unchecked
    fn backward = core::iter::range::{impl core::iter::range::Step for i32}#40::backward
    fn backward_unchecked = core::iter::range::{impl core::iter::range::Step for i32}#40::backward_unchecked
}

fn core::iter::traits::collect::IntoIterator::into_iter<Self>(@1: Self) -> Self::IntoIter

fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut (Self)) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>

fn core::cmp::impls::{impl core::cmp::PartialEq<usize> for usize}#21::eq<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialEq<usize> for usize}#21::ne<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> bool

impl core::cmp::impls::{impl core::cmp::PartialEq<usize> for usize}#21 : core::cmp::PartialEq<usize, usize>
{
    fn eq = core::cmp::impls::{impl core::cmp::PartialEq<usize> for usize}#21::eq
    fn ne = core::cmp::impls::{impl core::cmp::PartialEq<usize> for usize}#21::ne
}

fn core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::partial_cmp<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> core::option::Option<core::cmp::Ordering, core::marker::Sized<core::cmp::Ordering>>

fn core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::lt<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::le<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::gt<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::ge<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> bool

impl core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58 : core::cmp::PartialOrd<usize, usize>
{
    parent_clause0 = core::cmp::impls::{impl core::cmp::PartialEq<usize> for usize}#21
    fn partial_cmp = core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::partial_cmp
    fn lt = core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::lt
    fn le = core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::le
    fn gt = core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::gt
    fn ge = core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58::ge
}

fn core::iter::range::{impl core::iter::range::Step for usize}#43::steps_between<'_0, '_1>(@1: &'_0 (usize), @2: &'_1 (usize)) -> core::option::Option<usize, core::marker::Sized<usize>>

fn core::iter::range::{impl core::iter::range::Step for usize}#43::forward_checked(@1: usize, @2: usize) -> core::option::Option<usize, core::marker::Sized<usize>>

fn core::iter::range::{impl core::iter::range::Step for usize}#43::backward_checked(@1: usize, @2: usize) -> core::option::Option<usize, core::marker::Sized<usize>>

fn core::iter::range::{impl core::iter::range::Step for usize}#43::forward(@1: usize, @2: usize) -> usize

unsafe fn core::iter::range::{impl core::iter::range::Step for usize}#43::forward_unchecked(@1: usize, @2: usize) -> usize

fn core::iter::range::{impl core::iter::range::Step for usize}#43::backward(@1: usize, @2: usize) -> usize

unsafe fn core::iter::range::{impl core::iter::range::Step for usize}#43::backward_unchecked(@1: usize, @2: usize) -> usize

impl core::iter::range::{impl core::iter::range::Step for usize}#43 : core::iter::range::Step<usize>
{
    parent_clause0 = core::marker::Sized<usize>
    parent_clause1 = core::clone::impls::{impl core::clone::Clone for usize}#5
    parent_clause2 = core::cmp::impls::{impl core::cmp::PartialOrd<usize> for usize}#58
    fn steps_between = core::iter::range::{impl core::iter::range::Step for usize}#43::steps_between
    fn forward_checked = core::iter::range::{impl core::iter::range::Step for usize}#43::forward_checked
    fn backward_checked = core::iter::range::{impl core::iter::range::Step for usize}#43::backward_checked
    fn forward = core::iter::range::{impl core::iter::range::Step for usize}#43::forward
    fn forward_unchecked = core::iter::range::{impl core::iter::range::Step for usize}#43::forward_unchecked
    fn backward = core::iter::range::{impl core::iter::range::Step for usize}#43::backward
    fn backward_unchecked = core::iter::range::{impl core::iter::range::Step for usize}#43::backward_unchecked
}

fn test_crate::nested_loops_enum(@1: usize, @2: usize) -> usize
{
    let @0: usize; // return
    let step_out@1: usize; // arg #1
    let step_in@2: usize; // arg #2
    let s@3: usize; // local
    let @4: (); // anonymous local
    let @5: core::ops::range::Range<i32, core::marker::Sized<i32>>; // anonymous local
    let @6: core::ops::range::Range<i32, core::marker::Sized<i32>>; // anonymous local
    let iter@7: core::ops::range::Range<i32, core::marker::Sized<i32>>; // local
    let @8: (); // anonymous local
    let @9: (); // anonymous local
    let @10: core::option::Option<i32, core::marker::Sized<i32>>; // anonymous local
    let @11: &'_ mut (core::ops::range::Range<i32, core::marker::Sized<i32>>); // anonymous local
    let @12: &'_ mut (core::ops::range::Range<i32, core::marker::Sized<i32>>); // anonymous local
    let @13: (); // anonymous local
    let @14: core::ops::range::Range<usize, core::marker::Sized<usize>>; // anonymous local
    let @15: core::ops::range::Range<usize, core::marker::Sized<usize>>; // anonymous local
    let @16: usize; // anonymous local
    let iter@17: core::ops::range::Range<usize, core::marker::Sized<usize>>; // local
    let @18: (); // anonymous local
    let @19: core::option::Option<usize, core::marker::Sized<usize>>; // anonymous local
    let @20: &'_ mut (core::ops::range::Range<usize, core::marker::Sized<usize>>); // anonymous local
    let @21: &'_ mut (core::ops::range::Range<usize, core::marker::Sized<usize>>); // anonymous local
    let @22: core::ops::range::Range<usize, core::marker::Sized<usize>>; // anonymous local
    let @23: core::ops::range::Range<usize, core::marker::Sized<usize>>; // anonymous local
    let @24: usize; // anonymous local
    let iter@25: core::ops::range::Range<usize, core::marker::Sized<usize>>; // local
    let @26: (); // anonymous local
    let @27: core::option::Option<usize, core::marker::Sized<usize>>; // anonymous local
    let @28: &'_ mut (core::ops::range::Range<usize, core::marker::Sized<usize>>); // anonymous local
    let @29: &'_ mut (core::ops::range::Range<usize, core::marker::Sized<usize>>); // anonymous local
    let @30: (); // anonymous local
    let @31: (); // anonymous local
    let @32: (); // anonymous local
    let @33: (); // anonymous local
    let @34: (); // anonymous local
    let @35: (); // anonymous local
    let @36: (); // anonymous local
    let @37: (); // anonymous local

    s@3 := const (0 : usize)
    @fake_read(s@3)
    @6 := core::ops::range::Range { start: const (0 : i32), end: const (128 : i32) }
    @5 := core::iter::traits::collect::{impl core::iter::traits::collect::IntoIterator for I}#1<core::ops::range::Range<i32, core::marker::Sized<i32>>>[core::marker::Sized<core::ops::range::Range<i32, core::marker::Sized<i32>>>, core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<i32>[core::marker::Sized<i32>, core::iter::range::{impl core::iter::range::Step for i32}#40]]::into_iter(move (@6))
    drop @6
    @fake_read(@5)
    iter@7 := move (@5)
    loop {
        @12 := &mut iter@7
        @11 := &two-phase-mut *(@12)
        @10 := core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<i32>[core::marker::Sized<i32>, core::iter::range::{impl core::iter::range::Step for i32}#40]::next(move (@11))
        drop @11
        @fake_read(@10)
        match @10 {
            0 => {
                break 0
            },
            1 => {
                s@3 := copy (s@3) + const (1 : usize)
                @31 := ()
                @9 := move (@31)
                drop @12
                drop @10
                drop @9
                @32 := ()
                @8 := move (@32)
                continue 0
            },
        }
    }
    @30 := ()
    @4 := move (@30)
    drop @12
    drop @10
    drop @9
    drop iter@7
    drop @5
    drop @4
    @16 := copy (step_out@1)
    @15 := core::ops::range::Range { start: const (0 : usize), end: move (@16) }
    drop @16
    @14 := core::iter::traits::collect::{impl core::iter::traits::collect::IntoIterator for I}#1<core::ops::range::Range<usize, core::marker::Sized<usize>>>[core::marker::Sized<core::ops::range::Range<usize, core::marker::Sized<usize>>>, core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<usize>[core::marker::Sized<usize>, core::iter::range::{impl core::iter::range::Step for usize}#43]]::into_iter(move (@15))
    drop @15
    @fake_read(@14)
    iter@17 := move (@14)
    loop {
        @21 := &mut iter@17
        @20 := &two-phase-mut *(@21)
        @19 := core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<usize>[core::marker::Sized<usize>, core::iter::range::{impl core::iter::range::Step for usize}#43]::next(move (@20))
        drop @20
        @fake_read(@19)
        match @19 {
            0 => {
                break 0
            },
            1 => {
                @24 := copy (step_in@2)
                @23 := core::ops::range::Range { start: const (0 : usize), end: move (@24) }
                drop @24
                @22 := core::iter::traits::collect::{impl core::iter::traits::collect::IntoIterator for I}#1<core::ops::range::Range<usize, core::marker::Sized<usize>>>[core::marker::Sized<core::ops::range::Range<usize, core::marker::Sized<usize>>>, core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<usize>[core::marker::Sized<usize>, core::iter::range::{impl core::iter::range::Step for usize}#43]]::into_iter(move (@23))
                drop @23
                @fake_read(@22)
                iter@25 := move (@22)
                loop {
                    @29 := &mut iter@25
                    @28 := &two-phase-mut *(@29)
                    @27 := core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<usize>[core::marker::Sized<usize>, core::iter::range::{impl core::iter::range::Step for usize}#43]::next(move (@28))
                    drop @28
                    @fake_read(@27)
                    match @27 {
                        0 => {
                            break 0
                        },
                        1 => {
                            s@3 := copy (s@3) + const (1 : usize)
                            @36 := ()
                            @26 := move (@36)
                            drop @29
                            drop @27
                            drop @26
                            @37 := ()
                            @8 := move (@37)
                            continue 0
                        },
                    }
                }
                @34 := ()
                @18 := move (@34)
                drop @29
                drop @27
                drop @26
                drop iter@25
                drop @22
                drop @21
                drop @19
                drop @18
                @35 := ()
                @8 := move (@35)
                continue 0
            },
        }
    }
    @33 := ()
    @13 := move (@33)
    drop @21
    drop @19
    drop @18
    drop iter@17
    drop @14
    drop @13
    @0 := copy (s@3)
    drop s@3
    return
}

fn core::clone::impls::{impl core::clone::Clone for u32}#8::clone<'_0>(@1: &'_0 (u32)) -> u32

impl core::clone::impls::{impl core::clone::Clone for u32}#8 : core::clone::Clone<u32>
{
    parent_clause0 = core::marker::Sized<u32>
    fn clone = core::clone::impls::{impl core::clone::Clone for u32}#8::clone
}

fn core::cmp::impls::{impl core::cmp::PartialEq<u32> for u32}#24::eq<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialEq<u32> for u32}#24::ne<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> bool

impl core::cmp::impls::{impl core::cmp::PartialEq<u32> for u32}#24 : core::cmp::PartialEq<u32, u32>
{
    fn eq = core::cmp::impls::{impl core::cmp::PartialEq<u32> for u32}#24::eq
    fn ne = core::cmp::impls::{impl core::cmp::PartialEq<u32> for u32}#24::ne
}

fn core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::partial_cmp<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> core::option::Option<core::cmp::Ordering, core::marker::Sized<core::cmp::Ordering>>

fn core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::lt<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::le<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::gt<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::ge<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> bool

impl core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64 : core::cmp::PartialOrd<u32, u32>
{
    parent_clause0 = core::cmp::impls::{impl core::cmp::PartialEq<u32> for u32}#24
    fn partial_cmp = core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::partial_cmp
    fn lt = core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::lt
    fn le = core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::le
    fn gt = core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::gt
    fn ge = core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64::ge
}

fn core::iter::range::{impl core::iter::range::Step for u32}#39::steps_between<'_0, '_1>(@1: &'_0 (u32), @2: &'_1 (u32)) -> core::option::Option<usize, core::marker::Sized<usize>>

fn core::iter::range::{impl core::iter::range::Step for u32}#39::forward_checked(@1: u32, @2: usize) -> core::option::Option<u32, core::marker::Sized<u32>>

fn core::iter::range::{impl core::iter::range::Step for u32}#39::backward_checked(@1: u32, @2: usize) -> core::option::Option<u32, core::marker::Sized<u32>>

fn core::iter::range::{impl core::iter::range::Step for u32}#39::forward(@1: u32, @2: usize) -> u32

unsafe fn core::iter::range::{impl core::iter::range::Step for u32}#39::forward_unchecked(@1: u32, @2: usize) -> u32

fn core::iter::range::{impl core::iter::range::Step for u32}#39::backward(@1: u32, @2: usize) -> u32

unsafe fn core::iter::range::{impl core::iter::range::Step for u32}#39::backward_unchecked(@1: u32, @2: usize) -> u32

impl core::iter::range::{impl core::iter::range::Step for u32}#39 : core::iter::range::Step<u32>
{
    parent_clause0 = core::marker::Sized<u32>
    parent_clause1 = core::clone::impls::{impl core::clone::Clone for u32}#8
    parent_clause2 = core::cmp::impls::{impl core::cmp::PartialOrd<u32> for u32}#64
    fn steps_between = core::iter::range::{impl core::iter::range::Step for u32}#39::steps_between
    fn forward_checked = core::iter::range::{impl core::iter::range::Step for u32}#39::forward_checked
    fn backward_checked = core::iter::range::{impl core::iter::range::Step for u32}#39::backward_checked
    fn forward = core::iter::range::{impl core::iter::range::Step for u32}#39::forward
    fn forward_unchecked = core::iter::range::{impl core::iter::range::Step for u32}#39::forward_unchecked
    fn backward = core::iter::range::{impl core::iter::range::Step for u32}#39::backward
    fn backward_unchecked = core::iter::range::{impl core::iter::range::Step for u32}#39::backward_unchecked
}

fn test_crate::loop_inside_if(@1: bool, @2: u32) -> u32
{
    let @0: u32; // return
    let b@1: bool; // arg #1
    let n@2: u32; // arg #2
    let @3: bool; // anonymous local
    let s@4: u32; // local
    let @5: (); // anonymous local
    let @6: core::ops::range::Range<u32, core::marker::Sized<u32>>; // anonymous local
    let @7: core::ops::range::Range<u32, core::marker::Sized<u32>>; // anonymous local
    let @8: u32; // anonymous local
    let iter@9: core::ops::range::Range<u32, core::marker::Sized<u32>>; // local
    let @10: (); // anonymous local
    let @11: (); // anonymous local
    let @12: core::option::Option<u32, core::marker::Sized<u32>>; // anonymous local
    let @13: &'_ mut (core::ops::range::Range<u32, core::marker::Sized<u32>>); // anonymous local
    let @14: &'_ mut (core::ops::range::Range<u32, core::marker::Sized<u32>>); // anonymous local
    let i@15: u32; // local
    let @16: u32; // anonymous local
    let @17: (); // anonymous local
    let @18: (); // anonymous local
    let @19: (); // anonymous local

    @3 := copy (b@1)
    if move (@3) {
        s@4 := const (0 : u32)
        @fake_read(s@4)
        @8 := copy (n@2)
        @7 := core::ops::range::Range { start: const (0 : u32), end: move (@8) }
        drop @8
        @6 := core::iter::traits::collect::{impl core::iter::traits::collect::IntoIterator for I}#1<core::ops::range::Range<u32, core::marker::Sized<u32>>>[core::marker::Sized<core::ops::range::Range<u32, core::marker::Sized<u32>>>, core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<u32>[core::marker::Sized<u32>, core::iter::range::{impl core::iter::range::Step for u32}#39]]::into_iter(move (@7))
        drop @7
        @fake_read(@6)
        iter@9 := move (@6)
        loop {
            @14 := &mut iter@9
            @13 := &two-phase-mut *(@14)
            @12 := core::iter::range::{impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A, @TraitClause0>}#6<u32>[core::marker::Sized<u32>, core::iter::range::{impl core::iter::range::Step for u32}#39]::next(move (@13))
            drop @13
            @fake_read(@12)
            match @12 {
                0 => {
                    break 0
                },
                1 => {
                    i@15 := copy ((@12 as variant @1).0)
                    @16 := copy (i@15)
                    s@4 := copy (s@4) + move (@16)
                    drop @16
                    @18 := ()
                    @11 := move (@18)
                    drop i@15
                    drop @14
                    drop @12
                    drop @11
                    @19 := ()
                    @10 := move (@19)
                    continue 0
                },
            }
        }
        @17 := ()
        @5 := move (@17)
        drop @14
        drop @12
        drop @11
        drop iter@9
        drop @6
        drop @5
        @0 := copy (s@4)
        drop s@4
    }
    else {
        @0 := const (0 : u32)
    }
    drop @3
    return
}

fn test_crate::sum(@1: u32) -> u32
{
    let @0: u32; // return
    let max@1: u32; // arg #1
    let i@2: u32; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: (); // anonymous local
    let @11: (); // anonymous local
    let @12: (); // anonymous local

    i@2 := const (0 : u32)
    @fake_read(i@2)
    s@3 := const (0 : u32)
    @fake_read(s@3)
    loop {
        @7 := copy (i@2)
        @8 := copy (max@1)
        @6 := move (@7) < move (@8)
        if move (@6) {
            drop @8
            drop @7
            @9 := copy (i@2)
            s@3 := copy (s@3) + move (@9)
            drop @9
            i@2 := copy (i@2) + const (1 : u32)
            @11 := ()
            @5 := move (@11)
            drop @6
            continue 0
        }
        else {
            break 0
        }
    }
    drop @8
    drop @7
    @12 := ()
    @4 := move (@12)
    drop @10
    drop @6
    drop @4
    s@3 := copy (s@3) * const (2 : u32)
    @0 := copy (s@3)
    drop s@3
    drop i@2
    return
}

fn test_crate::sum_array<const N : usize>(@1: Array<u32, const N : usize>) -> u32
{
    let @0: u32; // return
    let a@1: Array<u32, const N : usize>; // arg #1
    let i@2: usize; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: usize; // anonymous local
    let @8: u32; // anonymous local
    let @9: usize; // anonymous local
    let @10: (); // anonymous local
    let @11: (); // anonymous local
    let @12: (); // anonymous local
    let @13: &'_ (Array<u32, const N : usize>); // anonymous local
    let @14: &'_ (u32); // anonymous local

    i@2 := const (0 : usize)
    @fake_read(i@2)
    s@3 := const (0 : u32)
    @fake_read(s@3)
    loop {
        @7 := copy (i@2)
        @6 := move (@7) < const (const N : usize)
        if move (@6) {
            drop @7
            @9 := copy (i@2)
            @13 := &a@1
            @14 := @ArrayIndexShared<'_, u32, const N : usize>(move (@13), copy (@9))
            @8 := copy (*(@14))
            s@3 := copy (s@3) + move (@8)
            drop @8
            drop @9
            i@2 := copy (i@2) + const (1 : usize)
            @11 := ()
            @5 := move (@11)
            drop @6
            continue 0
        }
        else {
            break 0
        }
    }
    drop @7
    @12 := ()
    @4 := move (@12)
    drop @10
    drop @6
    drop @4
    @0 := copy (s@3)
    drop s@3
    drop i@2
    return
}

opaque type alloc::vec::Vec<T, A>
  where
      [@TraitClause0]: core::marker::Sized<T>,
      [@TraitClause1]: core::marker::Sized<A>,

struct alloc::alloc::Global = {}

fn alloc::vec::{alloc::vec::Vec<T, A, @TraitClause0, @TraitClause1>}#1::len<'_0, T, A>(@1: &'_0 (alloc::vec::Vec<T, A, @TraitClause0, @TraitClause1>)) -> usize
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<A>,

trait core::ops::index::Index<Self, Idx>
{
    type Output
    fn index : core::ops::index::Index::index
}

trait core::ops::index::IndexMut<Self, Idx>
{
    parent_clause_0 : [@TraitClause0]: core::ops::index::Index<Self, Idx>
    fn index_mut : core::ops::index::IndexMut::index_mut
}

trait core::slice::index::private_slice_index::Sealed<Self>

trait core::slice::index::SliceIndex<Self, T>
{
    parent_clause_0 : [@TraitClause0]: core::slice::index::private_slice_index::Sealed<Self>
    type Output
    fn get : core::slice::index::SliceIndex::get
    fn get_mut : core::slice::index::SliceIndex::get_mut
    fn get_unchecked : core::slice::index::SliceIndex::get_unchecked
    fn get_unchecked_mut : core::slice::index::SliceIndex::get_unchecked_mut
    fn index : core::slice::index::SliceIndex::index
    fn index_mut : core::slice::index::SliceIndex::index_mut
}

fn alloc::vec::{impl core::ops::index::Index<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#13::index<'_0, T, I, A>(@1: &'_0 (alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>), @2: I) -> &'_0 (alloc::vec::{impl core::ops::index::Index<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#13<T, I, A>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3]::Output)
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::marker::Sized<A>,
    [@TraitClause3]: core::slice::index::SliceIndex<I, Slice<T>>,

impl<T, I, A> alloc::vec::{impl core::ops::index::Index<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#13<T, I, A> : core::ops::index::Index<alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>, I>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::marker::Sized<A>,
    [@TraitClause3]: core::slice::index::SliceIndex<I, Slice<T>>,
{
    type Output = @TraitClause3::Output
    fn index = alloc::vec::{impl core::ops::index::Index<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#13::index
}

fn alloc::vec::{impl core::ops::index::IndexMut<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#14::index_mut<'_0, T, I, A>(@1: &'_0 mut (alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>), @2: I) -> &'_0 mut (alloc::vec::{impl core::ops::index::Index<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#13<T, I, A>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3]::Output)
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::marker::Sized<A>,
    [@TraitClause3]: core::slice::index::SliceIndex<I, Slice<T>>,

impl<T, I, A> alloc::vec::{impl core::ops::index::IndexMut<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#14<T, I, A> : core::ops::index::IndexMut<alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>, I>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::marker::Sized<A>,
    [@TraitClause3]: core::slice::index::SliceIndex<I, Slice<T>>,
{
    parent_clause0 = alloc::vec::{impl core::ops::index::Index<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#13<T, I, A>[@TraitClause0, @TraitClause1, @TraitClause2, @TraitClause3]
    fn index_mut = alloc::vec::{impl core::ops::index::IndexMut<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#14::index_mut
}

impl core::slice::index::private_slice_index::{impl core::slice::index::private_slice_index::Sealed for usize} : core::slice::index::private_slice_index::Sealed<usize>

fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::get<'_0, T>(@1: usize, @2: &'_0 (Slice<T>)) -> core::option::Option<&'_0 (T), core::marker::Sized<&'_1_0 (T)>>
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,

fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::get_mut<'_0, T>(@1: usize, @2: &'_0 mut (Slice<T>)) -> core::option::Option<&'_0 mut (T), core::marker::Sized<&'_1_0 mut (T)>>
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,

unsafe fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::get_unchecked<T>(@1: usize, @2: *const Slice<T>) -> *const T
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,

unsafe fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::get_unchecked_mut<T>(@1: usize, @2: *mut Slice<T>) -> *mut T
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,

fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::index<'_0, T>(@1: usize, @2: &'_0 (Slice<T>)) -> &'_0 (T)
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,

fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::index_mut<'_0, T>(@1: usize, @2: &'_0 mut (Slice<T>)) -> &'_0 mut (T)
where
    // Inherited clauses:
    [@TraitClause0]: core::marker::Sized<T>,

impl<T> core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2<T> : core::slice::index::SliceIndex<usize, Slice<T>>
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    parent_clause0 = core::slice::index::private_slice_index::{impl core::slice::index::private_slice_index::Sealed for usize}
    type Output = T
    fn get = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::get
    fn get_mut = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::get_mut
    fn get_unchecked = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::get_unchecked
    fn get_unchecked_mut = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::get_unchecked_mut
    fn index = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::index
    fn index_mut = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2::index_mut
}

fn core::ops::index::IndexMut::index_mut<'_0, Self, Idx>(@1: &'_0 mut (Self), @2: Idx) -> &'_0 mut ((parents(Self)::[@TraitClause0])::Output)

fn test_crate::clear<'_0>(@1: &'_0 mut (alloc::vec::Vec<u32, alloc::alloc::Global, core::marker::Sized<u32>, core::marker::Sized<alloc::alloc::Global>>))
{
    let @0: (); // return
    let v@1: &'_ mut (alloc::vec::Vec<u32, alloc::alloc::Global, core::marker::Sized<u32>, core::marker::Sized<alloc::alloc::Global>>); // arg #1
    let i@2: usize; // local
    let @3: (); // anonymous local
    let @4: bool; // anonymous local
    let @5: usize; // anonymous local
    let @6: usize; // anonymous local
    let @7: &'_ (alloc::vec::Vec<u32, alloc::alloc::Global, core::marker::Sized<u32>, core::marker::Sized<alloc::alloc::Global>>); // anonymous local
    let @8: &'_ mut (u32); // anonymous local
    let @9: &'_ mut (alloc::vec::Vec<u32, alloc::alloc::Global, core::marker::Sized<u32>, core::marker::Sized<alloc::alloc::Global>>); // anonymous local
    let @10: usize; // anonymous local
    let @11: (); // anonymous local
    let @12: (); // anonymous local
    let @13: (); // anonymous local

    i@2 := const (0 : usize)
    @fake_read(i@2)
    loop {
        @5 := copy (i@2)
        @7 := &*(v@1)
        @6 := alloc::vec::{alloc::vec::Vec<T, A, @TraitClause0, @TraitClause1>}#1::len<u32, alloc::alloc::Global>[core::marker::Sized<u32>, core::marker::Sized<alloc::alloc::Global>](move (@7))
        drop @7
        @4 := move (@5) < move (@6)
        if move (@4) {
            drop @6
            drop @5
            @9 := &mut *(v@1)
            @10 := copy (i@2)
            @8 := alloc::vec::{impl core::ops::index::IndexMut<I> for alloc::vec::Vec<T, A, @TraitClause0, @TraitClause2>}#14<u32, usize, alloc::alloc::Global>[core::marker::Sized<u32>, core::marker::Sized<usize>, core::marker::Sized<alloc::alloc::Global>, core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>> for usize}#2<u32>[core::marker::Sized<u32>]]::index_mut(move (@9), move (@10))
            drop @10
            drop @9
            *(@8) := const (0 : u32)
            drop @8
            i@2 := copy (i@2) + const (1 : usize)
            @12 := ()
            @3 := move (@12)
            drop @4
            continue 0
        }
        else {
            break 0
        }
    }
    drop @6
    drop @5
    @13 := ()
    @0 := move (@13)
    drop @11
    drop @4
    drop i@2
    @0 := ()
    return
}

enum test_crate::List<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,
 =
|  Cons(T, alloc::boxed::Box<test_crate::List<T, @TraitClause0>, core::marker::Sized<alloc::alloc::Global>>)
|  Nil()


fn test_crate::get_elem_mut<'_0>(@1: &'_0 mut (test_crate::List<usize, core::marker::Sized<usize>>), @2: usize) -> &'_0 mut (usize)
{
    let @0: &'_ mut (usize); // return
    let ls@1: &'_ mut (test_crate::List<usize, core::marker::Sized<usize>>); // arg #1
    let x@2: usize; // arg #2
    let @3: (); // anonymous local
    let y@4: &'_ mut (usize); // local
    let tl@5: &'_ mut (alloc::boxed::Box<test_crate::List<usize, core::marker::Sized<usize>>, core::marker::Sized<alloc::alloc::Global>>); // local
    let @6: bool; // anonymous local
    let @7: usize; // anonymous local
    let @8: usize; // anonymous local
    let @9: &'_ mut (test_crate::List<usize, core::marker::Sized<usize>>); // anonymous local
    let @10: (); // anonymous local

    loop {
        @fake_read(ls@1)
        match *(ls@1) {
            0 => {
                y@4 := &mut (*(ls@1) as variant @0).0
                tl@5 := &mut (*(ls@1) as variant @0).1
                @7 := copy (*(y@4))
                @8 := copy (x@2)
                @6 := move (@7) == move (@8)
                if move (@6) {
                }
                else {
                    drop @8
                    drop @7
                    @9 := &mut *(*(tl@5))
                    ls@1 := move (@9)
                    drop @9
                    @10 := ()
                    @3 := move (@10)
                    drop @6
                    drop tl@5
                    drop y@4
                    continue 0
                }
                drop @8
                drop @7
                @0 := &mut *(y@4)
                drop @6
                drop tl@5
                drop y@4
                return
            },
            1 => {
                panic(core::panicking::panic_explicit)
            },
        }
    }
}

fn test_crate::list_nth_mut_loop_with_id<'_0, T>(@1: &'_0 mut (test_crate::List<T, @TraitClause0>), @2: u32) -> &'_0 mut (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (T); // return
    let ls@1: &'_ mut (test_crate::List<T, @TraitClause0>); // arg #1
    let i@2: u32; // arg #2
    let @3: (); // anonymous local
    let @4: (); // anonymous local
    let x@5: &'_ mut (T); // local
    let tl@6: &'_ mut (alloc::boxed::Box<test_crate::List<T, @TraitClause0>, core::marker::Sized<alloc::alloc::Global>>); // local
    let @7: bool; // anonymous local
    let @8: u32; // anonymous local
    let @9: &'_ mut (test_crate::List<T, @TraitClause0>); // anonymous local
    let @10: (); // anonymous local
    let @11: (); // anonymous local
    let @12: (); // anonymous local

    loop {
        @fake_read(ls@1)
        match *(ls@1) {
            0 => {
                x@5 := &mut (*(ls@1) as variant @0).0
                tl@6 := &mut (*(ls@1) as variant @0).1
                @8 := copy (i@2)
                @7 := move (@8) == const (0 : u32)
                if move (@7) {
                }
                else {
                    drop @8
                    @9 := &mut *(*(tl@6))
                    ls@1 := move (@9)
                    drop @9
                    i@2 := copy (i@2) - const (1 : u32)
                    @12 := ()
                    @4 := move (@12)
                    drop @7
                    drop tl@6
                    drop x@5
                    continue 0
                }
                drop @8
                @0 := &mut *(x@5)
                drop @7
                drop tl@6
                drop x@5
                drop @3
                return
            },
            _ => {
                @11 := ()
                @3 := move (@11)
                drop @10
                drop @3
                panic(core::panicking::panic_explicit)
            },
        }
    }
}

fn core::iter::range::Step::steps_between<'_0, '_1, Self>(@1: &'_0 (Self), @2: &'_1 (Self)) -> core::option::Option<usize, core::marker::Sized<usize>>

fn core::iter::range::Step::forward_checked<Self>(@1: Self, @2: usize) -> core::option::Option<Self, (parents(Self)::[@TraitClause0])>

fn core::iter::range::Step::forward<Self>(@1: Self, @2: usize) -> Self

unsafe fn core::iter::range::Step::forward_unchecked<Self>(@1: Self, @2: usize) -> Self

fn core::iter::range::Step::backward_checked<Self>(@1: Self, @2: usize) -> core::option::Option<Self, (parents(Self)::[@TraitClause0])>

fn core::iter::range::Step::backward<Self>(@1: Self, @2: usize) -> Self

unsafe fn core::iter::range::Step::backward_unchecked<Self>(@1: Self, @2: usize) -> Self

fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 (Self)) -> Self

fn core::clone::Clone::clone_from<'_0, '_1, Self>(@1: &'_0 mut (Self), @2: &'_1 (Self))

fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> core::option::Option<core::cmp::Ordering, core::marker::Sized<core::cmp::Ordering>>

fn core::cmp::PartialOrd::lt<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool

fn core::cmp::PartialOrd::le<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool

fn core::cmp::PartialOrd::gt<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool

fn core::cmp::PartialOrd::ge<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool

fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool

fn core::cmp::PartialEq::ne<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool

fn core::iter::traits::iterator::Iterator::next_chunk<'_0, Self, const N : usize>(@1: &'_0 mut (Self)) -> core::result::Result<Array<Self::Item, const N : usize>, core::array::iter::IntoIter<Self::Item, const N : usize, (parents(Self)::[@TraitClause0])>, core::marker::Sized<Array<Self::Item, const N : usize>>, core::marker::Sized<core::array::iter::IntoIter<Self::Item, const N : usize, (parents(Self)::[@TraitClause0])>>>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::size_hint<'_0, Self>(@1: &'_0 (Self)) -> (usize, core::option::Option<usize, core::marker::Sized<usize>>)

fn core::iter::traits::iterator::Iterator::count<Self>(@1: Self) -> usize
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::last<Self>(@1: Self) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::advance_by<'_0, Self>(@1: &'_0 mut (Self), @2: usize) -> core::result::Result<(), core::num::nonzero::NonZero<usize, core::marker::Sized<usize>, core::num::nonzero::{impl core::num::nonzero::ZeroablePrimitive for usize}#26>, core::marker::Sized<()>, core::marker::Sized<core::num::nonzero::NonZero<usize, core::marker::Sized<usize>, core::num::nonzero::{impl core::num::nonzero::ZeroablePrimitive for usize}#26>>>

fn core::iter::traits::iterator::Iterator::nth<'_0, Self>(@1: &'_0 mut (Self), @2: usize) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>

fn core::iter::traits::iterator::Iterator::step_by<Self>(@1: Self, @2: usize) -> core::iter::adapters::step_by::StepBy<Self, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::chain<Self, U>(@1: Self, @2: U) -> core::iter::adapters::chain::Chain<Self, @TraitClause2::IntoIter, @TraitClause1, (parents(@TraitClause2)::[@TraitClause2])>
where
    [@TraitClause0]: core::marker::Sized<U>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::iter::traits::collect::IntoIterator<U>,
    @TraitClause2::Item = Self::Item,

fn core::iter::traits::iterator::Iterator::zip<Self, U>(@1: Self, @2: U) -> core::iter::adapters::zip::Zip<Self, @TraitClause2::IntoIter, @TraitClause1, (parents(@TraitClause2)::[@TraitClause2])>
where
    [@TraitClause0]: core::marker::Sized<U>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::iter::traits::collect::IntoIterator<U>,

fn core::iter::traits::iterator::Iterator::intersperse<Self>(@1: Self, @2: Self::Item) -> core::iter::adapters::intersperse::Intersperse<Self, @TraitClause0, Self, @TraitClause1>
where
    [@TraitClause0]: core::marker::Sized<Self>,
    [@TraitClause1]: core::clone::Clone<Self::Item>,

fn core::iter::traits::iterator::Iterator::intersperse_with<Self, G>(@1: Self, @2: G) -> core::iter::adapters::intersperse::IntersperseWith<Self, G, @TraitClause1, @TraitClause0, Self>
where
    [@TraitClause0]: core::marker::Sized<G>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::ops::function::FnMut<G, ()>,
    (parents(@TraitClause2)::[@TraitClause0])::Output = Self::Item,

fn core::iter::traits::iterator::Iterator::map<Self, B, F>(@1: Self, @2: F) -> core::iter::adapters::map::Map<Self, F, @TraitClause2, @TraitClause1>
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::function::FnMut<F, (Self::Item)>,
    (parents(@TraitClause3)::[@TraitClause0])::Output = B,

fn core::iter::traits::iterator::Iterator::for_each<Self, F>(@1: Self, @2: F)
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::ops::function::FnMut<F, (Self::Item)>,
    (parents(@TraitClause2)::[@TraitClause0])::Output = (),

fn core::iter::traits::iterator::Iterator::filter<Self, P>(@1: Self, @2: P) -> core::iter::adapters::filter::Filter<Self, P, @TraitClause1, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0> core::ops::function::FnMut<P, (&'_1_0 (Self::Item))>,
    for<'_1_0> (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::filter_map<Self, B, F>(@1: Self, @2: F) -> core::iter::adapters::filter_map::FilterMap<Self, F, @TraitClause2, @TraitClause1>
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::function::FnMut<F, (Self::Item)>,
    (parents(@TraitClause3)::[@TraitClause0])::Output = core::option::Option<B, @TraitClause0>,

fn core::iter::traits::iterator::Iterator::enumerate<Self>(@1: Self) -> core::iter::adapters::enumerate::Enumerate<Self, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::peekable<Self>(@1: Self) -> core::iter::adapters::peekable::Peekable<Self, @TraitClause0, Self>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::skip_while<Self, P>(@1: Self, @2: P) -> core::iter::adapters::skip_while::SkipWhile<Self, P, @TraitClause1, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0> core::ops::function::FnMut<P, (&'_1_0 (Self::Item))>,
    for<'_1_0> (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::take_while<Self, P>(@1: Self, @2: P) -> core::iter::adapters::take_while::TakeWhile<Self, P, @TraitClause1, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0> core::ops::function::FnMut<P, (&'_1_0 (Self::Item))>,
    for<'_1_0> (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::map_while<Self, B, P>(@1: Self, @2: P) -> core::iter::adapters::map_while::MapWhile<Self, P, @TraitClause2, @TraitClause1>
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<P>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::function::FnMut<P, (Self::Item)>,
    (parents(@TraitClause3)::[@TraitClause0])::Output = core::option::Option<B, @TraitClause0>,

fn core::iter::traits::iterator::Iterator::skip<Self>(@1: Self, @2: usize) -> core::iter::adapters::skip::Skip<Self, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::take<Self>(@1: Self, @2: usize) -> core::iter::adapters::take::Take<Self, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::scan<Self, St, B, F>(@1: Self, @2: St, @3: F) -> core::iter::adapters::scan::Scan<Self, St, F, @TraitClause3, @TraitClause0, @TraitClause2>
where
    [@TraitClause0]: core::marker::Sized<St>,
    [@TraitClause1]: core::marker::Sized<B>,
    [@TraitClause2]: core::marker::Sized<F>,
    [@TraitClause3]: core::marker::Sized<Self>,
    [@TraitClause4]: for<'_1_0> core::ops::function::FnMut<F, (&'_1_0 mut (St), Self::Item)>,
    for<'_1_0> (parents(@TraitClause4)::[@TraitClause0])::Output = core::option::Option<B, @TraitClause1>,

fn core::iter::traits::iterator::Iterator::flat_map<Self, U, F>(@1: Self, @2: F) -> core::iter::adapters::flatten::FlatMap<Self, U, F, @TraitClause2, @TraitClause0, @TraitClause1, @TraitClause3>
where
    [@TraitClause0]: core::marker::Sized<U>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::iter::traits::collect::IntoIterator<U>,
    [@TraitClause4]: core::ops::function::FnMut<F, (Self::Item)>,
    (parents(@TraitClause4)::[@TraitClause0])::Output = U,

fn core::iter::traits::iterator::Iterator::flatten<Self>(@1: Self) -> core::iter::adapters::flatten::Flatten<Self, @TraitClause0, Self, @TraitClause1>
where
    [@TraitClause0]: core::marker::Sized<Self>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<Self::Item>,

fn core::iter::traits::iterator::Iterator::map_windows<Self, F, R, const N : usize>(@1: Self, @2: F) -> core::iter::adapters::map_windows::MapWindows<Self, F, const N : usize, @TraitClause2, @TraitClause0, Self>
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<R>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: for<'_1_0> core::ops::function::FnMut<F, (&'_1_0 (Array<Self::Item, const N : usize>))>,
    for<'_1_0> (parents(@TraitClause3)::[@TraitClause0])::Output = R,

fn core::iter::traits::iterator::Iterator::fuse<Self>(@1: Self) -> core::iter::adapters::fuse::Fuse<Self, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::inspect<Self, F>(@1: Self, @2: F) -> core::iter::adapters::inspect::Inspect<Self, F, @TraitClause1, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0> core::ops::function::FnMut<F, (&'_1_0 (Self::Item))>,
    for<'_1_0> (parents(@TraitClause2)::[@TraitClause0])::Output = (),

fn core::iter::traits::iterator::Iterator::by_ref<'_0, Self>(@1: &'_0 mut (Self)) -> &'_0 mut (Self)
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::collect<Self, B>(@1: Self) -> B
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::iter::traits::collect::FromIterator<B, Self::Item>,
    [@TraitClause2]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::try_collect<'_0, Self, B>(@1: &'_0 mut (Self)) -> @TraitClause3::TryType
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::ops::try_trait::Try<Self::Item>,
    [@TraitClause3]: core::ops::try_trait::Residual<@TraitClause2::Residual, B>,
    [@TraitClause4]: core::iter::traits::collect::FromIterator<B, @TraitClause2::Output>,

fn core::iter::traits::iterator::Iterator::collect_into<'_0, Self, E>(@1: Self, @2: &'_0 mut (E)) -> &'_0 mut (E)
where
    [@TraitClause0]: core::marker::Sized<E>,
    [@TraitClause1]: core::iter::traits::collect::Extend<E, Self::Item>,
    [@TraitClause2]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::partition<Self, B, F>(@1: Self, @2: F) -> (B, B)
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::default::Default<B>,
    [@TraitClause4]: core::iter::traits::collect::Extend<B, Self::Item>,
    [@TraitClause5]: for<'_1_0> core::ops::function::FnMut<F, (&'_1_0 (Self::Item))>,
    for<'_1_0> (parents(@TraitClause5)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::partition_in_place<'a, Self, T, P>(@1: Self, @2: P) -> usize
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<P>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::iter::traits::double_ended::DoubleEndedIterator<Self>,
    [@TraitClause4]: for<'_1_0> core::ops::function::FnMut<P, (&'_1_0 (T))>,
    T : 'a,
    Self::Item = &'a mut (T),
    for<'_1_0> (parents(@TraitClause4)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::is_partitioned<Self, P>(@1: Self, @2: P) -> bool
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::ops::function::FnMut<P, (Self::Item)>,
    (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::try_fold<'_0, Self, B, F, R>(@1: &'_0 mut (Self), @2: B, @3: F) -> R
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<R>,
    [@TraitClause3]: core::marker::Sized<Self>,
    [@TraitClause4]: core::ops::function::FnMut<F, (B, Self::Item)>,
    [@TraitClause5]: core::ops::try_trait::Try<R>,
    (parents(@TraitClause4)::[@TraitClause0])::Output = R,
    @TraitClause5::Output = B,

fn core::iter::traits::iterator::Iterator::try_for_each<'_0, Self, F, R>(@1: &'_0 mut (Self), @2: F) -> R
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<R>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::function::FnMut<F, (Self::Item)>,
    [@TraitClause4]: core::ops::try_trait::Try<R>,
    (parents(@TraitClause3)::[@TraitClause0])::Output = R,
    @TraitClause4::Output = (),

fn core::iter::traits::iterator::Iterator::fold<Self, B, F>(@1: Self, @2: B, @3: F) -> B
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::function::FnMut<F, (B, Self::Item)>,
    (parents(@TraitClause3)::[@TraitClause0])::Output = B,

fn core::iter::traits::iterator::Iterator::reduce<Self, F>(@1: Self, @2: F) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::ops::function::FnMut<F, (Self::Item, Self::Item)>,
    (parents(@TraitClause2)::[@TraitClause0])::Output = Self::Item,

fn core::iter::traits::iterator::Iterator::try_reduce<'_0, Self, R, impl FnMut(Self::Item, Self::Item) -> R>(@1: &'_0 mut (Self), @2: impl FnMut(Self::Item, Self::Item) -> R) -> @TraitClause4::TryType
where
    [@TraitClause0]: core::marker::Sized<R>,
    [@TraitClause1]: core::marker::Sized<impl FnMut(Self::Item, Self::Item) -> R>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::try_trait::Try<R>,
    [@TraitClause4]: core::ops::try_trait::Residual<@TraitClause3::Residual, core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>>,
    [@TraitClause5]: core::ops::function::FnMut<impl FnMut(Self::Item, Self::Item) -> R, (Self::Item, Self::Item)>,
    @TraitClause3::Output = Self::Item,
    (parents(@TraitClause5)::[@TraitClause0])::Output = R,

fn core::iter::traits::iterator::Iterator::all<'_0, Self, F>(@1: &'_0 mut (Self), @2: F) -> bool
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::ops::function::FnMut<F, (Self::Item)>,
    (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::any<'_0, Self, F>(@1: &'_0 mut (Self), @2: F) -> bool
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::ops::function::FnMut<F, (Self::Item)>,
    (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::find<'_0, Self, P>(@1: &'_0 mut (Self), @2: P) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0> core::ops::function::FnMut<P, (&'_1_0 (Self::Item))>,
    for<'_1_0> (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::find_map<'_0, Self, B, F>(@1: &'_0 mut (Self), @2: F) -> core::option::Option<B, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::function::FnMut<F, (Self::Item)>,
    (parents(@TraitClause3)::[@TraitClause0])::Output = core::option::Option<B, @TraitClause0>,

fn core::iter::traits::iterator::Iterator::try_find<'_0, Self, R, impl FnMut(&Self::Item) -> R>(@1: &'_0 mut (Self), @2: impl FnMut(&Self::Item) -> R) -> @TraitClause4::TryType
where
    [@TraitClause0]: core::marker::Sized<R>,
    [@TraitClause1]: core::marker::Sized<impl FnMut(&Self::Item) -> R>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::try_trait::Try<R>,
    [@TraitClause4]: core::ops::try_trait::Residual<@TraitClause3::Residual, core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>>,
    [@TraitClause5]: for<'_1_0> core::ops::function::FnMut<impl FnMut(&Self::Item) -> R, (&'_1_0 (Self::Item))>,
    @TraitClause3::Output = bool,
    for<'_1_0> (parents(@TraitClause5)::[@TraitClause0])::Output = R,

fn core::iter::traits::iterator::Iterator::position<'_0, Self, P>(@1: &'_0 mut (Self), @2: P) -> core::option::Option<usize, core::marker::Sized<usize>>
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::ops::function::FnMut<P, (Self::Item)>,
    (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::rposition<'_0, Self, P>(@1: &'_0 mut (Self), @2: P) -> core::option::Option<usize, core::marker::Sized<usize>>
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::ops::function::FnMut<P, (Self::Item)>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::iter::traits::exact_size::ExactSizeIterator<Self>,
    [@TraitClause4]: core::iter::traits::double_ended::DoubleEndedIterator<Self>,
    (parents(@TraitClause1)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::max<Self>(@1: Self) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<Self>,
    [@TraitClause1]: core::cmp::Ord<Self::Item>,

fn core::iter::traits::iterator::Iterator::min<Self>(@1: Self) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<Self>,
    [@TraitClause1]: core::cmp::Ord<Self::Item>,

fn core::iter::traits::iterator::Iterator::max_by_key<Self, B, F>(@1: Self, @2: F) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::cmp::Ord<B>,
    [@TraitClause3]: core::marker::Sized<Self>,
    [@TraitClause4]: for<'_1_0> core::ops::function::FnMut<F, (&'_1_0 (Self::Item))>,
    for<'_1_0> (parents(@TraitClause4)::[@TraitClause0])::Output = B,

fn core::iter::traits::iterator::Iterator::max_by<Self, F>(@1: Self, @2: F) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0, '_1_1> core::ops::function::FnMut<F, (&'_1_0 (Self::Item), &'_1_1 (Self::Item))>,
    for<'_1_0, '_1_1> (parents(@TraitClause2)::[@TraitClause0])::Output = core::cmp::Ordering,

fn core::iter::traits::iterator::Iterator::min_by_key<Self, B, F>(@1: Self, @2: F) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::cmp::Ord<B>,
    [@TraitClause3]: core::marker::Sized<Self>,
    [@TraitClause4]: for<'_1_0> core::ops::function::FnMut<F, (&'_1_0 (Self::Item))>,
    for<'_1_0> (parents(@TraitClause4)::[@TraitClause0])::Output = B,

fn core::iter::traits::iterator::Iterator::min_by<Self, F>(@1: Self, @2: F) -> core::option::Option<Self::Item, (parents(Self)::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0, '_1_1> core::ops::function::FnMut<F, (&'_1_0 (Self::Item), &'_1_1 (Self::Item))>,
    for<'_1_0, '_1_1> (parents(@TraitClause2)::[@TraitClause0])::Output = core::cmp::Ordering,

fn core::iter::traits::iterator::Iterator::rev<Self>(@1: Self) -> core::iter::adapters::rev::Rev<Self, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<Self>,
    [@TraitClause1]: core::iter::traits::double_ended::DoubleEndedIterator<Self>,

fn core::iter::traits::iterator::Iterator::unzip<Self, A, B, FromA, FromB>(@1: Self) -> (FromA, FromB)
where
    [@TraitClause0]: core::marker::Sized<A>,
    [@TraitClause1]: core::marker::Sized<B>,
    [@TraitClause2]: core::marker::Sized<FromA>,
    [@TraitClause3]: core::marker::Sized<FromB>,
    [@TraitClause4]: core::default::Default<FromA>,
    [@TraitClause5]: core::iter::traits::collect::Extend<FromA, A>,
    [@TraitClause6]: core::default::Default<FromB>,
    [@TraitClause7]: core::iter::traits::collect::Extend<FromB, B>,
    [@TraitClause8]: core::marker::Sized<Self>,
    [@TraitClause9]: core::iter::traits::iterator::Iterator<Self>,
    Self::Item = (A, B),

fn core::iter::traits::iterator::Iterator::copied<'a, Self, T>(@1: Self) -> core::iter::adapters::copied::Copied<Self, @TraitClause1>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::iter::traits::iterator::Iterator<Self>,
    [@TraitClause3]: core::marker::Copy<T>,
    T : 'a,
    Self::Item = &'a (T),

fn core::iter::traits::iterator::Iterator::cloned<'a, Self, T>(@1: Self) -> core::iter::adapters::cloned::Cloned<Self, @TraitClause1>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::iter::traits::iterator::Iterator<Self>,
    [@TraitClause3]: core::clone::Clone<T>,
    T : 'a,
    Self::Item = &'a (T),

fn core::iter::traits::iterator::Iterator::cycle<Self>(@1: Self) -> core::iter::adapters::cycle::Cycle<Self, @TraitClause0>
where
    [@TraitClause0]: core::marker::Sized<Self>,
    [@TraitClause1]: core::clone::Clone<Self>,

fn core::iter::traits::iterator::Iterator::array_chunks<Self, const N : usize>(@1: Self) -> core::iter::adapters::array_chunks::ArrayChunks<Self, const N : usize, @TraitClause0, Self>
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::sum<Self, S>(@1: Self) -> S
where
    [@TraitClause0]: core::marker::Sized<S>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::iter::traits::accum::Sum<S, Self::Item>,

fn core::iter::traits::iterator::Iterator::product<Self, P>(@1: Self) -> P
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: core::iter::traits::accum::Product<P, Self::Item>,

fn core::iter::traits::iterator::Iterator::cmp<Self, I>(@1: Self, @2: I) -> core::cmp::Ordering
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause2]: core::cmp::Ord<Self::Item>,
    [@TraitClause3]: core::marker::Sized<Self>,
    @TraitClause1::Item = Self::Item,

fn core::iter::traits::iterator::Iterator::cmp_by<Self, I, F>(@1: Self, @2: I, @3: F) -> core::cmp::Ordering
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause4]: core::ops::function::FnMut<F, (Self::Item, @TraitClause3::Item)>,
    (parents(@TraitClause4)::[@TraitClause0])::Output = core::cmp::Ordering,

fn core::iter::traits::iterator::Iterator::partial_cmp<Self, I>(@1: Self, @2: I) -> core::option::Option<core::cmp::Ordering, core::marker::Sized<core::cmp::Ordering>>
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause2]: core::cmp::PartialOrd<Self::Item, @TraitClause1::Item>,
    [@TraitClause3]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::partial_cmp_by<Self, I, F>(@1: Self, @2: I, @3: F) -> core::option::Option<core::cmp::Ordering, core::marker::Sized<core::cmp::Ordering>>
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause4]: core::ops::function::FnMut<F, (Self::Item, @TraitClause3::Item)>,
    (parents(@TraitClause4)::[@TraitClause0])::Output = core::option::Option<core::cmp::Ordering, core::marker::Sized<core::cmp::Ordering>>,

fn core::iter::traits::iterator::Iterator::eq<Self, I>(@1: Self, @2: I) -> bool
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause2]: core::cmp::PartialEq<Self::Item, @TraitClause1::Item>,
    [@TraitClause3]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::eq_by<Self, I, F>(@1: Self, @2: I, @3: F) -> bool
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause4]: core::ops::function::FnMut<F, (Self::Item, @TraitClause3::Item)>,
    (parents(@TraitClause4)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::ne<Self, I>(@1: Self, @2: I) -> bool
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause2]: core::cmp::PartialEq<Self::Item, @TraitClause1::Item>,
    [@TraitClause3]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::lt<Self, I>(@1: Self, @2: I) -> bool
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause2]: core::cmp::PartialOrd<Self::Item, @TraitClause1::Item>,
    [@TraitClause3]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::le<Self, I>(@1: Self, @2: I) -> bool
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause2]: core::cmp::PartialOrd<Self::Item, @TraitClause1::Item>,
    [@TraitClause3]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::gt<Self, I>(@1: Self, @2: I) -> bool
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause2]: core::cmp::PartialOrd<Self::Item, @TraitClause1::Item>,
    [@TraitClause3]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::ge<Self, I>(@1: Self, @2: I) -> bool
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<I>,
    [@TraitClause2]: core::cmp::PartialOrd<Self::Item, @TraitClause1::Item>,
    [@TraitClause3]: core::marker::Sized<Self>,

fn core::iter::traits::iterator::Iterator::is_sorted<Self>(@1: Self) -> bool
where
    [@TraitClause0]: core::marker::Sized<Self>,
    [@TraitClause1]: core::cmp::PartialOrd<Self::Item, Self::Item>,

fn core::iter::traits::iterator::Iterator::is_sorted_by<Self, F>(@1: Self, @2: F) -> bool
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0, '_1_1> core::ops::function::FnMut<F, (&'_1_0 (Self::Item), &'_1_1 (Self::Item))>,
    for<'_1_0, '_1_1> (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::iterator::Iterator::is_sorted_by_key<Self, F, K>(@1: Self, @2: F) -> bool
where
    [@TraitClause0]: core::marker::Sized<F>,
    [@TraitClause1]: core::marker::Sized<K>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::function::FnMut<F, (Self::Item)>,
    [@TraitClause4]: core::cmp::PartialOrd<K, K>,
    (parents(@TraitClause3)::[@TraitClause0])::Output = K,

unsafe fn core::iter::traits::iterator::Iterator::__iterator_get_unchecked<'_0, Self>(@1: &'_0 mut (Self), @2: usize) -> Self::Item
where
    [@TraitClause0]: core::iter::adapters::zip::TrustedRandomAccessNoCoerce<Self>,

fn core::slice::index::SliceIndex::get<'_0, Self, T>(@1: Self, @2: &'_0 (T)) -> core::option::Option<&'_0 (Self::Output), core::marker::Sized<&'_1_0 (Self::Output)>>

fn core::slice::index::SliceIndex::get_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut (T)) -> core::option::Option<&'_0 mut (Self::Output), core::marker::Sized<&'_1_0 mut (Self::Output)>>

unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T>(@1: Self, @2: *const T) -> *const Self::Output

unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T>(@1: Self, @2: *mut T) -> *mut Self::Output

fn core::slice::index::SliceIndex::index<'_0, Self, T>(@1: Self, @2: &'_0 (T)) -> &'_0 (Self::Output)

fn core::slice::index::SliceIndex::index_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut (T)) -> &'_0 mut (Self::Output)

fn core::ops::index::Index::index<'_0, Self, Idx>(@1: &'_0 (Self), @2: Idx) -> &'_0 (Self::Output)

fn core::cmp::Ord::cmp<'_0, '_1, Self>(@1: &'_0 (Self), @2: &'_1 (Self)) -> core::cmp::Ordering

fn core::cmp::Ord::max<Self>(@1: Self, @2: Self) -> Self
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::cmp::Ord::min<Self>(@1: Self, @2: Self) -> Self
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::cmp::Ord::clamp<Self>(@1: Self, @2: Self, @3: Self) -> Self
where
    [@TraitClause0]: core::marker::Sized<Self>,
    [@TraitClause1]: core::cmp::PartialOrd<Self, Self>,

fn core::cmp::Eq::assert_receiver_is_total_eq<'_0, Self>(@1: &'_0 (Self))

fn core::iter::adapters::zip::TrustedRandomAccessNoCoerce::size<'_0, Self>(@1: &'_0 (Self)) -> usize
where
    [@TraitClause0]: core::iter::traits::iterator::Iterator<Self>,

fn core::ops::function::FnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut (Self), @2: Args) -> (parents(Self)::[@TraitClause0])::Output

fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> Self::Output

fn core::iter::traits::collect::FromIterator::from_iter<Self, A, T>(@1: T) -> Self
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<T>,
    @TraitClause1::Item = A,

fn core::ops::try_trait::Try::from_output<Self>(@1: Self::Output) -> Self

fn core::ops::try_trait::Try::branch<Self>(@1: Self) -> core::ops::control_flow::ControlFlow<Self::Residual, Self::Output, (parents((parents(Self)::[@TraitClause0]))::[@TraitClause0]), (parents(Self)::[@TraitClause1])>

fn core::ops::try_trait::FromResidual::from_residual<Self, R>(@1: R) -> Self

fn core::iter::traits::collect::Extend::extend<'_0, Self, A, T>(@1: &'_0 mut (Self), @2: T)
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::iter::traits::collect::IntoIterator<T>,
    @TraitClause1::Item = A,

fn core::iter::traits::collect::Extend::extend_one<'_0, Self, A>(@1: &'_0 mut (Self), @2: A)

fn core::iter::traits::collect::Extend::extend_reserve<'_0, Self, A>(@1: &'_0 mut (Self), @2: usize)

unsafe fn core::iter::traits::collect::Extend::extend_one_unchecked<'_0, Self, A>(@1: &'_0 mut (Self), @2: A)
where
    [@TraitClause0]: core::marker::Sized<Self>,

fn core::default::Default::default<Self>() -> Self

fn core::iter::traits::double_ended::DoubleEndedIterator::next_back<'_0, Self>(@1: &'_0 mut (Self)) -> core::option::Option<(parents(Self)::[@TraitClause0])::Item, (parents((parents(Self)::[@TraitClause0]))::[@TraitClause0])>

fn core::iter::traits::double_ended::DoubleEndedIterator::advance_back_by<'_0, Self>(@1: &'_0 mut (Self), @2: usize) -> core::result::Result<(), core::num::nonzero::NonZero<usize, core::marker::Sized<usize>, core::num::nonzero::{impl core::num::nonzero::ZeroablePrimitive for usize}#26>, core::marker::Sized<()>, core::marker::Sized<core::num::nonzero::NonZero<usize, core::marker::Sized<usize>, core::num::nonzero::{impl core::num::nonzero::ZeroablePrimitive for usize}#26>>>

fn core::iter::traits::double_ended::DoubleEndedIterator::nth_back<'_0, Self>(@1: &'_0 mut (Self), @2: usize) -> core::option::Option<(parents(Self)::[@TraitClause0])::Item, (parents((parents(Self)::[@TraitClause0]))::[@TraitClause0])>

fn core::iter::traits::double_ended::DoubleEndedIterator::try_rfold<'_0, Self, B, F, R>(@1: &'_0 mut (Self), @2: B, @3: F) -> R
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<R>,
    [@TraitClause3]: core::marker::Sized<Self>,
    [@TraitClause4]: core::ops::function::FnMut<F, (B, (parents(Self)::[@TraitClause0])::Item)>,
    [@TraitClause5]: core::ops::try_trait::Try<R>,
    (parents(@TraitClause4)::[@TraitClause0])::Output = R,
    @TraitClause5::Output = B,

fn core::iter::traits::double_ended::DoubleEndedIterator::rfold<Self, B, F>(@1: Self, @2: B, @3: F) -> B
where
    [@TraitClause0]: core::marker::Sized<B>,
    [@TraitClause1]: core::marker::Sized<F>,
    [@TraitClause2]: core::marker::Sized<Self>,
    [@TraitClause3]: core::ops::function::FnMut<F, (B, (parents(Self)::[@TraitClause0])::Item)>,
    (parents(@TraitClause3)::[@TraitClause0])::Output = B,

fn core::iter::traits::double_ended::DoubleEndedIterator::rfind<'_0, Self, P>(@1: &'_0 mut (Self), @2: P) -> core::option::Option<(parents(Self)::[@TraitClause0])::Item, (parents((parents(Self)::[@TraitClause0]))::[@TraitClause0])>
where
    [@TraitClause0]: core::marker::Sized<P>,
    [@TraitClause1]: core::marker::Sized<Self>,
    [@TraitClause2]: for<'_1_0> core::ops::function::FnMut<P, (&'_1_0 ((parents(Self)::[@TraitClause0])::Item))>,
    for<'_1_0> (parents(@TraitClause2)::[@TraitClause0])::Output = bool,

fn core::iter::traits::exact_size::ExactSizeIterator::len<'_0, Self>(@1: &'_0 (Self)) -> usize

fn core::iter::traits::exact_size::ExactSizeIterator::is_empty<'_0, Self>(@1: &'_0 (Self)) -> bool

fn core::iter::traits::accum::Sum::sum<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::iterator::Iterator<I>,
    @TraitClause1::Item = A,

fn core::iter::traits::accum::Product::product<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: core::marker::Sized<I>,
    [@TraitClause1]: core::iter::traits::iterator::Iterator<I>,
    @TraitClause1::Item = A,



