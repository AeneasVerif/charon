# Final LLBC before serialization:

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub opaque type Layout

// Full name: core::intrinsics::offset_of
#[lang_item("offset_of")]
pub fn offset_of<T>(@1: u32, @2: u32) -> usize
= <opaque>

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::mem::size_of
#[lang_item("mem_size_of")]
pub fn size_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::mem::align_of
#[lang_item("mem_align_of")]
pub fn align_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::f32::{f32}::MAX
pub fn MAX() -> f32
= <opaque>

// Full name: core::f32::{f32}::MAX
pub const MAX: f32 = MAX()

// Full name: core::f64::{f64}::MIN
pub fn MIN() -> f64
= <opaque>

// Full name: core::f64::{f64}::MIN
pub const MIN: f64 = MIN()

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args>[Self]
    vtable: core::ops::function::FnOnce::{vtable}<Args, Self::Output>
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0_1> = core::ops::function::FnMut::call_mut<'_0_1, Self, Args>[Self]
    vtable: core::ops::function::FnMut::{vtable}<Args, Self::parent_clause1::Output>
}

// Full name: core::ops::function::Fn
#[lang_item("r#fn")]
pub trait Fn<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnMut<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call<'_0_1> = core::ops::function::Fn::call<'_0_1, Self, Args>[Self]
    vtable: core::ops::function::Fn::{vtable}<Args, Self::parent_clause1::parent_clause1::Output>
}

pub fn core::ops::function::Fn::call<'_0, Self, Args>(@1: &'_0 Self, @2: Args) -> @TraitClause0::parent_clause1::parent_clause1::Output
where
    [@TraitClause0]: Fn<Self, Args>,
= <opaque>

pub fn core::ops::function::FnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut Self, @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,
= <opaque>

pub fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,
= <opaque>

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::alloc::exchange_malloc
#[lang_item("exchange_malloc")]
unsafe fn exchange_malloc(@1: usize, @2: usize) -> *mut u8
= <opaque>

// Full name: alloc::boxed::Box::{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop_in_place
unsafe fn {impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop_in_place<T, A>(@1: *mut alloc::boxed::Box<T>[@TraitClause0, @TraitClause1])
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
= <opaque>

// Full name: alloc::boxed::Box::{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}
impl<T, A> Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
{
    fn drop_in_place = {impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop_in_place<T, A>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::addr_of
fn addr_of()
{
    let _0: (); // return
    let x_1: u32; // local
    let _2: *const u32; // anonymous local
    let _3: &'0 u32; // anonymous local
    let _4: *const u32; // anonymous local
    let _5: *mut u32; // anonymous local

    _0 = ()
    storage_live(x_1)
    x_1 = const (0 : u32)
    storage_live(_2)
    storage_live(_3)
    _3 = &x_1
    _2 = &raw const *(_3)
    storage_dead(_3)
    storage_dead(_2)
    storage_live(_4)
    _4 = &raw const x_1
    storage_dead(_4)
    storage_live(_5)
    _5 = &raw mut x_1
    storage_dead(_5)
    _0 = ()
    storage_dead(x_1)
    return
}

// Full name: test_crate::literal_casts
fn literal_casts()
{
    let _0: (); // return
    let _1: u8; // anonymous local
    let _2: u64; // anonymous local
    let _3: f64; // anonymous local
    let _4: u64; // anonymous local
    let _5: f64; // anonymous local

    _0 = ()
    storage_live(_1)
    _1 = cast<u64, u8>(const (0 : u64))
    storage_dead(_1)
    storage_live(_2)
    _2 = cast<u8, u64>(const (0 : u8))
    storage_dead(_2)
    storage_live(_3)
    _3 = cast<u64, f64>(const (0 : u64))
    storage_dead(_3)
    storage_live(_4)
    _4 = cast<f64, u64>(copy (MIN))
    storage_dead(_4)
    storage_live(_5)
    _5 = cast<f32, f64>(copy (MAX))
    storage_dead(_5)
    _0 = ()
    return
}

fn test_crate::ptr_casts::foo()
{
    let _0: (); // return

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::ptr_casts
fn ptr_casts()
{
    let _0: (); // return
    let array_ptr_1: *const [u32; 64 : usize]; // local
    let _2: &'0 [u32; 64 : usize]; // anonymous local
    let _3: *const u32; // anonymous local
    let _4: *const [u32; 64 : usize]; // anonymous local
    let x_5: u8; // local
    let x_6: *const u8; // local
    let _7: &'1 u8; // anonymous local
    let _8: *const u8; // anonymous local
    let _9: *const u8; // anonymous local
    let _10: *mut u8; // anonymous local
    let _11: *const u8; // anonymous local
    let _12: usize; // anonymous local
    let _13: *const u8; // anonymous local
    let _14: *const u8; // anonymous local
    let _15: *const u8; // anonymous local
    let _16: fn(); // anonymous local
    let _17: &'0 [u32; 64 : usize]; // anonymous local
    let _18: &'_ [u32; 64 : usize]; // anonymous local
    let _19: [u32; 64 : usize]; // anonymous local

    storage_live(_18)
    storage_live(_19)
    _19 = @ArrayRepeat<'_, u32, 64 : usize>(const (0 : u32))
    _18 = &_19
    storage_live(_17)
    _0 = ()
    storage_live(array_ptr_1)
    storage_live(_2)
    _17 = move (_18)
    _2 = &*(_17)
    array_ptr_1 = &raw const *(_2)
    storage_dead(_2)
    storage_live(_3)
    storage_live(_4)
    _4 = copy (array_ptr_1)
    _3 = cast<*const [u32; 64 : usize], *const u32>(move (_4))
    storage_dead(_4)
    storage_dead(_3)
    storage_live(x_5)
    x_5 = const (0 : u8)
    storage_live(x_6)
    storage_live(_7)
    _7 = &x_5
    x_6 = &raw const *(_7)
    storage_dead(_7)
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    storage_live(_11)
    _11 = copy (x_6)
    _10 = cast<*const u8, *mut u8>(move (_11))
    _9 = cast<*mut u8, *const u8>(move (_10))
    storage_dead(_11)
    storage_dead(_10)
    _8 = cast<*const u8, *const u8>(move (_9))
    storage_dead(_9)
    storage_dead(_8)
    storage_live(_12)
    storage_live(_13)
    _13 = copy (x_6)
    _12 = cast<*const u8, usize>(move (_13))
    storage_dead(_13)
    storage_dead(_12)
    storage_live(_14)
    _14 = cast<usize, *const u8>(const (0 : usize))
    storage_dead(_14)
    storage_live(_15)
    storage_live(_16)
    _16 = cast<test_crate::ptr_casts::foo, fn()>(const (test_crate::ptr_casts::foo))
    _15 = cast<fn(), *const u8>(move (_16))
    storage_dead(_16)
    storage_dead(_15)
    _0 = ()
    storage_dead(x_6)
    storage_dead(x_5)
    storage_dead(array_ptr_1)
    return
}

// Full name: test_crate::fn_casts::closure
struct closure {}

fn test_crate::fn_casts::foo()
{
    let _0: (); // return

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::fn_casts::bar
unsafe fn bar()
{
    let _0: (); // return

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::fn_casts::{impl Fn<(u8)> for closure}::call
fn {impl Fn<(u8)> for closure}::call<'_0>(@1: &'_0 closure, @2: (u8))
{
    let _0: (); // return
    let _1: &'0 closure; // arg #1
    let tupled_args_2: (u8); // arg #2
    let _3: u8; // anonymous local

    storage_live(_3)
    _0 = ()
    _3 = move ((tupled_args_2).0)
    _0 = ()
    return
}

// Full name: test_crate::fn_casts::{impl FnMut<(u8)> for closure}::call_mut
fn {impl FnMut<(u8)> for closure}::call_mut<'_0>(@1: &'_0 mut closure, @2: (u8))
{
    let _0: (); // return
    let state_1: &'_0 mut closure; // arg #1
    let args_2: (u8); // arg #2
    let _3: &'0 closure; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = &*(state_1)
    _0 = {impl Fn<(u8)> for closure}::call<'2>(move (_3), move (args_2))
    return
}

// Full name: test_crate::fn_casts::closure::{impl Destruct for closure}::drop_in_place
unsafe fn {impl Destruct for closure}::drop_in_place(@1: *mut closure)
= <missing>

// Full name: test_crate::fn_casts::closure::{impl Destruct for closure}
impl Destruct for closure {
    fn drop_in_place = {impl Destruct for closure}::drop_in_place
    non-dyn-compatible
}

// Full name: test_crate::fn_casts::{impl FnOnce<(u8)> for closure}::call_once
fn {impl FnOnce<(u8)> for closure}::call_once(@1: closure, @2: (u8))
{
    let _0: (); // return
    let _1: closure; // arg #1
    let _2: (u8); // arg #2
    let _3: &'0 mut closure; // anonymous local

    storage_live(_3)
    _0 = ()
    _3 = &mut _1
    _0 = {impl FnMut<(u8)> for closure}::call_mut<'_>(move (_3), move (_2))
    drop[{impl Destruct for closure}] _1
    return
}

// Full name: test_crate::fn_casts::closure::as_fn
fn as_fn(@1: u8)
{
    let _0: (); // return
    let arg1_1: u8; // arg #1
    let args_2: (u8); // local
    let state_3: closure; // local

    _0 = ()
    storage_live(args_2)
    storage_live(state_3)
    args_2 = (move (arg1_1))
    state_3 = closure {  }
    _0 = {impl FnOnce<(u8)> for closure}::call_once(move (state_3), move (args_2))
    return
}

// Full name: test_crate::fn_casts
fn fn_casts()
{
    let _0: (); // return
    let _1: fn(); // anonymous local
    let _2: unsafe fn(); // anonymous local
    let closure_3: closure; // local
    let _4: fn(u8); // anonymous local
    let _5: closure; // anonymous local
    let _6: unsafe fn(u8); // anonymous local
    let _7: closure; // anonymous local

    _0 = ()
    storage_live(_1)
    _1 = cast<test_crate::fn_casts::foo, fn()>(const (test_crate::fn_casts::foo))
    storage_dead(_1)
    storage_live(_2)
    _2 = cast<bar, unsafe fn()>(const (bar))
    storage_dead(_2)
    storage_live(closure_3)
    closure_3 = closure {  }
    storage_live(_4)
    storage_live(_5)
    _5 = copy (closure_3)
    _4 = cast<as_fn, fn(u8)>(const (as_fn))
    storage_dead(_5)
    storage_dead(_4)
    storage_live(_6)
    storage_live(_7)
    _7 = copy (closure_3)
    _6 = cast<as_fn, unsafe fn(u8)>(const (as_fn))
    storage_dead(_7)
    storage_dead(_6)
    _0 = ()
    storage_dead(closure_3)
    return
}

// Full name: test_crate::fn_casts::{impl FnOnce<(u8)> for closure}
impl FnOnce<(u8)> for closure {
    parent_clause0 = {built_in impl MetaSized for closure}
    parent_clause1 = {built_in impl Sized for (u8)}
    parent_clause2 = {built_in impl Tuple for (u8)}
    parent_clause3 = {built_in impl Sized for ()}
    type Output = ()
    fn call_once = {impl FnOnce<(u8)> for closure}::call_once
    non-dyn-compatible
}

// Full name: test_crate::fn_casts::{impl FnMut<(u8)> for closure}
impl FnMut<(u8)> for closure {
    parent_clause0 = {built_in impl MetaSized for closure}
    parent_clause1 = {impl FnOnce<(u8)> for closure}
    parent_clause2 = {built_in impl Sized for (u8)}
    parent_clause3 = {built_in impl Tuple for (u8)}
    fn call_mut<'_0_1> = {impl FnMut<(u8)> for closure}::call_mut<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::fn_casts::{impl Fn<(u8)> for closure}
impl Fn<(u8)> for closure {
    parent_clause0 = {built_in impl MetaSized for closure}
    parent_clause1 = {impl FnMut<(u8)> for closure}
    parent_clause2 = {built_in impl Sized for (u8)}
    parent_clause3 = {built_in impl Tuple for (u8)}
    fn call<'_0_1> = {impl Fn<(u8)> for closure}::call<'_0_1>
    non-dyn-compatible
}

// Full name: test_crate::boxes
fn boxes()
{
    let _0: (); // return
    let _1: alloc::boxed::Box<i32>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}]; // anonymous local
    let _2: alloc::boxed::Box<i32>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}]; // anonymous local

    _0 = ()
    storage_live(_1)
    storage_live(_2)
    _2 = @BoxNew<i32>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}](const (42 : i32))
    _1 = move (_2)
    conditional_drop[{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}]] _2
    storage_dead(_2)
    conditional_drop[{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}]] _1
    storage_dead(_1)
    _0 = ()
    return
}

// Full name: test_crate::STEAL
fn STEAL() -> [(); 1 : usize]
{
    let _0: [(); 1 : usize]; // return
    let _1: (); // anonymous local

    storage_live(_1)
    _1 = ()
    _0 = @ArrayRepeat<'_, (), 1 : usize>(move (_1))
    storage_dead(_1)
    return
}

// Full name: test_crate::STEAL
static STEAL: [(); 1 : usize] = STEAL()

// Full name: test_crate::transmute
fn transmute(@1: [u32; 2 : usize]) -> u64
{
    let _0: u64; // return
    let x_1: [u32; 2 : usize]; // arg #1
    let _2: [u32; 2 : usize]; // anonymous local

    storage_live(_2)
    // When optimized, this becomes a built-in cast. Otherwise this is just a call to `transmute`.
    _2 = copy (x_1)
    _0 = transmute<[u32; 2 : usize], u64>(move (_2))
    storage_dead(_2)
    return
}

// Full name: test_crate::STEAL2
fn STEAL2() -> [(); 13 : usize]
{
    let _0: [(); 13 : usize]; // return
    let _1: (); // anonymous local

    storage_live(_1)
    _1 = ()
    _0 = @ArrayRepeat<'_, (), 13 : usize>(move (_1))
    storage_dead(_1)
    return
}

// Full name: test_crate::STEAL2
static STEAL2: [(); 13 : usize] = STEAL2()

// Full name: test_crate::nullary_ops::Struct
struct Struct<T>
where
    [@TraitClause0]: Sized<T>,
{
  a: u8,
  b: T,
}

// Full name: test_crate::nullary_ops
fn nullary_ops<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return
    let size_1: usize; // local
    let align_2: usize; // local
    let ub_3: bool; // local
    let offset_4: usize; // local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local
    let _11: bool; // anonymous local
    let _12: usize; // anonymous local
    let _13: usize; // anonymous local
    let _14: usize; // anonymous local
    let _15: usize; // anonymous local

    storage_live(_9)
    storage_live(_12)
    storage_live(_14)
    storage_live(size_1)
    size_1 = size_of<T>[@TraitClause0]()
    storage_live(align_2)
    align_2 = align_of<T>[@TraitClause0]()
    storage_live(_15)
    // This is `const (false)` in the MIR we get, but `true` in const evaluation.
    _15 = offset_of(Struct<T>[@TraitClause0].b)<usize>
    storage_live(ub_3)
    ub_3 = ub_checks<bool>
    storage_live(offset_4)
    offset_4 = move (_15)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    _7 = copy (size_1)
    storage_live(_8)
    _8 = copy (align_2)
    _9 = copy (_7) panic.+ copy (_8)
    _6 = move (_9)
    storage_dead(_8)
    storage_dead(_7)
    storage_live(_10)
    storage_live(_11)
    _11 = copy (ub_3)
    _10 = cast<bool, usize>(move (_11))
    storage_dead(_11)
    _12 = copy (_6) panic.+ copy (_10)
    _5 = move (_12)
    storage_dead(_10)
    storage_dead(_6)
    storage_live(_13)
    _13 = copy (offset_4)
    _14 = copy (_5) panic.+ copy (_13)
    _0 = move (_14)
    storage_dead(_13)
    storage_dead(_5)
    storage_dead(offset_4)
    storage_dead(ub_3)
    storage_dead(align_2)
    storage_dead(size_1)
    return
}



