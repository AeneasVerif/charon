# Final LLBC before serialization:

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::neg_test
pub fn neg_test(@1: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let _2: i32; // anonymous local

    storage_live(_2)
    _2 = copy (x_1)
    _0 = panic.-(move (_2))
    storage_dead(_2)
    return
}

// Full name: test_crate::add_u32
pub fn add_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local

    storage_live(_5)
    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _5 = copy (_3) panic.+ copy (_4)
    _0 = move (_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::incr
pub fn incr<'_0>(@1: &'_0 mut u32)
{
    let _0: (); // return
    let x_1: &'0 mut u32; // arg #1
    let _2: u32; // anonymous local

    storage_live(_2)
    _0 = ()
    _2 = copy (*(x_1)) panic.+ const (1 : u32)
    *(x_1) = move (_2)
    _0 = ()
    return
}

// Full name: test_crate::subs_u32
pub fn subs_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local

    storage_live(_5)
    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _5 = copy (_3) panic.- copy (_4)
    _0 = move (_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::div_u32
pub fn div_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _0 = move (_3) panic./ move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::div_u32_const
pub fn div_u32_const(@1: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let _2: u32; // anonymous local

    storage_live(_2)
    _2 = copy (x_1)
    _0 = move (_2) panic./ const (2 : u32)
    storage_dead(_2)
    return
}

// Full name: test_crate::rem_u32
pub fn rem_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _0 = move (_3) panic.% move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::mul_u32
pub fn mul_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local

    storage_live(_5)
    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _5 = copy (_3) panic.* copy (_4)
    _0 = move (_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::add_i32
pub fn add_i32(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local

    storage_live(_5)
    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _5 = copy (_3) panic.+ copy (_4)
    _0 = move (_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::subs_i32
pub fn subs_i32(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local

    storage_live(_5)
    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _5 = copy (_3) panic.- copy (_4)
    _0 = move (_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::div_i32
pub fn div_i32(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _0 = move (_3) panic./ move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::div_i32_const
pub fn div_i32_const(@1: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let _2: i32; // anonymous local

    storage_live(_2)
    _2 = copy (x_1)
    _0 = move (_2) panic./ const (2 : i32)
    storage_dead(_2)
    return
}

// Full name: test_crate::rem_i32
pub fn rem_i32(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _0 = move (_3) panic.% move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::mul_i32
pub fn mul_i32(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local

    storage_live(_5)
    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _5 = copy (_3) panic.* copy (_4)
    _0 = move (_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::mix_arith_u32
pub fn mix_arith_u32(@1: u32, @2: u32, @3: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let z_3: u32; // arg #3
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local
    let _7: u32; // anonymous local
    let _8: u32; // anonymous local
    let _9: u32; // anonymous local
    let _10: u32; // anonymous local
    let _11: u32; // anonymous local
    let _12: u32; // anonymous local
    let _13: u32; // anonymous local
    let _14: u32; // anonymous local
    let _15: u32; // anonymous local
    let _16: u32; // anonymous local
    let _17: u32; // anonymous local
    let _18: u32; // anonymous local
    let _19: u32; // anonymous local
    let _20: u32; // anonymous local
    let _21: u32; // anonymous local
    let _22: u32; // anonymous local
    let _23: u32; // anonymous local
    let _24: u32; // anonymous local
    let _25: u32; // anonymous local
    let _26: u32; // anonymous local
    let _27: u32; // anonymous local

    storage_live(_9)
    storage_live(_13)
    storage_live(_19)
    storage_live(_20)
    storage_live(_25)
    storage_live(_27)
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    _7 = copy (x_1)
    storage_live(_8)
    _8 = copy (y_2)
    _9 = copy (_7) panic.+ copy (_8)
    _6 = move (_9)
    storage_dead(_8)
    storage_dead(_7)
    storage_live(_10)
    storage_live(_11)
    _11 = copy (x_1)
    storage_live(_12)
    _12 = copy (y_2)
    _10 = move (_11) panic./ move (_12)
    storage_dead(_12)
    storage_dead(_11)
    _13 = copy (_6) panic.* copy (_10)
    _5 = move (_13)
    storage_dead(_10)
    storage_dead(_6)
    storage_live(_14)
    storage_live(_15)
    _15 = copy (x_1)
    storage_live(_16)
    storage_live(_17)
    _17 = copy (z_3)
    storage_live(_18)
    _18 = copy (y_2)
    _16 = move (_17) panic.% move (_18)
    storage_dead(_18)
    storage_dead(_17)
    _19 = copy (_15) panic.- copy (_16)
    _14 = move (_19)
    storage_dead(_16)
    storage_dead(_15)
    _20 = copy (_5) panic.+ copy (_14)
    _4 = move (_20)
    storage_dead(_14)
    storage_dead(_5)
    storage_live(_21)
    storage_live(_22)
    storage_live(_23)
    _23 = copy (x_1)
    storage_live(_24)
    _24 = copy (y_2)
    _25 = copy (_23) panic.+ copy (_24)
    _22 = move (_25)
    storage_dead(_24)
    storage_dead(_23)
    storage_live(_26)
    _26 = copy (z_3)
    _27 = copy (_22) panic.+ copy (_26)
    _21 = move (_27)
    storage_dead(_26)
    storage_dead(_22)
    _0 = move (_4) panic.% move (_21)
    storage_dead(_21)
    storage_dead(_4)
    return
}

// Full name: test_crate::mix_arith_i32
pub fn mix_arith_i32(@1: i32, @2: i32, @3: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let z_3: i32; // arg #3
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local
    let _6: i32; // anonymous local
    let _7: i32; // anonymous local
    let _8: i32; // anonymous local
    let _9: i32; // anonymous local
    let _10: i32; // anonymous local
    let _11: i32; // anonymous local
    let _12: i32; // anonymous local
    let _13: i32; // anonymous local
    let _14: i32; // anonymous local
    let _15: i32; // anonymous local
    let _16: i32; // anonymous local
    let _17: i32; // anonymous local
    let _18: i32; // anonymous local
    let _19: i32; // anonymous local
    let _20: i32; // anonymous local
    let _21: i32; // anonymous local
    let _22: i32; // anonymous local
    let _23: i32; // anonymous local
    let _24: i32; // anonymous local
    let _25: i32; // anonymous local
    let _26: i32; // anonymous local
    let _27: i32; // anonymous local

    storage_live(_9)
    storage_live(_13)
    storage_live(_19)
    storage_live(_20)
    storage_live(_25)
    storage_live(_27)
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    _7 = copy (x_1)
    storage_live(_8)
    _8 = copy (y_2)
    _9 = copy (_7) panic.+ copy (_8)
    _6 = move (_9)
    storage_dead(_8)
    storage_dead(_7)
    storage_live(_10)
    storage_live(_11)
    _11 = copy (x_1)
    storage_live(_12)
    _12 = copy (y_2)
    _10 = move (_11) panic./ move (_12)
    storage_dead(_12)
    storage_dead(_11)
    _13 = copy (_6) panic.* copy (_10)
    _5 = move (_13)
    storage_dead(_10)
    storage_dead(_6)
    storage_live(_14)
    storage_live(_15)
    _15 = copy (x_1)
    storage_live(_16)
    storage_live(_17)
    _17 = copy (z_3)
    storage_live(_18)
    _18 = copy (y_2)
    _16 = move (_17) panic.% move (_18)
    storage_dead(_18)
    storage_dead(_17)
    _19 = copy (_15) panic.- copy (_16)
    _14 = move (_19)
    storage_dead(_16)
    storage_dead(_15)
    _20 = copy (_5) panic.+ copy (_14)
    _4 = move (_20)
    storage_dead(_14)
    storage_dead(_5)
    storage_live(_21)
    storage_live(_22)
    storage_live(_23)
    _23 = copy (x_1)
    storage_live(_24)
    _24 = copy (y_2)
    _25 = copy (_23) panic.+ copy (_24)
    _22 = move (_25)
    storage_dead(_24)
    storage_dead(_23)
    storage_live(_26)
    _26 = copy (z_3)
    _27 = copy (_22) panic.+ copy (_26)
    _21 = move (_27)
    storage_dead(_26)
    storage_dead(_22)
    _0 = move (_4) panic.% move (_21)
    storage_dead(_21)
    storage_dead(_4)
    return
}

// Full name: test_crate::shl_u32
fn shl_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _0 = move (_3) panic.<< move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::shr_u32
fn shr_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _0 = move (_3) panic.>> move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::shr_add_u32
fn shr_add_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_6)
    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    storage_live(_5)
    _5 = copy (y_2)
    _6 = copy (_5) panic.+ const (1 : u32)
    _4 = move (_6)
    storage_dead(_5)
    _0 = move (_3) panic.>> move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::shl_i32
fn shl_i32(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _0 = move (_3) panic.<< move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::shr_i32
fn shr_i32(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    _4 = copy (y_2)
    _0 = move (_3) panic.>> move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::shr_i32_manual_cast
fn shr_i32_manual_cast(@1: i32, @2: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1
    let y_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: u32; // anonymous local
    let _5: i32; // anonymous local

    storage_live(_3)
    _3 = copy (x_1)
    storage_live(_4)
    storage_live(_5)
    _5 = copy (y_2)
    _4 = cast<i32, u32>(move (_5))
    storage_dead(_5)
    _0 = move (_3) panic.>> move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::index_slice_ignore_value
fn index_slice_ignore_value<'_0>(@1: &'_0 [u32])
{
    let _0: (); // return
    let x_1: &'0 [u32]; // arg #1
    let _2: usize; // anonymous local

    _0 = ()
    storage_live(_2)
    // FIXME: Bug: the bound check is removed but the place is not mentioned, so the translated
    // function doesn't panic on empty slices anymore.
    _2 = const (0 : usize)
    storage_dead(_2)
    _0 = ()
    return
}

pub fn test_crate::_() -> isize
{
    let _0: isize; // return
    let _1: isize; // anonymous local

    storage_live(_1)
    _1 = const (1 : isize) panic.+ const (1 : isize)
    _0 = move (_1)
    return
}

pub const test_crate::_: isize = test_crate::_()

pub fn test_crate::_#1() -> isize
{
    let _0: isize; // return
    let _1: isize; // anonymous local

    storage_live(_1)
    _1 = const (1 : isize) panic.- const (1 : isize)
    _0 = move (_1)
    return
}

pub const test_crate::_#1: isize = test_crate::_#1()

pub fn test_crate::_#2() -> isize
{
    let _0: isize; // return

    _0 = const (-1 : isize)
    return
}

pub const test_crate::_#2: isize = test_crate::_#2()

pub fn test_crate::_#3() -> isize
{
    let _0: isize; // return
    let _1: isize; // anonymous local

    storage_live(_1)
    _1 = const (2 : isize) panic.* const (2 : isize)
    _0 = move (_1)
    return
}

pub const test_crate::_#3: isize = test_crate::_#3()

pub fn test_crate::_#4() -> isize
{
    let _0: isize; // return

    _0 = const (2 : isize) panic.>> const (2 : i32)
    return
}

pub const test_crate::_#4: isize = test_crate::_#4()

pub fn test_crate::_#5() -> isize
{
    let _0: isize; // return

    _0 = const (2 : isize) panic.<< const (2 : i32)
    return
}

pub const test_crate::_#5: isize = test_crate::_#5()

pub fn test_crate::_#6() -> isize
{
    let _0: isize; // return

    _0 = const (2 : isize) panic.% const (2 : isize)
    return
}

pub const test_crate::_#6: isize = test_crate::_#6()

pub fn test_crate::_#7() -> isize
{
    let _0: isize; // return

    _0 = const (2 : isize) panic./ const (2 : isize)
    return
}

pub const test_crate::_#7: isize = test_crate::_#7()

pub fn test_crate::FOO() -> u32
{
    let _0: u32; // return

    _0 = const (10 : u32)
    return
}

pub const test_crate::FOO: u32 = test_crate::FOO()

pub fn test_crate::_#8() -> u32
{
    let _0: u32; // return
    let _1: u32; // anonymous local

    storage_live(_1)
    _1 = const (1 : u32) panic.+ copy (test_crate::FOO)
    _0 = move (_1)
    return
}

pub const test_crate::_#8: u32 = test_crate::_#8()

pub fn test_crate::_#9() -> u32
{
    let _0: u32; // return
    let _1: u32; // anonymous local

    storage_live(_1)
    _1 = const (10 : u32) panic.- copy (test_crate::FOO)
    _0 = move (_1)
    return
}

pub const test_crate::_#9: u32 = test_crate::_#9()

pub fn test_crate::_#10() -> u32
{
    let _0: u32; // return
    let _1: u32; // anonymous local

    storage_live(_1)
    _1 = const (2 : u32) panic.* copy (test_crate::FOO)
    _0 = move (_1)
    return
}

pub const test_crate::_#10: u32 = test_crate::_#10()

pub fn test_crate::_#11() -> u32
{
    let _0: u32; // return

    _0 = const (2 : u32) panic.>> copy (test_crate::FOO)
    return
}

pub const test_crate::_#11: u32 = test_crate::_#11()

pub fn test_crate::_#12() -> u32
{
    let _0: u32; // return

    _0 = const (2 : u32) panic.<< copy (test_crate::FOO)
    return
}

pub const test_crate::_#12: u32 = test_crate::_#12()

pub fn test_crate::_#13() -> u32
{
    let _0: u32; // return

    _0 = const (2 : u32) panic.% copy (test_crate::FOO)
    return
}

pub const test_crate::_#13: u32 = test_crate::_#13()

pub fn test_crate::_#14() -> u32
{
    let _0: u32; // return

    _0 = const (2 : u32) panic./ copy (test_crate::FOO)
    return
}

pub const test_crate::_#14: u32 = test_crate::_#14()

fn test_crate::div_signed_with_constant::FOO() -> i32
{
    let _0: i32; // return

    _0 = const (42 : i32)
    return
}

const test_crate::div_signed_with_constant::FOO: i32 = test_crate::div_signed_with_constant::FOO()

// Full name: test_crate::div_signed_with_constant
fn div_signed_with_constant() -> i32
{
    let _0: i32; // return

    _0 = copy (test_crate::div_signed_with_constant::FOO) panic./ const (2 : i32)
    return
}

// Full name: test_crate::div_unsigned_to_slice
fn div_unsigned_to_slice<'_0>(@1: &'_0 mut [u32], @2: u32)
{
    let _0: (); // return
    let result_1: &'0 mut [u32]; // arg #1
    let x_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: usize; // anonymous local
    let _5: &'_ mut [u32]; // anonymous local
    let _6: &'_ mut u32; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = copy (x_2)
    storage_live(_4)
    _4 = const (0 : usize)
    storage_live(_5)
    _5 = &mut *(result_1) with_metadata(copy (result_1.metadata))
    storage_live(_6)
    _6 = @SliceIndexMut<'_, u32>(move (_5), copy (_4))
    *(_6) = move (_3) panic./ const (3329 : u32)
    storage_dead(_3)
    storage_dead(_4)
    _0 = ()
    return
}

// Full name: test_crate::div_signed_to_slice
fn div_signed_to_slice<'_0>(@1: &'_0 mut [i32], @2: i32)
{
    let _0: (); // return
    let result_1: &'0 mut [i32]; // arg #1
    let x_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: usize; // anonymous local
    let _5: &'_ mut [i32]; // anonymous local
    let _6: &'_ mut i32; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = copy (x_2)
    storage_live(_4)
    _4 = const (0 : usize)
    storage_live(_5)
    _5 = &mut *(result_1) with_metadata(copy (result_1.metadata))
    storage_live(_6)
    _6 = @SliceIndexMut<'_, i32>(move (_5), copy (_4))
    *(_6) = move (_3) panic./ const (3329 : i32)
    storage_dead(_3)
    storage_dead(_4)
    _0 = ()
    return
}

// Full name: test_crate::add_to_slice
fn add_to_slice<'_0>(@1: &'_0 mut [u32], @2: u32)
{
    let _0: (); // return
    let result_1: &'0 mut [u32]; // arg #1
    let x_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: usize; // anonymous local
    let _6: &'_ mut [u32]; // anonymous local
    let _7: &'_ mut u32; // anonymous local

    storage_live(_4)
    _0 = ()
    storage_live(_3)
    _3 = copy (x_2)
    _4 = copy (_3) panic.+ const (1 : u32)
    storage_live(_5)
    _5 = const (0 : usize)
    storage_live(_6)
    _6 = &mut *(result_1) with_metadata(copy (result_1.metadata))
    storage_live(_7)
    _7 = @SliceIndexMut<'_, u32>(move (_6), copy (_5))
    *(_7) = move (_4)
    storage_dead(_3)
    storage_dead(_5)
    _0 = ()
    return
}

// Full name: test_crate::add_to_slice2
fn add_to_slice2<'_0>(@1: &'_0 mut [u8], @2: usize, @3: u8)
{
    let _0: (); // return
    let result_1: &'0 mut [u8]; // arg #1
    let i_2: usize; // arg #2
    let x_3: u8; // arg #3
    let _4: u8; // anonymous local
    let _5: u8; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'_ mut [u8]; // anonymous local
    let _10: &'_ mut u8; // anonymous local

    storage_live(_5)
    storage_live(_8)
    _0 = ()
    storage_live(_4)
    _4 = copy (x_3)
    _5 = copy (_4) panic.* const (7 : u8)
    storage_live(_6)
    storage_live(_7)
    _7 = copy (i_2)
    _8 = copy (_7) panic.+ const (1 : usize)
    _6 = move (_8)
    storage_dead(_7)
    storage_live(_9)
    _9 = &mut *(result_1) with_metadata(copy (result_1.metadata))
    storage_live(_10)
    _10 = @SliceIndexMut<'_, u8>(move (_9), copy (_6))
    *(_10) = move (_5)
    storage_dead(_4)
    storage_dead(_6)
    _0 = ()
    return
}



