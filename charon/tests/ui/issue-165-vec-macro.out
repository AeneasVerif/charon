# Final LLBC before serialization:

opaque type alloc::vec::Vec<T, A>

struct alloc::alloc::Global = {}

fn alloc::slice::{Slice<T>}::into_vec<T, A>(@1: alloc::boxed::Box<Slice<T>>) -> alloc::vec::Vec<T, A>

fn test_crate::foo()
{
    let @0: (); // return
    let _v@1: alloc::vec::Vec<i32, alloc::alloc::Global>; // local
    let @2: alloc::boxed::Box<Slice<i32>>; // anonymous local
    let @3: alloc::boxed::Box<Array<i32, 1 : usize>>; // anonymous local
    let @4: alloc::boxed::Box<Array<i32, 1 : usize>>; // anonymous local
    let @5: (); // anonymous local
    let @6: Array<i32, 1 : usize>; // anonymous local

    @6 := [const (1 : i32); 1 : usize]
    @4 := @BoxNew<Array<i32, 1 : usize>>(move (@6))
    @3 := move (@4)
    @2 := unsize_cast<alloc::boxed::Box<Array<i32, 1 : usize>>, alloc::boxed::Box<Slice<i32>>>(move (@3))
    drop @3
    drop @4
    drop @4
    drop @3
    _v@1 := alloc::slice::{Slice<T>}::into_vec<i32, alloc::alloc::Global>(move (@2))
    drop @2
    @fake_read(_v@1)
    @5 := ()
    @0 := move (@5)
    drop _v@1
    drop _v@1
    @0 := ()
    return
}

impl alloc::alloc::{impl @TraitDecl1 for alloc::alloc::Global}#1 : @TraitDecl1<alloc::alloc::Global>
{
    fn allocate = @Fun3
    fn deallocate = @Fun5
    fn allocate_zeroed = @Fun4
    fn grow = @Fun6
    fn grow_zeroed = @Fun7
    fn shrink = @Fun8
}

unsafe fn alloc::alloc::exchange_malloc(@1: usize, @2: usize) -> *mut u8



