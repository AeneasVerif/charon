# Final LLBC before serialization:

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::fmt::FormattingOptions
pub struct FormattingOptions {
  flags: u32,
  width: u16,
  precision: u16,
}

// Full name: core::fmt::flags::DEBUG_LOWER_HEX_FLAG
fn DEBUG_LOWER_HEX_FLAG() -> u32
{
    let _0: u32; // return

    _0 = const 1 : u32 panic.<< const 25 : i32
    return
}

// Full name: core::fmt::flags::DEBUG_LOWER_HEX_FLAG
const DEBUG_LOWER_HEX_FLAG: u32 = DEBUG_LOWER_HEX_FLAG()

// Full name: core::fmt::flags::DEBUG_UPPER_HEX_FLAG
fn DEBUG_UPPER_HEX_FLAG() -> u32
{
    let _0: u32; // return

    _0 = const 1 : u32 panic.<< const 26 : i32
    return
}

// Full name: core::fmt::flags::DEBUG_UPPER_HEX_FLAG
const DEBUG_UPPER_HEX_FLAG: u32 = DEBUG_UPPER_HEX_FLAG()

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

struct core::fmt::Debug::{vtable} {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn Debug)),
  method_fmt: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 (dyn Debug), &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}],
}

// Full name: core::fmt::Debug
#[lang_item("Debug")]
pub trait Debug<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::Debug::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::Debug::{vtable}
}

pub fn core::fmt::Debug::fmt<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: Debug<Self>,
= <method_without_default_body>

// Full name: core::fmt::num::{impl#1}::fmt
pub fn {impl#1}::fmt<'_0, '_1, '_2>(@1: &'_0 u32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <missing>

// Full name: core::fmt::num::{impl#3}::fmt
pub fn {impl#3}::fmt<'_0, '_1, '_2>(@1: &'_0 u32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <missing>

// Full name: core::fmt::num::imp::{impl#2}::fmt
pub fn {impl#2}::fmt<'_0, '_1, '_2>(@1: &'_0 u32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <missing>

// Full name: core::fmt::num::{impl Debug for u32}::fmt
pub fn {impl Debug for u32}::fmt<'_0, '_1, '_2>(@1: &'_0 u32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
{
    let _0: Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // return
    let self_1: &'0 u32; // arg #1
    let f_2: &'1 mut Formatter<'2>; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy (((*f_2)).0).flags
    _3 = move _4 & copy DEBUG_LOWER_HEX_FLAG
    storage_dead(_4)
    switch move _3 {
        0 : u32 => {
        },
        _ => {
            storage_dead(_3)
            _0 = {impl#1}::fmt<'6, '7, '8>(move self_1, move f_2)
            return
        },
    }
    storage_dead(_3)
    storage_live(_5)
    storage_live(_6)
    _6 = copy (((*f_2)).0).flags
    _5 = move _6 & copy DEBUG_UPPER_HEX_FLAG
    storage_dead(_6)
    switch move _5 {
        0 : u32 => {
        },
        _ => {
            storage_dead(_5)
            _0 = {impl#3}::fmt<'18, '19, '20>(move self_1, move f_2)
            return
        },
    }
    storage_dead(_5)
    _0 = {impl#2}::fmt<'12, '13, '14>(move self_1, move f_2)
    return
}

// Full name: core::fmt::num::{impl Debug for u32}
impl Debug for u32 {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl Debug for u32}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl Debug for u32}::{vtable}
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: core::result::unwrap_failed
fn unwrap_failed<'_0, '_1>(@1: &'_0 Str, @2: &'_1 (dyn Debug + '_1)) -> !
= <missing>

pub fn core::result::{Result<T, E>[@TraitClause0, @TraitClause1]}::unwrap<T, E>(@1: Result<T, E>[@TraitClause0, @TraitClause1]) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
    [@TraitClause2]: Debug<E>,
{
    let t_0: T; // return
    let self_1: Result<T, E>[@TraitClause0, @TraitClause1]; // arg #1
    let e_2: E; // local
    let _3: !; // anonymous local
    let _4: &'0 (dyn Debug + '1); // anonymous local
    let _5: &'2 E; // anonymous local

    storage_live(_3)
    storage_live(_5)
    match self_1 {
        Result::Ok => {
        },
        Result::Err => {
            storage_live(e_2)
            e_2 = move (self_1 as variant Result::Err).0
            storage_live(_4)
            _5 = &e_2
            _4 = unsize_cast<&'2 E, &'0 (dyn Debug + '1), @TraitClause2 with ?>(copy _5)
            _3 = unwrap_failed<'5, '6>(const "called `Result::unwrap()` on an `Err` value", move _4)
        },
    }
    t_0 = move (self_1 as variant Result::Ok).0
    return
}

fn test_crate::unwrap(@1: Result<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]) -> u32
{
    let _0: u32; // return
    let res_1: Result<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // arg #1
    let _2: Result<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // anonymous local

    storage_live(_2)
    _2 = copy res_1
    _0 = core::result::{Result<T, E>[@TraitClause0, @TraitClause1]}::unwrap<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}, {impl Debug for u32}](move _2)
    storage_dead(_2)
    return
}



