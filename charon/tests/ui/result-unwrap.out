# Final LLBC before serialization:

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::fmt::FormattingOptions
pub struct FormattingOptions {
  flags: u32,
  width: u16,
  precision: u16,
}

// Full name: core::fmt::flags::DEBUG_LOWER_HEX_FLAG
fn DEBUG_LOWER_HEX_FLAG() -> u32
{
    let _0: u32; // return

    _0 = const 1 : u32 panic.<< const 25 : i32
    return
}

// Full name: core::fmt::flags::DEBUG_LOWER_HEX_FLAG
const DEBUG_LOWER_HEX_FLAG: u32 = DEBUG_LOWER_HEX_FLAG()

// Full name: core::fmt::flags::DEBUG_UPPER_HEX_FLAG
fn DEBUG_UPPER_HEX_FLAG() -> u32
{
    let _0: u32; // return

    _0 = const 1 : u32 panic.<< const 26 : i32
    return
}

// Full name: core::fmt::flags::DEBUG_UPPER_HEX_FLAG
const DEBUG_UPPER_HEX_FLAG: u32 = DEBUG_UPPER_HEX_FLAG()

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

struct core::fmt::Debug::{vtable} {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn Debug)),
  method_fmt: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 (dyn Debug), &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}],
}

// Full name: core::fmt::Debug
#[lang_item("Debug")]
pub trait Debug<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::Debug::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::Debug::{vtable}
}

pub fn core::fmt::Debug::fmt<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: Debug<Self>,
= <method_without_default_body>

// Full name: core::fmt::Display
#[lang_item("Display")]
pub trait Display<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::Display::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::Display::{vtable}
}

pub fn core::fmt::Display::fmt<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: Display<Self>,
= <method_without_default_body>

// Full name: core::fmt::LowerHex
pub trait LowerHex<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::LowerHex::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::LowerHex::{vtable}
}

pub fn core::fmt::LowerHex::fmt<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: LowerHex<Self>,
= <method_without_default_body>

// Full name: core::fmt::UpperHex
pub trait UpperHex<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::UpperHex::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::UpperHex::{vtable}
}

pub fn core::fmt::UpperHex::fmt<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: UpperHex<Self>,
= <method_without_default_body>

// Full name: core::fmt::num::{impl LowerHex for u32}::fmt
pub fn {impl LowerHex for u32}::fmt<'_0, '_1, '_2>(@1: &'_0 u32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <missing>

// Full name: core::fmt::num::{impl LowerHex for u32}
impl LowerHex for u32 {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl LowerHex for u32}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl LowerHex for u32}::{vtable}
}

// Full name: core::fmt::num::{impl UpperHex for u32}::fmt
pub fn {impl UpperHex for u32}::fmt<'_0, '_1, '_2>(@1: &'_0 u32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <missing>

// Full name: core::fmt::num::{impl UpperHex for u32}
impl UpperHex for u32 {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl UpperHex for u32}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl UpperHex for u32}::{vtable}
}

// Full name: core::fmt::num::imp::{impl Display for u32}::fmt
pub fn {impl Display for u32}::fmt<'_0, '_1, '_2>(@1: &'_0 u32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <missing>

// Full name: core::fmt::num::{impl Debug for u32}::fmt
pub fn {impl Debug for u32}::fmt<'_0, '_1, '_2>(@1: &'_0 u32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
{
    let _0: Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // return
    let self_1: &'0 u32; // arg #1
    let f_2: &'1 mut Formatter<'2>; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy (((*f_2)).0).flags
    _3 = move _4 & copy DEBUG_LOWER_HEX_FLAG
    storage_dead(_4)
    switch move _3 {
        0 : u32 => {
            loop {
                storage_dead(_3)
                storage_live(_5)
                storage_live(_6)
                _6 = copy (((*f_2)).0).flags
                _5 = move _6 & copy DEBUG_UPPER_HEX_FLAG
                storage_dead(_6)
                switch move _5 {
                    0 : u32 => {
                        storage_dead(_5)
                        _0 = {impl Display for u32}::fmt<'_, '_, '_>(move self_1, move f_2)
                    },
                    _ => {
                        storage_dead(_5)
                        _0 = {impl UpperHex for u32}::fmt<'_, '_, '_>(move self_1, move f_2)
                    },
                }
                break 0
            }
            return
        },
        _ => {
            storage_dead(_3)
            _0 = {impl LowerHex for u32}::fmt<'_, '_, '_>(move self_1, move f_2)
            return
        },
    }
}

// Full name: core::fmt::num::{impl Debug for u32}
impl Debug for u32 {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl Debug for u32}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl Debug for u32}::{vtable}
}

// Full name: core::fmt::num::imp::{impl Display for u32}
impl Display for u32 {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl Display for u32}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl Display for u32}::{vtable}
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::marker::Destruct::drop_in_place
unsafe fn drop_in_place<Self>(@1: *mut Self)
= <missing>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: core::result::unwrap_failed
fn unwrap_failed<'_0, '_1>(@1: &'_0 Str, @2: &'_1 (dyn Debug + '_1)) -> !
= <missing>

pub fn core::result::{Result<T, E>[@TraitClause0, @TraitClause1]}::unwrap<T, E>(@1: Result<T, E>[@TraitClause0, @TraitClause1]) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
    [@TraitClause2]: Debug<E>,
{
    let t_0: T; // return
    let self_1: Result<T, E>[@TraitClause0, @TraitClause1]; // arg #1
    let e_2: E; // local
    let _3: !; // anonymous local
    let _4: &'0 (dyn Debug + '1); // anonymous local
    let _5: &'2 E; // anonymous local

    storage_live(_3)
    storage_live(_5)
    match self_1 {
        Result::Ok => {
            t_0 = move (self_1 as variant Result::Ok).0
            return
        },
        Result::Err => {
            storage_live(e_2)
            e_2 = move (self_1 as variant Result::Err).0
            storage_live(_4)
            _5 = &e_2
            _4 = unsize_cast<&'2 E, &'0 (dyn Debug + '1), @TraitClause2 with ?>(copy _5)
            _3 = unwrap_failed<'_, '_>(const "called `Result::unwrap()` on an `Err` value", move _4)
        },
    }
}

fn test_crate::unwrap(@1: Result<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]) -> u32
{
    let _0: u32; // return
    let res_1: Result<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // arg #1
    let _2: Result<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // anonymous local

    storage_live(_2)
    _2 = copy res_1
    _0 = core::result::{Result<T, E>[@TraitClause0, @TraitClause1]}::unwrap<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}, {impl Debug for u32}](move _2)
    storage_dead(_2)
    return
}



