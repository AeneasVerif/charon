# Final LLBC before serialization:

fn test_crate::foo::bar()
{
    let @0: (); // return

    @0 := ()
    @0 := ()
    return
}

#[lang_item("sized")]
pub trait core::marker::Sized<Self>

trait test_crate::Trait<Self, T>
{
    parent_clause0 : [@TraitClause0]: core::marker::Sized<T>
    fn method<U, [@TraitClause0]: core::marker::Sized<U>> = test_crate::Trait::method<Self, T, U>[@TraitClause0_0]
}

#[lang_item("global_alloc_ty")]
pub struct alloc::alloc::Global {}

#[lang_item("Option")]
pub enum core::option::Option<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,
{
  None,
  Some(T),
}

fn test_crate::{impl test_crate::Trait<core::option::Option<T>[@TraitClause0]> for alloc::boxed::Box<T>[core::marker::Sized<alloc::alloc::Global>]}::method<T, U>()
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<U>,
{
    let @0: (); // return

    @0 := ()
    @0 := ()
    return
}

impl test_crate::{impl test_crate::Trait<core::option::Option<T>[@TraitClause0]> for alloc::boxed::Box<T>[core::marker::Sized<alloc::alloc::Global>]}<T> : test_crate::Trait<alloc::boxed::Box<T>[core::marker::Sized<alloc::alloc::Global>], core::option::Option<T>[@TraitClause0]>
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    parent_clause0 = core::marker::Sized<core::option::Option<T>[@TraitClause0]>
    fn method<U, [@TraitClause0]: core::marker::Sized<U>> = test_crate::{impl test_crate::Trait<core::option::Option<T>[@TraitClause0]> for alloc::boxed::Box<T>[core::marker::Sized<alloc::alloc::Global>]}::method<T, U>[@TraitClause0, @TraitClause0_0]
}

fn test_crate::{impl test_crate::Trait<T> for Slice<T>}#1::method<T, U>()
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<U>,
{
    let @0: (); // return

    @0 := ()
    @0 := ()
    return
}

impl test_crate::{impl test_crate::Trait<T> for Slice<T>}#1<T> : test_crate::Trait<Slice<T>, T>
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    parent_clause0 = @TraitClause0
    fn method<U, [@TraitClause0]: core::marker::Sized<U>> = test_crate::{impl test_crate::Trait<T> for Slice<T>}#1::method<T, U>[@TraitClause0, @TraitClause0_0]
}

fn test_crate::{impl test_crate::Trait<T> for &'_0 (Slice<T>)}#2::method<'_0, T, U>()
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<U>,
{
    let @0: (); // return

    @0 := ()
    @0 := ()
    return
}

impl test_crate::{impl test_crate::Trait<T> for &'_0 (Slice<T>)}#2<'_0, T> : test_crate::Trait<&'_0 (Slice<T>), T>
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    parent_clause0 = @TraitClause0
    fn method<U, [@TraitClause0]: core::marker::Sized<U>> = test_crate::{impl test_crate::Trait<T> for &'_0 (Slice<T>)}#2::method<'_0, T, U>[@TraitClause0, @TraitClause0_0]
}

fn test_crate::Trait::method<Self, T, U>()
where
    [@TraitClause0]: core::marker::Sized<U>,



