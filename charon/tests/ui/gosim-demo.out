# Final LLBC before serialization:

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub opaque type Argument<'a>

// Full name: core::fmt::{Arguments<'a>}::new
pub unsafe fn new<'a, const N : usize, const M : usize>(@1: &'a [u8; N], @2: &'a [Argument<'a>; M]) -> Arguments<'a>
= <opaque>

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::Debug
#[lang_item("Debug")]
pub trait Debug<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::Debug::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::Debug::{vtable}
}

pub fn core::fmt::Debug::fmt<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: Debug<Self>,
= <opaque>

// Full name: core::fmt::{impl Debug for &'_0 T}::fmt
pub fn {impl Debug for &'_0 T}::fmt<'_0, '_1, '_2, '_3, T>(@1: &'_1 &'_0 T, @2: &'_2 mut Formatter<'_3>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: Debug<T>,
= <opaque>

// Full name: core::fmt::{impl Debug for &'_0 T}
impl<'_0, T> Debug for &'_0 T
where
    [@TraitClause0]: Debug<T>,
{
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl Debug for &'_0 T}::fmt<'_0, '_0_1, '_1_1, '_2_1, T>[@TraitClause0]
    vtable: {impl Debug for &'_0 T}::{vtable}<'_0, T>[@TraitClause0]
}

// Full name: core::fmt::num::{impl Debug for i32}::fmt
pub fn {impl Debug for i32}::fmt<'_0, '_1, '_2>(@1: &'_0 i32, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <opaque>

// Full name: core::fmt::num::{impl Debug for i32}
impl Debug for i32 {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl Debug for i32}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl Debug for i32}::{vtable}
}

// Full name: core::fmt::rt::{Argument<'_0>}::new_debug
pub fn new_debug<'_0, '_1, T>(@1: &'_1 T) -> Argument<'_1>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Debug<T>,
= <opaque>

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::slice::iter::Iter
#[lang_item("SliceIter")]
pub opaque type Iter<'a, T>
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
    T : 'a,

// Full name: core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}::next
pub fn {impl Iterator for Iter<'a, T>[@TraitClause0]}::next<'a, '_1, T>(@1: &'_1 mut Iter<'a, T>[@TraitClause0]) -> Option<&'a T>[{built_in impl Sized for &'_ T}]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::iter::{impl IntoIterator for &'a [T]}::into_iter
pub fn {impl IntoIterator for &'a [T]}::into_iter<'a, T>(@1: &'a [T]) -> Iter<'a, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: std::io::stdio::_eprint
pub fn _eprint<'_0>(@1: Arguments<'_0>)
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::debug_slice
fn debug_slice<'_0, T>(@1: &'_0 [T])
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Debug<T>,
{
    let _0: (); // return
    let slice_1: &'1 [T]; // arg #1
    let _2: Iter<'3, T>[@TraitClause0]; // anonymous local
    let _3: &'4 [T]; // anonymous local
    let iter_4: Iter<'5, T>[@TraitClause0]; // local
    let _5: Option<&'12 T>[{built_in impl Sized for &'12 T}]; // anonymous local
    let _6: &'17 mut Iter<'18, T>[@TraitClause0]; // anonymous local
    let _7: &'19 mut Iter<'20, T>[@TraitClause0]; // anonymous local
    let x_8: &'21 T; // local
    let _9: (); // anonymous local
    let _10: Arguments<'23>; // anonymous local
    let args_11: (&'28 &'29 T,); // local
    let _12: &'30 &'31 T; // anonymous local
    let args_13: [Argument<'34>; 1 : usize]; // local
    let _14: Argument<'35>; // anonymous local
    let _15: &'36 &'37 T; // anonymous local
    let _16: &'39 [u8; 7 : usize]; // anonymous local
    let _17: &'40 [u8; 7 : usize]; // anonymous local
    let _18: &'43 [Argument<'44>; 1 : usize]; // anonymous local
    let _19: &'45 [Argument<'46>; 1 : usize]; // anonymous local
    let _20: [u8; 7 : usize]; // anonymous local
    let _21: &'71 [u8; 7 : usize]; // anonymous local

    _0 = ()
    storage_live(_2)
    storage_live(_3)
    _3 = copy slice_1
    _2 = {impl IntoIterator for &'a [T]}::into_iter<'47, T>[@TraitClause0](move _3)
    storage_dead(_3)
    _ = _2
    storage_live(iter_4)
    iter_4 = move _2
    loop {
        storage_live(_5)
        storage_live(_6)
        storage_live(_7)
        _7 = &mut iter_4
        _6 = &two-phase-mut (*_7)
        _5 = {impl Iterator for Iter<'a, T>[@TraitClause0]}::next<'49, '51, T>[@TraitClause0](move _6)
        storage_dead(_6)
        _ = _5
        match _5 {
            Option::None => {
                break 0
            },
            Option::Some => {
            },
        }
        storage_live(x_8)
        x_8 = copy (_5 as variant Option::Some).0
        storage_live(_9)
        storage_live(_10)
        storage_live(args_11)
        storage_live(_12)
        _12 = &x_8
        args_11 = (move _12,)
        storage_dead(_12)
        storage_live(args_13)
        storage_live(_14)
        storage_live(_15)
        _15 = &(*args_11.0)
        _14 = new_debug<'59, '69, &'60 T>[{built_in impl Sized for &'60 T}, {impl Debug for &'_0 T}<'60, T>[@TraitClause1]](move _15)
        storage_dead(_15)
        args_13 = [move _14]
        storage_dead(_14)
        storage_live(_16)
        storage_live(_17)
        storage_live(_20)
        _20 = [const 2 : u8, const 45 : u8, const 32 : u8, const 192 : u8, const 1 : u8, const 10 : u8, const 0 : u8]
        storage_live(_21)
        _21 = &_20
        _17 = move _21
        _16 = &(*_17)
        storage_live(_18)
        storage_live(_19)
        _19 = &args_13
        _18 = &(*_19)
        _10 = new<'73, 7 : usize, 1 : usize>(move _16, move _18)
        storage_dead(_19)
        storage_dead(_18)
        storage_dead(_17)
        storage_dead(_16)
        _9 = _eprint<'75>(move _10)
        storage_dead(_10)
        storage_dead(args_13)
        storage_dead(args_11)
        storage_dead(_9)
        storage_dead(x_8)
        storage_dead(_7)
        storage_dead(_5)
        continue 0
    }
    _0 = ()
    storage_dead(_7)
    storage_dead(_5)
    storage_dead(iter_4)
    storage_dead(_2)
    return
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let _1: (); // anonymous local
    let _2: &'1 [i32]; // anonymous local
    let _3: &'3 [i32; 3 : usize]; // anonymous local
    let _4: &'4 [i32; 3 : usize]; // anonymous local
    let _5: &'5 [i32; 3 : usize]; // anonymous local
    let _6: &'10 [i32; 3 : usize]; // anonymous local
    let _7: [i32; 3 : usize]; // anonymous local

    storage_live(_6)
    storage_live(_7)
    _7 = [const 0 : i32, const 1 : i32, const 2 : i32]
    _6 = &_7
    storage_live(_5)
    _0 = ()
    storage_live(_1)
    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    _5 = move _6
    _4 = &(*_5)
    _3 = &(*_4)
    _2 = @ArrayToSliceShared<'_, i32, 3 : usize>(move _3)
    storage_dead(_3)
    _1 = debug_slice<'9, i32>[{built_in impl Sized for i32}, {impl Debug for i32}](move _2)
    storage_dead(_2)
    storage_dead(_4)
    storage_dead(_1)
    _0 = ()
    return
}



