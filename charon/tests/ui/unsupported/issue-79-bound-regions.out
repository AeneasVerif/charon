# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0_1> = core::iter::traits::iterator::Iterator::next<'_0_1, Self>[Self]
    vtable: core::iter::traits::iterator::Iterator::{vtable}<Self::Item>
}

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut Self) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,
= <opaque>

// Full name: core::slice::iter::Iter
#[lang_item("SliceIter")]
pub opaque type Iter<'a, T>
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
    T : 'a,

// Full name: core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}::next
pub fn {impl Iterator for Iter<'a, T>[@TraitClause0]}::next<'a, '_1, T>(@1: &'_1 mut Iter<'a, T>[@TraitClause0]) -> Option<&'a T>[{built_in impl Sized for &'_ T}]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::iter::{impl Iterator for Iter<'a, T>[@TraitClause0]}
impl<'a, T> Iterator for Iter<'a, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Iter<'_, T>[@TraitClause0]}
    parent_clause1 = {built_in impl Sized for &'_ T}
    type Item = &'a T
    fn next<'_0_1> = {impl Iterator for Iter<'a, T>[@TraitClause0]}::next<'a, '_0_1, T>[@TraitClause0]
    vtable: {impl Iterator for Iter<'a, T>[@TraitClause0]}::{vtable}<'a, T>[@TraitClause0]
}

// Full name: core::slice::{[T]}::iter
#[lang_item("slice_iter")]
pub fn iter<'_0, T>(@1: &'_0 [T]) -> Iter<'_0, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let slice_1: &'0 [i32]; // local
    let _2: &'1 [i32; 1 : usize]; // anonymous local
    let _3: &'1 [i32; 1 : usize]; // anonymous local
    let _4: Option<&'2 i32>[{built_in impl Sized for &'2 i32}]; // anonymous local
    let _5: &'5 mut Iter<'6, i32>[{built_in impl Sized for i32}]; // anonymous local
    let _6: Iter<'6, i32>[{built_in impl Sized for i32}]; // anonymous local
    let _7: &'0 [i32]; // anonymous local
    let _8: &'1 [i32; 1 : usize]; // anonymous local
    let _9: &'_ [i32; 1 : usize]; // anonymous local
    let _10: [i32; 1 : usize]; // anonymous local

    storage_live(_9)
    storage_live(_10)
    _10 = [const 0 : i32]
    _9 = &_10
    storage_live(_8)
    _0 = ()
    storage_live(slice_1)
    storage_live(_2)
    storage_live(_3)
    _8 = move _9
    _3 = &(*_8)
    _2 = &(*_3)
    slice_1 = @ArrayToSliceShared<'_, i32, 1 : usize>(move _2)
    storage_dead(_2)
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    _7 = &(*slice_1) with_metadata(copy slice_1.metadata)
    _6 = iter<'8, i32>[{built_in impl Sized for i32}](move _7)
    _5 = &two-phase-mut _6
    storage_dead(_7)
    _4 = {impl Iterator for Iter<'a, T>[@TraitClause0]}::next<'9, '11, i32>[{built_in impl Sized for i32}](move _5)
    storage_dead(_5)
    storage_dead(_6)
    storage_dead(_4)
    _0 = ()
    storage_dead(slice_1)
    return
}



