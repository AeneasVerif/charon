# Final LLBC before serialization:

trait core::marker::Sized<Self>

enum core::option::Option<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,
 =
|  None()
|  Some(T)


fn core::option::{core::option::Option<T>[@TraitClause0]}::is_some<'_0, T>(@1: &'_0 (core::option::Option<T>[@TraitClause0])) -> bool
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: bool; // return
    let self@1: &'_ (core::option::Option<T>[@TraitClause0]); // arg #1

    match *(self@1) {
        1 => {
        },
        0 => {
            @0 := const (false)
            return
        },
    }
    @0 := const (true)
    return
}

trait core::convert::From<Self, T>
{
    parent_clause0 : [@TraitClause0]: core::marker::Sized<Self>
    parent_clause1 : [@TraitClause1]: core::marker::Sized<T>
    fn from = core::convert::From::from<Self, T>
}

fn core::convert::From::from<Self, T>(@1: T) -> Self

fn core::convert::{impl core::convert::Into<U> for T}#3::into<T, U>(@1: T) -> U
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<U>,
    [@TraitClause2]: core::convert::From<U, T>,
{
    let @0: U; // return
    let self@1: T; // arg #1

    @0 := @TraitClause2::from(move (self@1))
    return
}

fn core::convert::num::{impl core::convert::From<u32> for u64}#72::from(@1: u32) -> u64
{
    let @0: u64; // return
    let small@1: u32; // arg #1

    @0 := cast<u32, u64>(copy (small@1))
    return
}

impl core::convert::num::{impl core::convert::From<u32> for u64}#72 : core::convert::From<u64, u32>
{
    parent_clause0 = core::marker::Sized<u64>
    parent_clause1 = core::marker::Sized<u32>
    fn from = core::convert::num::{impl core::convert::From<u32> for u64}#72::from
}

fn test_crate::foo()
{
    let @0: (); // return
    let @1: bool; // anonymous local
    let @2: &'_ (core::option::Option<i32>[core::marker::Sized<i32>]); // anonymous local
    let @3: core::option::Option<i32>[core::marker::Sized<i32>]; // anonymous local
    let @4: u64; // anonymous local
    let @5: &'_ (Slice<i32>); // anonymous local
    let @6: &'_ (i32); // anonymous local
    let @7: &'_ (i32); // anonymous local
    let @8: i32; // anonymous local

    @3 := core::option::Option::Some { 0: const (0 : i32) }
    @2 := &@3
    @1 := core::option::{core::option::Option<T>[@TraitClause0]}::is_some<'_, i32>[core::marker::Sized<i32>](move (@2))
    drop @2
    @fake_read(@1)
    drop @3
    drop @1
    @4 := core::convert::{impl core::convert::Into<U> for T}#3::into<u32, u64>[core::marker::Sized<u32>, core::marker::Sized<u64>, core::convert::num::{impl core::convert::From<u32> for u64}#72](const (42 : u32))
    @fake_read(@4)
    drop @4
    @8 := const (0 : i32)
    @7 := &@8
    @6 := &*(@7)
    @5 := core::slice::raw::from_ref<'_, i32>[core::marker::Sized<i32>](move (@6))
    drop @6
    @fake_read(@5)
    drop @8
    drop @7
    drop @5
    @0 := ()
    @0 := ()
    return
}

fn test_crate::module::dont_translate_body()

fn test_crate::exclude_me()

struct test_crate::Struct = {}

unsafe fn test_crate::extern_fn(@1: i32)

fn core::convert::Into::into<Self, T>(@1: Self) -> T

trait core::convert::Into<Self, T>
{
    parent_clause0 : [@TraitClause0]: core::marker::Sized<Self>
    parent_clause1 : [@TraitClause1]: core::marker::Sized<T>
    fn into = core::convert::Into::into<Self, T>
}

impl core::convert::{impl core::convert::Into<U> for T}#3<T, U> : core::convert::Into<T, U>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<U>,
    [@TraitClause2]: core::convert::From<U, T>,
{
    parent_clause0 = @TraitClause0
    parent_clause1 = @TraitClause1
    fn into = core::convert::{impl core::convert::Into<U> for T}#3::into<T, U>[@TraitClause0, @TraitClause1, @TraitClause2]
}



