# Final LLBC before serialization:

// Full name: core::ptr::alignment::AlignmentEnum
enum AlignmentEnum {
  _Align1Shl0,
  _Align1Shl1,
  _Align1Shl2,
  _Align1Shl3,
  _Align1Shl4,
  _Align1Shl5,
  _Align1Shl6,
  _Align1Shl7,
  _Align1Shl8,
  _Align1Shl9,
  _Align1Shl10,
  _Align1Shl11,
  _Align1Shl12,
  _Align1Shl13,
  _Align1Shl14,
  _Align1Shl15,
  _Align1Shl16,
  _Align1Shl17,
  _Align1Shl18,
  _Align1Shl19,
  _Align1Shl20,
  _Align1Shl21,
  _Align1Shl22,
  _Align1Shl23,
  _Align1Shl24,
  _Align1Shl25,
  _Align1Shl26,
  _Align1Shl27,
  _Align1Shl28,
  _Align1Shl29,
  _Align1Shl30,
  _Align1Shl31,
  _Align1Shl32,
  _Align1Shl33,
  _Align1Shl34,
  _Align1Shl35,
  _Align1Shl36,
  _Align1Shl37,
  _Align1Shl38,
  _Align1Shl39,
  _Align1Shl40,
  _Align1Shl41,
  _Align1Shl42,
  _Align1Shl43,
  _Align1Shl44,
  _Align1Shl45,
  _Align1Shl46,
  _Align1Shl47,
  _Align1Shl48,
  _Align1Shl49,
  _Align1Shl50,
  _Align1Shl51,
  _Align1Shl52,
  _Align1Shl53,
  _Align1Shl54,
  _Align1Shl55,
  _Align1Shl56,
  _Align1Shl57,
  _Align1Shl58,
  _Align1Shl59,
  _Align1Shl60,
  _Align1Shl61,
  _Align1Shl62,
  _Align1Shl63,
}

// Full name: core::ptr::alignment::Alignment
pub struct Alignment {
  AlignmentEnum,
}

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub struct Layout {
  size: usize,
  align: Alignment,
}

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    fn clone_from<'_0_1, '_1_1, [@TraitClause0_1]: Destruct<Self>> = core::clone::Clone::clone_from<'_0_1, '_1_1, Self>[Self, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::intrinsics::ctpop
pub fn ctpop<T>(@1: T) -> u32
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Copy<T>,
{
    let _0: u32; // return
    let x_1: T; // arg #1

    undefined_behavior
}

// Full name: core::clone::impls::{impl Clone for usize}::clone
pub fn {impl Clone for usize}::clone<'_0>(@1: &'_0 usize) -> usize
{
    let _0: usize; // return
    let self_1: &'0 usize; // arg #1

    _0 = copy (*self_1)
    return
}

// Full name: core::clone::impls::{impl Clone for usize}::clone_from
pub fn {impl Clone for usize}::clone_from<'_0, '_1>(@1: &'_0 mut usize, @2: &'_1 usize)
where
    [@TraitClause0]: Destruct<usize>,
{
    let _0: (); // return
    let self_1: &'0 mut usize; // arg #1
    let source_2: &'1 usize; // arg #2
    let _3: usize; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = {impl Clone for usize}::clone<'_>(move source_2)
    drop[@TraitClause0] (*self_1)
    (*self_1) = move _3
    storage_dead(_3)
    return
}

// Full name: core::clone::impls::{impl Clone for usize}
impl Clone for usize {
    parent_clause0 = {built_in impl Sized for usize}
    fn clone<'_0_1> = {impl Clone for usize}::clone<'_0_1>
    fn clone_from<'_0_1, '_1_1, [@TraitClause0_1]: Destruct<usize>> = {impl Clone for usize}::clone_from<'_0_1, '_1_1>[@TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::marker::{impl Copy for usize}
impl Copy for usize {
    parent_clause0 = {built_in impl MetaSized for usize}
    parent_clause1 = {impl Clone for usize}
    non-dyn-compatible
}

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub struct NonNull<T> {
  pointer: *const T,
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::marker::PhantomData
#[lang_item("phantom_data")]
pub struct PhantomData<T> {}

// Full name: core::fmt::rt::ArgumentType
enum ArgumentType<'a> {
  Placeholder(value: NonNull<()>, formatter: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], _lifetime: PhantomData<&'a ()>),
  Count(u16),
}

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub struct Argument<'a> {
  ty: ArgumentType<'a>,
}

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub struct Arguments<'a> {
  template: NonNull<u8>,
  args: NonNull<Argument<'a>>,
}

// Full name: core::panicking::panic_nounwind_fmt::compiletime
fn compiletime<'_0>(@1: Arguments<'_0>, @2: bool) -> !
{
    let _0: !; // return
    let fmt_1: Arguments<'0>; // arg #1
    let force_no_backtrace_2: bool; // arg #2

    panic(core::panicking::panic_fmt)
}

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
{
    let _0: !; // return
    let fmt_1: Arguments<'0>; // arg #1
    let force_no_backtrace_2: bool; // arg #2
    let _3: (Arguments<'0>, bool); // anonymous local
    let _4: Arguments<'0>; // anonymous local
    let _5: bool; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy fmt_1
    storage_live(_5)
    _5 = copy force_no_backtrace_2
    _3 = (move _4, move _5)
    storage_dead(_5)
    storage_dead(_4)
    _0 = compiletime<'_>(move _3.0, move _3.1)
}

fn core::ptr::alignment::{Alignment}::new_unchecked::precondition_check(@1: usize)
{
    let _0: (); // return
    let align_1: usize; // arg #1
    let msg_2: &'0 Str; // local
    let _3: !; // anonymous local
    let _4: Arguments<'1>; // anonymous local
    let _5: u32; // anonymous local
    let _6: NonNull<u8>; // anonymous local
    let _7: *const u8; // anonymous local
    let _8: NonNull<Argument<'2>>; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local
    let _11: usize; // anonymous local
    let _12: *const Str; // anonymous local
    let _13: &'3 [u8]; // anonymous local

    storage_live(msg_2)
    storage_live(_3)
    _0 = ()
    storage_live(_5)
    _5 = ctpop<usize>[{built_in impl Sized for usize}, {impl Copy for usize}](move align_1)
    switch move _5 {
        1 : u32 => {
        },
        _ => {
            storage_dead(_5)
            msg_2 = const "unsafe precondition(s) violated: Alignment::new_unchecked requires a power of two\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
            storage_live(_4)
            storage_live(_6)
            storage_live(_7)
            storage_live(_12)
            _12 = &raw const (*msg_2) with_metadata(copy msg_2.metadata)
            _7 = cast<*const Str, *const u8>(copy _12)
            storage_dead(_12)
            _6 = transmute<*const u8, NonNull<u8>>(copy _7)
            storage_dead(_7)
            storage_live(_8)
            storage_live(_9)
            storage_live(_10)
            storage_live(_11)
            storage_live(_13)
            _13 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: Alignment::new_unchecked requires a power of two\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
            _11 = copy _13.metadata
            storage_dead(_13)
            _10 = move _11 wrap.<< const 1 : i32
            storage_dead(_11)
            _9 = move _10 | const 1 : usize
            storage_dead(_10)
            _8 = transmute<usize, NonNull<Argument<'2>>>(move _9)
            storage_dead(_9)
            _4 = Arguments { template: move _6, args: move _8 }
            storage_dead(_8)
            storage_dead(_6)
            _3 = panic_nounwind_fmt<'_>(move _4, const false)
        },
    }
    storage_dead(_5)
    return
}

pub fn core::ptr::alignment::{Alignment}::new(@1: usize) -> Option<Alignment>[{built_in impl Sized for Alignment}]
{
    let _0: Option<Alignment>[{built_in impl Sized for Alignment}]; // return
    let align_1: usize; // arg #1
    let _2: Alignment; // anonymous local
    let _3: u32; // anonymous local
    let _4: (); // anonymous local
    let _5: bool; // anonymous local
    let _6: Option<Alignment>[{built_in impl Sized for Alignment}]; // anonymous local

    storage_live(_4)
    storage_live(_3)
    _3 = ctpop<usize>[{built_in impl Sized for usize}, {impl Copy for usize}](copy align_1)
    switch move _3 {
        1 : u32 => {
        },
        _ => {
            storage_dead(_3)
            storage_live(_6)
            _6 = Option::None {  }
            _0 = move _6
            return
        },
    }
    loop {
        storage_dead(_3)
        storage_live(_2)
        storage_live(_5)
        _5 = ub_checks<bool>
        if copy _5 {
            _4 = core::ptr::alignment::{Alignment}::new_unchecked::precondition_check(copy align_1)
        } else {
        }
        break 0
    }
    _2 = transmute<usize, Alignment>(copy align_1)
    storage_dead(_5)
    _0 = Option::Some { 0: move _2 }
    storage_dead(_2)
    return
}

// Full name: core::alloc::layout::{Layout}::max_size_for_align
fn max_size_for_align(@1: Alignment) -> usize
{
    let _0: usize; // return
    let align_1: Alignment; // arg #1
    let _2: usize; // anonymous local
    let _3: AlignmentEnum; // anonymous local

    storage_live(_3)
    storage_live(_2)
    _3 = copy (align_1).0
    _2 = @discriminant(_3)
    _0 = const 9223372036854775808 : usize ub.- move _2
    storage_dead(_2)
    return
}

// Full name: core::alloc::layout::{Layout}::is_size_align_valid
fn is_size_align_valid(@1: usize, @2: usize) -> bool
{
    let _0: bool; // return
    let size_1: usize; // arg #1
    let align_2: usize; // arg #2
    let align_3: Alignment; // local
    let _4: Option<Alignment>[{built_in impl Sized for Alignment}]; // anonymous local
    let _5: usize; // anonymous local
    let _6: bool; // anonymous local
    let _7: usize; // anonymous local
    let _8: usize; // anonymous local
    let _9: Alignment; // anonymous local

    storage_live(_4)
    storage_live(_5)
    _5 = copy align_2
    _4 = core::ptr::alignment::{Alignment}::new(move _5)
    storage_dead(_5)
    match _4 {
        Option::Some => {
        },
        _ => {
            storage_dead(_4)
            _0 = const false
            return
        },
    }
    storage_live(align_3)
    align_3 = copy (_4 as variant Option::Some).0
    storage_dead(_4)
    storage_live(_6)
    storage_live(_7)
    _7 = copy size_1
    storage_live(_8)
    storage_live(_9)
    _9 = copy align_3
    _8 = max_size_for_align(move _9)
    storage_dead(_9)
    _6 = move _7 > move _8
    if move _6 {
    } else {
        storage_dead(_8)
        storage_dead(_7)
        storage_dead(_6)
        _0 = const true
        storage_dead(align_3)
        return
    }
    storage_dead(_8)
    storage_dead(_7)
    _0 = const false
    storage_dead(_6)
    storage_dead(align_3)
    return
}

fn core::alloc::layout::{Layout}::from_size_align_unchecked::precondition_check(@1: usize, @2: usize)
{
    let _0: (); // return
    let size_1: usize; // arg #1
    let align_2: usize; // arg #2
    let _3: bool; // anonymous local
    let msg_4: &'0 Str; // local
    let _5: !; // anonymous local
    let _6: Arguments<'1>; // anonymous local
    let _7: NonNull<u8>; // anonymous local
    let _8: *const u8; // anonymous local
    let _9: NonNull<Argument<'2>>; // anonymous local
    let _10: usize; // anonymous local
    let _11: usize; // anonymous local
    let _12: usize; // anonymous local
    let _13: *const Str; // anonymous local
    let _14: &'3 [u8]; // anonymous local

    storage_live(msg_4)
    storage_live(_5)
    _0 = ()
    storage_live(_3)
    _3 = is_size_align_valid(move size_1, move align_2)
    if move _3 {
    } else {
        msg_4 = const "unsafe precondition(s) violated: Layout::from_size_align_unchecked requires that align is a power of 2 and the rounded-up allocation size does not exceed isize::MAX\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
        storage_live(_6)
        storage_live(_7)
        storage_live(_8)
        storage_live(_13)
        _13 = &raw const (*msg_4) with_metadata(copy msg_4.metadata)
        _8 = cast<*const Str, *const u8>(copy _13)
        storage_dead(_13)
        _7 = transmute<*const u8, NonNull<u8>>(copy _8)
        storage_dead(_8)
        storage_live(_9)
        storage_live(_10)
        storage_live(_11)
        storage_live(_12)
        storage_live(_14)
        _14 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: Layout::from_size_align_unchecked requires that align is a power of 2 and the rounded-up allocation size does not exceed isize::MAX\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
        _12 = copy _14.metadata
        storage_dead(_14)
        _11 = move _12 wrap.<< const 1 : i32
        storage_dead(_12)
        _10 = move _11 | const 1 : usize
        storage_dead(_11)
        _9 = transmute<usize, NonNull<Argument<'2>>>(move _10)
        storage_dead(_10)
        _6 = Arguments { template: move _7, args: move _9 }
        storage_dead(_9)
        storage_dead(_7)
        _5 = panic_nounwind_fmt<'_>(move _6, const false)
    }
    storage_dead(_3)
    return
}

// Full name: core::alloc::layout::{Layout}::from_size_align_unchecked
pub unsafe fn from_size_align_unchecked(@1: usize, @2: usize) -> Layout
{
    let _0: Layout; // return
    let size_1: usize; // arg #1
    let align_2: usize; // arg #2
    let _3: bool; // anonymous local
    let _4: (); // anonymous local
    let _5: Alignment; // anonymous local

    loop {
        storage_live(_4)
        storage_live(_3)
        _3 = ub_checks<bool>
        if move _3 {
            _4 = core::alloc::layout::{Layout}::from_size_align_unchecked::precondition_check(copy size_1, copy align_2)
        } else {
        }
        break 0
    }
    storage_dead(_3)
    storage_live(_5)
    _5 = transmute<usize, Alignment>(copy align_2)
    _0 = Layout { size: copy size_1, align: move _5 }
    storage_dead(_5)
    return
}

// Full name: core::alloc::AllocError
pub struct AllocError {}

// Full name: core::alloc::Allocator
pub trait Allocator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn allocate<'_0_1> = core::alloc::Allocator::allocate<'_0_1, Self>[Self]
    fn allocate_zeroed<'_0_1> = core::alloc::Allocator::allocate_zeroed<'_0_1, Self>[Self]
    fn deallocate<'_0_1> = core::alloc::Allocator::deallocate<'_0_1, Self>[Self]
    fn grow<'_0_1> = core::alloc::Allocator::grow<'_0_1, Self>[Self]
    fn grow_zeroed<'_0_1> = core::alloc::Allocator::grow_zeroed<'_0_1, Self>[Self]
    fn shrink<'_0_1> = core::alloc::Allocator::shrink<'_0_1, Self>[Self]
    fn by_ref<'_0_1, [@TraitClause0_1]: Sized<Self>> = core::alloc::Allocator::by_ref<'_0_1, Self>[Self, @TraitClause0_1]
    vtable: core::alloc::Allocator::{vtable}
}

pub fn core::alloc::Allocator::allocate<'_0, Self>(@1: &'_0 Self, @2: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
= <method_without_default_body>

// Full name: core::ops::control_flow::ControlFlow
#[lang_item("ControlFlow")]
pub enum ControlFlow<B, C>
where
    [@TraitClause0]: Sized<B>,
    [@TraitClause1]: Sized<C>,
{
  Continue(C),
  Break(B),
}

// Full name: core::convert::Infallible
pub enum Infallible {
}

// Full name: core::ptr::const_ptr::{*const T}::is_aligned_to
pub fn is_aligned_to<T>(@1: *const T, @2: usize) -> bool
{
    let _0: bool; // return
    let self_1: *const T; // arg #1
    let align_2: usize; // arg #2
    let _3: Arguments<'0>; // anonymous local
    let _4: usize; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: u32; // anonymous local
    let _8: *const (); // anonymous local
    let s_9: &'1 Str; // local
    let _10: NonNull<u8>; // anonymous local
    let _11: *const u8; // anonymous local
    let _12: NonNull<Argument<'2>>; // anonymous local
    let _13: usize; // anonymous local
    let _14: usize; // anonymous local
    let _15: usize; // anonymous local
    let _16: *const Str; // anonymous local
    let _17: &'3 [u8]; // anonymous local

    storage_live(_7)
    _7 = ctpop<usize>[{built_in impl Sized for usize}, {impl Copy for usize}](copy align_2)
    switch move _7 {
        1 : u32 => {
        },
        _ => {
            storage_dead(_7)
            storage_live(_3)
            storage_live(s_9)
            s_9 = const "is_aligned_to: align is not a power-of-two"
            storage_live(_10)
            storage_live(_11)
            storage_live(_16)
            _16 = &raw const (*s_9) with_metadata(copy s_9.metadata)
            _11 = cast<*const Str, *const u8>(copy _16)
            storage_dead(_16)
            _10 = transmute<*const u8, NonNull<u8>>(copy _11)
            storage_dead(_11)
            storage_live(_12)
            storage_live(_13)
            storage_live(_14)
            storage_live(_15)
            storage_live(_17)
            _17 = transmute<&'1 Str, &'3 [u8]>(const "is_aligned_to: align is not a power-of-two")
            _15 = copy _17.metadata
            storage_dead(_17)
            _14 = move _15 wrap.<< const 1 : i32
            storage_dead(_15)
            _13 = move _14 | const 1 : usize
            storage_dead(_14)
            _12 = transmute<usize, NonNull<Argument<'2>>>(move _13)
            storage_dead(_13)
            _3 = Arguments { template: move _10, args: move _12 }
            storage_dead(_12)
            storage_dead(_10)
            storage_dead(s_9)
            panic(core::panicking::panic_fmt)
        },
    }
    storage_dead(_7)
    storage_live(_4)
    storage_live(_5)
    storage_live(_8)
    _8 = cast<*const T, *const ()>(copy self_1)
    _5 = transmute<*const (), usize>(copy _8)
    storage_dead(_8)
    storage_live(_6)
    _6 = copy align_2 wrap.- const 1 : usize
    _4 = move _5 & move _6
    storage_dead(_6)
    storage_dead(_5)
    _0 = move _4 == const 0 : usize
    storage_dead(_4)
    return
}

fn core::ptr::write_bytes::precondition_check(@1: *const (), @2: usize, @3: bool)
{
    let _0: (); // return
    let addr_1: *const (); // arg #1
    let align_2: usize; // arg #2
    let zero_size_3: bool; // arg #3
    let _4: bool; // anonymous local
    let msg_5: &'0 Str; // local
    let _6: !; // anonymous local
    let _7: Arguments<'1>; // anonymous local
    let _8: bool; // anonymous local
    let _9: bool; // anonymous local
    let _10: usize; // anonymous local
    let _11: NonNull<u8>; // anonymous local
    let _12: *const u8; // anonymous local
    let _13: NonNull<Argument<'2>>; // anonymous local
    let _14: usize; // anonymous local
    let _15: usize; // anonymous local
    let _16: usize; // anonymous local
    let _17: *const Str; // anonymous local
    let _18: &'3 [u8]; // anonymous local

    storage_live(msg_5)
    storage_live(_6)
    _0 = ()
    storage_live(_4)
    storage_live(_8)
    _8 = is_aligned_to<()>(copy addr_1, move align_2)
    loop {
        if move _8 {
            loop {
                if copy zero_size_3 {
                    storage_dead(_8)
                } else {
                    storage_live(_9)
                    storage_live(_10)
                    _10 = transmute<*const (), usize>(copy addr_1)
                    _9 = move _10 == const 0 : usize
                    storage_dead(_10)
                    _4 = ~(move _9)
                    storage_dead(_9)
                    storage_dead(_8)
                    if move _4 {
                    } else {
                    }
                }
                break 0
            }
            storage_dead(_4)
            return
        } else {
            storage_dead(_8)
        }
        break 0
    }
    msg_5 = const "unsafe precondition(s) violated: ptr::write_bytes requires that the destination pointer is aligned and non-null\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
    storage_live(_7)
    storage_live(_11)
    storage_live(_12)
    storage_live(_17)
    _17 = &raw const (*msg_5) with_metadata(copy msg_5.metadata)
    _12 = cast<*const Str, *const u8>(copy _17)
    storage_dead(_17)
    _11 = transmute<*const u8, NonNull<u8>>(copy _12)
    storage_dead(_12)
    storage_live(_13)
    storage_live(_14)
    storage_live(_15)
    storage_live(_16)
    storage_live(_18)
    _18 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: ptr::write_bytes requires that the destination pointer is aligned and non-null\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    _16 = copy _18.metadata
    storage_dead(_18)
    _15 = move _16 wrap.<< const 1 : i32
    storage_dead(_16)
    _14 = move _15 | const 1 : usize
    storage_dead(_15)
    _13 = transmute<usize, NonNull<Argument<'2>>>(move _14)
    storage_dead(_14)
    _7 = Arguments { template: move _11, args: move _13 }
    storage_dead(_13)
    storage_dead(_11)
    _6 = panic_nounwind_fmt<'_>(move _7, const false)
}

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::intrinsics::size_of
pub fn size_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    undefined_behavior
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return

    _0 = size_of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::intrinsics::align_of
pub fn align_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    undefined_behavior
}

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return

    _0 = align_of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: bool; // return

    _0 = const @TraitClause0::SIZE == const 0 : usize
    return
}

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: Layout; // return

    _0 = from_size_align_unchecked(const @TraitClause0::SIZE, const @TraitClause0::ALIGN)
    return
}

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

pub fn core::num::{usize}::MAX() -> usize
{
    let _0: usize; // return

    _0 = ~(const 0 : usize)
    return
}

pub const core::num::{usize}::MAX: usize = core::num::{usize}::MAX()

pub fn core::num::{isize}::MAX() -> isize
{
    let _0: isize; // return
    let _1: usize; // anonymous local
    let _2: u32; // anonymous local
    let _3: bool; // anonymous local

    storage_live(_2)
    storage_live(_3)
    storage_live(_1)
    _2 = cast<i32, u32>(const 1 : i32)
    _3 = move _2 < const 64 : u32
    assert(move _3 == true)
    _1 = copy core::num::{usize}::MAX wrap.>> const 1 : i32
    _0 = cast<usize, isize>(move _1)
    storage_dead(_1)
    return
}

pub const core::num::{isize}::MAX: isize = core::num::{isize}::MAX()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return
    let _1: usize; // anonymous local
    let n_2: usize; // local
    let _3: usize; // anonymous local
    let _4: usize; // anonymous local
    let _5: bool; // anonymous local

    loop {
        storage_live(_5)
        storage_live(_1)
        _1 = const @TraitClause0::SIZE
        switch copy _1 {
            0 : usize => {
                _0 = copy core::num::{usize}::MAX
            },
            _ => {
                storage_live(n_2)
                n_2 = copy _1
                storage_live(_3)
                _3 = cast<isize, usize>(copy core::num::{isize}::MAX)
                storage_live(_4)
                _4 = copy n_2
                _5 = copy _4 == const 0 : usize
                assert(move _5 == false)
                _0 = move _3 ub./ move _4
                storage_dead(_4)
                storage_dead(_3)
                storage_dead(n_2)
            },
        }
        break 0
    }
    storage_dead(_1)
    return
}

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::intrinsics::write_bytes
pub unsafe fn write_bytes<T>(@1: *mut T, @2: u8, @3: usize)
where
    [@TraitClause0]: Sized<T>,
{
    let _0: (); // return
    let dst_1: *mut T; // arg #1
    let val_2: u8; // arg #2
    let count_3: usize; // arg #3

    _0 = ()
    undefined_behavior
}

pub fn core::alloc::Allocator::allocate_zeroed<'_0, Self>(@1: &'_0 Self, @2: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Self; // arg #1
    let layout_2: Layout; // arg #2
    let _3: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<[u8]>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<[u8]>}]; // anonymous local
    let self_4: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // local
    let ptr_5: NonNull<[u8]>; // local
    let _6: (); // anonymous local
    let self_7: *mut u8; // local
    let self_8: NonNull<u8>; // local
    let count_9: usize; // local
    let v_10: NonNull<[u8]>; // local
    let _11: *const u8; // anonymous local
    let _12: *mut [u8]; // anonymous local
    let _13: (); // anonymous local
    let _14: *const (); // anonymous local
    let _15: bool; // anonymous local
    let _16: bool; // anonymous local
    let _17: AllocError; // anonymous local
    let _18: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(ptr_5)
    storage_live(_6)
    storage_live(_12)
    storage_live(_13)
    storage_live(_3)
    storage_live(self_4)
    self_4 = @TraitClause0::allocate<'_>(move self_1, move layout_2)
    storage_live(v_10)
    match self_4 {
        Result::Ok => {
        },
        Result::Err => {
            storage_dead(v_10)
            storage_dead(self_4)
            storage_live(_17)
            _17 = AllocError {  }
            storage_live(_18)
            _18 = Result::Err { 0: move _17 }
            _0 = move _18
            storage_dead(_3)
            return
        },
    }
    loop {
        v_10 = move (self_4 as variant Result::Ok).0
        _3 = ControlFlow::Continue { 0: copy v_10 }
        storage_dead(v_10)
        storage_dead(self_4)
        ptr_5 = copy (_3 as variant ControlFlow::Continue).0
        storage_dead(_3)
        storage_live(self_7)
        storage_live(self_8)
        storage_live(_11)
        _12 = transmute<NonNull<[u8]>, *mut [u8]>(copy ptr_5)
        _11 = cast<*mut [u8], *const u8>(copy _12)
        self_8 = NonNull { pointer: copy _11 }
        storage_dead(_11)
        self_7 = cast<*mut [u8], *mut u8>(copy _12)
        storage_dead(self_8)
        storage_live(count_9)
        count_9 = copy _12.metadata
        storage_live(_16)
        _16 = ub_checks<bool>
        if copy _16 {
            storage_live(_14)
            _14 = cast<*mut [u8], *const ()>(copy _12)
            storage_live(_15)
            _15 = copy count_9 == const 0 : usize
            _13 = core::ptr::write_bytes::precondition_check(move _14, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN, move _15)
            storage_dead(_15)
            storage_dead(_14)
        } else {
        }
        break 0
    }
    _6 = write_bytes<u8>[{built_in impl Sized for u8}](move self_7, const 0 : u8, move count_9)
    storage_dead(_16)
    storage_dead(count_9)
    storage_dead(self_7)
    _0 = Result::Ok { 0: copy ptr_5 }
    return
}

pub unsafe fn core::alloc::Allocator::deallocate<'_0, Self>(@1: &'_0 Self, @2: NonNull<u8>, @3: Layout)
where
    [@TraitClause0]: Allocator<Self>,
= <method_without_default_body>

// Full name: core::intrinsics::cold_path
pub fn cold_path()
{
    let _0: (); // return

    _0 = ()
    return
}

// Full name: core::fmt::{Arguments<'a>}::from_str
pub fn from_str<'a>(@1: &'static Str) -> Arguments<'a>
{
    let _0: Arguments<'0>; // return
    let s_1: &'1 Str; // arg #1
    let _2: NonNull<u8>; // anonymous local
    let _3: *const u8; // anonymous local
    let _4: NonNull<Argument<'2>>; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let _8: *const Str; // anonymous local
    let _9: &'3 [u8]; // anonymous local

    storage_live(_2)
    storage_live(_3)
    storage_live(_8)
    _8 = &raw const (*s_1) with_metadata(copy s_1.metadata)
    _3 = cast<*const Str, *const u8>(copy _8)
    storage_dead(_8)
    _2 = transmute<*const u8, NonNull<u8>>(copy _3)
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    storage_live(_9)
    _9 = transmute<&'1 Str, &'3 [u8]>(copy s_1)
    _7 = copy _9.metadata
    storage_dead(_9)
    _6 = move _7 wrap.<< const 1 : i32
    storage_dead(_7)
    _5 = move _6 | const 1 : usize
    storage_dead(_6)
    _4 = transmute<usize, NonNull<Argument<'2>>>(move _5)
    storage_dead(_5)
    _0 = Arguments { template: move _2, args: move _4 }
    storage_dead(_4)
    storage_dead(_2)
    return
}

// Full name: core::panicking::panic_nounwind
#[lang_item("panic_nounwind")]
pub fn panic_nounwind(@1: &'static Str) -> !
{
    let _0: !; // return
    let expr_1: &'0 Str; // arg #1
    let _2: !; // anonymous local
    let _3: Arguments<'1>; // anonymous local
    let _4: &'0 Str; // anonymous local

    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    _4 = copy expr_1
    _3 = from_str<'2>(move _4)
    storage_dead(_4)
    _2 = panic_nounwind_fmt<'_>(move _3, const false)
}

// Full name: core::ub_checks::maybe_is_nonoverlapping::runtime
fn runtime(@1: *const (), @2: *const (), @3: usize, @4: usize) -> bool
{
    let _0: bool; // return
    let src_1: *const (); // arg #1
    let dst_2: *const (); // arg #2
    let size_3: usize; // arg #3
    let count_4: usize; // arg #4
    let src_usize_5: usize; // local
    let dst_usize_6: usize; // local
    let _7: !; // anonymous local
    let size_8: usize; // local
    let _9: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let diff_10: usize; // local
    let _11: u64; // anonymous local
    let b_12: bool; // local
    let _13: (u64, bool); // anonymous local
    let _14: u64; // anonymous local
    let _15: u64; // anonymous local
    let a_16: usize; // local
    let _17: (); // anonymous local
    let _18: bool; // anonymous local

    storage_live(src_usize_5)
    storage_live(dst_usize_6)
    storage_live(_7)
    storage_live(size_8)
    storage_live(diff_10)
    storage_live(_17)
    src_usize_5 = transmute<*const (), usize>(copy src_1)
    dst_usize_6 = transmute<*const (), usize>(copy dst_2)
    storage_live(_9)
    storage_live(b_12)
    storage_live(a_16)
    storage_live(_11)
    storage_live(_13)
    storage_live(_14)
    _14 = cast<usize, u64>(copy size_3)
    storage_live(_15)
    _15 = cast<usize, u64>(copy count_4)
    _13 = move _14 checked.* move _15
    storage_dead(_15)
    storage_dead(_14)
    _11 = copy _13.0
    b_12 = copy _13.1
    storage_dead(_13)
    a_16 = cast<u64, usize>(copy _11)
    storage_dead(_11)
    if copy b_12 {
    } else {
        loop {
            _9 = Option::Some { 0: copy a_16 }
            storage_dead(a_16)
            storage_dead(b_12)
            size_8 = copy (_9 as variant Option::Some).0
            storage_dead(_9)
            storage_live(_18)
            _18 = copy src_usize_5 < copy dst_usize_6
            if move _18 {
                diff_10 = copy dst_usize_6 wrap.- copy src_usize_5
            } else {
                diff_10 = copy src_usize_5 wrap.- copy dst_usize_6
            }
            break 0
        }
        storage_dead(_18)
        _0 = move diff_10 >= copy size_8
        return
    }
    _17 = cold_path()
    storage_dead(a_16)
    storage_dead(b_12)
    storage_dead(_9)
    _7 = panic_nounwind(const "is_nonoverlapping: `size_of::<T>() * count` overflows a usize")
}

fn core::ptr::copy_nonoverlapping::precondition_check(@1: *const (), @2: *mut (), @3: usize, @4: usize, @5: usize)
{
    let _0: (); // return
    let src_1: *const (); // arg #1
    let dst_2: *mut (); // arg #2
    let size_3: usize; // arg #3
    let align_4: usize; // arg #4
    let count_5: usize; // arg #5
    let _6: bool; // anonymous local
    let zero_size_7: bool; // local
    let _8: bool; // anonymous local
    let align_9: usize; // local
    let is_zst_10: bool; // local
    let _11: bool; // anonymous local
    let ptr_12: *const (); // local
    let msg_13: &'0 Str; // local
    let _14: !; // anonymous local
    let _15: Arguments<'1>; // anonymous local
    let _16: bool; // anonymous local
    let _17: bool; // anonymous local
    let _18: usize; // anonymous local
    let _19: bool; // anonymous local
    let _20: bool; // anonymous local
    let _21: usize; // anonymous local
    let _22: NonNull<u8>; // anonymous local
    let _23: *const u8; // anonymous local
    let _24: NonNull<Argument<'2>>; // anonymous local
    let _25: usize; // anonymous local
    let _26: usize; // anonymous local
    let _27: usize; // anonymous local
    let _28: *const Str; // anonymous local
    let _29: &'3 [u8]; // anonymous local

    loop {
        loop {
            loop {
                loop {
                    loop {
                        loop {
                            storage_live(zero_size_7)
                            storage_live(ptr_12)
                            storage_live(msg_13)
                            storage_live(_14)
                            _0 = ()
                            storage_live(_6)
                            switch copy count_5 {
                                0 : usize => {
                                    zero_size_7 = const true
                                    storage_live(_8)
                                    storage_live(align_9)
                                    align_9 = copy align_4
                                    storage_live(is_zst_10)
                                    is_zst_10 = copy zero_size_7
                                    storage_live(_16)
                                    _16 = is_aligned_to<()>(copy src_1, copy align_4)
                                    if move _16 {
                                        break 0
                                    } else {
                                        break 2
                                    }
                                },
                                _ => {
                                    zero_size_7 = copy size_3 == const 0 : usize
                                    storage_live(_8)
                                    storage_live(align_9)
                                    align_9 = copy align_4
                                    storage_live(is_zst_10)
                                    is_zst_10 = copy zero_size_7
                                    storage_live(_16)
                                    _16 = is_aligned_to<()>(copy src_1, copy align_4)
                                    if move _16 {
                                        if copy is_zst_10 {
                                            break 0
                                        } else {
                                            storage_live(_17)
                                            storage_live(_18)
                                            _18 = transmute<*const (), usize>(copy src_1)
                                            _17 = move _18 == const 0 : usize
                                            storage_dead(_18)
                                            _8 = ~(move _17)
                                            storage_dead(_17)
                                            storage_dead(_16)
                                            if move _8 {
                                                break 1
                                            } else {
                                                break 3
                                            }
                                        }
                                    } else {
                                        break 2
                                    }
                                },
                            }
                            break 5
                            break 0
                        }
                        storage_dead(_16)
                        break 0
                    }
                    storage_dead(is_zst_10)
                    storage_dead(align_9)
                    storage_live(_11)
                    ptr_12 = cast<*mut (), *const ()>(copy dst_2)
                    storage_live(_19)
                    _19 = is_aligned_to<()>(copy ptr_12, move align_4)
                    loop {
                        if move _19 {
                            loop {
                                if copy zero_size_7 {
                                    storage_dead(_19)
                                } else {
                                    storage_live(_20)
                                    storage_live(_21)
                                    _21 = transmute<*mut (), usize>(copy dst_2)
                                    _20 = move _21 == const 0 : usize
                                    storage_dead(_21)
                                    _11 = ~(move _20)
                                    storage_dead(_20)
                                    storage_dead(_19)
                                    if move _11 {
                                    } else {
                                        break 1
                                    }
                                }
                                break 0
                            }
                            _6 = runtime(move src_1, move ptr_12, move size_3, move count_5)
                            storage_dead(_11)
                            storage_dead(_8)
                            if move _6 {
                                storage_dead(_6)
                                return
                            } else {
                                break 4
                            }
                        } else {
                            storage_dead(_19)
                        }
                        break 0
                    }
                    break 2
                    break 0
                }
                storage_dead(_16)
                break 0
            }
            storage_dead(is_zst_10)
            storage_dead(align_9)
            break 0
        }
        storage_dead(_11)
        storage_dead(_8)
        break 0
    }
    msg_13 = const "unsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
    storage_live(_15)
    storage_live(_22)
    storage_live(_23)
    storage_live(_28)
    _28 = &raw const (*msg_13) with_metadata(copy msg_13.metadata)
    _23 = cast<*const Str, *const u8>(copy _28)
    storage_dead(_28)
    _22 = transmute<*const u8, NonNull<u8>>(copy _23)
    storage_dead(_23)
    storage_live(_24)
    storage_live(_25)
    storage_live(_26)
    storage_live(_27)
    storage_live(_29)
    _29 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    _27 = copy _29.metadata
    storage_dead(_29)
    _26 = move _27 wrap.<< const 1 : i32
    storage_dead(_27)
    _25 = move _26 | const 1 : usize
    storage_dead(_26)
    _24 = transmute<usize, NonNull<Argument<'2>>>(move _25)
    storage_dead(_25)
    _15 = Arguments { template: move _22, args: move _24 }
    storage_dead(_24)
    storage_dead(_22)
    _14 = panic_nounwind_fmt<'_>(move _15, const false)
}

pub unsafe fn core::alloc::Allocator::grow<'_0, Self>(@1: &'_0 Self, @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Self; // arg #1
    let ptr_2: NonNull<u8>; // arg #2
    let old_layout_3: Layout; // arg #3
    let new_layout_4: Layout; // arg #4
    let _5: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<[u8]>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<[u8]>}]; // anonymous local
    let self_6: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr_7: NonNull<[u8]>; // local
    let src_8: *const u8; // local
    let dst_9: *mut u8; // local
    let count_10: usize; // local
    let _11: (); // anonymous local
    let v_12: NonNull<[u8]>; // local
    let _13: *mut [u8]; // anonymous local
    let _14: (); // anonymous local
    let _15: *const (); // anonymous local
    let _16: *mut (); // anonymous local
    let _17: bool; // anonymous local
    let _18: AllocError; // anonymous local
    let _19: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(new_ptr_7)
    storage_live(_11)
    storage_live(_13)
    storage_live(_14)
    storage_live(_5)
    storage_live(self_6)
    self_6 = @TraitClause0::allocate<'_>(copy self_1, move new_layout_4)
    storage_live(v_12)
    match self_6 {
        Result::Ok => {
        },
        Result::Err => {
            storage_dead(v_12)
            storage_dead(self_6)
            storage_live(_18)
            _18 = AllocError {  }
            storage_live(_19)
            _19 = Result::Err { 0: move _18 }
            _0 = move _19
            storage_dead(_5)
            return
        },
    }
    loop {
        v_12 = move (self_6 as variant Result::Ok).0
        _5 = ControlFlow::Continue { 0: copy v_12 }
        storage_dead(v_12)
        storage_dead(self_6)
        new_ptr_7 = copy (_5 as variant ControlFlow::Continue).0
        storage_dead(_5)
        storage_live(src_8)
        src_8 = transmute<NonNull<u8>, *const u8>(copy ptr_2)
        storage_live(dst_9)
        _13 = transmute<NonNull<[u8]>, *mut [u8]>(copy new_ptr_7)
        dst_9 = cast<*mut [u8], *mut u8>(copy _13)
        storage_live(count_10)
        count_10 = copy (old_layout_3).size
        storage_live(_17)
        _17 = ub_checks<bool>
        if copy _17 {
            storage_live(_15)
            _15 = transmute<NonNull<u8>, *const ()>(copy ptr_2)
            storage_live(_16)
            _16 = cast<*mut [u8], *mut ()>(copy _13)
            _14 = core::ptr::copy_nonoverlapping::precondition_check(move _15, move _16, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN, copy count_10)
            storage_dead(_16)
            storage_dead(_15)
        } else {
        }
        break 0
    }
    copy_nonoverlapping(copy src_8, copy dst_9, copy count_10)
    storage_dead(_17)
    storage_dead(count_10)
    storage_dead(dst_9)
    storage_dead(src_8)
    _11 = @TraitClause0::deallocate<'_>(move self_1, move ptr_2, move old_layout_3)
    _0 = Result::Ok { 0: copy new_ptr_7 }
    return
}

pub unsafe fn core::alloc::Allocator::grow_zeroed<'_0, Self>(@1: &'_0 Self, @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Self; // arg #1
    let ptr_2: NonNull<u8>; // arg #2
    let old_layout_3: Layout; // arg #3
    let new_layout_4: Layout; // arg #4
    let _5: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<[u8]>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<[u8]>}]; // anonymous local
    let self_6: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr_7: NonNull<[u8]>; // local
    let src_8: *const u8; // local
    let dst_9: *mut u8; // local
    let count_10: usize; // local
    let _11: (); // anonymous local
    let v_12: NonNull<[u8]>; // local
    let _13: *mut [u8]; // anonymous local
    let _14: (); // anonymous local
    let _15: *const (); // anonymous local
    let _16: *mut (); // anonymous local
    let _17: bool; // anonymous local
    let _18: AllocError; // anonymous local
    let _19: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(new_ptr_7)
    storage_live(_11)
    storage_live(_13)
    storage_live(_14)
    storage_live(_5)
    storage_live(self_6)
    self_6 = @TraitClause0::allocate_zeroed<'_>(copy self_1, move new_layout_4)
    storage_live(v_12)
    match self_6 {
        Result::Ok => {
        },
        Result::Err => {
            storage_dead(v_12)
            storage_dead(self_6)
            storage_live(_18)
            _18 = AllocError {  }
            storage_live(_19)
            _19 = Result::Err { 0: move _18 }
            _0 = move _19
            storage_dead(_5)
            return
        },
    }
    loop {
        v_12 = move (self_6 as variant Result::Ok).0
        _5 = ControlFlow::Continue { 0: copy v_12 }
        storage_dead(v_12)
        storage_dead(self_6)
        new_ptr_7 = copy (_5 as variant ControlFlow::Continue).0
        storage_dead(_5)
        storage_live(src_8)
        src_8 = transmute<NonNull<u8>, *const u8>(copy ptr_2)
        storage_live(dst_9)
        _13 = transmute<NonNull<[u8]>, *mut [u8]>(copy new_ptr_7)
        dst_9 = cast<*mut [u8], *mut u8>(copy _13)
        storage_live(count_10)
        count_10 = copy (old_layout_3).size
        storage_live(_17)
        _17 = ub_checks<bool>
        if copy _17 {
            storage_live(_15)
            _15 = transmute<NonNull<u8>, *const ()>(copy ptr_2)
            storage_live(_16)
            _16 = cast<*mut [u8], *mut ()>(copy _13)
            _14 = core::ptr::copy_nonoverlapping::precondition_check(move _15, move _16, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN, copy count_10)
            storage_dead(_16)
            storage_dead(_15)
        } else {
        }
        break 0
    }
    copy_nonoverlapping(copy src_8, copy dst_9, copy count_10)
    storage_dead(_17)
    storage_dead(count_10)
    storage_dead(dst_9)
    storage_dead(src_8)
    _11 = @TraitClause0::deallocate<'_>(move self_1, move ptr_2, move old_layout_3)
    _0 = Result::Ok { 0: copy new_ptr_7 }
    return
}

pub unsafe fn core::alloc::Allocator::shrink<'_0, Self>(@1: &'_0 Self, @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Self; // arg #1
    let ptr_2: NonNull<u8>; // arg #2
    let old_layout_3: Layout; // arg #3
    let new_layout_4: Layout; // arg #4
    let _5: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<[u8]>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<[u8]>}]; // anonymous local
    let self_6: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr_7: NonNull<[u8]>; // local
    let src_8: *const u8; // local
    let dst_9: *mut u8; // local
    let count_10: usize; // local
    let _11: (); // anonymous local
    let v_12: NonNull<[u8]>; // local
    let _13: *mut [u8]; // anonymous local
    let _14: (); // anonymous local
    let _15: *const (); // anonymous local
    let _16: *mut (); // anonymous local
    let _17: bool; // anonymous local
    let _18: AllocError; // anonymous local
    let _19: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(new_ptr_7)
    storage_live(_11)
    storage_live(_13)
    storage_live(_14)
    storage_live(_5)
    storage_live(self_6)
    self_6 = @TraitClause0::allocate<'_>(copy self_1, copy new_layout_4)
    storage_live(v_12)
    match self_6 {
        Result::Ok => {
        },
        Result::Err => {
            storage_dead(v_12)
            storage_dead(self_6)
            storage_live(_18)
            _18 = AllocError {  }
            storage_live(_19)
            _19 = Result::Err { 0: move _18 }
            _0 = move _19
            storage_dead(_5)
            return
        },
    }
    loop {
        v_12 = move (self_6 as variant Result::Ok).0
        _5 = ControlFlow::Continue { 0: copy v_12 }
        storage_dead(v_12)
        storage_dead(self_6)
        new_ptr_7 = copy (_5 as variant ControlFlow::Continue).0
        storage_dead(_5)
        storage_live(src_8)
        src_8 = transmute<NonNull<u8>, *const u8>(copy ptr_2)
        storage_live(dst_9)
        _13 = transmute<NonNull<[u8]>, *mut [u8]>(copy new_ptr_7)
        dst_9 = cast<*mut [u8], *mut u8>(copy _13)
        storage_live(count_10)
        count_10 = copy (new_layout_4).size
        storage_live(_17)
        _17 = ub_checks<bool>
        if copy _17 {
            storage_live(_15)
            _15 = transmute<NonNull<u8>, *const ()>(copy ptr_2)
            storage_live(_16)
            _16 = cast<*mut [u8], *mut ()>(copy _13)
            _14 = core::ptr::copy_nonoverlapping::precondition_check(move _15, move _16, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN, copy count_10)
            storage_dead(_16)
            storage_dead(_15)
        } else {
        }
        break 0
    }
    copy_nonoverlapping(copy src_8, copy dst_9, copy count_10)
    storage_dead(_17)
    storage_dead(count_10)
    storage_dead(dst_9)
    storage_dead(src_8)
    _11 = @TraitClause0::deallocate<'_>(move self_1, move ptr_2, move old_layout_3)
    _0 = Result::Ok { 0: copy new_ptr_7 }
    return
}

pub fn core::alloc::Allocator::by_ref<'_0, Self>(@1: &'_0 Self) -> &'_0 Self
where
    [@TraitClause0]: Allocator<Self>,
    [@TraitClause1]: Sized<Self>,
{
    let _0: &'0 Self; // return
    let self_1: &'0 Self; // arg #1

    _0 = copy self_1
    return
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <method_without_default_body>

pub fn core::clone::Clone::clone_from<'_0, '_1, Self>(@1: &'_0 mut Self, @2: &'_1 Self)
where
    [@TraitClause0]: Clone<Self>,
    [@TraitClause1]: Destruct<Self>,
{
    let _0: (); // return
    let self_1: &'0 mut Self; // arg #1
    let source_2: &'1 Self; // arg #2
    let _3: Self; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = @TraitClause0::clone<'_>(move source_2)
    drop[@TraitClause1] (*self_1)
    (*self_1) = move _3
    storage_dead(_3)
    return
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <missing>

// Full name: core::num::niche_types::NonZeroUsizeInner
pub struct NonZeroUsizeInner {
  usize,
}

// Full name: core::num::niche_types::{impl Clone for NonZeroUsizeInner}::clone
pub fn {impl Clone for NonZeroUsizeInner}::clone<'_0>(@1: &'_0 NonZeroUsizeInner) -> NonZeroUsizeInner
{
    let _0: NonZeroUsizeInner; // return
    let self_1: &'0 NonZeroUsizeInner; // arg #1

    _0 = copy (*self_1)
    return
}

// Full name: core::num::niche_types::{impl Clone for NonZeroUsizeInner}::clone_from
pub fn {impl Clone for NonZeroUsizeInner}::clone_from<'_0, '_1>(@1: &'_0 mut NonZeroUsizeInner, @2: &'_1 NonZeroUsizeInner)
where
    [@TraitClause0]: Destruct<NonZeroUsizeInner>,
{
    let _0: (); // return
    let self_1: &'0 mut NonZeroUsizeInner; // arg #1
    let source_2: &'1 NonZeroUsizeInner; // arg #2
    let _3: NonZeroUsizeInner; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = {impl Clone for NonZeroUsizeInner}::clone<'_>(move source_2)
    drop[@TraitClause0] (*self_1)
    (*self_1) = move _3
    storage_dead(_3)
    return
}

// Full name: core::num::niche_types::{impl Clone for NonZeroUsizeInner}
impl Clone for NonZeroUsizeInner {
    parent_clause0 = {built_in impl Sized for NonZeroUsizeInner}
    fn clone<'_0_1> = {impl Clone for NonZeroUsizeInner}::clone<'_0_1>
    fn clone_from<'_0_1, '_1_1, [@TraitClause0_1]: Destruct<NonZeroUsizeInner>> = {impl Clone for NonZeroUsizeInner}::clone_from<'_0_1, '_1_1>[@TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::num::niche_types::{impl Copy for NonZeroUsizeInner}
impl Copy for NonZeroUsizeInner {
    parent_clause0 = {built_in impl MetaSized for NonZeroUsizeInner}
    parent_clause1 = {impl Clone for NonZeroUsizeInner}
    non-dyn-compatible
}

// Full name: core::num::nonzero::private::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::num::nonzero::private::Sealed::{vtable}
}

// Full name: core::num::nonzero::ZeroablePrimitive
pub trait ZeroablePrimitive<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Copy<Self>
    parent_clause2 : [@TraitClause2]: Sealed<Self>
    parent_clause3 : [@TraitClause3]: Sized<Self::NonZeroInner>
    parent_clause4 : [@TraitClause4]: Copy<Self::NonZeroInner>
    type NonZeroInner
    non-dyn-compatible
}

// Full name: core::num::nonzero::{impl Sealed for usize}
impl Sealed for usize {
    parent_clause0 = {built_in impl MetaSized for usize}
    vtable: {impl Sealed for usize}::{vtable}
}

// Full name: core::num::nonzero::{impl ZeroablePrimitive for usize}
impl ZeroablePrimitive for usize {
    parent_clause0 = {built_in impl Sized for usize}
    parent_clause1 = {impl Copy for usize}
    parent_clause2 = {impl Sealed for usize}
    parent_clause3 = {built_in impl Sized for NonZeroUsizeInner}
    parent_clause4 = {impl Copy for NonZeroUsizeInner}
    type NonZeroInner = NonZeroUsizeInner
    non-dyn-compatible
}

// Full name: core::num::nonzero::NonZero
#[lang_item("NonZero")]
pub struct NonZero<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ZeroablePrimitive<T>,
{
  @TraitClause1::NonZeroInner,
}

// Full name: core::ptr::unique::Unique
pub struct Unique<T> {
  pointer: NonNull<T>,
  _marker: PhantomData<T>,
}

fn core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(@1: *mut ())
{
    let _0: (); // return
    let ptr_1: *mut (); // arg #1
    let msg_2: &'0 Str; // local
    let _3: !; // anonymous local
    let _4: Arguments<'1>; // anonymous local
    let _5: usize; // anonymous local
    let _6: NonNull<u8>; // anonymous local
    let _7: *const u8; // anonymous local
    let _8: NonNull<Argument<'2>>; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local
    let _11: usize; // anonymous local
    let _12: *const Str; // anonymous local
    let _13: &'3 [u8]; // anonymous local

    storage_live(msg_2)
    storage_live(_3)
    _0 = ()
    storage_live(_5)
    _5 = transmute<*mut (), usize>(copy ptr_1)
    switch move _5 {
        0 : usize => {
        },
        _ => {
            storage_dead(_5)
            return
        },
    }
    storage_dead(_5)
    msg_2 = const "unsafe precondition(s) violated: NonNull::new_unchecked requires that the pointer is non-null\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
    storage_live(_4)
    storage_live(_6)
    storage_live(_7)
    storage_live(_12)
    _12 = &raw const (*msg_2) with_metadata(copy msg_2.metadata)
    _7 = cast<*const Str, *const u8>(copy _12)
    storage_dead(_12)
    _6 = transmute<*const u8, NonNull<u8>>(copy _7)
    storage_dead(_7)
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    storage_live(_11)
    storage_live(_13)
    _13 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: NonNull::new_unchecked requires that the pointer is non-null\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    _11 = copy _13.metadata
    storage_dead(_13)
    _10 = move _11 wrap.<< const 1 : i32
    storage_dead(_11)
    _9 = move _10 | const 1 : usize
    storage_dead(_10)
    _8 = transmute<usize, NonNull<Argument<'2>>>(move _9)
    storage_dead(_9)
    _4 = Arguments { template: move _6, args: move _8 }
    storage_dead(_8)
    storage_dead(_6)
    _3 = panic_nounwind_fmt<'_>(move _4, const false)
}

fn core::hint::assert_unchecked::precondition_check(@1: bool)
{
    let _0: (); // return
    let cond_1: bool; // arg #1
    let msg_2: &'0 Str; // local
    let _3: !; // anonymous local
    let _4: Arguments<'1>; // anonymous local
    let _5: NonNull<u8>; // anonymous local
    let _6: *const u8; // anonymous local
    let _7: NonNull<Argument<'2>>; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local
    let _11: *const Str; // anonymous local
    let _12: &'3 [u8]; // anonymous local

    storage_live(msg_2)
    storage_live(_3)
    _0 = ()
    if copy cond_1 {
    } else {
        msg_2 = const "unsafe precondition(s) violated: hint::assert_unchecked must never be called when the condition is false\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
        storage_live(_4)
        storage_live(_5)
        storage_live(_6)
        storage_live(_11)
        _11 = &raw const (*msg_2) with_metadata(copy msg_2.metadata)
        _6 = cast<*const Str, *const u8>(copy _11)
        storage_dead(_11)
        _5 = transmute<*const u8, NonNull<u8>>(copy _6)
        storage_dead(_6)
        storage_live(_7)
        storage_live(_8)
        storage_live(_9)
        storage_live(_10)
        storage_live(_12)
        _12 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: hint::assert_unchecked must never be called when the condition is false\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
        _10 = copy _12.metadata
        storage_dead(_12)
        _9 = move _10 wrap.<< const 1 : i32
        storage_dead(_10)
        _8 = move _9 | const 1 : usize
        storage_dead(_9)
        _7 = transmute<usize, NonNull<Argument<'2>>>(move _8)
        storage_dead(_8)
        _4 = Arguments { template: move _5, args: move _7 }
        storage_dead(_7)
        storage_dead(_5)
        _3 = panic_nounwind_fmt<'_>(move _4, const false)
    }
    return
}

// Full name: alloc::alloc::__rust_alloc
unsafe fn __rust_alloc(@1: usize, @2: usize) -> *mut u8
= <opaque>

// Full name: alloc::alloc::__rust_dealloc
unsafe fn __rust_dealloc(@1: *mut u8, @2: usize, @3: usize)
= <opaque>

// Full name: alloc::alloc::__rust_realloc
unsafe fn __rust_realloc(@1: *mut u8, @2: usize, @3: usize, @4: usize) -> *mut u8
= <opaque>

// Full name: alloc::alloc::__rust_alloc_zeroed
unsafe fn __rust_alloc_zeroed(@1: usize, @2: usize) -> *mut u8
= <opaque>

// Full name: alloc::alloc::__rust_no_alloc_shim_is_unstable_v2
unsafe fn __rust_no_alloc_shim_is_unstable_v2()
= <opaque>

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::alloc::{Global}::alloc_impl
fn alloc_impl<'_0>(@1: &'_0 Global, @2: Layout, @3: bool) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Global; // arg #1
    let layout_2: Layout; // arg #2
    let zeroed_3: bool; // arg #3
    let size_4: usize; // local
    let _5: NonNull<[u8]>; // anonymous local
    let data_6: NonNull<u8>; // local
    let raw_ptr_7: *mut u8; // local
    let _8: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<u8>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<u8>}]; // anonymous local
    let self_9: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // local
    let self_10: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // local
    let ptr_11: NonNull<u8>; // local
    let _12: NonNull<[u8]>; // anonymous local
    let _13: NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}]; // anonymous local
    let _14: Alignment; // anonymous local
    let _15: *const u8; // anonymous local
    let ptr_16: *mut [u8]; // local
    let data_17: *mut u8; // local
    let _18: (); // anonymous local
    let _19: *mut (); // anonymous local
    let _20: *const [u8]; // anonymous local
    let _21: bool; // anonymous local
    let _22: (); // anonymous local
    let _23: usize; // anonymous local
    let _24: AlignmentEnum; // anonymous local
    let _25: (); // anonymous local
    let _26: usize; // anonymous local
    let _27: AlignmentEnum; // anonymous local
    let _28: NonNull<u8>; // anonymous local
    let _29: *const u8; // anonymous local
    let _30: usize; // anonymous local
    let _31: (); // anonymous local
    let _32: *mut (); // anonymous local
    let _33: bool; // anonymous local
    let v_34: NonNull<u8>; // local
    let v_35: NonNull<u8>; // local
    let ptr_36: *mut [u8]; // local
    let data_37: *mut u8; // local
    let _38: (); // anonymous local
    let _39: *mut (); // anonymous local
    let _40: *const [u8]; // anonymous local
    let _41: bool; // anonymous local
    let _42: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // anonymous local
    let _43: AllocError; // anonymous local
    let _44: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // anonymous local
    let _45: AllocError; // anonymous local
    let _46: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(size_4)
    storage_live(raw_ptr_7)
    storage_live(ptr_11)
    storage_live(_13)
    storage_live(_18)
    storage_live(_22)
    storage_live(_25)
    storage_live(_29)
    storage_live(_31)
    storage_live(_38)
    size_4 = copy (layout_2).size
    switch copy size_4 {
        0 : usize => {
        },
        _ => {
            loop {
                if copy zeroed_3 {
                    _22 = __rust_no_alloc_shim_is_unstable_v2()
                    storage_live(_23)
                    storage_live(_24)
                    _24 = copy ((layout_2).align).0
                    _23 = @discriminant(_24)
                    storage_dead(_24)
                    raw_ptr_7 = __rust_alloc_zeroed(copy size_4, move _23)
                    storage_dead(_23)
                } else {
                    _25 = __rust_no_alloc_shim_is_unstable_v2()
                    storage_live(_26)
                    storage_live(_27)
                    _27 = copy ((layout_2).align).0
                    _26 = @discriminant(_27)
                    storage_dead(_27)
                    raw_ptr_7 = __rust_alloc(copy size_4, move _26)
                    storage_dead(_26)
                }
                break 0
            }
            storage_live(_8)
            storage_live(self_9)
            storage_live(self_10)
            _29 = cast<*mut u8, *const u8>(copy raw_ptr_7)
            storage_live(_30)
            _30 = transmute<*mut u8, usize>(copy raw_ptr_7)
            switch move _30 {
                0 : usize => {
                },
                _ => {
                    loop {
                        storage_dead(_30)
                        storage_live(_28)
                        storage_live(_33)
                        _33 = ub_checks<bool>
                        if copy _33 {
                            storage_live(_32)
                            _32 = cast<*mut u8, *mut ()>(copy raw_ptr_7)
                            _31 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _32)
                            storage_dead(_32)
                        } else {
                        }
                        break 0
                    }
                    loop {
                        _28 = NonNull { pointer: copy _29 }
                        storage_dead(_33)
                        self_10 = Option::Some { 0: move _28 }
                        storage_dead(_28)
                        storage_live(v_34)
                        v_34 = move (self_10 as variant Option::Some).0
                        self_9 = Result::Ok { 0: copy v_34 }
                        storage_dead(v_34)
                        storage_dead(self_10)
                        storage_live(v_35)
                        v_35 = move (self_9 as variant Result::Ok).0
                        _8 = ControlFlow::Continue { 0: copy v_35 }
                        storage_dead(v_35)
                        storage_dead(self_9)
                        ptr_11 = copy (_8 as variant ControlFlow::Continue).0
                        storage_dead(_8)
                        storage_live(_12)
                        storage_live(ptr_36)
                        storage_live(data_37)
                        data_37 = transmute<NonNull<u8>, *mut u8>(copy ptr_11)
                        ptr_36 = *mut  (copy data_37, copy size_4)
                        storage_dead(data_37)
                        storage_live(_40)
                        storage_live(_41)
                        _41 = ub_checks<bool>
                        if copy _41 {
                            storage_live(_39)
                            _39 = transmute<NonNull<u8>, *mut ()>(copy ptr_11)
                            _38 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _39)
                            storage_dead(_39)
                        } else {
                        }
                        break 0
                    }
                    _40 = cast<*mut [u8], *const [u8]>(copy ptr_36)
                    _12 = NonNull { pointer: copy _40 }
                    storage_dead(_41)
                    storage_dead(_40)
                    storage_dead(ptr_36)
                    _0 = Result::Ok { 0: move _12 }
                    storage_dead(_12)
                    return
                },
            }
            storage_dead(_30)
            storage_live(_42)
            _42 = Option::None {  }
            self_10 = move _42
            storage_live(v_34)
            storage_live(_43)
            _43 = AllocError {  }
            storage_live(_44)
            _44 = Result::Err { 0: move _43 }
            self_9 = move _44
            storage_dead(v_34)
            storage_dead(self_10)
            storage_live(v_35)
            storage_dead(v_35)
            storage_dead(self_9)
            storage_live(_45)
            _45 = AllocError {  }
            storage_live(_46)
            _46 = Result::Err { 0: move _45 }
            _0 = move _46
            storage_dead(_8)
            return
        },
    }
    loop {
        storage_live(_5)
        storage_live(data_6)
        storage_live(_14)
        _14 = copy (layout_2).align
        _13 = transmute<Alignment, NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}]>(copy _14)
        storage_dead(_14)
        storage_live(_15)
        _15 = transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *const u8>(copy _13)
        data_6 = NonNull { pointer: copy _15 }
        storage_dead(_15)
        storage_live(ptr_16)
        storage_live(data_17)
        data_17 = transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *mut u8>(copy _13)
        ptr_16 = *mut  (copy data_17, const 0 : usize)
        storage_dead(data_17)
        storage_live(_20)
        storage_live(_21)
        _21 = ub_checks<bool>
        if copy _21 {
            storage_live(_19)
            _19 = transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *mut ()>(copy _13)
            _18 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _19)
            storage_dead(_19)
        } else {
        }
        break 0
    }
    _20 = cast<*mut [u8], *const [u8]>(copy ptr_16)
    _5 = NonNull { pointer: copy _20 }
    storage_dead(_21)
    storage_dead(_20)
    storage_dead(ptr_16)
    storage_dead(data_6)
    _0 = Result::Ok { 0: move _5 }
    storage_dead(_5)
    return
}

// Full name: alloc::alloc::{Global}::grow_impl
unsafe fn grow_impl<'_0>(@1: &'_0 Global, @2: NonNull<u8>, @3: Layout, @4: Layout, @5: bool) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Global; // arg #1
    let ptr_2: NonNull<u8>; // arg #2
    let old_layout_3: Layout; // arg #3
    let new_layout_4: Layout; // arg #4
    let zeroed_5: bool; // arg #5
    let old_size_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let new_size_10: usize; // local
    let cond_11: bool; // local
    let raw_ptr_12: *mut u8; // local
    let ptr_13: *mut u8; // local
    let self_14: NonNull<u8>; // local
    let new_size_15: usize; // local
    let _16: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<u8>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<u8>}]; // anonymous local
    let self_17: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // local
    let self_18: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // local
    let ptr_19: *mut u8; // local
    let ptr_20: NonNull<u8>; // local
    let _21: (); // anonymous local
    let self_22: *mut u8; // local
    let self_23: *mut u8; // local
    let count_24: usize; // local
    let _25: NonNull<[u8]>; // anonymous local
    let _26: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<[u8]>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<[u8]>}]; // anonymous local
    let self_27: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr_28: NonNull<[u8]>; // local
    let src_29: *const u8; // local
    let ptr_30: *mut u8; // local
    let dst_31: *mut u8; // local
    let _32: (); // anonymous local
    let _33: AlignmentEnum; // anonymous local
    let _34: AlignmentEnum; // anonymous local
    let _35: (); // anonymous local
    let _36: bool; // anonymous local
    let _37: NonNull<u8>; // anonymous local
    let _38: *const u8; // anonymous local
    let _39: usize; // anonymous local
    let _40: (); // anonymous local
    let _41: *mut (); // anonymous local
    let v_42: NonNull<u8>; // local
    let v_43: NonNull<u8>; // local
    let _44: (); // anonymous local
    let _45: *const (); // anonymous local
    let _46: bool; // anonymous local
    let ptr_47: *mut [u8]; // local
    let data_48: *mut u8; // local
    let _49: (); // anonymous local
    let _50: *mut (); // anonymous local
    let _51: *const [u8]; // anonymous local
    let v_52: NonNull<[u8]>; // local
    let _53: *mut [u8]; // anonymous local
    let _54: (); // anonymous local
    let _55: *const (); // anonymous local
    let _56: *mut (); // anonymous local
    let _57: bool; // anonymous local
    let _58: AllocError; // anonymous local
    let _59: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local
    let _60: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // anonymous local
    let _61: AllocError; // anonymous local
    let _62: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // anonymous local
    let _63: AllocError; // anonymous local
    let _64: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(old_size_6)
    storage_live(_8)
    storage_live(new_size_10)
    storage_live(raw_ptr_12)
    storage_live(ptr_20)
    storage_live(_21)
    storage_live(new_ptr_28)
    storage_live(ptr_30)
    storage_live(_32)
    storage_live(_33)
    storage_live(_35)
    storage_live(_36)
    storage_live(_38)
    storage_live(_40)
    storage_live(_44)
    storage_live(_49)
    storage_live(_53)
    storage_live(_54)
    old_size_6 = copy (old_layout_3).size
    switch copy old_size_6 {
        0 : usize => {
        },
        _ => {
            storage_live(_7)
            _33 = copy ((old_layout_3).align).0
            _8 = @discriminant(_33)
            storage_live(_9)
            storage_live(_34)
            _34 = copy ((new_layout_4).align).0
            _9 = @discriminant(_34)
            storage_dead(_34)
            _7 = copy _8 == move _9
            if move _7 {
            } else {
                storage_dead(_9)
                storage_dead(_7)
                storage_live(_26)
                storage_live(self_27)
                self_27 = alloc_impl<'_>(move self_1, move new_layout_4, move zeroed_5)
                storage_live(v_52)
                match self_27 {
                    Result::Ok => {
                    },
                    Result::Err => {
                        storage_dead(v_52)
                        storage_dead(self_27)
                        storage_live(_58)
                        _58 = AllocError {  }
                        storage_live(_59)
                        _59 = Result::Err { 0: move _58 }
                        _0 = move _59
                        storage_dead(_26)
                        return
                    },
                }
                loop {
                    v_52 = move (self_27 as variant Result::Ok).0
                    _26 = ControlFlow::Continue { 0: copy v_52 }
                    storage_dead(v_52)
                    storage_dead(self_27)
                    new_ptr_28 = copy (_26 as variant ControlFlow::Continue).0
                    storage_dead(_26)
                    storage_live(src_29)
                    ptr_30 = transmute<NonNull<u8>, *mut u8>(copy ptr_2)
                    src_29 = transmute<NonNull<u8>, *const u8>(copy ptr_2)
                    storage_live(dst_31)
                    _53 = transmute<NonNull<[u8]>, *mut [u8]>(copy new_ptr_28)
                    dst_31 = cast<*mut [u8], *mut u8>(copy _53)
                    storage_live(_57)
                    _57 = ub_checks<bool>
                    if copy _57 {
                        storage_live(_55)
                        _55 = transmute<NonNull<u8>, *const ()>(copy ptr_2)
                        storage_live(_56)
                        _56 = cast<*mut [u8], *mut ()>(copy _53)
                        _54 = core::ptr::copy_nonoverlapping::precondition_check(move _55, move _56, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN, copy old_size_6)
                        storage_dead(_56)
                        storage_dead(_55)
                    } else {
                    }
                    break 0
                }
                loop {
                    copy_nonoverlapping(copy src_29, copy dst_31, copy old_size_6)
                    storage_dead(_57)
                    storage_dead(dst_31)
                    storage_dead(src_29)
                    switch copy old_size_6 {
                        0 : usize => {
                        },
                        _ => {
                            _32 = __rust_dealloc(move ptr_30, move old_size_6, move _8)
                        },
                    }
                    break 0
                }
                _0 = Result::Ok { 0: copy new_ptr_28 }
                return
            }
            loop {
                loop {
                    loop {
                        storage_dead(_9)
                        storage_dead(_7)
                        new_size_10 = copy (new_layout_4).size
                        storage_live(cond_11)
                        cond_11 = copy new_size_10 >= copy old_size_6
                        _36 = ub_checks<bool>
                        if copy _36 {
                        } else {
                            assert(copy cond_11 == true)
                            storage_dead(cond_11)
                            storage_live(ptr_13)
                            storage_live(self_14)
                            self_14 = copy ptr_2
                            ptr_13 = transmute<NonNull<u8>, *mut u8>(copy ptr_2)
                            storage_dead(self_14)
                            storage_live(new_size_15)
                            new_size_15 = copy new_size_10
                            raw_ptr_12 = __rust_realloc(move ptr_13, copy old_size_6, move _8, copy new_size_10)
                            storage_dead(new_size_15)
                            storage_dead(ptr_13)
                            storage_live(_16)
                            storage_live(self_17)
                            storage_live(self_18)
                            storage_live(ptr_19)
                            ptr_19 = copy raw_ptr_12
                            _38 = cast<*mut u8, *const u8>(copy raw_ptr_12)
                            storage_live(_39)
                            _39 = transmute<*mut u8, usize>(copy raw_ptr_12)
                            switch move _39 {
                                0 : usize => {
                                },
                                _ => {
                                    storage_dead(_39)
                                    storage_live(_37)
                                    if copy _36 {
                                        break 1
                                    } else {
                                    }
                                    break 2
                                },
                            }
                            break 0
                        }
                        _35 = core::hint::assert_unchecked::precondition_check(copy cond_11)
                        assert(copy cond_11 == true)
                        storage_dead(cond_11)
                        storage_live(ptr_13)
                        storage_live(self_14)
                        self_14 = copy ptr_2
                        ptr_13 = transmute<NonNull<u8>, *mut u8>(copy ptr_2)
                        storage_dead(self_14)
                        storage_live(new_size_15)
                        new_size_15 = copy new_size_10
                        raw_ptr_12 = __rust_realloc(move ptr_13, copy old_size_6, move _8, copy new_size_10)
                        storage_dead(new_size_15)
                        storage_dead(ptr_13)
                        storage_live(_16)
                        storage_live(self_17)
                        storage_live(self_18)
                        storage_live(ptr_19)
                        ptr_19 = copy raw_ptr_12
                        _38 = cast<*mut u8, *const u8>(copy raw_ptr_12)
                        storage_live(_39)
                        _39 = transmute<*mut u8, usize>(copy raw_ptr_12)
                        switch move _39 {
                            0 : usize => {
                                break 0
                            },
                            _ => {
                            },
                        }
                        storage_dead(_39)
                        storage_live(_37)
                        break 1
                        break 0
                    }
                    storage_dead(_39)
                    storage_live(_60)
                    _60 = Option::None {  }
                    self_18 = move _60
                    storage_dead(ptr_19)
                    storage_live(v_42)
                    storage_live(_61)
                    _61 = AllocError {  }
                    storage_live(_62)
                    _62 = Result::Err { 0: move _61 }
                    self_17 = move _62
                    storage_dead(v_42)
                    storage_dead(self_18)
                    storage_live(v_43)
                    storage_dead(v_43)
                    storage_dead(self_17)
                    storage_live(_63)
                    _63 = AllocError {  }
                    storage_live(_64)
                    _64 = Result::Err { 0: move _63 }
                    _0 = move _64
                    storage_dead(_16)
                    return
                    break 0
                }
                storage_live(_41)
                _41 = cast<*mut u8, *mut ()>(copy raw_ptr_12)
                _40 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _41)
                storage_dead(_41)
                break 0
            }
            loop {
                _37 = NonNull { pointer: copy _38 }
                self_18 = Option::Some { 0: move _37 }
                storage_dead(_37)
                storage_dead(ptr_19)
                storage_live(v_42)
                v_42 = move (self_18 as variant Option::Some).0
                self_17 = Result::Ok { 0: copy v_42 }
                storage_dead(v_42)
                storage_dead(self_18)
                storage_live(v_43)
                v_43 = move (self_17 as variant Result::Ok).0
                _16 = ControlFlow::Continue { 0: copy v_43 }
                storage_dead(v_43)
                storage_dead(self_17)
                ptr_20 = copy (_16 as variant ControlFlow::Continue).0
                storage_dead(_16)
                if copy zeroed_5 {
                    loop {
                        storage_live(self_22)
                        storage_live(self_23)
                        self_23 = copy raw_ptr_12
                        self_22 = copy raw_ptr_12 offset copy old_size_6
                        storage_dead(self_23)
                        storage_live(count_24)
                        count_24 = copy new_size_10 wrap.- copy old_size_6
                        if copy _36 {
                            storage_live(_45)
                            _45 = cast<*mut u8, *const ()>(copy self_22)
                            storage_live(_46)
                            _46 = copy count_24 == const 0 : usize
                            _44 = core::ptr::write_bytes::precondition_check(move _45, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN, move _46)
                            storage_dead(_46)
                            storage_dead(_45)
                        } else {
                        }
                        break 0
                    }
                    _21 = write_bytes<u8>[{built_in impl Sized for u8}](move self_22, const 0 : u8, move count_24)
                    storage_dead(count_24)
                    storage_dead(self_22)
                } else {
                }
                break 0
            }
            loop {
                storage_live(_25)
                storage_live(ptr_47)
                storage_live(data_48)
                data_48 = transmute<NonNull<u8>, *mut u8>(copy ptr_20)
                ptr_47 = *mut  (copy data_48, copy new_size_10)
                storage_dead(data_48)
                storage_live(_51)
                if copy _36 {
                    storage_live(_50)
                    _50 = transmute<NonNull<u8>, *mut ()>(copy ptr_20)
                    _49 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _50)
                    storage_dead(_50)
                } else {
                }
                break 0
            }
            _51 = cast<*mut [u8], *const [u8]>(copy ptr_47)
            _25 = NonNull { pointer: copy _51 }
            storage_dead(_51)
            storage_dead(ptr_47)
            _0 = Result::Ok { 0: move _25 }
            storage_dead(_25)
            return
        },
    }
    _0 = alloc_impl<'_>(move self_1, move new_layout_4, move zeroed_5)
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::allocate
pub fn {impl Allocator for Global}::allocate<'_0>(@1: &'_0 Global, @2: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Global; // arg #1
    let layout_2: Layout; // arg #2

    _0 = alloc_impl<'_>(move self_1, move layout_2, const false)
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::allocate_zeroed
pub fn {impl Allocator for Global}::allocate_zeroed<'_0>(@1: &'_0 Global, @2: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Global; // arg #1
    let layout_2: Layout; // arg #2

    _0 = alloc_impl<'_>(move self_1, move layout_2, const true)
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::deallocate
pub unsafe fn {impl Allocator for Global}::deallocate<'_0>(@1: &'_0 Global, @2: NonNull<u8>, @3: Layout)
{
    let _0: (); // return
    let self_1: &'0 Global; // arg #1
    let ptr_2: NonNull<u8>; // arg #2
    let layout_3: Layout; // arg #3
    let _4: usize; // anonymous local
    let ptr_5: *mut u8; // local
    let _6: usize; // anonymous local
    let _7: AlignmentEnum; // anonymous local

    storage_live(_4)
    _0 = ()
    _4 = copy (layout_3).size
    switch move _4 {
        0 : usize => {
        },
        _ => {
            storage_live(ptr_5)
            ptr_5 = transmute<NonNull<u8>, *mut u8>(copy ptr_2)
            storage_live(_6)
            storage_live(_7)
            _7 = copy ((layout_3).align).0
            _6 = @discriminant(_7)
            storage_dead(_7)
            _0 = __rust_dealloc(move ptr_5, move _4, move _6)
            storage_dead(_6)
            storage_dead(ptr_5)
            return
        },
    }
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::grow
pub unsafe fn {impl Allocator for Global}::grow<'_0>(@1: &'_0 Global, @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Global; // arg #1
    let ptr_2: NonNull<u8>; // arg #2
    let old_layout_3: Layout; // arg #3
    let new_layout_4: Layout; // arg #4

    _0 = grow_impl<'_>(move self_1, move ptr_2, move old_layout_3, move new_layout_4, const false)
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::grow_zeroed
pub unsafe fn {impl Allocator for Global}::grow_zeroed<'_0>(@1: &'_0 Global, @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Global; // arg #1
    let ptr_2: NonNull<u8>; // arg #2
    let old_layout_3: Layout; // arg #3
    let new_layout_4: Layout; // arg #4

    _0 = grow_impl<'_>(move self_1, move ptr_2, move old_layout_3, move new_layout_4, const true)
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::shrink
pub unsafe fn {impl Allocator for Global}::shrink<'_0>(@1: &'_0 Global, @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]
{
    let _0: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // return
    let self_1: &'0 Global; // arg #1
    let ptr_2: NonNull<u8>; // arg #2
    let old_layout_3: Layout; // arg #3
    let new_layout_4: Layout; // arg #4
    let new_size_5: usize; // local
    let _6: (); // anonymous local
    let _7: NonNull<[u8]>; // anonymous local
    let data_8: NonNull<u8>; // local
    let _9: bool; // anonymous local
    let _10: usize; // anonymous local
    let _11: usize; // anonymous local
    let cond_12: bool; // local
    let _13: usize; // anonymous local
    let raw_ptr_14: *mut u8; // local
    let ptr_15: *mut u8; // local
    let self_16: NonNull<u8>; // local
    let new_size_17: usize; // local
    let _18: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<u8>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<u8>}]; // anonymous local
    let self_19: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // local
    let self_20: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // local
    let ptr_21: *mut u8; // local
    let ptr_22: NonNull<u8>; // local
    let _23: NonNull<[u8]>; // anonymous local
    let _24: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<[u8]>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<[u8]>}]; // anonymous local
    let self_25: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr_26: NonNull<[u8]>; // local
    let src_27: *const u8; // local
    let ptr_28: *mut u8; // local
    let dst_29: *mut u8; // local
    let _30: (); // anonymous local
    let _31: AlignmentEnum; // anonymous local
    let _32: usize; // anonymous local
    let ptr_33: *mut u8; // local
    let _34: usize; // anonymous local
    let _35: AlignmentEnum; // anonymous local
    let _36: NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}]; // anonymous local
    let _37: Alignment; // anonymous local
    let _38: *const u8; // anonymous local
    let ptr_39: *mut [u8]; // local
    let data_40: *mut u8; // local
    let _41: (); // anonymous local
    let _42: *mut (); // anonymous local
    let _43: *const [u8]; // anonymous local
    let _44: bool; // anonymous local
    let _45: AlignmentEnum; // anonymous local
    let _46: (); // anonymous local
    let _47: bool; // anonymous local
    let _48: NonNull<u8>; // anonymous local
    let _49: *const u8; // anonymous local
    let _50: usize; // anonymous local
    let _51: (); // anonymous local
    let _52: *mut (); // anonymous local
    let v_53: NonNull<u8>; // local
    let v_54: NonNull<u8>; // local
    let ptr_55: *mut [u8]; // local
    let data_56: *mut u8; // local
    let _57: (); // anonymous local
    let _58: *mut (); // anonymous local
    let _59: *const [u8]; // anonymous local
    let v_60: NonNull<[u8]>; // local
    let _61: *mut [u8]; // anonymous local
    let _62: (); // anonymous local
    let _63: *const (); // anonymous local
    let _64: *mut (); // anonymous local
    let _65: bool; // anonymous local
    let _66: usize; // anonymous local
    let _67: AllocError; // anonymous local
    let _68: Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]; // anonymous local
    let _69: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<[u8]>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<[u8]>}]; // anonymous local
    let _70: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // anonymous local
    let _71: AllocError; // anonymous local
    let _72: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local
    let _73: AllocError; // anonymous local
    let _74: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // anonymous local
    let _75: AllocError; // anonymous local
    let _76: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(new_size_5)
    storage_live(_6)
    storage_live(_10)
    storage_live(_13)
    storage_live(raw_ptr_14)
    storage_live(ptr_22)
    storage_live(new_ptr_26)
    storage_live(ptr_28)
    storage_live(_30)
    storage_live(_31)
    storage_live(_36)
    storage_live(_41)
    storage_live(_46)
    storage_live(_47)
    storage_live(_49)
    storage_live(_51)
    storage_live(_57)
    storage_live(_61)
    storage_live(_62)
    new_size_5 = copy (new_layout_4).size
    switch copy new_size_5 {
        0 : usize => {
        },
        _ => {
            loop {
                storage_live(_9)
                _31 = copy ((old_layout_3).align).0
                _10 = @discriminant(_31)
                storage_live(_11)
                storage_live(_45)
                _45 = copy ((new_layout_4).align).0
                _11 = @discriminant(_45)
                storage_dead(_45)
                _9 = copy _10 == move _11
                if move _9 {
                    loop {
                        loop {
                            loop {
                                loop {
                                    storage_dead(_11)
                                    storage_dead(_9)
                                    storage_live(cond_12)
                                    _13 = copy (old_layout_3).size
                                    cond_12 = copy new_size_5 <= copy _13
                                    _47 = ub_checks<bool>
                                    if copy _47 {
                                        _46 = core::hint::assert_unchecked::precondition_check(copy cond_12)
                                        assert(copy cond_12 == true)
                                        storage_dead(cond_12)
                                        storage_live(ptr_15)
                                        storage_live(self_16)
                                        self_16 = copy ptr_2
                                        ptr_15 = transmute<NonNull<u8>, *mut u8>(copy ptr_2)
                                        storage_dead(self_16)
                                        storage_live(new_size_17)
                                        new_size_17 = copy new_size_5
                                        raw_ptr_14 = __rust_realloc(move ptr_15, move _13, move _10, copy new_size_5)
                                        storage_dead(new_size_17)
                                        storage_dead(ptr_15)
                                        storage_live(_18)
                                        storage_live(self_19)
                                        storage_live(self_20)
                                        storage_live(ptr_21)
                                        ptr_21 = copy raw_ptr_14
                                        _49 = cast<*mut u8, *const u8>(copy raw_ptr_14)
                                        storage_live(_50)
                                        _50 = transmute<*mut u8, usize>(copy raw_ptr_14)
                                        switch move _50 {
                                            0 : usize => {
                                                break 0
                                            },
                                            _ => {
                                                storage_dead(_50)
                                                storage_live(_48)
                                                break 1
                                            },
                                        }
                                    } else {
                                        assert(copy cond_12 == true)
                                        storage_dead(cond_12)
                                        storage_live(ptr_15)
                                        storage_live(self_16)
                                        self_16 = copy ptr_2
                                        ptr_15 = transmute<NonNull<u8>, *mut u8>(copy ptr_2)
                                        storage_dead(self_16)
                                        storage_live(new_size_17)
                                        new_size_17 = copy new_size_5
                                        raw_ptr_14 = __rust_realloc(move ptr_15, move _13, move _10, copy new_size_5)
                                        storage_dead(new_size_17)
                                        storage_dead(ptr_15)
                                        storage_live(_18)
                                        storage_live(self_19)
                                        storage_live(self_20)
                                        storage_live(ptr_21)
                                        ptr_21 = copy raw_ptr_14
                                        _49 = cast<*mut u8, *const u8>(copy raw_ptr_14)
                                        storage_live(_50)
                                        _50 = transmute<*mut u8, usize>(copy raw_ptr_14)
                                        switch move _50 {
                                            0 : usize => {
                                                break 0
                                            },
                                            _ => {
                                                storage_dead(_50)
                                                storage_live(_48)
                                                if copy _47 {
                                                    break 1
                                                } else {
                                                }
                                                break 2
                                            },
                                        }
                                    }
                                    break 3
                                    break 0
                                }
                                storage_dead(_50)
                                storage_live(_70)
                                _70 = Option::None {  }
                                self_20 = move _70
                                break 2
                                break 0
                            }
                            storage_live(_52)
                            _52 = cast<*mut u8, *mut ()>(copy raw_ptr_14)
                            _51 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _52)
                            storage_dead(_52)
                            break 0
                        }
                        _48 = NonNull { pointer: copy _49 }
                        self_20 = Option::Some { 0: move _48 }
                        storage_dead(_48)
                        break 0
                    }
                    loop {
                        storage_dead(ptr_21)
                        storage_live(v_53)
                        match self_20 {
                            Option::None => {
                                storage_live(_73)
                                _73 = AllocError {  }
                                storage_live(_74)
                                _74 = Result::Err { 0: move _73 }
                                self_19 = move _74
                            },
                            Option::Some => {
                                v_53 = move (self_20 as variant Option::Some).0
                                self_19 = Result::Ok { 0: copy v_53 }
                            },
                        }
                        break 0
                    }
                    storage_dead(v_53)
                    storage_dead(self_20)
                    storage_live(v_54)
                    match self_19 {
                        Result::Ok => {
                            loop {
                                v_54 = move (self_19 as variant Result::Ok).0
                                _18 = ControlFlow::Continue { 0: copy v_54 }
                                storage_dead(v_54)
                                storage_dead(self_19)
                                ptr_22 = copy (_18 as variant ControlFlow::Continue).0
                                storage_dead(_18)
                                storage_live(_23)
                                storage_live(ptr_55)
                                storage_live(data_56)
                                data_56 = transmute<NonNull<u8>, *mut u8>(copy ptr_22)
                                ptr_55 = *mut  (copy data_56, copy new_size_5)
                                storage_dead(data_56)
                                storage_live(_59)
                                if copy _47 {
                                    storage_live(_58)
                                    _58 = transmute<NonNull<u8>, *mut ()>(copy ptr_22)
                                    _57 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _58)
                                    storage_dead(_58)
                                } else {
                                }
                                break 0
                            }
                            _59 = cast<*mut [u8], *const [u8]>(copy ptr_55)
                            _23 = NonNull { pointer: copy _59 }
                            storage_dead(_59)
                            storage_dead(ptr_55)
                            _0 = Result::Ok { 0: move _23 }
                            storage_dead(_23)
                            return
                        },
                        Result::Err => {
                            storage_dead(v_54)
                            storage_dead(self_19)
                            storage_live(_75)
                            _75 = AllocError {  }
                            storage_live(_76)
                            _76 = Result::Err { 0: move _75 }
                            _0 = move _76
                            storage_dead(_18)
                            return
                        },
                    }
                } else {
                    storage_dead(_11)
                    storage_dead(_9)
                    storage_live(_24)
                    storage_live(self_25)
                    self_25 = alloc_impl<'_>(move self_1, move new_layout_4, const false)
                    loop {
                        storage_live(v_60)
                        match self_25 {
                            Result::Ok => {
                                v_60 = move (self_25 as variant Result::Ok).0
                                _24 = ControlFlow::Continue { 0: copy v_60 }
                            },
                            Result::Err => {
                                storage_live(_67)
                                _67 = AllocError {  }
                                storage_live(_68)
                                _68 = Result::Err { 0: move _67 }
                                storage_live(_69)
                                _69 = ControlFlow::Break { 0: move _68 }
                                _24 = move _69
                            },
                        }
                        break 0
                    }
                    storage_dead(v_60)
                    storage_dead(self_25)
                    match _24 {
                        ControlFlow::Continue => {
                            loop {
                                new_ptr_26 = copy (_24 as variant ControlFlow::Continue).0
                                storage_dead(_24)
                                storage_live(src_27)
                                ptr_28 = transmute<NonNull<u8>, *mut u8>(copy ptr_2)
                                src_27 = transmute<NonNull<u8>, *const u8>(copy ptr_2)
                                storage_live(dst_29)
                                _61 = transmute<NonNull<[u8]>, *mut [u8]>(copy new_ptr_26)
                                dst_29 = cast<*mut [u8], *mut u8>(copy _61)
                                storage_live(_65)
                                _65 = ub_checks<bool>
                                if copy _65 {
                                    storage_live(_63)
                                    _63 = transmute<NonNull<u8>, *const ()>(copy ptr_2)
                                    storage_live(_64)
                                    _64 = cast<*mut [u8], *mut ()>(copy _61)
                                    _62 = core::ptr::copy_nonoverlapping::precondition_check(move _63, move _64, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE, const {impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN, copy new_size_5)
                                    storage_dead(_64)
                                    storage_dead(_63)
                                } else {
                                }
                                break 0
                            }
                            loop {
                                copy_nonoverlapping(copy src_27, copy dst_29, copy new_size_5)
                                storage_dead(_65)
                                storage_dead(dst_29)
                                storage_dead(src_27)
                                storage_live(_66)
                                _66 = copy (old_layout_3).size
                                switch move _66 {
                                    0 : usize => {
                                    },
                                    _ => {
                                        _30 = __rust_dealloc(move ptr_28, move _66, move _10)
                                    },
                                }
                                break 0
                            }
                            storage_dead(_66)
                            _0 = Result::Ok { 0: copy new_ptr_26 }
                            return
                        },
                        ControlFlow::Break => {
                            storage_live(_71)
                            _71 = AllocError {  }
                            storage_live(_72)
                            _72 = Result::Err { 0: move _71 }
                            _0 = move _72
                            storage_dead(_24)
                            return
                        },
                    }
                }
                break 0
            }
            undefined_behavior
        },
    }
    loop {
        storage_live(_32)
        _32 = copy (old_layout_3).size
        switch move _32 {
            0 : usize => {
            },
            _ => {
                storage_live(ptr_33)
                ptr_33 = transmute<NonNull<u8>, *mut u8>(copy ptr_2)
                storage_live(_34)
                storage_live(_35)
                _35 = copy ((old_layout_3).align).0
                _34 = @discriminant(_35)
                storage_dead(_35)
                _6 = __rust_dealloc(move ptr_33, move _32, move _34)
                storage_dead(_34)
                storage_dead(ptr_33)
            },
        }
        break 0
    }
    loop {
        storage_dead(_32)
        storage_live(_7)
        storage_live(data_8)
        storage_live(_37)
        _37 = copy (new_layout_4).align
        _36 = transmute<Alignment, NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}]>(copy _37)
        storage_dead(_37)
        storage_live(_38)
        _38 = transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *const u8>(copy _36)
        data_8 = NonNull { pointer: copy _38 }
        storage_dead(_38)
        storage_live(ptr_39)
        storage_live(data_40)
        data_40 = transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *mut u8>(copy _36)
        ptr_39 = *mut  (copy data_40, const 0 : usize)
        storage_dead(data_40)
        storage_live(_43)
        storage_live(_44)
        _44 = ub_checks<bool>
        if copy _44 {
            storage_live(_42)
            _42 = transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *mut ()>(copy _36)
            _41 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _42)
            storage_dead(_42)
        } else {
        }
        break 0
    }
    _43 = cast<*mut [u8], *const [u8]>(copy ptr_39)
    _7 = NonNull { pointer: copy _43 }
    storage_dead(_44)
    storage_dead(_43)
    storage_dead(ptr_39)
    storage_dead(data_8)
    _0 = Result::Ok { 0: move _7 }
    storage_dead(_7)
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::by_ref
pub fn {impl Allocator for Global}::by_ref<'_0>(@1: &'_0 Global) -> &'_0 Global
where
    [@TraitClause0]: Sized<Global>,
{
    let _0: &'0 Global; // return
    let self_1: &'0 Global; // arg #1

    _0 = copy self_1
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}
impl Allocator for Global {
    parent_clause0 = {built_in impl MetaSized for Global}
    fn allocate<'_0_1> = {impl Allocator for Global}::allocate<'_0_1>
    fn allocate_zeroed<'_0_1> = {impl Allocator for Global}::allocate_zeroed<'_0_1>
    fn deallocate<'_0_1> = {impl Allocator for Global}::deallocate<'_0_1>
    fn grow<'_0_1> = {impl Allocator for Global}::grow<'_0_1>
    fn grow_zeroed<'_0_1> = {impl Allocator for Global}::grow_zeroed<'_0_1>
    fn shrink<'_0_1> = {impl Allocator for Global}::shrink<'_0_1>
    fn by_ref<'_0_1, [@TraitClause0_1]: Sized<Global>> = {impl Allocator for Global}::by_ref<'_0_1>[@TraitClause0_1]
    vtable: {impl Allocator for Global}::{vtable}
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: alloc::alloc::handle_alloc_error::ct_error
fn ct_error(@1: Layout) -> !
{
    let _0: !; // return
    let _1: Layout; // arg #1
    let _2: Arguments<'0>; // anonymous local

    storage_live(_2)
    _2 = from_str<'1>(const "allocation failed")
    panic(core::panicking::panic_fmt)
}

// Full name: alloc::alloc::handle_alloc_error
pub fn handle_alloc_error(@1: Layout) -> !
{
    let _0: !; // return
    let layout_1: Layout; // arg #1
    let _2: (Layout); // anonymous local
    let _3: Layout; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = copy layout_1
    _2 = (move _3)
    storage_dead(_3)
    _0 = ct_error(move _2.0)
}

// Full name: alloc::alloc::exchange_malloc
#[lang_item("exchange_malloc")]
unsafe fn exchange_malloc(@1: usize, @2: usize) -> *mut u8
{
    let _0: *mut u8; // return
    let size_1: usize; // arg #1
    let align_2: usize; // arg #2
    let layout_3: Layout; // local
    let _4: Result<NonNull<[u8]>, AllocError>[{built_in impl Sized for NonNull<[u8]>}, {built_in impl Sized for AllocError}]; // anonymous local
    let ptr_5: NonNull<[u8]>; // local
    let _6: !; // anonymous local
    let _7: bool; // anonymous local
    let _8: (); // anonymous local
    let _9: Alignment; // anonymous local
    let _10: *mut [u8]; // anonymous local
    let _11: &'_ Global; // anonymous local
    let _12: Global; // anonymous local

    loop {
        storage_live(layout_3)
        storage_live(ptr_5)
        storage_live(_6)
        storage_live(_8)
        storage_live(_7)
        _7 = ub_checks<bool>
        if move _7 {
            _8 = core::alloc::layout::{Layout}::from_size_align_unchecked::precondition_check(copy size_1, copy align_2)
        } else {
        }
        break 0
    }
    storage_live(_11)
    storage_live(_12)
    _12 = Global {  }
    _11 = &_12
    storage_dead(_7)
    storage_live(_9)
    _9 = transmute<usize, Alignment>(copy align_2)
    layout_3 = Layout { size: copy size_1, align: move _9 }
    storage_dead(_9)
    storage_live(_4)
    _4 = alloc_impl<'_>(move _11, copy layout_3, const false)
    match _4 {
        Result::Ok => {
        },
        Result::Err => {
            _6 = handle_alloc_error(move layout_3)
        },
    }
    ptr_5 = copy (_4 as variant Result::Ok).0
    storage_live(_10)
    _10 = transmute<NonNull<[u8]>, *mut [u8]>(copy ptr_5)
    _0 = cast<*mut [u8], *mut u8>(copy _10)
    storage_dead(_10)
    storage_dead(_4)
    return
}

// Full name: alloc::boxed::Box
#[lang_item("owned_box")]
pub struct Box<T, A>
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
    [@TraitClause2]: Allocator<A>,
{
  Unique<T>,
  A,
}

// Full name: alloc::boxed::Box::{impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}::drop_in_place
unsafe fn {impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}::drop_in_place<T, A>(@1: *mut Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2])
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
    [@TraitClause2]: Allocator<A>,
= <missing>

// Full name: alloc::boxed::Box::{impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}
impl<T, A> Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
    [@TraitClause2]: Allocator<A>,
{
    fn drop_in_place = {impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}::drop_in_place<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]
    non-dyn-compatible
}

#[lang_item("box_new")]
pub fn alloc::boxed::{Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::new<T>(@1: T) -> Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]; // return
    let x_1: T; // arg #1
    let _2: *mut u8; // anonymous local
    let _3: *const T; // anonymous local
    let _4: NonNull<T>; // anonymous local
    let _5: Unique<T>; // anonymous local
    let _6: PhantomData<T>; // anonymous local
    let _7: Global; // anonymous local

    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _2 = exchange_malloc(const {impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE, const {impl SizedTypeProperties for T}<T>[@TraitClause0]::ALIGN)
    _3 = cast<*mut u8, *const T>(copy _2)
    _4 = NonNull { pointer: copy _3 }
    storage_live(_6)
    _6 = PhantomData {  }
    _5 = Unique { pointer: copy _4, _marker: move _6 }
    storage_live(_7)
    _7 = Global {  }
    _0 = Box { 0: move _5, 1: move _7 }
    (*_3) = move x_1
    return
}

// Full name: alloc::boxed::{Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::from_raw
pub unsafe fn from_raw<T>(@1: *mut T) -> Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]
where
    [@TraitClause0]: MetaSized<T>,
{
    let _0: Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]; // return
    let raw_1: *mut T; // arg #1
    let _2: Unique<T>; // anonymous local
    let _3: NonNull<T>; // anonymous local
    let _4: (); // anonymous local
    let _5: *mut (); // anonymous local
    let _6: *const T; // anonymous local
    let _7: bool; // anonymous local
    let _8: PhantomData<T>; // anonymous local
    let _9: Global; // anonymous local

    loop {
        storage_live(_4)
        storage_live(_2)
        storage_live(_3)
        storage_live(_6)
        storage_live(_7)
        _7 = ub_checks<bool>
        if copy _7 {
            storage_live(_5)
            _5 = cast<*mut T, *mut ()>(copy raw_1)
            _4 = core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move _5)
            storage_dead(_5)
        } else {
        }
        break 0
    }
    _6 = cast<*mut T, *const T>(copy raw_1)
    _3 = NonNull { pointer: copy _6 }
    storage_dead(_7)
    storage_dead(_6)
    storage_live(_8)
    _8 = PhantomData {  }
    _2 = Unique { pointer: move _3, _marker: move _8 }
    storage_dead(_3)
    storage_live(_9)
    _9 = Global {  }
    _0 = Box { 0: move _2, 1: move _9 }
    storage_dead(_2)
    return
}

// Full name: alloc::boxed::{Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::into_raw
pub fn into_raw<T>(@1: Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]) -> *mut T
where
    [@TraitClause0]: MetaSized<T>,
{
    let _0: *mut T; // return
    let b_1: Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]; // arg #1
    let _2: *const T; // anonymous local
    let _3: NonNull<T>; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = copy ((b_1).0).pointer
    _2 = transmute<NonNull<T>, *const T>(copy _3)
    _0 = &raw mut (*_2) with_metadata(copy _2.metadata)
    return
}

// Full name: alloc::boxed::{Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}::leak
pub fn leak<'a, T, A>(@1: Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]) -> &'a mut T
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
    [@TraitClause2]: Allocator<A>,
    A : 'a,
{
    let _0: &'0 mut T; // return
    let b_1: Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]; // arg #1
    let _2: *mut T; // anonymous local
    let _3: *const T; // anonymous local
    let _4: NonNull<T>; // anonymous local

    storage_live(_2)
    storage_live(_4)
    _4 = move ((b_1).0).pointer
    storage_live(_3)
    _3 = transmute<NonNull<T>, *const T>(copy _4)
    _2 = &raw mut (*_3) with_metadata(copy _3.metadata)
    storage_dead(_3)
    _0 = &mut (*_2) with_metadata(copy _2.metadata)
    return
}

// Full name: test_crate::foo
unsafe fn foo()
{
    let _0: (); // return
    let b_1: Box<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]; // local
    let p_2: *mut i32; // local
    let _3: Box<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]; // anonymous local
    let _4: &'0 mut i32; // anonymous local
    let _5: Box<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]; // anonymous local
    let b_6: Box<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]; // local
    let _7: *mut i32; // anonymous local
    let i_8: i32; // local
    let _9: *const i32; // anonymous local

    storage_live(_9)
    _0 = ()
    storage_live(b_1)
    b_1 = alloc::boxed::{Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::new<i32>[{built_in impl Sized for i32}](const 42 : i32)
    storage_live(p_2)
    storage_live(_3)
    _3 = move b_1
    p_2 = into_raw<i32>[{built_in impl MetaSized for i32}](move _3)
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = alloc::boxed::{Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::new<i32>[{built_in impl Sized for i32}](const 42 : i32)
    _4 = leak<'1, i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}](move _5)
    storage_dead(_5)
    storage_dead(_4)
    storage_live(b_6)
    storage_live(_7)
    _7 = copy p_2
    b_6 = from_raw<i32>[{built_in impl MetaSized for i32}](move _7)
    storage_dead(_7)
    storage_live(i_8)
    _9 = transmute<NonNull<i32>, *const i32>(copy ((b_6).0).pointer)
    i_8 = copy (*_9)
    _0 = ()
    storage_dead(i_8)
    drop[{impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]] b_6
    storage_dead(b_6)
    storage_dead(p_2)
    storage_dead(b_1)
    return
}



