# Final LLBC before serialization:

// Full name: core::ptr::alignment::AlignmentEnum
enum AlignmentEnum {
  _Align1Shl0,
  _Align1Shl1,
  _Align1Shl2,
  _Align1Shl3,
  _Align1Shl4,
  _Align1Shl5,
  _Align1Shl6,
  _Align1Shl7,
  _Align1Shl8,
  _Align1Shl9,
  _Align1Shl10,
  _Align1Shl11,
  _Align1Shl12,
  _Align1Shl13,
  _Align1Shl14,
  _Align1Shl15,
  _Align1Shl16,
  _Align1Shl17,
  _Align1Shl18,
  _Align1Shl19,
  _Align1Shl20,
  _Align1Shl21,
  _Align1Shl22,
  _Align1Shl23,
  _Align1Shl24,
  _Align1Shl25,
  _Align1Shl26,
  _Align1Shl27,
  _Align1Shl28,
  _Align1Shl29,
  _Align1Shl30,
  _Align1Shl31,
  _Align1Shl32,
  _Align1Shl33,
  _Align1Shl34,
  _Align1Shl35,
  _Align1Shl36,
  _Align1Shl37,
  _Align1Shl38,
  _Align1Shl39,
  _Align1Shl40,
  _Align1Shl41,
  _Align1Shl42,
  _Align1Shl43,
  _Align1Shl44,
  _Align1Shl45,
  _Align1Shl46,
  _Align1Shl47,
  _Align1Shl48,
  _Align1Shl49,
  _Align1Shl50,
  _Align1Shl51,
  _Align1Shl52,
  _Align1Shl53,
  _Align1Shl54,
  _Align1Shl55,
  _Align1Shl56,
  _Align1Shl57,
  _Align1Shl58,
  _Align1Shl59,
  _Align1Shl60,
  _Align1Shl61,
  _Align1Shl62,
  _Align1Shl63,
}

// Full name: core::ptr::alignment::Alignment
pub struct Alignment {
  AlignmentEnum,
}

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub struct Layout {
  size: usize,
  align: Alignment,
}

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    fn clone_from<'_0_1, '_1_1, [@TraitClause0_1]: Destruct<Self>> = core::clone::Clone::clone_from<'_0_1, '_1_1, Self>[Self, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::intrinsics::ctpop
pub fn ctpop<T>(@1: T) -> u32
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Copy<T>,
{
    let @0: u32; // return
    let x@1: T; // arg #1

    undefined_behavior
}

// Full name: core::clone::impls::{impl Clone for usize}::clone
pub fn {impl Clone for usize}::clone<'_0>(@1: &'_0 (usize)) -> usize
{
    let @0: usize; // return
    let self@1: &'_ (usize); // arg #1

    @0 := copy (*(self@1))
    return
}

// Full name: core::clone::impls::{impl Clone for usize}::clone_from
pub fn {impl Clone for usize}::clone_from<'_0, '_1>(@1: &'_0 mut (usize), @2: &'_1 (usize))
where
    [@TraitClause0]: Destruct<usize>,
{
    let @0: (); // return
    let self@1: &'_ mut (usize); // arg #1
    let source@2: &'_ (usize); // arg #2
    let @3: usize; // anonymous local

    @0 := ()
    storage_live(@3)
    @3 := {impl Clone for usize}::clone<'_>(move (source@2))
    drop[@TraitClause0] *(self@1)
    *(self@1) := move (@3)
    storage_dead(@3)
    return
}

// Full name: core::clone::impls::{impl Clone for usize}
impl Clone for usize {
    parent_clause0 = {built_in impl Sized for usize}
    fn clone<'_0_1> = {impl Clone for usize}::clone<'_0_1>
    fn clone_from<'_0_1, '_1_1, [@TraitClause0_1]: Destruct<usize>> = {impl Clone for usize}::clone_from<'_0_1, '_1_1>[@TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::marker::{impl Copy for usize}
impl Copy for usize {
    parent_clause0 = {built_in impl MetaSized for usize}
    parent_clause1 = {impl Clone for usize}
    non-dyn-compatible
}

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub struct NonNull<T> {
  pointer: *const T,
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::marker::PhantomData
#[lang_item("phantom_data")]
pub struct PhantomData<T> {}

// Full name: core::fmt::rt::ArgumentType
enum ArgumentType<'a> {
  Placeholder(value: NonNull<()>, formatter: fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut (Formatter<'_1_1>)) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], _lifetime: PhantomData<&'a (())>),
  Count(u16),
}

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub struct Argument<'a> {
  ty: ArgumentType<'a>,
}

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub struct Arguments<'a> {
  template: NonNull<u8>,
  args: NonNull<Argument<'a>>,
}

// Full name: core::panicking::panic_nounwind_fmt::compiletime
fn compiletime<'_0>(@1: Arguments<'_0>, @2: bool) -> !
{
    let @0: !; // return
    let fmt@1: Arguments<'_>; // arg #1
    let force_no_backtrace@2: bool; // arg #2

    panic(core::panicking::panic_fmt)
}

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
{
    let @0: !; // return
    let fmt@1: Arguments<'_>; // arg #1
    let force_no_backtrace@2: bool; // arg #2
    let @3: (Arguments<'_>, bool); // anonymous local
    let @4: Arguments<'_>; // anonymous local
    let @5: bool; // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := copy (fmt@1)
    storage_live(@5)
    @5 := copy (force_no_backtrace@2)
    @3 := (move (@4), move (@5))
    storage_dead(@5)
    storage_dead(@4)
    @0 := compiletime<'_>(move ((@3).0), move ((@3).1))
}

fn core::ptr::alignment::{Alignment}::new_unchecked::precondition_check(@1: usize)
{
    let @0: (); // return
    let align@1: usize; // arg #1
    let msg@2: &'_ (Str); // local
    let @3: !; // anonymous local
    let @4: Arguments<'_>; // anonymous local
    let @5: u32; // anonymous local
    let @6: NonNull<u8>; // anonymous local
    let @7: *const u8; // anonymous local
    let @8: NonNull<Argument<'_>>; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local
    let @11: usize; // anonymous local
    let @12: *const Str; // anonymous local
    let @13: &'_ (Slice<u8>); // anonymous local

    storage_live(msg@2)
    storage_live(@3)
    @0 := ()
    storage_live(@5)
    @5 := ctpop<usize>[{built_in impl Sized for usize}, {impl Copy for usize}](move (align@1))
    switch move (@5) {
        1 : u32 => {
        },
        _ => {
            storage_dead(@5)
            msg@2 := const ("unsafe precondition(s) violated: Alignment::new_unchecked requires a power of two\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
            storage_live(@4)
            storage_live(@6)
            storage_live(@7)
            storage_live(@12)
            @12 := &raw const *(msg@2) with_metadata(copy (msg@2.metadata))
            @7 := cast<*const Str, *const u8>(copy (@12))
            storage_dead(@12)
            @6 := transmute<*const u8, NonNull<u8>>(copy (@7))
            storage_dead(@7)
            storage_live(@8)
            storage_live(@9)
            storage_live(@10)
            storage_live(@11)
            storage_live(@13)
            @13 := transmute<&'_ (Str), &'_ (Slice<u8>)>(const ("unsafe precondition(s) violated: Alignment::new_unchecked requires a power of two\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
            @11 := copy (@13.metadata)
            storage_dead(@13)
            @10 := move (@11) wrap.<< const (1 : i32)
            storage_dead(@11)
            @9 := move (@10) | const (1 : usize)
            storage_dead(@10)
            @8 := transmute<usize, NonNull<Argument<'_>>>(move (@9))
            storage_dead(@9)
            @4 := Arguments { template: move (@6), args: move (@8) }
            storage_dead(@8)
            storage_dead(@6)
            @3 := panic_nounwind_fmt<'_>(move (@4), const (false))
        },
    }
    storage_dead(@5)
    return
}

pub fn core::ptr::alignment::{Alignment}::new(@1: usize) -> Option<Alignment>[{built_in impl Sized for Alignment}]
{
    let @0: Option<Alignment>[{built_in impl Sized for Alignment}]; // return
    let align@1: usize; // arg #1
    let @2: Alignment; // anonymous local
    let @3: u32; // anonymous local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: Option<Alignment>[{built_in impl Sized for Alignment}]; // anonymous local

    storage_live(@4)
    storage_live(@3)
    @3 := ctpop<usize>[{built_in impl Sized for usize}, {impl Copy for usize}](copy (align@1))
    switch move (@3) {
        1 : u32 => {
        },
        _ => {
            storage_dead(@3)
            storage_live(@6)
            @6 := Option::None {  }
            @0 := move (@6)
            return
        },
    }
    storage_dead(@3)
    storage_live(@2)
    storage_live(@5)
    @5 := ub_checks<bool>
    if copy (@5) {
        @4 := core::ptr::alignment::{Alignment}::new_unchecked::precondition_check(copy (align@1))
    } else {
    }
    @2 := transmute<usize, Alignment>(copy (align@1))
    storage_dead(@5)
    @0 := Option::Some { 0: move (@2) }
    storage_dead(@2)
    return
}

// Full name: core::alloc::layout::{Layout}::max_size_for_align
fn max_size_for_align(@1: Alignment) -> usize
{
    let @0: usize; // return
    let align@1: Alignment; // arg #1
    let @2: usize; // anonymous local
    let @3: AlignmentEnum; // anonymous local

    storage_live(@3)
    storage_live(@2)
    @3 := copy ((align@1).0)
    @2 := @discriminant(@3)
    @0 := const (9223372036854775808 : usize) ub.- move (@2)
    storage_dead(@2)
    return
}

// Full name: core::alloc::layout::{Layout}::is_size_align_valid
fn is_size_align_valid(@1: usize, @2: usize) -> bool
{
    let @0: bool; // return
    let size@1: usize; // arg #1
    let align@2: usize; // arg #2
    let align@3: Alignment; // local
    let @4: Option<Alignment>[{built_in impl Sized for Alignment}]; // anonymous local
    let @5: usize; // anonymous local
    let @6: bool; // anonymous local
    let @7: usize; // anonymous local
    let @8: usize; // anonymous local
    let @9: Alignment; // anonymous local

    storage_live(@4)
    storage_live(@5)
    @5 := copy (align@2)
    @4 := core::ptr::alignment::{Alignment}::new(move (@5))
    storage_dead(@5)
    match @4 {
        Option::Some => {
        },
        _ => {
            storage_dead(@4)
            @0 := const (false)
            return
        },
    }
    storage_live(align@3)
    align@3 := copy ((@4 as variant Option::Some).0)
    storage_dead(@4)
    storage_live(@6)
    storage_live(@7)
    @7 := copy (size@1)
    storage_live(@8)
    storage_live(@9)
    @9 := copy (align@3)
    @8 := max_size_for_align(move (@9))
    storage_dead(@9)
    @6 := move (@7) > move (@8)
    if move (@6) {
    } else {
        storage_dead(@8)
        storage_dead(@7)
        storage_dead(@6)
        @0 := const (true)
        storage_dead(align@3)
        return
    }
    storage_dead(@8)
    storage_dead(@7)
    @0 := const (false)
    storage_dead(@6)
    storage_dead(align@3)
    return
}

fn core::alloc::layout::{Layout}::from_size_align_unchecked::precondition_check(@1: usize, @2: usize)
{
    let @0: (); // return
    let size@1: usize; // arg #1
    let align@2: usize; // arg #2
    let @3: bool; // anonymous local
    let msg@4: &'_ (Str); // local
    let @5: !; // anonymous local
    let @6: Arguments<'_>; // anonymous local
    let @7: NonNull<u8>; // anonymous local
    let @8: *const u8; // anonymous local
    let @9: NonNull<Argument<'_>>; // anonymous local
    let @10: usize; // anonymous local
    let @11: usize; // anonymous local
    let @12: usize; // anonymous local
    let @13: *const Str; // anonymous local
    let @14: &'_ (Slice<u8>); // anonymous local

    storage_live(msg@4)
    storage_live(@5)
    @0 := ()
    storage_live(@3)
    @3 := is_size_align_valid(move (size@1), move (align@2))
    if move (@3) {
    } else {
        msg@4 := const ("unsafe precondition(s) violated: Layout::from_size_align_unchecked requires that align is a power of 2 and the rounded-up allocation size does not exceed isize::MAX\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
        storage_live(@6)
        storage_live(@7)
        storage_live(@8)
        storage_live(@13)
        @13 := &raw const *(msg@4) with_metadata(copy (msg@4.metadata))
        @8 := cast<*const Str, *const u8>(copy (@13))
        storage_dead(@13)
        @7 := transmute<*const u8, NonNull<u8>>(copy (@8))
        storage_dead(@8)
        storage_live(@9)
        storage_live(@10)
        storage_live(@11)
        storage_live(@12)
        storage_live(@14)
        @14 := transmute<&'_ (Str), &'_ (Slice<u8>)>(const ("unsafe precondition(s) violated: Layout::from_size_align_unchecked requires that align is a power of 2 and the rounded-up allocation size does not exceed isize::MAX\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
        @12 := copy (@14.metadata)
        storage_dead(@14)
        @11 := move (@12) wrap.<< const (1 : i32)
        storage_dead(@12)
        @10 := move (@11) | const (1 : usize)
        storage_dead(@11)
        @9 := transmute<usize, NonNull<Argument<'_>>>(move (@10))
        storage_dead(@10)
        @6 := Arguments { template: move (@7), args: move (@9) }
        storage_dead(@9)
        storage_dead(@7)
        @5 := panic_nounwind_fmt<'_>(move (@6), const (false))
    }
    storage_dead(@3)
    return
}

// Full name: core::alloc::layout::{Layout}::from_size_align_unchecked
pub unsafe fn from_size_align_unchecked(@1: usize, @2: usize) -> Layout
{
    let @0: Layout; // return
    let size@1: usize; // arg #1
    let align@2: usize; // arg #2
    let @3: bool; // anonymous local
    let @4: (); // anonymous local
    let @5: Alignment; // anonymous local

    storage_live(@4)
    storage_live(@3)
    @3 := ub_checks<bool>
    if move (@3) {
        @4 := core::alloc::layout::{Layout}::from_size_align_unchecked::precondition_check(copy (size@1), copy (align@2))
    } else {
    }
    storage_dead(@3)
    storage_live(@5)
    @5 := transmute<usize, Alignment>(copy (align@2))
    @0 := Layout { size: copy (size@1), align: move (@5) }
    storage_dead(@5)
    return
}

// Full name: core::alloc::AllocError
pub struct AllocError {}

// Full name: core::alloc::Allocator
pub trait Allocator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn allocate<'_0_1> = core::alloc::Allocator::allocate<'_0_1, Self>[Self]
    fn allocate_zeroed<'_0_1> = core::alloc::Allocator::allocate_zeroed<'_0_1, Self>[Self]
    fn deallocate<'_0_1> = core::alloc::Allocator::deallocate<'_0_1, Self>[Self]
    fn grow<'_0_1> = core::alloc::Allocator::grow<'_0_1, Self>[Self]
    fn grow_zeroed<'_0_1> = core::alloc::Allocator::grow_zeroed<'_0_1, Self>[Self]
    fn shrink<'_0_1> = core::alloc::Allocator::shrink<'_0_1, Self>[Self]
    fn by_ref<'_0_1, [@TraitClause0_1]: Sized<Self>> = core::alloc::Allocator::by_ref<'_0_1, Self>[Self, @TraitClause0_1]
    vtable: core::alloc::Allocator::{vtable}
}

pub fn core::alloc::Allocator::allocate<'_0, Self>(@1: &'_0 (Self), @2: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
= <method_without_default_body>

// Full name: core::ops::control_flow::ControlFlow
#[lang_item("ControlFlow")]
pub enum ControlFlow<B, C>
where
    [@TraitClause0]: Sized<B>,
    [@TraitClause1]: Sized<C>,
{
  Continue(C),
  Break(B),
}

// Full name: core::convert::Infallible
pub enum Infallible {
}

// Full name: core::ptr::const_ptr::{*const T}::is_aligned_to
pub fn is_aligned_to<T>(@1: *const T, @2: usize) -> bool
{
    let @0: bool; // return
    let self@1: *const T; // arg #1
    let align@2: usize; // arg #2
    let @3: Arguments<'_>; // anonymous local
    let @4: usize; // anonymous local
    let @5: usize; // anonymous local
    let @6: usize; // anonymous local
    let @7: u32; // anonymous local
    let @8: *const (); // anonymous local
    let s@9: &'_ (Str); // local
    let @10: NonNull<u8>; // anonymous local
    let @11: *const u8; // anonymous local
    let @12: NonNull<Argument<'_>>; // anonymous local
    let @13: usize; // anonymous local
    let @14: usize; // anonymous local
    let @15: usize; // anonymous local
    let @16: *const Str; // anonymous local
    let @17: &'_ (Slice<u8>); // anonymous local

    storage_live(@7)
    @7 := ctpop<usize>[{built_in impl Sized for usize}, {impl Copy for usize}](copy (align@2))
    switch move (@7) {
        1 : u32 => {
        },
        _ => {
            storage_dead(@7)
            storage_live(@3)
            storage_live(s@9)
            s@9 := const ("is_aligned_to: align is not a power-of-two")
            storage_live(@10)
            storage_live(@11)
            storage_live(@16)
            @16 := &raw const *(s@9) with_metadata(copy (s@9.metadata))
            @11 := cast<*const Str, *const u8>(copy (@16))
            storage_dead(@16)
            @10 := transmute<*const u8, NonNull<u8>>(copy (@11))
            storage_dead(@11)
            storage_live(@12)
            storage_live(@13)
            storage_live(@14)
            storage_live(@15)
            storage_live(@17)
            @17 := transmute<&'_ (Str), &'_ (Slice<u8>)>(const ("is_aligned_to: align is not a power-of-two"))
            @15 := copy (@17.metadata)
            storage_dead(@17)
            @14 := move (@15) wrap.<< const (1 : i32)
            storage_dead(@15)
            @13 := move (@14) | const (1 : usize)
            storage_dead(@14)
            @12 := transmute<usize, NonNull<Argument<'_>>>(move (@13))
            storage_dead(@13)
            @3 := Arguments { template: move (@10), args: move (@12) }
            storage_dead(@12)
            storage_dead(@10)
            storage_dead(s@9)
            panic(core::panicking::panic_fmt)
        },
    }
    storage_dead(@7)
    storage_live(@4)
    storage_live(@5)
    storage_live(@8)
    @8 := cast<*const T, *const ()>(copy (self@1))
    @5 := transmute<*const (), usize>(copy (@8))
    storage_dead(@8)
    storage_live(@6)
    @6 := copy (align@2) wrap.- const (1 : usize)
    @4 := move (@5) & move (@6)
    storage_dead(@6)
    storage_dead(@5)
    @0 := move (@4) == const (0 : usize)
    storage_dead(@4)
    return
}

fn core::ptr::write_bytes::precondition_check(@1: *const (), @2: usize, @3: bool)
{
    let @0: (); // return
    let addr@1: *const (); // arg #1
    let align@2: usize; // arg #2
    let zero_size@3: bool; // arg #3
    let @4: bool; // anonymous local
    let msg@5: &'_ (Str); // local
    let @6: !; // anonymous local
    let @7: Arguments<'_>; // anonymous local
    let @8: bool; // anonymous local
    let @9: bool; // anonymous local
    let @10: usize; // anonymous local
    let @11: NonNull<u8>; // anonymous local
    let @12: *const u8; // anonymous local
    let @13: NonNull<Argument<'_>>; // anonymous local
    let @14: usize; // anonymous local
    let @15: usize; // anonymous local
    let @16: usize; // anonymous local
    let @17: *const Str; // anonymous local
    let @18: &'_ (Slice<u8>); // anonymous local

    storage_live(msg@5)
    storage_live(@6)
    @0 := ()
    storage_live(@4)
    storage_live(@8)
    @8 := is_aligned_to<()>(copy (addr@1), move (align@2))
    if move (@8) {
        if copy (zero_size@3) {
            storage_dead(@8)
            storage_dead(@4)
            return
        } else {
            storage_live(@9)
            storage_live(@10)
            @10 := transmute<*const (), usize>(copy (addr@1))
            @9 := move (@10) == const (0 : usize)
            storage_dead(@10)
            @4 := ~(move (@9))
            storage_dead(@9)
            storage_dead(@8)
            if move (@4) {
                storage_dead(@4)
                return
            } else {
            }
        }
    } else {
        storage_dead(@8)
    }
    msg@5 := const ("unsafe precondition(s) violated: ptr::write_bytes requires that the destination pointer is aligned and non-null\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    storage_live(@7)
    storage_live(@11)
    storage_live(@12)
    storage_live(@17)
    @17 := &raw const *(msg@5) with_metadata(copy (msg@5.metadata))
    @12 := cast<*const Str, *const u8>(copy (@17))
    storage_dead(@17)
    @11 := transmute<*const u8, NonNull<u8>>(copy (@12))
    storage_dead(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    storage_live(@18)
    @18 := transmute<&'_ (Str), &'_ (Slice<u8>)>(const ("unsafe precondition(s) violated: ptr::write_bytes requires that the destination pointer is aligned and non-null\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
    @16 := copy (@18.metadata)
    storage_dead(@18)
    @15 := move (@16) wrap.<< const (1 : i32)
    storage_dead(@16)
    @14 := move (@15) | const (1 : usize)
    storage_dead(@15)
    @13 := transmute<usize, NonNull<Argument<'_>>>(move (@14))
    storage_dead(@14)
    @7 := Arguments { template: move (@11), args: move (@13) }
    storage_dead(@13)
    storage_dead(@11)
    @6 := panic_nounwind_fmt<'_>(move (@7), const (false))
}

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::intrinsics::size_of
pub fn size_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return

    undefined_behavior
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let @0: usize; // return

    @0 := size_of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::intrinsics::align_of
pub fn align_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return

    undefined_behavior
}

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let @0: usize; // return

    @0 := align_of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let @0: bool; // return

    @0 := const (@TraitClause0::SIZE) == const (0 : usize)
    return
}

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let @0: Layout; // return

    @0 := from_size_align_unchecked(const (@TraitClause0::SIZE), const (@TraitClause0::ALIGN))
    return
}

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

pub fn core::num::{usize}::MAX() -> usize
{
    let @0: usize; // return

    @0 := ~(const (0 : usize))
    return
}

pub const core::num::{usize}::MAX: usize = core::num::{usize}::MAX()

pub fn core::num::{isize}::MAX() -> isize
{
    let @0: isize; // return
    let @1: usize; // anonymous local

    storage_live(@1)
    @1 := copy (core::num::{usize}::MAX) panic.>> const (1 : i32)
    @0 := cast<usize, isize>(move (@1))
    storage_dead(@1)
    return
}

pub const core::num::{isize}::MAX: isize = core::num::{isize}::MAX()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let @0: usize; // return
    let @1: usize; // anonymous local
    let n@2: usize; // local
    let @3: usize; // anonymous local
    let @4: usize; // anonymous local

    storage_live(@1)
    @1 := const (@TraitClause0::SIZE)
    switch copy (@1) {
        0 : usize => {
            @0 := copy (core::num::{usize}::MAX)
        },
        _ => {
            storage_live(n@2)
            n@2 := copy (@1)
            storage_live(@3)
            @3 := cast<isize, usize>(copy (core::num::{isize}::MAX))
            storage_live(@4)
            @4 := copy (n@2)
            @0 := move (@3) panic./ move (@4)
            storage_dead(@4)
            storage_dead(@3)
            storage_dead(n@2)
        },
    }
    storage_dead(@1)
    return
}

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::intrinsics::write_bytes
pub unsafe fn write_bytes<T>(@1: *mut T, @2: u8, @3: usize)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: (); // return
    let dst@1: *mut T; // arg #1
    let val@2: u8; // arg #2
    let count@3: usize; // arg #3

    @0 := ()
    undefined_behavior
}

pub fn core::alloc::Allocator::allocate_zeroed<'_0, Self>(@1: &'_0 (Self), @2: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Self); // arg #1
    let layout@2: Layout; // arg #2
    let @3: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<Slice<u8>>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<Slice<u8>>}]; // anonymous local
    let self@4: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // local
    let ptr@5: NonNull<Slice<u8>>; // local
    let @6: (); // anonymous local
    let self@7: *mut u8; // local
    let self@8: NonNull<u8>; // local
    let count@9: usize; // local
    let v@10: NonNull<Slice<u8>>; // local
    let @11: *const u8; // anonymous local
    let @12: *mut Slice<u8>; // anonymous local
    let @13: (); // anonymous local
    let @14: *const (); // anonymous local
    let @15: bool; // anonymous local
    let @16: bool; // anonymous local
    let @17: AllocError; // anonymous local
    let @18: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(ptr@5)
    storage_live(@6)
    storage_live(@12)
    storage_live(@13)
    storage_live(@3)
    storage_live(self@4)
    self@4 := @TraitClause0::allocate<'_>(move (self@1), move (layout@2))
    storage_live(v@10)
    match self@4 {
        Result::Ok => {
        },
        Result::Err => {
            storage_dead(v@10)
            storage_dead(self@4)
            storage_live(@17)
            @17 := AllocError {  }
            storage_live(@18)
            @18 := Result::Err { 0: move (@17) }
            @0 := move (@18)
            storage_dead(@3)
            return
        },
    }
    v@10 := move ((self@4 as variant Result::Ok).0)
    @3 := ControlFlow::Continue { 0: copy (v@10) }
    storage_dead(v@10)
    storage_dead(self@4)
    ptr@5 := copy ((@3 as variant ControlFlow::Continue).0)
    storage_dead(@3)
    storage_live(self@7)
    storage_live(self@8)
    storage_live(@11)
    @12 := transmute<NonNull<Slice<u8>>, *mut Slice<u8>>(copy (ptr@5))
    @11 := cast<*mut Slice<u8>, *const u8>(copy (@12))
    self@8 := NonNull { pointer: copy (@11) }
    storage_dead(@11)
    self@7 := cast<*mut Slice<u8>, *mut u8>(copy (@12))
    storage_dead(self@8)
    storage_live(count@9)
    count@9 := copy (@12.metadata)
    storage_live(@16)
    @16 := ub_checks<bool>
    if copy (@16) {
        storage_live(@14)
        @14 := cast<*mut Slice<u8>, *const ()>(copy (@12))
        storage_live(@15)
        @15 := copy (count@9) == const (0 : usize)
        @13 := core::ptr::write_bytes::precondition_check(move (@14), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), move (@15))
        storage_dead(@15)
        storage_dead(@14)
    } else {
    }
    @6 := write_bytes<u8>[{built_in impl Sized for u8}](move (self@7), const (0 : u8), move (count@9))
    storage_dead(@16)
    storage_dead(count@9)
    storage_dead(self@7)
    @0 := Result::Ok { 0: copy (ptr@5) }
    return
}

pub unsafe fn core::alloc::Allocator::deallocate<'_0, Self>(@1: &'_0 (Self), @2: NonNull<u8>, @3: Layout)
where
    [@TraitClause0]: Allocator<Self>,
= <method_without_default_body>

// Full name: core::intrinsics::cold_path
pub fn cold_path()
{
    let @0: (); // return

    @0 := ()
    return
}

// Full name: core::fmt::{Arguments<'a>}::from_str
pub fn from_str<'a>(@1: &'static (Str)) -> Arguments<'a>
{
    let @0: Arguments<'_>; // return
    let s@1: &'_ (Str); // arg #1
    let @2: NonNull<u8>; // anonymous local
    let @3: *const u8; // anonymous local
    let @4: NonNull<Argument<'_>>; // anonymous local
    let @5: usize; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: *const Str; // anonymous local
    let @9: &'_ (Slice<u8>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@8)
    @8 := &raw const *(s@1) with_metadata(copy (s@1.metadata))
    @3 := cast<*const Str, *const u8>(copy (@8))
    storage_dead(@8)
    @2 := transmute<*const u8, NonNull<u8>>(copy (@3))
    storage_dead(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@9)
    @9 := transmute<&'_ (Str), &'_ (Slice<u8>)>(copy (s@1))
    @7 := copy (@9.metadata)
    storage_dead(@9)
    @6 := move (@7) wrap.<< const (1 : i32)
    storage_dead(@7)
    @5 := move (@6) | const (1 : usize)
    storage_dead(@6)
    @4 := transmute<usize, NonNull<Argument<'_>>>(move (@5))
    storage_dead(@5)
    @0 := Arguments { template: move (@2), args: move (@4) }
    storage_dead(@4)
    storage_dead(@2)
    return
}

// Full name: core::panicking::panic_nounwind
#[lang_item("panic_nounwind")]
pub fn panic_nounwind(@1: &'static (Str)) -> !
{
    let @0: !; // return
    let expr@1: &'_ (Str); // arg #1
    let @2: !; // anonymous local
    let @3: Arguments<'_>; // anonymous local
    let @4: &'_ (Str); // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := copy (expr@1)
    @3 := from_str<'_>(move (@4))
    storage_dead(@4)
    @2 := panic_nounwind_fmt<'_>(move (@3), const (false))
}

// Full name: core::ub_checks::maybe_is_nonoverlapping::runtime
fn runtime(@1: *const (), @2: *const (), @3: usize, @4: usize) -> bool
{
    let @0: bool; // return
    let src@1: *const (); // arg #1
    let dst@2: *const (); // arg #2
    let size@3: usize; // arg #3
    let count@4: usize; // arg #4
    let src_usize@5: usize; // local
    let dst_usize@6: usize; // local
    let @7: !; // anonymous local
    let size@8: usize; // local
    let @9: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let diff@10: usize; // local
    let @11: u64; // anonymous local
    let b@12: bool; // local
    let @13: (u64, bool); // anonymous local
    let @14: u64; // anonymous local
    let @15: u64; // anonymous local
    let a@16: usize; // local
    let @17: (); // anonymous local
    let @18: bool; // anonymous local

    storage_live(src_usize@5)
    storage_live(dst_usize@6)
    storage_live(@7)
    storage_live(size@8)
    storage_live(diff@10)
    storage_live(@17)
    src_usize@5 := transmute<*const (), usize>(copy (src@1))
    dst_usize@6 := transmute<*const (), usize>(copy (dst@2))
    storage_live(@9)
    storage_live(b@12)
    storage_live(a@16)
    storage_live(@11)
    storage_live(@13)
    storage_live(@14)
    @14 := cast<usize, u64>(copy (size@3))
    storage_live(@15)
    @15 := cast<usize, u64>(copy (count@4))
    @13 := move (@14) checked.* move (@15)
    storage_dead(@15)
    storage_dead(@14)
    @11 := copy ((@13).0)
    b@12 := copy ((@13).1)
    storage_dead(@13)
    a@16 := cast<u64, usize>(copy (@11))
    storage_dead(@11)
    if copy (b@12) {
    } else {
        @9 := Option::Some { 0: copy (a@16) }
        storage_dead(a@16)
        storage_dead(b@12)
        size@8 := copy ((@9 as variant Option::Some).0)
        storage_dead(@9)
        storage_live(@18)
        @18 := copy (src_usize@5) < copy (dst_usize@6)
        if move (@18) {
            diff@10 := copy (dst_usize@6) wrap.- copy (src_usize@5)
        } else {
            diff@10 := copy (src_usize@5) wrap.- copy (dst_usize@6)
        }
        storage_dead(@18)
        @0 := move (diff@10) >= copy (size@8)
        return
    }
    @17 := cold_path()
    storage_dead(a@16)
    storage_dead(b@12)
    storage_dead(@9)
    @7 := panic_nounwind(const ("is_nonoverlapping: `size_of::<T>() * count` overflows a usize"))
}

fn core::ptr::copy_nonoverlapping::precondition_check(@1: *const (), @2: *mut (), @3: usize, @4: usize, @5: usize)
{
    let @0: (); // return
    let src@1: *const (); // arg #1
    let dst@2: *mut (); // arg #2
    let size@3: usize; // arg #3
    let align@4: usize; // arg #4
    let count@5: usize; // arg #5
    let @6: bool; // anonymous local
    let zero_size@7: bool; // local
    let @8: bool; // anonymous local
    let align@9: usize; // local
    let is_zst@10: bool; // local
    let @11: bool; // anonymous local
    let ptr@12: *const (); // local
    let msg@13: &'_ (Str); // local
    let @14: !; // anonymous local
    let @15: Arguments<'_>; // anonymous local
    let @16: bool; // anonymous local
    let @17: bool; // anonymous local
    let @18: usize; // anonymous local
    let @19: bool; // anonymous local
    let @20: bool; // anonymous local
    let @21: usize; // anonymous local
    let @22: NonNull<u8>; // anonymous local
    let @23: *const u8; // anonymous local
    let @24: NonNull<Argument<'_>>; // anonymous local
    let @25: usize; // anonymous local
    let @26: usize; // anonymous local
    let @27: usize; // anonymous local
    let @28: *const Str; // anonymous local
    let @29: &'_ (Slice<u8>); // anonymous local

    storage_live(zero_size@7)
    storage_live(ptr@12)
    storage_live(msg@13)
    storage_live(@14)
    @0 := ()
    storage_live(@6)
    switch copy (count@5) {
        0 : usize => {
            zero_size@7 := const (true)
            storage_live(@8)
            storage_live(align@9)
            align@9 := copy (align@4)
            storage_live(is_zst@10)
            is_zst@10 := copy (zero_size@7)
            storage_live(@16)
            @16 := is_aligned_to<()>(copy (src@1), copy (align@4))
            if move (@16) {
                storage_dead(@16)
                storage_dead(is_zst@10)
                storage_dead(align@9)
                storage_live(@11)
                ptr@12 := cast<*mut (), *const ()>(copy (dst@2))
                storage_live(@19)
                @19 := is_aligned_to<()>(copy (ptr@12), move (align@4))
                if move (@19) {
                    if copy (zero_size@7) {
                        storage_dead(@19)
                        @6 := runtime(move (src@1), move (ptr@12), move (size@3), move (count@5))
                        storage_dead(@11)
                        storage_dead(@8)
                        if move (@6) {
                            storage_dead(@6)
                            return
                        } else {
                        }
                    } else {
                        storage_live(@20)
                        storage_live(@21)
                        @21 := transmute<*mut (), usize>(copy (dst@2))
                        @20 := move (@21) == const (0 : usize)
                        storage_dead(@21)
                        @11 := ~(move (@20))
                        storage_dead(@20)
                        storage_dead(@19)
                        if move (@11) {
                            @6 := runtime(move (src@1), move (ptr@12), move (size@3), move (count@5))
                            storage_dead(@11)
                            storage_dead(@8)
                            if move (@6) {
                                storage_dead(@6)
                                return
                            } else {
                            }
                        } else {
                            storage_dead(@11)
                            storage_dead(@8)
                        }
                    }
                } else {
                    storage_dead(@19)
                    storage_dead(@11)
                    storage_dead(@8)
                }
            } else {
                storage_dead(@16)
                storage_dead(is_zst@10)
                storage_dead(align@9)
                storage_dead(@11)
                storage_dead(@8)
            }
        },
        _ => {
            zero_size@7 := copy (size@3) == const (0 : usize)
            storage_live(@8)
            storage_live(align@9)
            align@9 := copy (align@4)
            storage_live(is_zst@10)
            is_zst@10 := copy (zero_size@7)
            storage_live(@16)
            @16 := is_aligned_to<()>(copy (src@1), copy (align@4))
            if move (@16) {
                if copy (is_zst@10) {
                    storage_dead(@16)
                    storage_dead(is_zst@10)
                    storage_dead(align@9)
                    storage_live(@11)
                    ptr@12 := cast<*mut (), *const ()>(copy (dst@2))
                    storage_live(@19)
                    @19 := is_aligned_to<()>(copy (ptr@12), move (align@4))
                    if move (@19) {
                        if copy (zero_size@7) {
                            storage_dead(@19)
                            @6 := runtime(move (src@1), move (ptr@12), move (size@3), move (count@5))
                            storage_dead(@11)
                            storage_dead(@8)
                            if move (@6) {
                                storage_dead(@6)
                                return
                            } else {
                            }
                        } else {
                            storage_live(@20)
                            storage_live(@21)
                            @21 := transmute<*mut (), usize>(copy (dst@2))
                            @20 := move (@21) == const (0 : usize)
                            storage_dead(@21)
                            @11 := ~(move (@20))
                            storage_dead(@20)
                            storage_dead(@19)
                            if move (@11) {
                                @6 := runtime(move (src@1), move (ptr@12), move (size@3), move (count@5))
                                storage_dead(@11)
                                storage_dead(@8)
                                if move (@6) {
                                    storage_dead(@6)
                                    return
                                } else {
                                }
                            } else {
                                storage_dead(@11)
                                storage_dead(@8)
                            }
                        }
                    } else {
                        storage_dead(@19)
                        storage_dead(@11)
                        storage_dead(@8)
                    }
                } else {
                    storage_live(@17)
                    storage_live(@18)
                    @18 := transmute<*const (), usize>(copy (src@1))
                    @17 := move (@18) == const (0 : usize)
                    storage_dead(@18)
                    @8 := ~(move (@17))
                    storage_dead(@17)
                    storage_dead(@16)
                    if move (@8) {
                        storage_dead(is_zst@10)
                        storage_dead(align@9)
                        storage_live(@11)
                        ptr@12 := cast<*mut (), *const ()>(copy (dst@2))
                        storage_live(@19)
                        @19 := is_aligned_to<()>(copy (ptr@12), move (align@4))
                        if move (@19) {
                            if copy (zero_size@7) {
                                storage_dead(@19)
                                @6 := runtime(move (src@1), move (ptr@12), move (size@3), move (count@5))
                                storage_dead(@11)
                                storage_dead(@8)
                                if move (@6) {
                                    storage_dead(@6)
                                    return
                                } else {
                                }
                            } else {
                                storage_live(@20)
                                storage_live(@21)
                                @21 := transmute<*mut (), usize>(copy (dst@2))
                                @20 := move (@21) == const (0 : usize)
                                storage_dead(@21)
                                @11 := ~(move (@20))
                                storage_dead(@20)
                                storage_dead(@19)
                                if move (@11) {
                                    @6 := runtime(move (src@1), move (ptr@12), move (size@3), move (count@5))
                                    storage_dead(@11)
                                    storage_dead(@8)
                                    if move (@6) {
                                        storage_dead(@6)
                                        return
                                    } else {
                                    }
                                } else {
                                    storage_dead(@11)
                                    storage_dead(@8)
                                }
                            }
                        } else {
                            storage_dead(@19)
                            storage_dead(@11)
                            storage_dead(@8)
                        }
                    } else {
                        storage_dead(is_zst@10)
                        storage_dead(align@9)
                        storage_dead(@11)
                        storage_dead(@8)
                    }
                }
            } else {
                storage_dead(@16)
                storage_dead(is_zst@10)
                storage_dead(align@9)
                storage_dead(@11)
                storage_dead(@8)
            }
        },
    }
    msg@13 := const ("unsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    storage_live(@15)
    storage_live(@22)
    storage_live(@23)
    storage_live(@28)
    @28 := &raw const *(msg@13) with_metadata(copy (msg@13.metadata))
    @23 := cast<*const Str, *const u8>(copy (@28))
    storage_dead(@28)
    @22 := transmute<*const u8, NonNull<u8>>(copy (@23))
    storage_dead(@23)
    storage_live(@24)
    storage_live(@25)
    storage_live(@26)
    storage_live(@27)
    storage_live(@29)
    @29 := transmute<&'_ (Str), &'_ (Slice<u8>)>(const ("unsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
    @27 := copy (@29.metadata)
    storage_dead(@29)
    @26 := move (@27) wrap.<< const (1 : i32)
    storage_dead(@27)
    @25 := move (@26) | const (1 : usize)
    storage_dead(@26)
    @24 := transmute<usize, NonNull<Argument<'_>>>(move (@25))
    storage_dead(@25)
    @15 := Arguments { template: move (@22), args: move (@24) }
    storage_dead(@24)
    storage_dead(@22)
    @14 := panic_nounwind_fmt<'_>(move (@15), const (false))
}

pub unsafe fn core::alloc::Allocator::grow<'_0, Self>(@1: &'_0 (Self), @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Self); // arg #1
    let ptr@2: NonNull<u8>; // arg #2
    let old_layout@3: Layout; // arg #3
    let new_layout@4: Layout; // arg #4
    let @5: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<Slice<u8>>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<Slice<u8>>}]; // anonymous local
    let self@6: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr@7: NonNull<Slice<u8>>; // local
    let src@8: *const u8; // local
    let dst@9: *mut u8; // local
    let count@10: usize; // local
    let @11: (); // anonymous local
    let v@12: NonNull<Slice<u8>>; // local
    let @13: *mut Slice<u8>; // anonymous local
    let @14: (); // anonymous local
    let @15: *const (); // anonymous local
    let @16: *mut (); // anonymous local
    let @17: bool; // anonymous local
    let @18: AllocError; // anonymous local
    let @19: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(new_ptr@7)
    storage_live(@11)
    storage_live(@13)
    storage_live(@14)
    storage_live(@5)
    storage_live(self@6)
    self@6 := @TraitClause0::allocate<'_>(copy (self@1), move (new_layout@4))
    storage_live(v@12)
    match self@6 {
        Result::Ok => {
        },
        Result::Err => {
            storage_dead(v@12)
            storage_dead(self@6)
            storage_live(@18)
            @18 := AllocError {  }
            storage_live(@19)
            @19 := Result::Err { 0: move (@18) }
            @0 := move (@19)
            storage_dead(@5)
            return
        },
    }
    v@12 := move ((self@6 as variant Result::Ok).0)
    @5 := ControlFlow::Continue { 0: copy (v@12) }
    storage_dead(v@12)
    storage_dead(self@6)
    new_ptr@7 := copy ((@5 as variant ControlFlow::Continue).0)
    storage_dead(@5)
    storage_live(src@8)
    src@8 := transmute<NonNull<u8>, *const u8>(copy (ptr@2))
    storage_live(dst@9)
    @13 := transmute<NonNull<Slice<u8>>, *mut Slice<u8>>(copy (new_ptr@7))
    dst@9 := cast<*mut Slice<u8>, *mut u8>(copy (@13))
    storage_live(count@10)
    count@10 := copy ((old_layout@3).size)
    storage_live(@17)
    @17 := ub_checks<bool>
    if copy (@17) {
        storage_live(@15)
        @15 := transmute<NonNull<u8>, *const ()>(copy (ptr@2))
        storage_live(@16)
        @16 := cast<*mut Slice<u8>, *mut ()>(copy (@13))
        @14 := core::ptr::copy_nonoverlapping::precondition_check(move (@15), move (@16), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), copy (count@10))
        storage_dead(@16)
        storage_dead(@15)
    } else {
    }
    copy_nonoverlapping(copy (src@8), copy (dst@9), copy (count@10))
    storage_dead(@17)
    storage_dead(count@10)
    storage_dead(dst@9)
    storage_dead(src@8)
    @11 := @TraitClause0::deallocate<'_>(move (self@1), move (ptr@2), move (old_layout@3))
    @0 := Result::Ok { 0: copy (new_ptr@7) }
    return
}

pub unsafe fn core::alloc::Allocator::grow_zeroed<'_0, Self>(@1: &'_0 (Self), @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Self); // arg #1
    let ptr@2: NonNull<u8>; // arg #2
    let old_layout@3: Layout; // arg #3
    let new_layout@4: Layout; // arg #4
    let @5: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<Slice<u8>>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<Slice<u8>>}]; // anonymous local
    let self@6: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr@7: NonNull<Slice<u8>>; // local
    let src@8: *const u8; // local
    let dst@9: *mut u8; // local
    let count@10: usize; // local
    let @11: (); // anonymous local
    let v@12: NonNull<Slice<u8>>; // local
    let @13: *mut Slice<u8>; // anonymous local
    let @14: (); // anonymous local
    let @15: *const (); // anonymous local
    let @16: *mut (); // anonymous local
    let @17: bool; // anonymous local
    let @18: AllocError; // anonymous local
    let @19: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(new_ptr@7)
    storage_live(@11)
    storage_live(@13)
    storage_live(@14)
    storage_live(@5)
    storage_live(self@6)
    self@6 := @TraitClause0::allocate_zeroed<'_>(copy (self@1), move (new_layout@4))
    storage_live(v@12)
    match self@6 {
        Result::Ok => {
        },
        Result::Err => {
            storage_dead(v@12)
            storage_dead(self@6)
            storage_live(@18)
            @18 := AllocError {  }
            storage_live(@19)
            @19 := Result::Err { 0: move (@18) }
            @0 := move (@19)
            storage_dead(@5)
            return
        },
    }
    v@12 := move ((self@6 as variant Result::Ok).0)
    @5 := ControlFlow::Continue { 0: copy (v@12) }
    storage_dead(v@12)
    storage_dead(self@6)
    new_ptr@7 := copy ((@5 as variant ControlFlow::Continue).0)
    storage_dead(@5)
    storage_live(src@8)
    src@8 := transmute<NonNull<u8>, *const u8>(copy (ptr@2))
    storage_live(dst@9)
    @13 := transmute<NonNull<Slice<u8>>, *mut Slice<u8>>(copy (new_ptr@7))
    dst@9 := cast<*mut Slice<u8>, *mut u8>(copy (@13))
    storage_live(count@10)
    count@10 := copy ((old_layout@3).size)
    storage_live(@17)
    @17 := ub_checks<bool>
    if copy (@17) {
        storage_live(@15)
        @15 := transmute<NonNull<u8>, *const ()>(copy (ptr@2))
        storage_live(@16)
        @16 := cast<*mut Slice<u8>, *mut ()>(copy (@13))
        @14 := core::ptr::copy_nonoverlapping::precondition_check(move (@15), move (@16), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), copy (count@10))
        storage_dead(@16)
        storage_dead(@15)
    } else {
    }
    copy_nonoverlapping(copy (src@8), copy (dst@9), copy (count@10))
    storage_dead(@17)
    storage_dead(count@10)
    storage_dead(dst@9)
    storage_dead(src@8)
    @11 := @TraitClause0::deallocate<'_>(move (self@1), move (ptr@2), move (old_layout@3))
    @0 := Result::Ok { 0: copy (new_ptr@7) }
    return
}

pub unsafe fn core::alloc::Allocator::shrink<'_0, Self>(@1: &'_0 (Self), @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
where
    [@TraitClause0]: Allocator<Self>,
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Self); // arg #1
    let ptr@2: NonNull<u8>; // arg #2
    let old_layout@3: Layout; // arg #3
    let new_layout@4: Layout; // arg #4
    let @5: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<Slice<u8>>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<Slice<u8>>}]; // anonymous local
    let self@6: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr@7: NonNull<Slice<u8>>; // local
    let src@8: *const u8; // local
    let dst@9: *mut u8; // local
    let count@10: usize; // local
    let @11: (); // anonymous local
    let v@12: NonNull<Slice<u8>>; // local
    let @13: *mut Slice<u8>; // anonymous local
    let @14: (); // anonymous local
    let @15: *const (); // anonymous local
    let @16: *mut (); // anonymous local
    let @17: bool; // anonymous local
    let @18: AllocError; // anonymous local
    let @19: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(new_ptr@7)
    storage_live(@11)
    storage_live(@13)
    storage_live(@14)
    storage_live(@5)
    storage_live(self@6)
    self@6 := @TraitClause0::allocate<'_>(copy (self@1), copy (new_layout@4))
    storage_live(v@12)
    match self@6 {
        Result::Ok => {
        },
        Result::Err => {
            storage_dead(v@12)
            storage_dead(self@6)
            storage_live(@18)
            @18 := AllocError {  }
            storage_live(@19)
            @19 := Result::Err { 0: move (@18) }
            @0 := move (@19)
            storage_dead(@5)
            return
        },
    }
    v@12 := move ((self@6 as variant Result::Ok).0)
    @5 := ControlFlow::Continue { 0: copy (v@12) }
    storage_dead(v@12)
    storage_dead(self@6)
    new_ptr@7 := copy ((@5 as variant ControlFlow::Continue).0)
    storage_dead(@5)
    storage_live(src@8)
    src@8 := transmute<NonNull<u8>, *const u8>(copy (ptr@2))
    storage_live(dst@9)
    @13 := transmute<NonNull<Slice<u8>>, *mut Slice<u8>>(copy (new_ptr@7))
    dst@9 := cast<*mut Slice<u8>, *mut u8>(copy (@13))
    storage_live(count@10)
    count@10 := copy ((new_layout@4).size)
    storage_live(@17)
    @17 := ub_checks<bool>
    if copy (@17) {
        storage_live(@15)
        @15 := transmute<NonNull<u8>, *const ()>(copy (ptr@2))
        storage_live(@16)
        @16 := cast<*mut Slice<u8>, *mut ()>(copy (@13))
        @14 := core::ptr::copy_nonoverlapping::precondition_check(move (@15), move (@16), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), copy (count@10))
        storage_dead(@16)
        storage_dead(@15)
    } else {
    }
    copy_nonoverlapping(copy (src@8), copy (dst@9), copy (count@10))
    storage_dead(@17)
    storage_dead(count@10)
    storage_dead(dst@9)
    storage_dead(src@8)
    @11 := @TraitClause0::deallocate<'_>(move (self@1), move (ptr@2), move (old_layout@3))
    @0 := Result::Ok { 0: copy (new_ptr@7) }
    return
}

pub fn core::alloc::Allocator::by_ref<'_0, Self>(@1: &'_0 (Self)) -> &'_0 (Self)
where
    [@TraitClause0]: Allocator<Self>,
    [@TraitClause1]: Sized<Self>,
{
    let @0: &'_ (Self); // return
    let self@1: &'_ (Self); // arg #1

    @0 := copy (self@1)
    return
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 (Self)) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <method_without_default_body>

pub fn core::clone::Clone::clone_from<'_0, '_1, Self>(@1: &'_0 mut (Self), @2: &'_1 (Self))
where
    [@TraitClause0]: Clone<Self>,
    [@TraitClause1]: Destruct<Self>,
{
    let @0: (); // return
    let self@1: &'_ mut (Self); // arg #1
    let source@2: &'_ (Self); // arg #2
    let @3: Self; // anonymous local

    @0 := ()
    storage_live(@3)
    @3 := @TraitClause0::clone<'_>(move (source@2))
    drop[@TraitClause1] *(self@1)
    *(self@1) := move (@3)
    storage_dead(@3)
    return
}

fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <missing>

// Full name: core::num::niche_types::NonZeroUsizeInner
pub struct NonZeroUsizeInner {
  usize,
}

// Full name: core::num::niche_types::{impl Clone for NonZeroUsizeInner}::clone
pub fn {impl Clone for NonZeroUsizeInner}::clone<'_0>(@1: &'_0 (NonZeroUsizeInner)) -> NonZeroUsizeInner
{
    let @0: NonZeroUsizeInner; // return
    let self@1: &'_ (NonZeroUsizeInner); // arg #1

    @0 := copy (*(self@1))
    return
}

// Full name: core::num::niche_types::{impl Clone for NonZeroUsizeInner}::clone_from
pub fn {impl Clone for NonZeroUsizeInner}::clone_from<'_0, '_1>(@1: &'_0 mut (NonZeroUsizeInner), @2: &'_1 (NonZeroUsizeInner))
where
    [@TraitClause0]: Destruct<NonZeroUsizeInner>,
{
    let @0: (); // return
    let self@1: &'_ mut (NonZeroUsizeInner); // arg #1
    let source@2: &'_ (NonZeroUsizeInner); // arg #2
    let @3: NonZeroUsizeInner; // anonymous local

    @0 := ()
    storage_live(@3)
    @3 := {impl Clone for NonZeroUsizeInner}::clone<'_>(move (source@2))
    drop[@TraitClause0] *(self@1)
    *(self@1) := move (@3)
    storage_dead(@3)
    return
}

// Full name: core::num::niche_types::{impl Clone for NonZeroUsizeInner}
impl Clone for NonZeroUsizeInner {
    parent_clause0 = {built_in impl Sized for NonZeroUsizeInner}
    fn clone<'_0_1> = {impl Clone for NonZeroUsizeInner}::clone<'_0_1>
    fn clone_from<'_0_1, '_1_1, [@TraitClause0_1]: Destruct<NonZeroUsizeInner>> = {impl Clone for NonZeroUsizeInner}::clone_from<'_0_1, '_1_1>[@TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::num::niche_types::{impl Copy for NonZeroUsizeInner}
impl Copy for NonZeroUsizeInner {
    parent_clause0 = {built_in impl MetaSized for NonZeroUsizeInner}
    parent_clause1 = {impl Clone for NonZeroUsizeInner}
    non-dyn-compatible
}

// Full name: core::num::nonzero::private::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::num::nonzero::private::Sealed::{vtable}
}

// Full name: core::num::nonzero::ZeroablePrimitive
pub trait ZeroablePrimitive<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Copy<Self>
    parent_clause2 : [@TraitClause2]: Sealed<Self>
    parent_clause3 : [@TraitClause3]: Sized<Self::NonZeroInner>
    parent_clause4 : [@TraitClause4]: Copy<Self::NonZeroInner>
    type NonZeroInner
    non-dyn-compatible
}

// Full name: core::num::nonzero::{impl Sealed for usize}
impl Sealed for usize {
    parent_clause0 = {built_in impl MetaSized for usize}
    vtable: {impl Sealed for usize}::{vtable}
}

// Full name: core::num::nonzero::{impl ZeroablePrimitive for usize}
impl ZeroablePrimitive for usize {
    parent_clause0 = {built_in impl Sized for usize}
    parent_clause1 = {impl Copy for usize}
    parent_clause2 = {impl Sealed for usize}
    parent_clause3 = {built_in impl Sized for NonZeroUsizeInner}
    parent_clause4 = {impl Copy for NonZeroUsizeInner}
    type NonZeroInner = NonZeroUsizeInner
    non-dyn-compatible
}

// Full name: core::num::nonzero::NonZero
#[lang_item("NonZero")]
pub struct NonZero<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ZeroablePrimitive<T>,
{
  @TraitClause1::NonZeroInner,
}

// Full name: core::ptr::unique::Unique
pub struct Unique<T> {
  pointer: NonNull<T>,
  _marker: PhantomData<T>,
}

fn core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(@1: *mut ())
{
    let @0: (); // return
    let ptr@1: *mut (); // arg #1
    let msg@2: &'_ (Str); // local
    let @3: !; // anonymous local
    let @4: Arguments<'_>; // anonymous local
    let @5: usize; // anonymous local
    let @6: NonNull<u8>; // anonymous local
    let @7: *const u8; // anonymous local
    let @8: NonNull<Argument<'_>>; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local
    let @11: usize; // anonymous local
    let @12: *const Str; // anonymous local
    let @13: &'_ (Slice<u8>); // anonymous local

    storage_live(msg@2)
    storage_live(@3)
    @0 := ()
    storage_live(@5)
    @5 := transmute<*mut (), usize>(copy (ptr@1))
    switch move (@5) {
        0 : usize => {
        },
        _ => {
            storage_dead(@5)
            return
        },
    }
    storage_dead(@5)
    msg@2 := const ("unsafe precondition(s) violated: NonNull::new_unchecked requires that the pointer is non-null\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    storage_live(@4)
    storage_live(@6)
    storage_live(@7)
    storage_live(@12)
    @12 := &raw const *(msg@2) with_metadata(copy (msg@2.metadata))
    @7 := cast<*const Str, *const u8>(copy (@12))
    storage_dead(@12)
    @6 := transmute<*const u8, NonNull<u8>>(copy (@7))
    storage_dead(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@13)
    @13 := transmute<&'_ (Str), &'_ (Slice<u8>)>(const ("unsafe precondition(s) violated: NonNull::new_unchecked requires that the pointer is non-null\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
    @11 := copy (@13.metadata)
    storage_dead(@13)
    @10 := move (@11) wrap.<< const (1 : i32)
    storage_dead(@11)
    @9 := move (@10) | const (1 : usize)
    storage_dead(@10)
    @8 := transmute<usize, NonNull<Argument<'_>>>(move (@9))
    storage_dead(@9)
    @4 := Arguments { template: move (@6), args: move (@8) }
    storage_dead(@8)
    storage_dead(@6)
    @3 := panic_nounwind_fmt<'_>(move (@4), const (false))
}

fn core::hint::assert_unchecked::precondition_check(@1: bool)
{
    let @0: (); // return
    let cond@1: bool; // arg #1
    let msg@2: &'_ (Str); // local
    let @3: !; // anonymous local
    let @4: Arguments<'_>; // anonymous local
    let @5: NonNull<u8>; // anonymous local
    let @6: *const u8; // anonymous local
    let @7: NonNull<Argument<'_>>; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local
    let @11: *const Str; // anonymous local
    let @12: &'_ (Slice<u8>); // anonymous local

    storage_live(msg@2)
    storage_live(@3)
    @0 := ()
    if copy (cond@1) {
    } else {
        msg@2 := const ("unsafe precondition(s) violated: hint::assert_unchecked must never be called when the condition is false\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
        storage_live(@4)
        storage_live(@5)
        storage_live(@6)
        storage_live(@11)
        @11 := &raw const *(msg@2) with_metadata(copy (msg@2.metadata))
        @6 := cast<*const Str, *const u8>(copy (@11))
        storage_dead(@11)
        @5 := transmute<*const u8, NonNull<u8>>(copy (@6))
        storage_dead(@6)
        storage_live(@7)
        storage_live(@8)
        storage_live(@9)
        storage_live(@10)
        storage_live(@12)
        @12 := transmute<&'_ (Str), &'_ (Slice<u8>)>(const ("unsafe precondition(s) violated: hint::assert_unchecked must never be called when the condition is false\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
        @10 := copy (@12.metadata)
        storage_dead(@12)
        @9 := move (@10) wrap.<< const (1 : i32)
        storage_dead(@10)
        @8 := move (@9) | const (1 : usize)
        storage_dead(@9)
        @7 := transmute<usize, NonNull<Argument<'_>>>(move (@8))
        storage_dead(@8)
        @4 := Arguments { template: move (@5), args: move (@7) }
        storage_dead(@7)
        storage_dead(@5)
        @3 := panic_nounwind_fmt<'_>(move (@4), const (false))
    }
    return
}

// Full name: alloc::alloc::__rust_alloc
unsafe fn __rust_alloc(@1: usize, @2: usize) -> *mut u8
= <opaque>

// Full name: alloc::alloc::__rust_dealloc
unsafe fn __rust_dealloc(@1: *mut u8, @2: usize, @3: usize)
= <opaque>

// Full name: alloc::alloc::__rust_realloc
unsafe fn __rust_realloc(@1: *mut u8, @2: usize, @3: usize, @4: usize) -> *mut u8
= <opaque>

// Full name: alloc::alloc::__rust_alloc_zeroed
unsafe fn __rust_alloc_zeroed(@1: usize, @2: usize) -> *mut u8
= <opaque>

// Full name: alloc::alloc::__rust_no_alloc_shim_is_unstable_v2
unsafe fn __rust_no_alloc_shim_is_unstable_v2()
= <opaque>

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::alloc::{Global}::alloc_impl
fn alloc_impl<'_0>(@1: &'_0 (Global), @2: Layout, @3: bool) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Global); // arg #1
    let layout@2: Layout; // arg #2
    let zeroed@3: bool; // arg #3
    let size@4: usize; // local
    let @5: NonNull<Slice<u8>>; // anonymous local
    let data@6: NonNull<u8>; // local
    let raw_ptr@7: *mut u8; // local
    let @8: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<u8>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<u8>}]; // anonymous local
    let self@9: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // local
    let self@10: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // local
    let ptr@11: NonNull<u8>; // local
    let @12: NonNull<Slice<u8>>; // anonymous local
    let @13: NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}]; // anonymous local
    let @14: Alignment; // anonymous local
    let @15: *const u8; // anonymous local
    let ptr@16: *mut Slice<u8>; // local
    let data@17: *mut u8; // local
    let @18: (); // anonymous local
    let @19: *mut (); // anonymous local
    let @20: *const Slice<u8>; // anonymous local
    let @21: bool; // anonymous local
    let @22: (); // anonymous local
    let @23: usize; // anonymous local
    let @24: AlignmentEnum; // anonymous local
    let @25: (); // anonymous local
    let @26: usize; // anonymous local
    let @27: AlignmentEnum; // anonymous local
    let @28: NonNull<u8>; // anonymous local
    let @29: *const u8; // anonymous local
    let @30: usize; // anonymous local
    let @31: (); // anonymous local
    let @32: *mut (); // anonymous local
    let @33: bool; // anonymous local
    let v@34: NonNull<u8>; // local
    let v@35: NonNull<u8>; // local
    let ptr@36: *mut Slice<u8>; // local
    let data@37: *mut u8; // local
    let @38: (); // anonymous local
    let @39: *mut (); // anonymous local
    let @40: *const Slice<u8>; // anonymous local
    let @41: bool; // anonymous local
    let @42: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // anonymous local
    let @43: AllocError; // anonymous local
    let @44: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // anonymous local
    let @45: AllocError; // anonymous local
    let @46: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(size@4)
    storage_live(raw_ptr@7)
    storage_live(ptr@11)
    storage_live(@13)
    storage_live(@18)
    storage_live(@22)
    storage_live(@25)
    storage_live(@29)
    storage_live(@31)
    storage_live(@38)
    size@4 := copy ((layout@2).size)
    switch copy (size@4) {
        0 : usize => {
        },
        _ => {
            if copy (zeroed@3) {
                @22 := __rust_no_alloc_shim_is_unstable_v2()
                storage_live(@23)
                storage_live(@24)
                @24 := copy (((layout@2).align).0)
                @23 := @discriminant(@24)
                storage_dead(@24)
                raw_ptr@7 := __rust_alloc_zeroed(copy (size@4), move (@23))
                storage_dead(@23)
            } else {
                @25 := __rust_no_alloc_shim_is_unstable_v2()
                storage_live(@26)
                storage_live(@27)
                @27 := copy (((layout@2).align).0)
                @26 := @discriminant(@27)
                storage_dead(@27)
                raw_ptr@7 := __rust_alloc(copy (size@4), move (@26))
                storage_dead(@26)
            }
            storage_live(@8)
            storage_live(self@9)
            storage_live(self@10)
            @29 := cast<*mut u8, *const u8>(copy (raw_ptr@7))
            storage_live(@30)
            @30 := transmute<*mut u8, usize>(copy (raw_ptr@7))
            switch move (@30) {
                0 : usize => {
                },
                _ => {
                    storage_dead(@30)
                    storage_live(@28)
                    storage_live(@33)
                    @33 := ub_checks<bool>
                    if copy (@33) {
                        storage_live(@32)
                        @32 := cast<*mut u8, *mut ()>(copy (raw_ptr@7))
                        @31 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@32))
                        storage_dead(@32)
                    } else {
                    }
                    @28 := NonNull { pointer: copy (@29) }
                    storage_dead(@33)
                    self@10 := Option::Some { 0: move (@28) }
                    storage_dead(@28)
                    storage_live(v@34)
                    v@34 := move ((self@10 as variant Option::Some).0)
                    self@9 := Result::Ok { 0: copy (v@34) }
                    storage_dead(v@34)
                    storage_dead(self@10)
                    storage_live(v@35)
                    v@35 := move ((self@9 as variant Result::Ok).0)
                    @8 := ControlFlow::Continue { 0: copy (v@35) }
                    storage_dead(v@35)
                    storage_dead(self@9)
                    ptr@11 := copy ((@8 as variant ControlFlow::Continue).0)
                    storage_dead(@8)
                    storage_live(@12)
                    storage_live(ptr@36)
                    storage_live(data@37)
                    data@37 := transmute<NonNull<u8>, *mut u8>(copy (ptr@11))
                    ptr@36 := *mut  (copy (data@37), copy (size@4))
                    storage_dead(data@37)
                    storage_live(@40)
                    storage_live(@41)
                    @41 := ub_checks<bool>
                    if copy (@41) {
                        storage_live(@39)
                        @39 := transmute<NonNull<u8>, *mut ()>(copy (ptr@11))
                        @38 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@39))
                        storage_dead(@39)
                    } else {
                    }
                    @40 := cast<*mut Slice<u8>, *const Slice<u8>>(copy (ptr@36))
                    @12 := NonNull { pointer: copy (@40) }
                    storage_dead(@41)
                    storage_dead(@40)
                    storage_dead(ptr@36)
                    @0 := Result::Ok { 0: move (@12) }
                    storage_dead(@12)
                    return
                },
            }
            storage_dead(@30)
            storage_live(@42)
            @42 := Option::None {  }
            self@10 := move (@42)
            storage_live(v@34)
            storage_live(@43)
            @43 := AllocError {  }
            storage_live(@44)
            @44 := Result::Err { 0: move (@43) }
            self@9 := move (@44)
            storage_dead(v@34)
            storage_dead(self@10)
            storage_live(v@35)
            storage_dead(v@35)
            storage_dead(self@9)
            storage_live(@45)
            @45 := AllocError {  }
            storage_live(@46)
            @46 := Result::Err { 0: move (@45) }
            @0 := move (@46)
            storage_dead(@8)
            return
        },
    }
    storage_live(@5)
    storage_live(data@6)
    storage_live(@14)
    @14 := copy ((layout@2).align)
    @13 := transmute<Alignment, NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}]>(copy (@14))
    storage_dead(@14)
    storage_live(@15)
    @15 := transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *const u8>(copy (@13))
    data@6 := NonNull { pointer: copy (@15) }
    storage_dead(@15)
    storage_live(ptr@16)
    storage_live(data@17)
    data@17 := transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *mut u8>(copy (@13))
    ptr@16 := *mut  (copy (data@17), const (0 : usize))
    storage_dead(data@17)
    storage_live(@20)
    storage_live(@21)
    @21 := ub_checks<bool>
    if copy (@21) {
        storage_live(@19)
        @19 := transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *mut ()>(copy (@13))
        @18 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@19))
        storage_dead(@19)
    } else {
    }
    @20 := cast<*mut Slice<u8>, *const Slice<u8>>(copy (ptr@16))
    @5 := NonNull { pointer: copy (@20) }
    storage_dead(@21)
    storage_dead(@20)
    storage_dead(ptr@16)
    storage_dead(data@6)
    @0 := Result::Ok { 0: move (@5) }
    storage_dead(@5)
    return
}

// Full name: alloc::alloc::{Global}::grow_impl
unsafe fn grow_impl<'_0>(@1: &'_0 (Global), @2: NonNull<u8>, @3: Layout, @4: Layout, @5: bool) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Global); // arg #1
    let ptr@2: NonNull<u8>; // arg #2
    let old_layout@3: Layout; // arg #3
    let new_layout@4: Layout; // arg #4
    let zeroed@5: bool; // arg #5
    let old_size@6: usize; // local
    let @7: bool; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local
    let new_size@10: usize; // local
    let cond@11: bool; // local
    let raw_ptr@12: *mut u8; // local
    let ptr@13: *mut u8; // local
    let self@14: NonNull<u8>; // local
    let new_size@15: usize; // local
    let @16: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<u8>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<u8>}]; // anonymous local
    let self@17: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // local
    let self@18: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // local
    let ptr@19: *mut u8; // local
    let ptr@20: NonNull<u8>; // local
    let @21: (); // anonymous local
    let self@22: *mut u8; // local
    let self@23: *mut u8; // local
    let count@24: usize; // local
    let @25: NonNull<Slice<u8>>; // anonymous local
    let @26: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<Slice<u8>>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<Slice<u8>>}]; // anonymous local
    let self@27: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr@28: NonNull<Slice<u8>>; // local
    let src@29: *const u8; // local
    let ptr@30: *mut u8; // local
    let dst@31: *mut u8; // local
    let @32: (); // anonymous local
    let @33: AlignmentEnum; // anonymous local
    let @34: AlignmentEnum; // anonymous local
    let @35: (); // anonymous local
    let @36: bool; // anonymous local
    let @37: NonNull<u8>; // anonymous local
    let @38: *const u8; // anonymous local
    let @39: usize; // anonymous local
    let @40: (); // anonymous local
    let @41: *mut (); // anonymous local
    let v@42: NonNull<u8>; // local
    let v@43: NonNull<u8>; // local
    let @44: (); // anonymous local
    let @45: *const (); // anonymous local
    let @46: bool; // anonymous local
    let ptr@47: *mut Slice<u8>; // local
    let data@48: *mut u8; // local
    let @49: (); // anonymous local
    let @50: *mut (); // anonymous local
    let @51: *const Slice<u8>; // anonymous local
    let v@52: NonNull<Slice<u8>>; // local
    let @53: *mut Slice<u8>; // anonymous local
    let @54: (); // anonymous local
    let @55: *const (); // anonymous local
    let @56: *mut (); // anonymous local
    let @57: bool; // anonymous local
    let @58: AllocError; // anonymous local
    let @59: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local
    let @60: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // anonymous local
    let @61: AllocError; // anonymous local
    let @62: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // anonymous local
    let @63: AllocError; // anonymous local
    let @64: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(old_size@6)
    storage_live(@8)
    storage_live(new_size@10)
    storage_live(raw_ptr@12)
    storage_live(ptr@20)
    storage_live(@21)
    storage_live(new_ptr@28)
    storage_live(ptr@30)
    storage_live(@32)
    storage_live(@33)
    storage_live(@35)
    storage_live(@36)
    storage_live(@38)
    storage_live(@40)
    storage_live(@44)
    storage_live(@49)
    storage_live(@53)
    storage_live(@54)
    old_size@6 := copy ((old_layout@3).size)
    switch copy (old_size@6) {
        0 : usize => {
        },
        _ => {
            storage_live(@7)
            @33 := copy (((old_layout@3).align).0)
            @8 := @discriminant(@33)
            storage_live(@9)
            storage_live(@34)
            @34 := copy (((new_layout@4).align).0)
            @9 := @discriminant(@34)
            storage_dead(@34)
            @7 := copy (@8) == move (@9)
            if move (@7) {
            } else {
                storage_dead(@9)
                storage_dead(@7)
                storage_live(@26)
                storage_live(self@27)
                self@27 := alloc_impl<'_>(move (self@1), move (new_layout@4), move (zeroed@5))
                storage_live(v@52)
                match self@27 {
                    Result::Ok => {
                    },
                    Result::Err => {
                        storage_dead(v@52)
                        storage_dead(self@27)
                        storage_live(@58)
                        @58 := AllocError {  }
                        storage_live(@59)
                        @59 := Result::Err { 0: move (@58) }
                        @0 := move (@59)
                        storage_dead(@26)
                        return
                    },
                }
                v@52 := move ((self@27 as variant Result::Ok).0)
                @26 := ControlFlow::Continue { 0: copy (v@52) }
                storage_dead(v@52)
                storage_dead(self@27)
                new_ptr@28 := copy ((@26 as variant ControlFlow::Continue).0)
                storage_dead(@26)
                storage_live(src@29)
                ptr@30 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
                src@29 := transmute<NonNull<u8>, *const u8>(copy (ptr@2))
                storage_live(dst@31)
                @53 := transmute<NonNull<Slice<u8>>, *mut Slice<u8>>(copy (new_ptr@28))
                dst@31 := cast<*mut Slice<u8>, *mut u8>(copy (@53))
                storage_live(@57)
                @57 := ub_checks<bool>
                if copy (@57) {
                    storage_live(@55)
                    @55 := transmute<NonNull<u8>, *const ()>(copy (ptr@2))
                    storage_live(@56)
                    @56 := cast<*mut Slice<u8>, *mut ()>(copy (@53))
                    @54 := core::ptr::copy_nonoverlapping::precondition_check(move (@55), move (@56), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), copy (old_size@6))
                    storage_dead(@56)
                    storage_dead(@55)
                } else {
                }
                copy_nonoverlapping(copy (src@29), copy (dst@31), copy (old_size@6))
                storage_dead(@57)
                storage_dead(dst@31)
                storage_dead(src@29)
                switch copy (old_size@6) {
                    0 : usize => {
                    },
                    _ => {
                        @32 := __rust_dealloc(move (ptr@30), move (old_size@6), move (@8))
                    },
                }
                @0 := Result::Ok { 0: copy (new_ptr@28) }
                return
            }
            storage_dead(@9)
            storage_dead(@7)
            new_size@10 := copy ((new_layout@4).size)
            storage_live(cond@11)
            cond@11 := copy (new_size@10) >= copy (old_size@6)
            @36 := ub_checks<bool>
            if copy (@36) {
            } else {
                assert(copy (cond@11) == true)
                storage_dead(cond@11)
                storage_live(ptr@13)
                storage_live(self@14)
                self@14 := copy (ptr@2)
                ptr@13 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
                storage_dead(self@14)
                storage_live(new_size@15)
                new_size@15 := copy (new_size@10)
                raw_ptr@12 := __rust_realloc(move (ptr@13), copy (old_size@6), move (@8), copy (new_size@10))
                storage_dead(new_size@15)
                storage_dead(ptr@13)
                storage_live(@16)
                storage_live(self@17)
                storage_live(self@18)
                storage_live(ptr@19)
                ptr@19 := copy (raw_ptr@12)
                @38 := cast<*mut u8, *const u8>(copy (raw_ptr@12))
                storage_live(@39)
                @39 := transmute<*mut u8, usize>(copy (raw_ptr@12))
                switch move (@39) {
                    0 : usize => {
                    },
                    _ => {
                        storage_dead(@39)
                        storage_live(@37)
                        if copy (@36) {
                            storage_live(@41)
                            @41 := cast<*mut u8, *mut ()>(copy (raw_ptr@12))
                            @40 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@41))
                            storage_dead(@41)
                        } else {
                        }
                        @37 := NonNull { pointer: copy (@38) }
                        self@18 := Option::Some { 0: move (@37) }
                        storage_dead(@37)
                        storage_dead(ptr@19)
                        storage_live(v@42)
                        v@42 := move ((self@18 as variant Option::Some).0)
                        self@17 := Result::Ok { 0: copy (v@42) }
                        storage_dead(v@42)
                        storage_dead(self@18)
                        storage_live(v@43)
                        v@43 := move ((self@17 as variant Result::Ok).0)
                        @16 := ControlFlow::Continue { 0: copy (v@43) }
                        storage_dead(v@43)
                        storage_dead(self@17)
                        ptr@20 := copy ((@16 as variant ControlFlow::Continue).0)
                        storage_dead(@16)
                        if copy (zeroed@5) {
                            storage_live(self@22)
                            storage_live(self@23)
                            self@23 := copy (raw_ptr@12)
                            self@22 := copy (raw_ptr@12) offset copy (old_size@6)
                            storage_dead(self@23)
                            storage_live(count@24)
                            count@24 := copy (new_size@10) wrap.- copy (old_size@6)
                            if copy (@36) {
                                storage_live(@45)
                                @45 := cast<*mut u8, *const ()>(copy (self@22))
                                storage_live(@46)
                                @46 := copy (count@24) == const (0 : usize)
                                @44 := core::ptr::write_bytes::precondition_check(move (@45), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), move (@46))
                                storage_dead(@46)
                                storage_dead(@45)
                            } else {
                            }
                            @21 := write_bytes<u8>[{built_in impl Sized for u8}](move (self@22), const (0 : u8), move (count@24))
                            storage_dead(count@24)
                            storage_dead(self@22)
                        } else {
                        }
                        storage_live(@25)
                        storage_live(ptr@47)
                        storage_live(data@48)
                        data@48 := transmute<NonNull<u8>, *mut u8>(copy (ptr@20))
                        ptr@47 := *mut  (copy (data@48), copy (new_size@10))
                        storage_dead(data@48)
                        storage_live(@51)
                        if copy (@36) {
                            storage_live(@50)
                            @50 := transmute<NonNull<u8>, *mut ()>(copy (ptr@20))
                            @49 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@50))
                            storage_dead(@50)
                        } else {
                        }
                        @51 := cast<*mut Slice<u8>, *const Slice<u8>>(copy (ptr@47))
                        @25 := NonNull { pointer: copy (@51) }
                        storage_dead(@51)
                        storage_dead(ptr@47)
                        @0 := Result::Ok { 0: move (@25) }
                        storage_dead(@25)
                        return
                    },
                }
                storage_dead(@39)
                storage_live(@60)
                @60 := Option::None {  }
                self@18 := move (@60)
                storage_dead(ptr@19)
                storage_live(v@42)
                storage_live(@61)
                @61 := AllocError {  }
                storage_live(@62)
                @62 := Result::Err { 0: move (@61) }
                self@17 := move (@62)
                storage_dead(v@42)
                storage_dead(self@18)
                storage_live(v@43)
                storage_dead(v@43)
                storage_dead(self@17)
                storage_live(@63)
                @63 := AllocError {  }
                storage_live(@64)
                @64 := Result::Err { 0: move (@63) }
                @0 := move (@64)
                storage_dead(@16)
                return
            }
            @35 := core::hint::assert_unchecked::precondition_check(copy (cond@11))
            assert(copy (cond@11) == true)
            storage_dead(cond@11)
            storage_live(ptr@13)
            storage_live(self@14)
            self@14 := copy (ptr@2)
            ptr@13 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
            storage_dead(self@14)
            storage_live(new_size@15)
            new_size@15 := copy (new_size@10)
            raw_ptr@12 := __rust_realloc(move (ptr@13), copy (old_size@6), move (@8), copy (new_size@10))
            storage_dead(new_size@15)
            storage_dead(ptr@13)
            storage_live(@16)
            storage_live(self@17)
            storage_live(self@18)
            storage_live(ptr@19)
            ptr@19 := copy (raw_ptr@12)
            @38 := cast<*mut u8, *const u8>(copy (raw_ptr@12))
            storage_live(@39)
            @39 := transmute<*mut u8, usize>(copy (raw_ptr@12))
            switch move (@39) {
                0 : usize => {
                    storage_dead(@39)
                    storage_live(@60)
                    @60 := Option::None {  }
                    self@18 := move (@60)
                    storage_dead(ptr@19)
                    storage_live(v@42)
                    storage_live(@61)
                    @61 := AllocError {  }
                    storage_live(@62)
                    @62 := Result::Err { 0: move (@61) }
                    self@17 := move (@62)
                    storage_dead(v@42)
                    storage_dead(self@18)
                    storage_live(v@43)
                    storage_dead(v@43)
                    storage_dead(self@17)
                    storage_live(@63)
                    @63 := AllocError {  }
                    storage_live(@64)
                    @64 := Result::Err { 0: move (@63) }
                    @0 := move (@64)
                    storage_dead(@16)
                    return
                },
                _ => {
                },
            }
            storage_dead(@39)
            storage_live(@37)
            storage_live(@41)
            @41 := cast<*mut u8, *mut ()>(copy (raw_ptr@12))
            @40 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@41))
            storage_dead(@41)
            @37 := NonNull { pointer: copy (@38) }
            self@18 := Option::Some { 0: move (@37) }
            storage_dead(@37)
            storage_dead(ptr@19)
            storage_live(v@42)
            v@42 := move ((self@18 as variant Option::Some).0)
            self@17 := Result::Ok { 0: copy (v@42) }
            storage_dead(v@42)
            storage_dead(self@18)
            storage_live(v@43)
            v@43 := move ((self@17 as variant Result::Ok).0)
            @16 := ControlFlow::Continue { 0: copy (v@43) }
            storage_dead(v@43)
            storage_dead(self@17)
            ptr@20 := copy ((@16 as variant ControlFlow::Continue).0)
            storage_dead(@16)
            if copy (zeroed@5) {
                storage_live(self@22)
                storage_live(self@23)
                self@23 := copy (raw_ptr@12)
                self@22 := copy (raw_ptr@12) offset copy (old_size@6)
                storage_dead(self@23)
                storage_live(count@24)
                count@24 := copy (new_size@10) wrap.- copy (old_size@6)
                if copy (@36) {
                    storage_live(@45)
                    @45 := cast<*mut u8, *const ()>(copy (self@22))
                    storage_live(@46)
                    @46 := copy (count@24) == const (0 : usize)
                    @44 := core::ptr::write_bytes::precondition_check(move (@45), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), move (@46))
                    storage_dead(@46)
                    storage_dead(@45)
                } else {
                }
                @21 := write_bytes<u8>[{built_in impl Sized for u8}](move (self@22), const (0 : u8), move (count@24))
                storage_dead(count@24)
                storage_dead(self@22)
            } else {
            }
            storage_live(@25)
            storage_live(ptr@47)
            storage_live(data@48)
            data@48 := transmute<NonNull<u8>, *mut u8>(copy (ptr@20))
            ptr@47 := *mut  (copy (data@48), copy (new_size@10))
            storage_dead(data@48)
            storage_live(@51)
            if copy (@36) {
                storage_live(@50)
                @50 := transmute<NonNull<u8>, *mut ()>(copy (ptr@20))
                @49 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@50))
                storage_dead(@50)
            } else {
            }
            @51 := cast<*mut Slice<u8>, *const Slice<u8>>(copy (ptr@47))
            @25 := NonNull { pointer: copy (@51) }
            storage_dead(@51)
            storage_dead(ptr@47)
            @0 := Result::Ok { 0: move (@25) }
            storage_dead(@25)
            return
        },
    }
    @0 := alloc_impl<'_>(move (self@1), move (new_layout@4), move (zeroed@5))
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::allocate
pub fn {impl Allocator for Global}::allocate<'_0>(@1: &'_0 (Global), @2: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Global); // arg #1
    let layout@2: Layout; // arg #2

    @0 := alloc_impl<'_>(move (self@1), move (layout@2), const (false))
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::allocate_zeroed
pub fn {impl Allocator for Global}::allocate_zeroed<'_0>(@1: &'_0 (Global), @2: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Global); // arg #1
    let layout@2: Layout; // arg #2

    @0 := alloc_impl<'_>(move (self@1), move (layout@2), const (true))
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::deallocate
pub unsafe fn {impl Allocator for Global}::deallocate<'_0>(@1: &'_0 (Global), @2: NonNull<u8>, @3: Layout)
{
    let @0: (); // return
    let self@1: &'_ (Global); // arg #1
    let ptr@2: NonNull<u8>; // arg #2
    let layout@3: Layout; // arg #3
    let @4: usize; // anonymous local
    let ptr@5: *mut u8; // local
    let @6: usize; // anonymous local
    let @7: AlignmentEnum; // anonymous local

    storage_live(@4)
    @0 := ()
    @4 := copy ((layout@3).size)
    switch move (@4) {
        0 : usize => {
        },
        _ => {
            storage_live(ptr@5)
            ptr@5 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
            storage_live(@6)
            storage_live(@7)
            @7 := copy (((layout@3).align).0)
            @6 := @discriminant(@7)
            storage_dead(@7)
            @0 := __rust_dealloc(move (ptr@5), move (@4), move (@6))
            storage_dead(@6)
            storage_dead(ptr@5)
            return
        },
    }
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::grow
pub unsafe fn {impl Allocator for Global}::grow<'_0>(@1: &'_0 (Global), @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Global); // arg #1
    let ptr@2: NonNull<u8>; // arg #2
    let old_layout@3: Layout; // arg #3
    let new_layout@4: Layout; // arg #4

    @0 := grow_impl<'_>(move (self@1), move (ptr@2), move (old_layout@3), move (new_layout@4), const (false))
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::grow_zeroed
pub unsafe fn {impl Allocator for Global}::grow_zeroed<'_0>(@1: &'_0 (Global), @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Global); // arg #1
    let ptr@2: NonNull<u8>; // arg #2
    let old_layout@3: Layout; // arg #3
    let new_layout@4: Layout; // arg #4

    @0 := grow_impl<'_>(move (self@1), move (ptr@2), move (old_layout@3), move (new_layout@4), const (true))
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::shrink
pub unsafe fn {impl Allocator for Global}::shrink<'_0>(@1: &'_0 (Global), @2: NonNull<u8>, @3: Layout, @4: Layout) -> Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]
{
    let @0: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // return
    let self@1: &'_ (Global); // arg #1
    let ptr@2: NonNull<u8>; // arg #2
    let old_layout@3: Layout; // arg #3
    let new_layout@4: Layout; // arg #4
    let new_size@5: usize; // local
    let @6: (); // anonymous local
    let @7: NonNull<Slice<u8>>; // anonymous local
    let data@8: NonNull<u8>; // local
    let @9: bool; // anonymous local
    let @10: usize; // anonymous local
    let @11: usize; // anonymous local
    let cond@12: bool; // local
    let @13: usize; // anonymous local
    let raw_ptr@14: *mut u8; // local
    let ptr@15: *mut u8; // local
    let self@16: NonNull<u8>; // local
    let new_size@17: usize; // local
    let @18: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<u8>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<u8>}]; // anonymous local
    let self@19: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // local
    let self@20: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // local
    let ptr@21: *mut u8; // local
    let ptr@22: NonNull<u8>; // local
    let @23: NonNull<Slice<u8>>; // anonymous local
    let @24: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<Slice<u8>>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<Slice<u8>>}]; // anonymous local
    let self@25: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // local
    let new_ptr@26: NonNull<Slice<u8>>; // local
    let src@27: *const u8; // local
    let ptr@28: *mut u8; // local
    let dst@29: *mut u8; // local
    let @30: (); // anonymous local
    let @31: AlignmentEnum; // anonymous local
    let @32: usize; // anonymous local
    let ptr@33: *mut u8; // local
    let @34: usize; // anonymous local
    let @35: AlignmentEnum; // anonymous local
    let @36: NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}]; // anonymous local
    let @37: Alignment; // anonymous local
    let @38: *const u8; // anonymous local
    let ptr@39: *mut Slice<u8>; // local
    let data@40: *mut u8; // local
    let @41: (); // anonymous local
    let @42: *mut (); // anonymous local
    let @43: *const Slice<u8>; // anonymous local
    let @44: bool; // anonymous local
    let @45: AlignmentEnum; // anonymous local
    let @46: (); // anonymous local
    let @47: bool; // anonymous local
    let @48: NonNull<u8>; // anonymous local
    let @49: *const u8; // anonymous local
    let @50: usize; // anonymous local
    let @51: (); // anonymous local
    let @52: *mut (); // anonymous local
    let v@53: NonNull<u8>; // local
    let v@54: NonNull<u8>; // local
    let ptr@55: *mut Slice<u8>; // local
    let data@56: *mut u8; // local
    let @57: (); // anonymous local
    let @58: *mut (); // anonymous local
    let @59: *const Slice<u8>; // anonymous local
    let v@60: NonNull<Slice<u8>>; // local
    let @61: *mut Slice<u8>; // anonymous local
    let @62: (); // anonymous local
    let @63: *const (); // anonymous local
    let @64: *mut (); // anonymous local
    let @65: bool; // anonymous local
    let @66: usize; // anonymous local
    let @67: AllocError; // anonymous local
    let @68: Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]; // anonymous local
    let @69: ControlFlow<Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}], NonNull<Slice<u8>>>[{built_in impl Sized for Result<Infallible, AllocError>[{built_in impl Sized for Infallible}, {built_in impl Sized for AllocError}]}, {built_in impl Sized for NonNull<Slice<u8>>}]; // anonymous local
    let @70: Option<NonNull<u8>>[{built_in impl Sized for NonNull<u8>}]; // anonymous local
    let @71: AllocError; // anonymous local
    let @72: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local
    let @73: AllocError; // anonymous local
    let @74: Result<NonNull<u8>, AllocError>[{built_in impl Sized for NonNull<u8>}, {built_in impl Sized for AllocError}]; // anonymous local
    let @75: AllocError; // anonymous local
    let @76: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local

    storage_live(new_size@5)
    storage_live(@6)
    storage_live(@10)
    storage_live(@13)
    storage_live(raw_ptr@14)
    storage_live(ptr@22)
    storage_live(new_ptr@26)
    storage_live(ptr@28)
    storage_live(@30)
    storage_live(@31)
    storage_live(@36)
    storage_live(@41)
    storage_live(@46)
    storage_live(@47)
    storage_live(@49)
    storage_live(@51)
    storage_live(@57)
    storage_live(@61)
    storage_live(@62)
    new_size@5 := copy ((new_layout@4).size)
    switch copy (new_size@5) {
        0 : usize => {
        },
        _ => {
            storage_live(@9)
            @31 := copy (((old_layout@3).align).0)
            @10 := @discriminant(@31)
            storage_live(@11)
            storage_live(@45)
            @45 := copy (((new_layout@4).align).0)
            @11 := @discriminant(@45)
            storage_dead(@45)
            @9 := copy (@10) == move (@11)
            if move (@9) {
                storage_dead(@11)
                storage_dead(@9)
                storage_live(cond@12)
                @13 := copy ((old_layout@3).size)
                cond@12 := copy (new_size@5) <= copy (@13)
                @47 := ub_checks<bool>
                if copy (@47) {
                    @46 := core::hint::assert_unchecked::precondition_check(copy (cond@12))
                    assert(copy (cond@12) == true)
                    storage_dead(cond@12)
                    storage_live(ptr@15)
                    storage_live(self@16)
                    self@16 := copy (ptr@2)
                    ptr@15 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
                    storage_dead(self@16)
                    storage_live(new_size@17)
                    new_size@17 := copy (new_size@5)
                    raw_ptr@14 := __rust_realloc(move (ptr@15), move (@13), move (@10), copy (new_size@5))
                    storage_dead(new_size@17)
                    storage_dead(ptr@15)
                    storage_live(@18)
                    storage_live(self@19)
                    storage_live(self@20)
                    storage_live(ptr@21)
                    ptr@21 := copy (raw_ptr@14)
                    @49 := cast<*mut u8, *const u8>(copy (raw_ptr@14))
                    storage_live(@50)
                    @50 := transmute<*mut u8, usize>(copy (raw_ptr@14))
                    switch move (@50) {
                        0 : usize => {
                            storage_dead(@50)
                            storage_live(@70)
                            @70 := Option::None {  }
                            self@20 := move (@70)
                        },
                        _ => {
                            storage_dead(@50)
                            storage_live(@48)
                            storage_live(@52)
                            @52 := cast<*mut u8, *mut ()>(copy (raw_ptr@14))
                            @51 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@52))
                            storage_dead(@52)
                            @48 := NonNull { pointer: copy (@49) }
                            self@20 := Option::Some { 0: move (@48) }
                            storage_dead(@48)
                        },
                    }
                } else {
                    assert(copy (cond@12) == true)
                    storage_dead(cond@12)
                    storage_live(ptr@15)
                    storage_live(self@16)
                    self@16 := copy (ptr@2)
                    ptr@15 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
                    storage_dead(self@16)
                    storage_live(new_size@17)
                    new_size@17 := copy (new_size@5)
                    raw_ptr@14 := __rust_realloc(move (ptr@15), move (@13), move (@10), copy (new_size@5))
                    storage_dead(new_size@17)
                    storage_dead(ptr@15)
                    storage_live(@18)
                    storage_live(self@19)
                    storage_live(self@20)
                    storage_live(ptr@21)
                    ptr@21 := copy (raw_ptr@14)
                    @49 := cast<*mut u8, *const u8>(copy (raw_ptr@14))
                    storage_live(@50)
                    @50 := transmute<*mut u8, usize>(copy (raw_ptr@14))
                    switch move (@50) {
                        0 : usize => {
                            storage_dead(@50)
                            storage_live(@70)
                            @70 := Option::None {  }
                            self@20 := move (@70)
                        },
                        _ => {
                            storage_dead(@50)
                            storage_live(@48)
                            if copy (@47) {
                                storage_live(@52)
                                @52 := cast<*mut u8, *mut ()>(copy (raw_ptr@14))
                                @51 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@52))
                                storage_dead(@52)
                            } else {
                            }
                            @48 := NonNull { pointer: copy (@49) }
                            self@20 := Option::Some { 0: move (@48) }
                            storage_dead(@48)
                        },
                    }
                }
                storage_dead(ptr@21)
                storage_live(v@53)
                match self@20 {
                    Option::None => {
                        storage_live(@73)
                        @73 := AllocError {  }
                        storage_live(@74)
                        @74 := Result::Err { 0: move (@73) }
                        self@19 := move (@74)
                        storage_dead(v@53)
                        storage_dead(self@20)
                        storage_live(v@54)
                        match self@19 {
                            Result::Ok => {
                                v@54 := move ((self@19 as variant Result::Ok).0)
                                @18 := ControlFlow::Continue { 0: copy (v@54) }
                                storage_dead(v@54)
                                storage_dead(self@19)
                                ptr@22 := copy ((@18 as variant ControlFlow::Continue).0)
                                storage_dead(@18)
                                storage_live(@23)
                                storage_live(ptr@55)
                                storage_live(data@56)
                                data@56 := transmute<NonNull<u8>, *mut u8>(copy (ptr@22))
                                ptr@55 := *mut  (copy (data@56), copy (new_size@5))
                                storage_dead(data@56)
                                storage_live(@59)
                                if copy (@47) {
                                    storage_live(@58)
                                    @58 := transmute<NonNull<u8>, *mut ()>(copy (ptr@22))
                                    @57 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@58))
                                    storage_dead(@58)
                                } else {
                                }
                                @59 := cast<*mut Slice<u8>, *const Slice<u8>>(copy (ptr@55))
                                @23 := NonNull { pointer: copy (@59) }
                                storage_dead(@59)
                                storage_dead(ptr@55)
                                @0 := Result::Ok { 0: move (@23) }
                                storage_dead(@23)
                                return
                            },
                            Result::Err => {
                                storage_dead(v@54)
                                storage_dead(self@19)
                                storage_live(@75)
                                @75 := AllocError {  }
                                storage_live(@76)
                                @76 := Result::Err { 0: move (@75) }
                                @0 := move (@76)
                                storage_dead(@18)
                                return
                            },
                        }
                    },
                    Option::Some => {
                        v@53 := move ((self@20 as variant Option::Some).0)
                        self@19 := Result::Ok { 0: copy (v@53) }
                        storage_dead(v@53)
                        storage_dead(self@20)
                        storage_live(v@54)
                        match self@19 {
                            Result::Ok => {
                                v@54 := move ((self@19 as variant Result::Ok).0)
                                @18 := ControlFlow::Continue { 0: copy (v@54) }
                                storage_dead(v@54)
                                storage_dead(self@19)
                                ptr@22 := copy ((@18 as variant ControlFlow::Continue).0)
                                storage_dead(@18)
                                storage_live(@23)
                                storage_live(ptr@55)
                                storage_live(data@56)
                                data@56 := transmute<NonNull<u8>, *mut u8>(copy (ptr@22))
                                ptr@55 := *mut  (copy (data@56), copy (new_size@5))
                                storage_dead(data@56)
                                storage_live(@59)
                                if copy (@47) {
                                    storage_live(@58)
                                    @58 := transmute<NonNull<u8>, *mut ()>(copy (ptr@22))
                                    @57 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@58))
                                    storage_dead(@58)
                                } else {
                                }
                                @59 := cast<*mut Slice<u8>, *const Slice<u8>>(copy (ptr@55))
                                @23 := NonNull { pointer: copy (@59) }
                                storage_dead(@59)
                                storage_dead(ptr@55)
                                @0 := Result::Ok { 0: move (@23) }
                                storage_dead(@23)
                                return
                            },
                            Result::Err => {
                                storage_dead(v@54)
                                storage_dead(self@19)
                                storage_live(@75)
                                @75 := AllocError {  }
                                storage_live(@76)
                                @76 := Result::Err { 0: move (@75) }
                                @0 := move (@76)
                                storage_dead(@18)
                                return
                            },
                        }
                    },
                }
            } else {
                storage_dead(@11)
                storage_dead(@9)
                storage_live(@24)
                storage_live(self@25)
                self@25 := alloc_impl<'_>(move (self@1), move (new_layout@4), const (false))
                storage_live(v@60)
                match self@25 {
                    Result::Ok => {
                        v@60 := move ((self@25 as variant Result::Ok).0)
                        @24 := ControlFlow::Continue { 0: copy (v@60) }
                        storage_dead(v@60)
                        storage_dead(self@25)
                        match @24 {
                            ControlFlow::Continue => {
                                new_ptr@26 := copy ((@24 as variant ControlFlow::Continue).0)
                                storage_dead(@24)
                                storage_live(src@27)
                                ptr@28 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
                                src@27 := transmute<NonNull<u8>, *const u8>(copy (ptr@2))
                                storage_live(dst@29)
                                @61 := transmute<NonNull<Slice<u8>>, *mut Slice<u8>>(copy (new_ptr@26))
                                dst@29 := cast<*mut Slice<u8>, *mut u8>(copy (@61))
                                storage_live(@65)
                                @65 := ub_checks<bool>
                                if copy (@65) {
                                    storage_live(@63)
                                    @63 := transmute<NonNull<u8>, *const ()>(copy (ptr@2))
                                    storage_live(@64)
                                    @64 := cast<*mut Slice<u8>, *mut ()>(copy (@61))
                                    @62 := core::ptr::copy_nonoverlapping::precondition_check(move (@63), move (@64), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), copy (new_size@5))
                                    storage_dead(@64)
                                    storage_dead(@63)
                                } else {
                                }
                                copy_nonoverlapping(copy (src@27), copy (dst@29), copy (new_size@5))
                                storage_dead(@65)
                                storage_dead(dst@29)
                                storage_dead(src@27)
                                storage_live(@66)
                                @66 := copy ((old_layout@3).size)
                                switch move (@66) {
                                    0 : usize => {
                                    },
                                    _ => {
                                        @30 := __rust_dealloc(move (ptr@28), move (@66), move (@10))
                                    },
                                }
                                storage_dead(@66)
                                @0 := Result::Ok { 0: copy (new_ptr@26) }
                                return
                            },
                            ControlFlow::Break => {
                                storage_live(@71)
                                @71 := AllocError {  }
                                storage_live(@72)
                                @72 := Result::Err { 0: move (@71) }
                                @0 := move (@72)
                                storage_dead(@24)
                                return
                            },
                        }
                    },
                    Result::Err => {
                        storage_live(@67)
                        @67 := AllocError {  }
                        storage_live(@68)
                        @68 := Result::Err { 0: move (@67) }
                        storage_live(@69)
                        @69 := ControlFlow::Break { 0: move (@68) }
                        @24 := move (@69)
                        storage_dead(v@60)
                        storage_dead(self@25)
                        match @24 {
                            ControlFlow::Continue => {
                                new_ptr@26 := copy ((@24 as variant ControlFlow::Continue).0)
                                storage_dead(@24)
                                storage_live(src@27)
                                ptr@28 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
                                src@27 := transmute<NonNull<u8>, *const u8>(copy (ptr@2))
                                storage_live(dst@29)
                                @61 := transmute<NonNull<Slice<u8>>, *mut Slice<u8>>(copy (new_ptr@26))
                                dst@29 := cast<*mut Slice<u8>, *mut u8>(copy (@61))
                                storage_live(@65)
                                @65 := ub_checks<bool>
                                if copy (@65) {
                                    storage_live(@63)
                                    @63 := transmute<NonNull<u8>, *const ()>(copy (ptr@2))
                                    storage_live(@64)
                                    @64 := cast<*mut Slice<u8>, *mut ()>(copy (@61))
                                    @62 := core::ptr::copy_nonoverlapping::precondition_check(move (@63), move (@64), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::SIZE), const ({impl SizedTypeProperties for T}<u8>[{built_in impl Sized for u8}]::ALIGN), copy (new_size@5))
                                    storage_dead(@64)
                                    storage_dead(@63)
                                } else {
                                }
                                copy_nonoverlapping(copy (src@27), copy (dst@29), copy (new_size@5))
                                storage_dead(@65)
                                storage_dead(dst@29)
                                storage_dead(src@27)
                                storage_live(@66)
                                @66 := copy ((old_layout@3).size)
                                switch move (@66) {
                                    0 : usize => {
                                    },
                                    _ => {
                                        @30 := __rust_dealloc(move (ptr@28), move (@66), move (@10))
                                    },
                                }
                                storage_dead(@66)
                                @0 := Result::Ok { 0: copy (new_ptr@26) }
                                return
                            },
                            ControlFlow::Break => {
                                storage_live(@71)
                                @71 := AllocError {  }
                                storage_live(@72)
                                @72 := Result::Err { 0: move (@71) }
                                @0 := move (@72)
                                storage_dead(@24)
                                return
                            },
                        }
                    },
                }
            }
            undefined_behavior
        },
    }
    storage_live(@32)
    @32 := copy ((old_layout@3).size)
    switch move (@32) {
        0 : usize => {
        },
        _ => {
            storage_live(ptr@33)
            ptr@33 := transmute<NonNull<u8>, *mut u8>(copy (ptr@2))
            storage_live(@34)
            storage_live(@35)
            @35 := copy (((old_layout@3).align).0)
            @34 := @discriminant(@35)
            storage_dead(@35)
            @6 := __rust_dealloc(move (ptr@33), move (@32), move (@34))
            storage_dead(@34)
            storage_dead(ptr@33)
        },
    }
    storage_dead(@32)
    storage_live(@7)
    storage_live(data@8)
    storage_live(@37)
    @37 := copy ((new_layout@4).align)
    @36 := transmute<Alignment, NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}]>(copy (@37))
    storage_dead(@37)
    storage_live(@38)
    @38 := transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *const u8>(copy (@36))
    data@8 := NonNull { pointer: copy (@38) }
    storage_dead(@38)
    storage_live(ptr@39)
    storage_live(data@40)
    data@40 := transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *mut u8>(copy (@36))
    ptr@39 := *mut  (copy (data@40), const (0 : usize))
    storage_dead(data@40)
    storage_live(@43)
    storage_live(@44)
    @44 := ub_checks<bool>
    if copy (@44) {
        storage_live(@42)
        @42 := transmute<NonZero<usize>[{built_in impl Sized for usize}, {impl ZeroablePrimitive for usize}], *mut ()>(copy (@36))
        @41 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@42))
        storage_dead(@42)
    } else {
    }
    @43 := cast<*mut Slice<u8>, *const Slice<u8>>(copy (ptr@39))
    @7 := NonNull { pointer: copy (@43) }
    storage_dead(@44)
    storage_dead(@43)
    storage_dead(ptr@39)
    storage_dead(data@8)
    @0 := Result::Ok { 0: move (@7) }
    storage_dead(@7)
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}::by_ref
pub fn {impl Allocator for Global}::by_ref<'_0>(@1: &'_0 (Global)) -> &'_0 (Global)
where
    [@TraitClause0]: Sized<Global>,
{
    let @0: &'_ (Global); // return
    let self@1: &'_ (Global); // arg #1

    @0 := copy (self@1)
    return
}

// Full name: alloc::alloc::{impl Allocator for Global}
impl Allocator for Global {
    parent_clause0 = {built_in impl MetaSized for Global}
    fn allocate<'_0_1> = {impl Allocator for Global}::allocate<'_0_1>
    fn allocate_zeroed<'_0_1> = {impl Allocator for Global}::allocate_zeroed<'_0_1>
    fn deallocate<'_0_1> = {impl Allocator for Global}::deallocate<'_0_1>
    fn grow<'_0_1> = {impl Allocator for Global}::grow<'_0_1>
    fn grow_zeroed<'_0_1> = {impl Allocator for Global}::grow_zeroed<'_0_1>
    fn shrink<'_0_1> = {impl Allocator for Global}::shrink<'_0_1>
    fn by_ref<'_0_1, [@TraitClause0_1]: Sized<Global>> = {impl Allocator for Global}::by_ref<'_0_1>[@TraitClause0_1]
    vtable: {impl Allocator for Global}::{vtable}
}

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: alloc::alloc::handle_alloc_error::ct_error
fn ct_error(@1: Layout) -> !
{
    let @0: !; // return
    let @1: Layout; // arg #1
    let @2: Arguments<'_>; // anonymous local

    storage_live(@2)
    @2 := from_str<'_>(const ("allocation failed"))
    panic(core::panicking::panic_fmt)
}

// Full name: alloc::alloc::handle_alloc_error
pub fn handle_alloc_error(@1: Layout) -> !
{
    let @0: !; // return
    let layout@1: Layout; // arg #1
    let @2: (Layout); // anonymous local
    let @3: Layout; // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := copy (layout@1)
    @2 := (move (@3))
    storage_dead(@3)
    @0 := ct_error(move ((@2).0))
}

// Full name: alloc::alloc::exchange_malloc
#[lang_item("exchange_malloc")]
unsafe fn exchange_malloc(@1: usize, @2: usize) -> *mut u8
{
    let @0: *mut u8; // return
    let size@1: usize; // arg #1
    let align@2: usize; // arg #2
    let layout@3: Layout; // local
    let @4: Result<NonNull<Slice<u8>>, AllocError>[{built_in impl Sized for NonNull<Slice<u8>>}, {built_in impl Sized for AllocError}]; // anonymous local
    let ptr@5: NonNull<Slice<u8>>; // local
    let @6: !; // anonymous local
    let @7: bool; // anonymous local
    let @8: (); // anonymous local
    let @9: Alignment; // anonymous local
    let @10: *mut Slice<u8>; // anonymous local
    let @11: &'_ (Global); // anonymous local
    let @12: Global; // anonymous local

    storage_live(layout@3)
    storage_live(ptr@5)
    storage_live(@6)
    storage_live(@8)
    storage_live(@7)
    @7 := ub_checks<bool>
    if move (@7) {
        @8 := core::alloc::layout::{Layout}::from_size_align_unchecked::precondition_check(copy (size@1), copy (align@2))
    } else {
    }
    storage_live(@11)
    storage_live(@12)
    @12 := Global {  }
    @11 := &@12
    storage_dead(@7)
    storage_live(@9)
    @9 := transmute<usize, Alignment>(copy (align@2))
    layout@3 := Layout { size: copy (size@1), align: move (@9) }
    storage_dead(@9)
    storage_live(@4)
    @4 := alloc_impl<'_>(move (@11), copy (layout@3), const (false))
    match @4 {
        Result::Ok => {
        },
        Result::Err => {
            @6 := handle_alloc_error(move (layout@3))
        },
    }
    ptr@5 := copy ((@4 as variant Result::Ok).0)
    storage_live(@10)
    @10 := transmute<NonNull<Slice<u8>>, *mut Slice<u8>>(copy (ptr@5))
    @0 := cast<*mut Slice<u8>, *mut u8>(copy (@10))
    storage_dead(@10)
    storage_dead(@4)
    return
}

// Full name: alloc::boxed::Box
#[lang_item("owned_box")]
pub struct Box<T, A>
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
    [@TraitClause2]: Allocator<A>,
{
  Unique<T>,
  A,
}

// Full name: alloc::boxed::Box::{impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}::drop_in_place
fn {impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}::drop_in_place<T, A>(@1: *mut Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2])
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
    [@TraitClause2]: Allocator<A>,
= <missing>

// Full name: alloc::boxed::Box::{impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}
impl<T, A> Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
    [@TraitClause2]: Allocator<A>,
{
    fn drop_in_place = {impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}::drop_in_place<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]
    non-dyn-compatible
}

#[lang_item("box_new")]
pub fn alloc::boxed::{Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::new<T>(@1: T) -> Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]
where
    [@TraitClause0]: Sized<T>,
{
    let @0: Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]; // return
    let x@1: T; // arg #1
    let @2: *mut u8; // anonymous local
    let @3: *const T; // anonymous local
    let @4: NonNull<T>; // anonymous local
    let @5: Unique<T>; // anonymous local
    let @6: PhantomData<T>; // anonymous local
    let @7: Global; // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @2 := exchange_malloc(const ({impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE), const ({impl SizedTypeProperties for T}<T>[@TraitClause0]::ALIGN))
    @3 := cast<*mut u8, *const T>(copy (@2))
    @4 := NonNull { pointer: copy (@3) }
    storage_live(@6)
    @6 := PhantomData {  }
    @5 := Unique { pointer: copy (@4), _marker: move (@6) }
    storage_live(@7)
    @7 := Global {  }
    @0 := Box { 0: move (@5), 1: move (@7) }
    *(@3) := move (x@1)
    return
}

// Full name: alloc::boxed::{Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::from_raw
pub unsafe fn from_raw<T>(@1: *mut T) -> Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]
where
    [@TraitClause0]: MetaSized<T>,
{
    let @0: Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]; // return
    let raw@1: *mut T; // arg #1
    let @2: Unique<T>; // anonymous local
    let @3: NonNull<T>; // anonymous local
    let @4: (); // anonymous local
    let @5: *mut (); // anonymous local
    let @6: *const T; // anonymous local
    let @7: bool; // anonymous local
    let @8: PhantomData<T>; // anonymous local
    let @9: Global; // anonymous local

    storage_live(@4)
    storage_live(@2)
    storage_live(@3)
    storage_live(@6)
    storage_live(@7)
    @7 := ub_checks<bool>
    if copy (@7) {
        storage_live(@5)
        @5 := cast<*mut T, *mut ()>(copy (raw@1))
        @4 := core::ptr::non_null::{NonNull<T>}::new_unchecked::precondition_check(move (@5))
        storage_dead(@5)
    } else {
    }
    @6 := cast<*mut T, *const T>(copy (raw@1))
    @3 := NonNull { pointer: copy (@6) }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@8)
    @8 := PhantomData {  }
    @2 := Unique { pointer: move (@3), _marker: move (@8) }
    storage_dead(@3)
    storage_live(@9)
    @9 := Global {  }
    @0 := Box { 0: move (@2), 1: move (@9) }
    storage_dead(@2)
    return
}

// Full name: alloc::boxed::{Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::into_raw
pub fn into_raw<T>(@1: Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]) -> *mut T
where
    [@TraitClause0]: MetaSized<T>,
{
    let @0: *mut T; // return
    let b@1: Box<T, Global>[@TraitClause0, {built_in impl Sized for Global}, {impl Allocator for Global}]; // arg #1
    let @2: *const T; // anonymous local
    let @3: NonNull<T>; // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := copy (((b@1).0).pointer)
    @2 := transmute<NonNull<T>, *const T>(copy (@3))
    @0 := &raw mut *(@2) with_metadata(copy (@2.metadata))
    return
}

// Full name: alloc::boxed::{Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}::leak
pub fn leak<'a, T, A>(@1: Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]) -> &'a mut (T)
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
    [@TraitClause2]: Allocator<A>,
    A : 'a,
{
    let @0: &'_ mut (T); // return
    let b@1: Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]; // arg #1
    let @2: *mut T; // anonymous local
    let @3: *const T; // anonymous local
    let @4: NonNull<T>; // anonymous local

    storage_live(@2)
    storage_live(@4)
    @4 := move (((b@1).0).pointer)
    storage_live(@3)
    @3 := transmute<NonNull<T>, *const T>(copy (@4))
    @2 := &raw mut *(@3) with_metadata(copy (@3.metadata))
    storage_dead(@3)
    @0 := &mut *(@2) with_metadata(copy (@2.metadata))
    return
}

// Full name: test_crate::foo
unsafe fn foo()
{
    let @0: (); // return
    let b@1: Box<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]; // local
    let p@2: *mut i32; // local
    let @3: Box<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]; // anonymous local
    let @4: &'_ mut (i32); // anonymous local
    let @5: Box<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]; // anonymous local
    let b@6: Box<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]; // local
    let @7: *mut i32; // anonymous local
    let i@8: i32; // local
    let @9: *const i32; // anonymous local

    storage_live(@9)
    @0 := ()
    storage_live(b@1)
    b@1 := alloc::boxed::{Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::new<i32>[{built_in impl Sized for i32}](const (42 : i32))
    storage_live(p@2)
    storage_live(@3)
    @3 := move (b@1)
    p@2 := into_raw<i32>[{built_in impl MetaSized for i32}](move (@3))
    storage_dead(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := alloc::boxed::{Box<T, Global>[@TraitClause0::parent_clause0, {built_in impl Sized for Global}, {impl Allocator for Global}]}::new<i32>[{built_in impl Sized for i32}](const (42 : i32))
    @4 := leak<'_, i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}](move (@5))
    storage_dead(@5)
    storage_dead(@4)
    storage_live(b@6)
    storage_live(@7)
    @7 := copy (p@2)
    b@6 := from_raw<i32>[{built_in impl MetaSized for i32}](move (@7))
    storage_dead(@7)
    storage_live(i@8)
    @9 := transmute<NonNull<i32>, *const i32>(copy (((b@6).0).pointer))
    i@8 := copy (*(@9))
    @0 := ()
    storage_dead(i@8)
    drop[{impl Destruct for Box<T, A>[@TraitClause0, @TraitClause1, @TraitClause2]}<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}, {impl Allocator for Global}]] b@6
    storage_dead(b@6)
    storage_dead(p@2)
    storage_dead(b@1)
    return
}



