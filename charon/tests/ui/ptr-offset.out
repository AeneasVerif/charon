# Final LLBC before serialization:

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub opaque type Layout

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub opaque type Argument<'a>

// Full name: core::intrinsics::cold_path
pub fn cold_path()
= <opaque>

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
= <opaque>

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub opaque type NonNull<T>

// Full name: core::ptr::const_ptr::{*const T}::offset::precondition_check
fn precondition_check(@1: *const (), @2: isize, @3: usize)
{
    let @0: (); // return
    let this@1: *const (); // arg #1
    let count@2: isize; // arg #2
    let size@3: usize; // arg #3
    let @4: bool; // anonymous local
    let msg@5: &'0 (Str); // local
    let @6: !; // anonymous local
    let @7: Arguments<'1>; // anonymous local
    let rhs@8: isize; // local
    let self@9: usize; // local
    let @10: i64; // anonymous local
    let b@11: bool; // local
    let @12: (i64, bool); // anonymous local
    let @13: i64; // anonymous local
    let @14: i64; // anonymous local
    let byte_offset@15: isize; // local
    let @16: (); // anonymous local
    let @17: usize; // anonymous local
    let overflow@18: bool; // local
    let @19: bool; // anonymous local
    let @20: bool; // anonymous local
    let @21: (u64, bool); // anonymous local
    let @22: u64; // anonymous local
    let @23: u64; // anonymous local
    let @24: NonNull<u8>; // anonymous local
    let @25: *const u8; // anonymous local
    let @26: NonNull<Argument<'2>>; // anonymous local
    let @27: usize; // anonymous local
    let @28: usize; // anonymous local
    let @29: usize; // anonymous local
    let @30: *const Str; // anonymous local
    let @31: &'3 (Slice<u8>); // anonymous local

    storage_live(msg@5)
    storage_live(@6)
    storage_live(byte_offset@15)
    storage_live(@16)
    @0 := ()
    storage_live(@4)
    storage_live(overflow@18)
    storage_live(rhs@8)
    rhs@8 := cast<usize, isize>(copy (size@3))
    storage_live(b@11)
    storage_live(@10)
    storage_live(@12)
    storage_live(@13)
    @13 := cast<isize, i64>(copy (count@2))
    storage_live(@14)
    @14 := cast<isize, i64>(copy (rhs@8))
    @12 := move (@13) checked.* move (@14)
    storage_dead(@14)
    storage_dead(@13)
    @10 := copy ((@12).0)
    b@11 := copy ((@12).1)
    storage_dead(@12)
    byte_offset@15 := cast<i64, isize>(copy (@10))
    storage_dead(@10)
    if copy (b@11) {
        @16 := cold_path()
        storage_dead(b@11)
        storage_dead(rhs@8)
        storage_dead(overflow@18)
    } else {
        storage_dead(b@11)
        storage_dead(rhs@8)
        storage_live(self@9)
        self@9 := transmute<*const (), usize>(copy (this@1))
        storage_live(@20)
        storage_live(@17)
        @17 := cast<isize, usize>(copy (byte_offset@15))
        storage_live(@21)
        storage_live(@22)
        @22 := cast<usize, u64>(copy (self@9))
        storage_live(@23)
        @23 := cast<usize, u64>(copy (@17))
        @21 := move (@22) checked.+ move (@23)
        storage_dead(@23)
        storage_dead(@22)
        @20 := copy ((@21).1)
        storage_dead(@21)
        storage_dead(@17)
        storage_live(@19)
        @19 := copy (byte_offset@15) < const (0 : isize)
        overflow@18 := copy (@20) ^ move (@19)
        storage_dead(@19)
        storage_dead(@20)
        storage_dead(self@9)
        @4 := ~(copy (overflow@18))
        storage_dead(overflow@18)
        if move (@4) {
            storage_dead(@4)
            return
        } else {
        }
    }
    msg@5 := const ("unsafe precondition(s) violated: ptr::offset requires the address calculation to not overflow\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    storage_live(@7)
    storage_live(@24)
    storage_live(@25)
    storage_live(@30)
    @30 := &raw const *(msg@5) with_metadata(copy (msg@5.metadata))
    @25 := cast<*const Str, *const u8>(copy (@30))
    storage_dead(@30)
    @24 := transmute<*const u8, NonNull<u8>>(copy (@25))
    storage_dead(@25)
    storage_live(@26)
    storage_live(@27)
    storage_live(@28)
    storage_live(@29)
    storage_live(@31)
    @31 := transmute<&'0 (Str), &'3 (Slice<u8>)>(const ("unsafe precondition(s) violated: ptr::offset requires the address calculation to not overflow\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
    @29 := copy (@31.metadata)
    storage_dead(@31)
    @28 := move (@29) wrap.<< const (1 : i32)
    storage_dead(@29)
    @27 := move (@28) | const (1 : usize)
    storage_dead(@28)
    @26 := transmute<usize, NonNull<Argument<'2>>>(move (@27))
    storage_dead(@27)
    @7 := Arguments { 0: move (@24), 1: move (@26) }
    storage_dead(@26)
    storage_dead(@24)
    @6 := panic_nounwind_fmt<'_>(move (@7), const (false))
}

// Full name: core::ptr::const_ptr::{*const T}::offset
pub unsafe fn offset<T>(@1: *const T, @2: isize) -> *const T
where
    [@TraitClause0]: Sized<T>,
{
    let @0: *const T; // return
    let self@1: *const T; // arg #1
    let count@2: isize; // arg #2
    let @3: (); // anonymous local
    let @4: *const (); // anonymous local
    let @5: bool; // anonymous local

    storage_live(@3)
    storage_live(@5)
    @5 := ub_checks<bool>
    if copy (@5) {
        storage_live(@4)
        @4 := cast<*const T, *const ()>(copy (self@1))
        @3 := precondition_check(move (@4), copy (count@2), const ({impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE))
        storage_dead(@4)
    } else {
    }
    @0 := copy (self@1) offset copy (count@2)
    return
}

// Full name: core::slice::{Slice<T>}::as_ptr
pub fn as_ptr<'_0, T>(@1: &'_0 (Slice<T>)) -> *const T
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let s@1: Array<i32, 2 : usize>; // local
    let ptr@2: *const i32; // local
    let @3: &'0 (Slice<i32>); // anonymous local
    let @4: &'1 (Array<i32, 2 : usize>); // anonymous local
    let @5: bool; // anonymous local
    let @6: i32; // anonymous local
    let @7: *const i32; // anonymous local
    let @8: *const i32; // anonymous local

    @0 := ()
    storage_live(s@1)
    s@1 := [const (11 : i32), const (42 : i32)]
    storage_live(ptr@2)
    storage_live(@3)
    storage_live(@4)
    @4 := &s@1
    @3 := @ArrayToSliceShared<'_, i32, 2 : usize>(move (@4))
    storage_dead(@4)
    ptr@2 := as_ptr<'_, i32>[{built_in impl Sized for i32}](move (@3))
    storage_dead(@3)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (ptr@2)
    @7 := offset<i32>[{built_in impl Sized for i32}](move (@8), const (1 : isize))
    storage_dead(@8)
    @6 := copy (*(@7))
    @5 := move (@6) == const (42 : i32)
    if move (@5) {
    } else {
        storage_dead(@6)
        storage_dead(@7)
        panic(core::panicking::panic)
    }
    storage_dead(@6)
    storage_dead(@7)
    storage_dead(@5)
    @0 := ()
    storage_dead(ptr@2)
    storage_dead(s@1)
    return
}



