# Final LLBC before serialization:

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub opaque type Layout

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>
where
    'a : 'a,

// Full name: core::fmt::rt::Count
#[lang_item("format_count")]
pub enum Count {
  Is(u16),
  Param(usize),
  Implied,
}

// Full name: core::fmt::rt::Placeholder
#[lang_item("format_placeholder")]
pub struct Placeholder {
  position: usize,
  flags: u32,
  precision: Count,
  width: Count,
}

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub opaque type Argument<'a>

// Full name: core::intrinsics::cold_path
pub fn cold_path()
= <opaque>

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
= <opaque>

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: core::ptr::const_ptr::{*const T}::offset::precondition_check
fn precondition_check(@1: *const (), @2: isize, @3: usize)
{
    let @0: (); // return
    let this@1: *const (); // arg #1
    let count@2: isize; // arg #2
    let size@3: usize; // arg #3
    let @4: bool; // anonymous local
    let @5: !; // anonymous local
    let @6: Arguments<'_>; // anonymous local
    let pieces@7: &'_ (Array<&'_ (Str), 1 : usize>); // local
    let @8: Array<&'_ (Str), 1 : usize>; // anonymous local
    let rhs@9: isize; // local
    let self@10: usize; // local
    let @11: i64; // anonymous local
    let b@12: bool; // local
    let @13: (i64, bool); // anonymous local
    let @14: i64; // anonymous local
    let @15: i64; // anonymous local
    let byte_offset@16: isize; // local
    let @17: (); // anonymous local
    let @18: usize; // anonymous local
    let overflow@19: bool; // local
    let @20: bool; // anonymous local
    let @21: bool; // anonymous local
    let @22: (u64, bool); // anonymous local
    let @23: u64; // anonymous local
    let @24: u64; // anonymous local
    let @25: &'_ (Slice<&'_ (Str)>); // anonymous local
    let @26: &'_ (Slice<Argument<'_>>); // anonymous local
    let @27: Option<&'_ (Slice<Placeholder>)>[{built_in impl Sized for &'_ (Slice<Placeholder>)}]; // anonymous local

    loop {
        storage_live(@5)
        storage_live(pieces@7)
        storage_live(byte_offset@16)
        storage_live(@17)
        @0 := ()
        storage_live(@4)
        storage_live(overflow@19)
        storage_live(rhs@9)
        rhs@9 := cast<usize, isize>(copy (size@3))
        storage_live(b@12)
        storage_live(@11)
        storage_live(@13)
        storage_live(@14)
        @14 := cast<isize, i64>(copy (count@2))
        storage_live(@15)
        @15 := cast<isize, i64>(copy (rhs@9))
        @13 := move (@14) checked.* move (@15)
        storage_dead(@15)
        storage_dead(@14)
        @11 := copy ((@13).0)
        b@12 := copy ((@13).1)
        storage_dead(@13)
        byte_offset@16 := cast<i64, isize>(copy (@11))
        storage_dead(@11)
        if copy (b@12) {
            @17 := cold_path()
            storage_dead(b@12)
            storage_dead(rhs@9)
            storage_dead(overflow@19)
            break 0
        }
        else {
            storage_dead(b@12)
            storage_dead(rhs@9)
            storage_live(self@10)
            self@10 := transmute<*const (), usize>(copy (this@1))
            storage_live(@21)
            storage_live(@18)
            @18 := cast<isize, usize>(copy (byte_offset@16))
            storage_live(@22)
            storage_live(@23)
            @23 := cast<usize, u64>(copy (self@10))
            storage_live(@24)
            @24 := cast<usize, u64>(copy (@18))
            @22 := move (@23) checked.+ move (@24)
            storage_dead(@24)
            storage_dead(@23)
            @21 := copy ((@22).1)
            storage_dead(@22)
            storage_dead(@18)
            storage_live(@20)
            @20 := copy (byte_offset@16) < const (0 : isize)
            overflow@19 := copy (@21) ^ move (@20)
            storage_dead(@20)
            storage_dead(@21)
            storage_dead(self@10)
            @4 := ~(copy (overflow@19))
            storage_dead(overflow@19)
            if move (@4) {
                storage_dead(@4)
                return
            }
            else {
                break 0
            }
        }
    }
    storage_live(@6)
    storage_live(@8)
    @8 := [const ("unsafe precondition(s) violated: ptr::offset requires the address calculation to not overflow\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")]
    pieces@7 := &@8
    storage_live(@25)
    @25 := @ArrayToSliceShared<'_, &'_ (Str), 1 : usize>(copy (pieces@7))
    storage_live(@26)
    @26 := @ArrayToSliceShared<'_, Argument<'_>, 0 : usize>(copy ({promoted_const}<'_, 1 : usize>))
    storage_live(@27)
    @27 := Option::None {  }
    @6 := Arguments { 0: copy (@25), 1: move (@27), 2: copy (@26) }
    storage_dead(@26)
    storage_dead(@25)
    @5 := panic_nounwind_fmt<'_>(move (@6), const (false))
}

// Full name: core::ptr::const_ptr::{*const T}::offset
pub unsafe fn offset<T>(@1: *const T, @2: isize) -> *const T
where
    [@TraitClause0]: Sized<T>,
{
    let @0: *const T; // return
    let self@1: *const T; // arg #1
    let count@2: isize; // arg #2
    let @3: (); // anonymous local
    let @4: *const (); // anonymous local
    let @5: bool; // anonymous local

    loop {
        storage_live(@3)
        storage_live(@5)
        @5 := ub_checks<bool>
        if copy (@5) {
            storage_live(@4)
            @4 := cast<*const T, *const ()>(copy (self@1))
            @3 := precondition_check(move (@4), copy (count@2), const ({impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE))
            storage_dead(@4)
            break 0
        }
        else {
            break 0
        }
    }
    @0 := copy (self@1) offset copy (count@2)
    return
}

// Full name: core::slice::{Slice<T>}::as_ptr
pub fn as_ptr<'_0, T>(@1: &'_0 (Slice<T>)) -> *const T
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let s@1: Array<i32, 2 : usize>; // local
    let ptr@2: *const i32; // local
    let @3: &'_ (Slice<i32>); // anonymous local
    let @4: &'_ (Array<i32, 2 : usize>); // anonymous local
    let @5: bool; // anonymous local
    let @6: i32; // anonymous local
    let @7: *const i32; // anonymous local
    let @8: *const i32; // anonymous local

    @0 := ()
    storage_live(s@1)
    s@1 := [const (11 : i32), const (42 : i32)]
    storage_live(ptr@2)
    storage_live(@3)
    storage_live(@4)
    @4 := &s@1
    @3 := @ArrayToSliceShared<'_, i32, 2 : usize>(move (@4))
    storage_dead(@4)
    ptr@2 := as_ptr<'_, i32>[{built_in impl Sized for i32}](move (@3))
    storage_dead(@3)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (ptr@2)
    @7 := offset<i32>[{built_in impl Sized for i32}](move (@8), const (1 : isize))
    storage_dead(@8)
    @6 := copy (*(@7))
    @5 := move (@6) == const (42 : i32)
    if move (@5) {
        storage_dead(@6)
        storage_dead(@7)
        storage_dead(@5)
        @0 := ()
        storage_dead(ptr@2)
        storage_dead(s@1)
        return
    }
    else {
        storage_dead(@6)
        storage_dead(@7)
        panic(core::panicking::panic)
    }
}



