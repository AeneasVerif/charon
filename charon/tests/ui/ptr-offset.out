# Final LLBC before serialization:

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub opaque type Layout

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub opaque type Argument<'a>

// Full name: core::intrinsics::cold_path
pub fn cold_path()
= <opaque>

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
= <opaque>

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
= <opaque>

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub opaque type NonNull<T>

// Full name: core::ptr::const_ptr::{*const T}::offset::precondition_check
fn precondition_check(@1: *const (), @2: isize, @3: usize)
{
    let _0: (); // return
    let this_1: *const (); // arg #1
    let count_2: isize; // arg #2
    let size_3: usize; // arg #3
    let _4: bool; // anonymous local
    let msg_5: &'0 Str; // local
    let _6: !; // anonymous local
    let _7: Arguments<'1>; // anonymous local
    let rhs_8: isize; // local
    let self_9: usize; // local
    let _10: i64; // anonymous local
    let b_11: bool; // local
    let _12: (i64, bool); // anonymous local
    let _13: i64; // anonymous local
    let _14: i64; // anonymous local
    let byte_offset_15: isize; // local
    let _16: (); // anonymous local
    let _17: usize; // anonymous local
    let overflow_18: bool; // local
    let _19: bool; // anonymous local
    let _20: bool; // anonymous local
    let _21: (u64, bool); // anonymous local
    let _22: u64; // anonymous local
    let _23: u64; // anonymous local
    let _24: NonNull<u8>; // anonymous local
    let _25: *const u8; // anonymous local
    let _26: NonNull<Argument<'2>>; // anonymous local
    let _27: usize; // anonymous local
    let _28: usize; // anonymous local
    let _29: usize; // anonymous local
    let _30: *const Str; // anonymous local
    let _31: &'3 [u8]; // anonymous local

    storage_live(msg_5)
    storage_live(_6)
    storage_live(byte_offset_15)
    storage_live(_16)
    _0 = ()
    storage_live(_4)
    storage_live(overflow_18)
    storage_live(rhs_8)
    rhs_8 = cast<usize, isize>(copy size_3)
    storage_live(b_11)
    storage_live(_10)
    storage_live(_12)
    storage_live(_13)
    _13 = cast<isize, i64>(copy count_2)
    storage_live(_14)
    _14 = cast<isize, i64>(copy rhs_8)
    _12 = move _13 checked.* move _14
    storage_dead(_14)
    storage_dead(_13)
    _10 = copy _12.0
    b_11 = copy _12.1
    storage_dead(_12)
    byte_offset_15 = cast<i64, isize>(copy _10)
    storage_dead(_10)
    if copy b_11 {
        _16 = cold_path()
        storage_dead(b_11)
        storage_dead(rhs_8)
        storage_dead(overflow_18)
    } else {
        storage_dead(b_11)
        storage_dead(rhs_8)
        storage_live(self_9)
        self_9 = transmute<*const (), usize>(copy this_1)
        storage_live(_20)
        storage_live(_17)
        _17 = cast<isize, usize>(copy byte_offset_15)
        storage_live(_21)
        storage_live(_22)
        _22 = cast<usize, u64>(copy self_9)
        storage_live(_23)
        _23 = cast<usize, u64>(copy _17)
        _21 = move _22 checked.+ move _23
        storage_dead(_23)
        storage_dead(_22)
        _20 = copy _21.1
        storage_dead(_21)
        storage_dead(_17)
        storage_live(_19)
        _19 = copy byte_offset_15 < const 0 : isize
        overflow_18 = copy _20 ^ move _19
        storage_dead(_19)
        storage_dead(_20)
        storage_dead(self_9)
        _4 = ~(copy overflow_18)
        storage_dead(overflow_18)
        if move _4 {
            storage_dead(_4)
            return
        } else {
        }
    }
    msg_5 = const "unsafe precondition(s) violated: ptr::offset requires the address calculation to not overflow\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
    storage_live(_7)
    storage_live(_24)
    storage_live(_25)
    storage_live(_30)
    _30 = &raw const (*msg_5) with_metadata(copy msg_5.metadata)
    _25 = cast<*const Str, *const u8>(copy _30)
    storage_dead(_30)
    _24 = transmute<*const u8, NonNull<u8>>(copy _25)
    storage_dead(_25)
    storage_live(_26)
    storage_live(_27)
    storage_live(_28)
    storage_live(_29)
    storage_live(_31)
    _31 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: ptr::offset requires the address calculation to not overflow\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    _29 = copy _31.metadata
    storage_dead(_31)
    _28 = move _29 wrap.<< const 1 : i32
    storage_dead(_29)
    _27 = move _28 | const 1 : usize
    storage_dead(_28)
    _26 = transmute<usize, NonNull<Argument<'2>>>(move _27)
    storage_dead(_27)
    _7 = Arguments { 0: move _24, 1: move _26 }
    storage_dead(_26)
    storage_dead(_24)
    _6 = panic_nounwind_fmt<'_>(move _7, const false)
}

// Full name: core::ptr::const_ptr::{*const T}::offset
pub unsafe fn offset<T>(@1: *const T, @2: isize) -> *const T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *const T; // return
    let self_1: *const T; // arg #1
    let count_2: isize; // arg #2
    let _3: (); // anonymous local
    let _4: *const (); // anonymous local
    let _5: bool; // anonymous local

    storage_live(_3)
    storage_live(_5)
    _5 = ub_checks<bool>
    if copy _5 {
        storage_live(_4)
        _4 = cast<*const T, *const ()>(copy self_1)
        _3 = precondition_check(move _4, copy count_2, const {impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE)
        storage_dead(_4)
    } else {
    }
    _0 = copy self_1 offset copy count_2
    return
}

// Full name: core::slice::{[T]}::as_ptr
pub fn as_ptr<'_0, T>(@1: &'_0 [T]) -> *const T
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let s_1: [i32; 2 : usize]; // local
    let ptr_2: *const i32; // local
    let _3: &'0 [i32]; // anonymous local
    let _4: &'1 [i32; 2 : usize]; // anonymous local
    let _5: bool; // anonymous local
    let _6: i32; // anonymous local
    let _7: *const i32; // anonymous local
    let _8: *const i32; // anonymous local

    _0 = ()
    storage_live(s_1)
    s_1 = [const 11 : i32, const 42 : i32]
    storage_live(ptr_2)
    storage_live(_3)
    storage_live(_4)
    _4 = &s_1
    _3 = @ArrayToSliceShared<'_, i32, 2 : usize>(move _4)
    storage_dead(_4)
    ptr_2 = as_ptr<'_, i32>[{built_in impl Sized for i32}](move _3)
    storage_dead(_3)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    _8 = copy ptr_2
    _7 = offset<i32>[{built_in impl Sized for i32}](move _8, const 1 : isize)
    storage_dead(_8)
    _6 = copy (*_7)
    _5 = move _6 == const 42 : i32
    if move _5 {
    } else {
        storage_dead(_6)
        storage_dead(_7)
        panic(core::panicking::panic)
    }
    storage_dead(_6)
    storage_dead(_7)
    storage_dead(_5)
    _0 = ()
    storage_dead(ptr_2)
    storage_dead(s_1)
    return
}



