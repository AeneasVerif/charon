# Final LLBC before serialization:

#[lang_item("sized")]
pub trait core::marker::Sized<Self>

pub fn core::slice::{Slice<T>}::as_ptr<'_0, T>(@1: &'_0 (Slice<T>)) -> *const T
where
    [@TraitClause0]: core::marker::Sized<T>,

pub fn core::intrinsics::cold_path()

#[lang_item("panic_nounwind")]
pub fn core::panicking::panic_nounwind(@1: &'static (Str)) -> !

fn core::ptr::const_ptr::{*const T}::offset::precondition_check(@1: *const (), @2: isize, @3: usize)
{
    let @0: (); // return
    let this@1: *const (); // arg #1
    let count@2: isize; // arg #2
    let size@3: usize; // arg #3
    let @4: bool; // anonymous local
    let @5: !; // anonymous local
    let rhs@6: isize; // local
    let self@7: usize; // local
    let @8: i64; // anonymous local
    let b@9: bool; // local
    let @10: (i64, bool); // anonymous local
    let @11: i64; // anonymous local
    let @12: i64; // anonymous local
    let byte_offset@13: isize; // local
    let @14: (); // anonymous local
    let @15: usize; // anonymous local
    let overflow@16: bool; // local
    let @17: bool; // anonymous local
    let @18: bool; // anonymous local
    let @19: (u64, bool); // anonymous local
    let @20: u64; // anonymous local
    let @21: u64; // anonymous local

    rhs@6 := cast<usize, isize>(copy (size@3))
    @11 := cast<isize, i64>(copy (count@2))
    @12 := cast<isize, i64>(copy (rhs@6))
    @10 := move (@11) checked.* move (@12)
    drop @12
    drop @11
    @8 := copy ((@10).0)
    b@9 := copy ((@10).1)
    drop @10
    byte_offset@13 := cast<i64, isize>(copy (@8))
    drop @8
    if copy (b@9) {
        @14 := core::intrinsics::cold_path()
        drop b@9
        drop rhs@6
        drop overflow@16
    }
    else {
        drop b@9
        drop rhs@6
        self@7 := transmute<*const (), usize>(copy (this@1))
        @15 := cast<isize, usize>(copy (byte_offset@13))
        @20 := cast<usize, u64>(copy (self@7))
        @21 := cast<usize, u64>(copy (@15))
        @19 := move (@20) checked.+ move (@21)
        drop @21
        drop @20
        @18 := copy ((@19).1)
        drop @19
        drop @15
        @17 := copy (byte_offset@13) < const (0 : isize)
        overflow@16 := copy (@18) ^ move (@17)
        drop @17
        drop @18
        drop self@7
        @4 := ~(copy (overflow@16))
        drop overflow@16
        if move (@4) {
            drop @4
            @0 := ()
            return
        }
        else {
        }
    }
    @5 := core::panicking::panic_nounwind(const ("unsafe precondition(s) violated: ptr::offset requires the address calculation to not overflow\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."))
}

pub unsafe fn core::ptr::const_ptr::{*const T}::offset<T>(@1: *const T, @2: isize) -> *const T
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: *const T; // return
    let self@1: *const T; // arg #1
    let count@2: isize; // arg #2
    let @3: bool; // anonymous local
    let @4: (); // anonymous local
    let @5: *const (); // anonymous local
    let @6: usize; // anonymous local

    @3 := ub_checks<bool>
    if move (@3) {
        @5 := cast<*const T, *const ()>(copy (self@1))
        @6 := size_of<T>
        @4 := core::ptr::const_ptr::{*const T}::offset::precondition_check(move (@5), copy (count@2), move (@6))
        drop @6
        drop @5
    }
    else {
    }
    drop @3
    @0 := copy (self@1) offset copy (count@2)
    return
}

fn test_crate::main()
{
    let @0: (); // return
    let s@1: Array<i32, 2 : usize>; // local
    let ptr@2: *const i32; // local
    let @3: &'_ (Slice<i32>); // anonymous local
    let @4: &'_ (Array<i32, 2 : usize>); // anonymous local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: i32; // anonymous local
    let @8: *const i32; // anonymous local
    let @9: *const i32; // anonymous local

    s@1 := [const (11 : i32), const (42 : i32)]
    @fake_read(s@1)
    @4 := &s@1
    @3 := @ArrayToSliceShared<'_, i32, 2 : usize>(move (@4))
    drop @4
    ptr@2 := core::slice::{Slice<T>}::as_ptr<'_, i32>[core::marker::Sized<i32>](move (@3))
    drop @3
    @fake_read(ptr@2)
    @9 := copy (ptr@2)
    @8 := core::ptr::const_ptr::{*const T}::offset<i32>[core::marker::Sized<i32>](move (@9), const (1 : isize))
    drop @9
    @7 := copy (*(@8))
    @6 := move (@7) == const (42 : i32)
    if move (@6) {
    }
    else {
        drop @7
        drop @8
        panic(core::panicking::panic)
    }
    drop @7
    drop @8
    drop @6
    drop @5
    @0 := ()
    drop ptr@2
    drop s@1
    @0 := ()
    return
}



