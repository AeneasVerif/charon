# Final LLBC before serialization:

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::CONST
fn CONST() -> u8
{
    let _0: u8; // return

    _0 = const (0 : u8)
    return
}

// Full name: test_crate::CONST
const CONST: u8 = CONST()

// Full name: test_crate::f0
fn f0()
{
    let _0: (); // return
    let _1: bool; // anonymous local
    let _2: bool; // anonymous local
    let x_3: u8; // local

    _0 = ()
    storage_live(_1)
    _1 = const (0 : i32) < const (1 : i32)
    if move (_1) {
        storage_live(_2)
        _2 = const (0 : i32) < const (1 : i32)
        if move (_2) {
        } else {
        }
        storage_dead(_2)
        storage_live(x_3)
        x_3 = copy (CONST)
        _0 = ()
        storage_dead(x_3)
    } else {
        _0 = ()
    }
    storage_dead(_1)
    return
}

// Full name: test_crate::f1
fn f1<'_0>(@1: &'_0 [u8; 1 : usize])
{
    let _0: (); // return
    let serialized_1: &'0 [u8; 1 : usize]; // arg #1
    let previous_true_hints_seen_2: usize; // local
    let i_3: i32; // local
    let _4: bool; // anonymous local
    let _5: i32; // anonymous local
    let _6: bool; // anonymous local
    let _7: bool; // anonymous local
    let j_8: i32; // local
    let _9: bool; // anonymous local
    let _10: i32; // anonymous local
    let x_11: u8; // local

    _0 = ()
    storage_live(previous_true_hints_seen_2)
    previous_true_hints_seen_2 = const (0 : usize)
    storage_live(i_3)
    i_3 = const (0 : i32)
    loop {
        storage_live(_4)
        storage_live(_5)
        _5 = copy (i_3)
        _4 = move (_5) < const (1 : i32)
        if move (_4) {
            storage_dead(_5)
            storage_live(_6)
            _6 = const (0 : i32) < const (1 : i32)
            if move (_6) {
            } else {
                storage_live(_7)
                _7 = const (1 : i32) > const (1 : i32)
                if move (_7) {
                } else {
                }
            }
            storage_dead(_7)
            storage_dead(_6)
            storage_live(j_8)
            j_8 = const (0 : i32)
            loop {
                storage_live(_9)
                storage_live(_10)
                _10 = copy (j_8)
                _9 = move (_10) < const (1 : i32)
                if move (_9) {
                    storage_dead(_10)
                    storage_live(x_11)
                    x_11 = copy (CONST)
                    storage_dead(x_11)
                    storage_dead(_9)
                    continue 0
                } else {
                    break 0
                }
            }
            storage_dead(_10)
            storage_dead(_9)
            storage_dead(j_8)
            storage_dead(_4)
            continue 0
        } else {
            break 0
        }
    }
    storage_dead(_5)
    _0 = ()
    storage_dead(_4)
    storage_dead(i_3)
    storage_dead(previous_true_hints_seen_2)
    return
}



