# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0_1> = core::iter::traits::iterator::Iterator::next<'_0_1, Self>[Self]
    vtable: core::iter::traits::iterator::Iterator::{vtable}<Self::Item>
}

// Full name: core::iter::traits::collect::IntoIterator
#[lang_item("IntoIterator")]
pub trait IntoIterator<Self>
where
    Self::parent_clause3::Item = Self::Item,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: Sized<Self::IntoIter>
    parent_clause3 : [@TraitClause3]: Iterator<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter = core::iter::traits::collect::IntoIterator::into_iter<Self>[Self]
    vtable: core::iter::traits::collect::IntoIterator::{vtable}<Self::Item, Self::IntoIter>
}

#[lang_item("into_iter")]
pub fn core::iter::traits::collect::IntoIterator::into_iter<Self>(@1: Self) -> @TraitClause0::IntoIter
where
    [@TraitClause0]: IntoIterator<Self>,
= <opaque>

// Full name: core::iter::traits::collect::{impl IntoIterator for I}::into_iter
pub fn {impl IntoIterator for I}::into_iter<I>(@1: I) -> I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
= <opaque>

// Full name: core::iter::traits::collect::{impl IntoIterator for I}
impl<I> IntoIterator for I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
{
    parent_clause0 = @TraitClause0::parent_clause0
    parent_clause1 = @TraitClause1::parent_clause1
    parent_clause2 = @TraitClause0
    parent_clause3 = @TraitClause1
    type Item = @TraitClause1::Item
    type IntoIter = I
    fn into_iter = {impl IntoIterator for I}::into_iter<I>[@TraitClause0, @TraitClause1]
    vtable: {impl IntoIterator for I}::{vtable}<I>[@TraitClause0, @TraitClause1]
}

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut Self) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,
= <opaque>

// Full name: core::slice::iter::Chunks
pub opaque type Chunks<'a, T>
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
    T : 'a,

// Full name: core::slice::iter::{impl Iterator for Chunks<'a, T>[@TraitClause0]}::next
pub fn {impl Iterator for Chunks<'a, T>[@TraitClause0]}::next<'a, '_1, T>(@1: &'_1 mut Chunks<'a, T>[@TraitClause0]) -> Option<&'a [T]>[{built_in impl Sized for &'_ [T]}]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::iter::{impl Iterator for Chunks<'a, T>[@TraitClause0]}
impl<'a, T> Iterator for Chunks<'a, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Chunks<'_, T>[@TraitClause0]}
    parent_clause1 = {built_in impl Sized for &'_ [T]}
    type Item = &'a [T]
    fn next<'_0_1> = {impl Iterator for Chunks<'a, T>[@TraitClause0]}::next<'a, '_0_1, T>[@TraitClause0]
    vtable: {impl Iterator for Chunks<'a, T>[@TraitClause0]}::{vtable}<'a, T>[@TraitClause0]
}

// Full name: core::slice::{[T]}::chunks
pub fn chunks<'_0, T>(@1: &'_0 [T], @2: usize) -> Chunks<'_0, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::f1
fn f1<'_0>(@1: &'_0 [u8]) -> usize
{
    let _0: usize; // return
    let a_1: &'0 [u8]; // arg #1
    let sampled_2: usize; // local
    let _3: bool; // anonymous local
    let _4: u8; // anonymous local
    let _5: usize; // anonymous local
    let _6: bool; // anonymous local
    let _7: u8; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local
    let _11: &'_ [u8]; // anonymous local
    let _12: &'_ u8; // anonymous local
    let _13: &'_ [u8]; // anonymous local
    let _14: &'_ u8; // anonymous local

    storage_live(_9)
    storage_live(_10)
    storage_live(sampled_2)
    sampled_2 = const 0 : usize
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = const 0 : usize
    storage_live(_13)
    _13 = &(*a_1) with_metadata(copy a_1.metadata)
    storage_live(_14)
    _14 = @SliceIndexShared<'_, u8>(move _13, copy _5)
    _4 = copy (*_14)
    _3 = move _4 < const 42 : u8
    if move _3 {
        storage_dead(_5)
        storage_dead(_4)
        storage_live(_6)
        storage_live(_7)
        storage_live(_8)
        _8 = const 1 : usize
        storage_live(_11)
        _11 = &(*a_1) with_metadata(copy a_1.metadata)
        storage_live(_12)
        _12 = @SliceIndexShared<'_, u8>(move _11, copy _8)
        _7 = copy (*_12)
        _6 = move _7 < const 16 : u8
        if move _6 {
            storage_dead(_8)
            storage_dead(_7)
            _9 = copy sampled_2 panic.+ const 100 : usize
            sampled_2 = move _9
        } else {
            storage_dead(_8)
            storage_dead(_7)
        }
    } else {
        storage_dead(_5)
        storage_dead(_4)
    }
    storage_dead(_6)
    storage_dead(_3)
    _10 = copy sampled_2 panic.+ const 101 : usize
    sampled_2 = move _10
    _0 = copy sampled_2
    storage_dead(sampled_2)
    return
}

// Full name: test_crate::FIELD_MODULUS
fn FIELD_MODULUS() -> i16
{
    let _0: i16; // return

    _0 = const 8 : i16
    return
}

// Full name: test_crate::FIELD_MODULUS
const FIELD_MODULUS: i16 = FIELD_MODULUS()

// Full name: test_crate::f2
fn f2<'_0, '_1>(@1: &'_0 [u8], @2: &'_1 mut [i16]) -> usize
{
    let _0: usize; // return
    let a_1: &'0 [u8]; // arg #1
    let result_2: &'1 mut [i16]; // arg #2
    let sampled_3: usize; // local
    let _4: Chunks<'2, u8>[{built_in impl Sized for u8}]; // anonymous local
    let _5: Chunks<'2, u8>[{built_in impl Sized for u8}]; // anonymous local
    let _6: &'0 [u8]; // anonymous local
    let iter_7: Chunks<'2, u8>[{built_in impl Sized for u8}]; // local
    let _8: Option<&'0 [u8]>[{built_in impl Sized for &'0 [u8]}]; // anonymous local
    let _9: &'5 mut Chunks<'2, u8>[{built_in impl Sized for u8}]; // anonymous local
    let _10: &'5 mut Chunks<'2, u8>[{built_in impl Sized for u8}]; // anonymous local
    let bytes_11: &'0 [u8]; // local
    let b1_12: i16; // local
    let _13: u8; // anonymous local
    let _14: usize; // anonymous local
    let b2_15: i16; // local
    let _16: u8; // anonymous local
    let _17: usize; // anonymous local
    let b3_18: i16; // local
    let _19: u8; // anonymous local
    let _20: usize; // anonymous local
    let d1_21: i16; // local
    let _22: i16; // anonymous local
    let _23: i16; // anonymous local
    let _24: i16; // anonymous local
    let _25: i16; // anonymous local
    let d2_26: i16; // local
    let _27: i16; // anonymous local
    let _28: i16; // anonymous local
    let _29: i16; // anonymous local
    let _30: i16; // anonymous local
    let _31: bool; // anonymous local
    let _32: i16; // anonymous local
    let _33: bool; // anonymous local
    let _34: usize; // anonymous local
    let _35: i16; // anonymous local
    let _36: usize; // anonymous local
    let _37: usize; // anonymous local
    let _38: bool; // anonymous local
    let _39: i16; // anonymous local
    let _40: bool; // anonymous local
    let _41: usize; // anonymous local
    let _42: i16; // anonymous local
    let _43: usize; // anonymous local
    let _44: usize; // anonymous local
    let _45: &'_ mut [i16]; // anonymous local
    let _46: &'_ mut i16; // anonymous local
    let _47: &'_ mut [i16]; // anonymous local
    let _48: &'_ mut i16; // anonymous local
    let _49: &'_ [u8]; // anonymous local
    let _50: &'_ u8; // anonymous local
    let _51: &'_ [u8]; // anonymous local
    let _52: &'_ u8; // anonymous local
    let _53: &'_ [u8]; // anonymous local
    let _54: &'_ u8; // anonymous local

    storage_live(_37)
    storage_live(_44)
    storage_live(sampled_3)
    sampled_3 = const 0 : usize
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _6 = &(*a_1) with_metadata(copy a_1.metadata)
    _5 = chunks<'7, u8>[{built_in impl Sized for u8}](move _6, const 3 : usize)
    storage_dead(_6)
    _4 = {impl IntoIterator for I}::into_iter<Chunks<'2, u8>[{built_in impl Sized for u8}]>[{built_in impl Sized for Chunks<'2, u8>[{built_in impl Sized for u8}]}, {impl Iterator for Chunks<'a, T>[@TraitClause0]}<'2, u8>[{built_in impl Sized for u8}]](move _5)
    storage_dead(_5)
    storage_live(iter_7)
    iter_7 = move _4
    loop {
        storage_live(_8)
        storage_live(_9)
        storage_live(_10)
        _10 = &mut iter_7
        _9 = &two-phase-mut (*_10)
        _8 = {impl Iterator for Chunks<'a, T>[@TraitClause0]}::next<'12, '14, u8>[{built_in impl Sized for u8}](move _9)
        storage_dead(_9)
        match _8 {
            Option::None => {
                break 0
            },
            Option::Some => {
            },
        }
        storage_live(bytes_11)
        bytes_11 = copy (_8 as variant Option::Some).0
        storage_live(b1_12)
        storage_live(_13)
        storage_live(_14)
        _14 = const 0 : usize
        storage_live(_49)
        _49 = &(*bytes_11) with_metadata(copy bytes_11.metadata)
        storage_live(_50)
        _50 = @SliceIndexShared<'_, u8>(move _49, copy _14)
        _13 = copy (*_50)
        b1_12 = cast<u8, i16>(move _13)
        storage_dead(_13)
        storage_dead(_14)
        storage_live(b2_15)
        storage_live(_16)
        storage_live(_17)
        _17 = const 1 : usize
        storage_live(_51)
        _51 = &(*bytes_11) with_metadata(copy bytes_11.metadata)
        storage_live(_52)
        _52 = @SliceIndexShared<'_, u8>(move _51, copy _17)
        _16 = copy (*_52)
        b2_15 = cast<u8, i16>(move _16)
        storage_dead(_16)
        storage_dead(_17)
        storage_live(b3_18)
        storage_live(_19)
        storage_live(_20)
        _20 = const 2 : usize
        storage_live(_53)
        _53 = &(*bytes_11) with_metadata(copy bytes_11.metadata)
        storage_live(_54)
        _54 = @SliceIndexShared<'_, u8>(move _53, copy _20)
        _19 = copy (*_54)
        b3_18 = cast<u8, i16>(move _19)
        storage_dead(_19)
        storage_dead(_20)
        storage_live(d1_21)
        storage_live(_22)
        storage_live(_23)
        storage_live(_24)
        _24 = copy b2_15
        _23 = move _24 & const 15 : i16
        storage_dead(_24)
        _22 = move _23 panic.<< const 8 : i32
        storage_dead(_23)
        storage_live(_25)
        _25 = copy b1_12
        d1_21 = move _22 | move _25
        storage_dead(_25)
        storage_dead(_22)
        storage_live(d2_26)
        storage_live(_27)
        storage_live(_28)
        _28 = copy b3_18
        _27 = move _28 panic.<< const 4 : i32
        storage_dead(_28)
        storage_live(_29)
        storage_live(_30)
        _30 = copy b2_15
        _29 = move _30 panic.>> const 4 : i32
        storage_dead(_30)
        d2_26 = move _27 | move _29
        storage_dead(_29)
        storage_dead(_27)
        storage_live(_31)
        storage_live(_32)
        _32 = copy d1_21
        _31 = move _32 < copy FIELD_MODULUS
        if move _31 {
            storage_dead(_32)
            storage_live(_33)
            storage_live(_34)
            _34 = copy sampled_3
            _33 = move _34 < const 16 : usize
            if move _33 {
                storage_dead(_34)
                storage_live(_35)
                _35 = copy d1_21
                storage_live(_36)
                _36 = copy sampled_3
                storage_live(_45)
                _45 = &mut (*result_2) with_metadata(copy result_2.metadata)
                storage_live(_46)
                _46 = @SliceIndexMut<'_, i16>(move _45, copy _36)
                (*_46) = move _35
                storage_dead(_35)
                storage_dead(_36)
                _37 = copy sampled_3 panic.+ const 1 : usize
                sampled_3 = move _37
            } else {
                storage_dead(_34)
            }
        } else {
            storage_dead(_32)
        }
        storage_dead(_33)
        storage_dead(_31)
        storage_live(_38)
        storage_live(_39)
        _39 = copy d2_26
        _38 = move _39 < copy FIELD_MODULUS
        if move _38 {
            storage_dead(_39)
            storage_live(_40)
            storage_live(_41)
            _41 = copy sampled_3
            _40 = move _41 < const 16 : usize
            if move _40 {
                storage_dead(_41)
                storage_live(_42)
                _42 = copy d2_26
                storage_live(_43)
                _43 = copy sampled_3
                storage_live(_47)
                _47 = &mut (*result_2) with_metadata(copy result_2.metadata)
                storage_live(_48)
                _48 = @SliceIndexMut<'_, i16>(move _47, copy _43)
                (*_48) = move _42
                storage_dead(_42)
                storage_dead(_43)
                _44 = copy sampled_3 panic.+ const 1 : usize
                sampled_3 = move _44
            } else {
                storage_dead(_41)
            }
        } else {
            storage_dead(_39)
        }
        storage_dead(_40)
        storage_dead(_38)
        storage_dead(d2_26)
        storage_dead(d1_21)
        storage_dead(b3_18)
        storage_dead(b2_15)
        storage_dead(b1_12)
        storage_dead(bytes_11)
        storage_dead(_10)
        storage_dead(_8)
        continue 0
    }
    storage_dead(_10)
    storage_dead(_8)
    storage_dead(iter_7)
    storage_dead(_4)
    _0 = copy sampled_3
    storage_dead(sampled_3)
    return
}



