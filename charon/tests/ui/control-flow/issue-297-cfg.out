# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = clone<'_0_1, Self>[Self]
    non-dyn-compatible
}

// Full name: core::clone::Clone::clone
#[lang_item("clone_fn")]
pub fn clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <opaque>

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0_1, '_1_1> = core::cmp::PartialEq::eq<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

#[lang_item("cmp_partialeq_eq")]
pub fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,
= <opaque>

// Full name: core::cmp::Eq
#[lang_item("Eq")]
pub trait Eq<Self>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Self>
    non-dyn-compatible
}

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0_1, '_1_1> = core::cmp::PartialOrd::partial_cmp<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

// Full name: core::cmp::Ord
#[lang_item("Ord")]
pub trait Ord<Self>
{
    parent_clause0 : [@TraitClause0]: Eq<Self>
    parent_clause1 : [@TraitClause1]: PartialOrd<Self, Self>
    fn cmp<'_0_1, '_1_1> = core::cmp::Ord::cmp<'_0_1, '_1_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("ord_cmp_method")]
pub fn core::cmp::Ord::cmp<'_0, '_1, Self>(@1: &'_0 Self, @2: &'_1 Self) -> Ordering
where
    [@TraitClause0]: Ord<Self>,
= <opaque>

#[lang_item("cmp_partialord_cmp")]
pub fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> Option<Ordering>[{built_in impl Sized for Ordering}]
where
    [@TraitClause0]: PartialOrd<Self, Rhs>,
= <opaque>

// Full name: core::default::Default
#[lang_item("Default")]
pub trait Default<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn default = default<Self>[Self]
    non-dyn-compatible
}

// Full name: core::default::Default::default
#[lang_item("default_fn")]
pub fn default<Self>() -> Self
where
    [@TraitClause0]: Default<Self>,
= <opaque>

// Full name: core::iter::adapters::zip::TrustedRandomAccessNoCoerce
pub trait TrustedRandomAccessNoCoerce<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const MAY_HAVE_SIDE_EFFECT : bool
    non-dyn-compatible
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0_1> = core::iter::traits::iterator::Iterator::next<'_0_1, Self>[Self]
    vtable: core::iter::traits::iterator::Iterator::{vtable}<Self::Item>
}

// Full name: core::iter::traits::accum::Sum
pub trait Sum<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn sum<I, [@TraitClause0_1]: Sized<I>, [@TraitClause1_1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Sum::sum<Self, A, I>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

pub fn core::iter::traits::accum::Sum::sum<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Sum<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,
= <opaque>

// Full name: core::iter::traits::accum::Product
pub trait Product<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn product<I, [@TraitClause0_1]: Sized<I>, [@TraitClause1_1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Product::product<Self, A, I>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

pub fn core::iter::traits::accum::Product::product<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Product<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,
= <opaque>

// Full name: core::iter::traits::collect::IntoIterator
#[lang_item("IntoIterator")]
pub trait IntoIterator<Self>
where
    Self::parent_clause3::Item = Self::Item,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: Sized<Self::IntoIter>
    parent_clause3 : [@TraitClause3]: Iterator<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter = core::iter::traits::collect::IntoIterator::into_iter<Self>[Self]
    vtable: core::iter::traits::collect::IntoIterator::{vtable}<Self::Item, Self::IntoIter>
}

// Full name: core::iter::traits::collect::FromIterator
#[lang_item("FromIterator")]
pub trait FromIterator<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn from_iter<T, [@TraitClause0_1]: Sized<T>, [@TraitClause1_1]: IntoIterator<T>, @TraitClause1_1::Item = A> = from_iter<Self, A, T>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::FromIterator::from_iter
#[lang_item("from_iter_fn")]
pub fn from_iter<Self, A, T>(@1: T) -> Self
where
    [@TraitClause0]: FromIterator<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,
= <opaque>

#[lang_item("into_iter")]
pub fn core::iter::traits::collect::IntoIterator::into_iter<Self>(@1: Self) -> @TraitClause0::IntoIter
where
    [@TraitClause0]: IntoIterator<Self>,
= <opaque>

// Full name: core::iter::traits::collect::{impl IntoIterator for I}::into_iter
pub fn {impl IntoIterator for I}::into_iter<I>(@1: I) -> I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
= <opaque>

// Full name: core::iter::traits::collect::{impl IntoIterator for I}
impl<I> IntoIterator for I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
{
    parent_clause0 = @TraitClause0::parent_clause0
    parent_clause1 = @TraitClause1::parent_clause1
    parent_clause2 = @TraitClause0
    parent_clause3 = @TraitClause1
    type Item = @TraitClause1::Item
    type IntoIter = I
    fn into_iter = {impl IntoIterator for I}::into_iter<I>[@TraitClause0, @TraitClause1]
    vtable: {impl IntoIterator for I}::{vtable}<I>[@TraitClause0, @TraitClause1]
}

// Full name: core::iter::traits::collect::Extend
pub trait Extend<Self, A>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn extend<'_0_1, T, [@TraitClause0_1]: Sized<T>, [@TraitClause1_1]: IntoIterator<T>, @TraitClause1_1::Item = A> = extend<'_0_1, Self, A, T>[Self, @TraitClause0_1, @TraitClause1_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::Extend::extend
pub fn extend<'_0, Self, A, T>(@1: &'_0 mut Self, @2: T)
where
    [@TraitClause0]: Extend<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,
= <opaque>

// Full name: core::iter::traits::double_ended::DoubleEndedIterator
#[lang_item("DoubleEndedIterator")]
pub trait DoubleEndedIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    fn next_back<'_0_1> = next_back<'_0_1, Self>[Self]
    vtable: core::iter::traits::double_ended::DoubleEndedIterator::{vtable}<Self::parent_clause1::Item>
}

// Full name: core::iter::traits::double_ended::DoubleEndedIterator::next_back
pub fn next_back<'_0, Self>(@1: &'_0 mut Self) -> Option<@TraitClause0::parent_clause1::Item>[@TraitClause0::parent_clause1::parent_clause1]
where
    [@TraitClause0]: DoubleEndedIterator<Self>,
= <opaque>

// Full name: core::iter::traits::exact_size::ExactSizeIterator
pub trait ExactSizeIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    vtable: core::iter::traits::exact_size::ExactSizeIterator::{vtable}<Self::parent_clause1::Item>
}

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut Self) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,
= <opaque>

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::marker::Destruct::drop_in_place
unsafe fn drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::control_flow::ControlFlow
#[lang_item("ControlFlow")]
pub enum ControlFlow<B, C>
where
    [@TraitClause0]: Sized<B>,
    [@TraitClause1]: Sized<C>,
{
  Continue(C),
  Break(B),
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = call_once<Self, Args>[Self]
    vtable: core::ops::function::FnOnce::{vtable}<Args, Self::Output>
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0_1> = call_mut<'_0_1, Self, Args>[Self]
    vtable: core::ops::function::FnMut::{vtable}<Args, Self::parent_clause1::Output>
}

// Full name: core::ops::function::FnMut::call_mut
pub fn call_mut<'_0, Self, Args>(@1: &'_0 mut Self, @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,
= <opaque>

// Full name: core::ops::function::FnOnce::call_once
pub fn call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,
= <opaque>

// Full name: core::ops::try_trait::FromResidual
#[lang_item("FromResidual")]
pub trait FromResidual<Self, R>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<R>
    fn from_residual = from_residual<Self, R>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try
#[lang_item("Try")]
pub trait Try<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FromResidual<Self, Self::Residual>
    parent_clause2 : [@TraitClause2]: Sized<Self::Output>
    parent_clause3 : [@TraitClause3]: Sized<Self::Residual>
    type Output
    type Residual
    fn from_output = from_output<Self>[Self]
    fn branch = branch<Self>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try::from_output
#[lang_item("from_output")]
pub fn from_output<Self>(@1: @TraitClause0::Output) -> Self
where
    [@TraitClause0]: Try<Self>,
= <opaque>

// Full name: core::ops::try_trait::Try::branch
#[lang_item("branch")]
pub fn branch<Self>(@1: Self) -> ControlFlow<@TraitClause0::Residual, @TraitClause0::Output>[@TraitClause0::parent_clause1::parent_clause1, @TraitClause0::parent_clause2]
where
    [@TraitClause0]: Try<Self>,
= <opaque>

// Full name: core::ops::try_trait::FromResidual::from_residual
#[lang_item("from_residual")]
pub fn from_residual<Self, R>(@1: R) -> Self
where
    [@TraitClause0]: FromResidual<Self, R>,
= <opaque>

// Full name: core::ops::try_trait::Residual
pub trait Residual<Self, O>
where
    Self::parent_clause3::Output = O,
    Self::parent_clause3::Residual = Self,
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<O>
    parent_clause2 : [@TraitClause2]: Sized<Self::TryType>
    parent_clause3 : [@TraitClause3]: Try<Self::TryType>
    type TryType
    non-dyn-compatible
}

// Full name: core::slice::iter::Chunks
pub opaque type Chunks<'a, T>
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
    T : 'a,

// Full name: core::slice::iter::{impl Iterator for Chunks<'a, T>[@TraitClause0]}::next
pub fn {impl Iterator for Chunks<'a, T>[@TraitClause0]}::next<'a, '_1, T>(@1: &'_1 mut Chunks<'a, T>[@TraitClause0]) -> Option<&'a [T]>[{built_in impl Sized for &'_ [T]}]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::iter::{impl Iterator for Chunks<'a, T>[@TraitClause0]}
impl<'a, T> Iterator for Chunks<'a, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Chunks<'_, T>[@TraitClause0]}
    parent_clause1 = {built_in impl Sized for &'_ [T]}
    type Item = &'a [T]
    fn next<'_0_1> = {impl Iterator for Chunks<'a, T>[@TraitClause0]}::next<'a, '_0_1, T>[@TraitClause0]
    vtable: {impl Iterator for Chunks<'a, T>[@TraitClause0]}::{vtable}<'a, T>[@TraitClause0]
}

// Full name: core::slice::{[T]}::chunks
pub fn chunks<'_0, T>(@1: &'_0 [T], @2: usize) -> Chunks<'_0, T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::f1
fn f1<'_0>(@1: &'_0 [u8]) -> usize
{
    let _0: usize; // return
    let a_1: &'0 [u8]; // arg #1
    let sampled_2: usize; // local
    let _3: bool; // anonymous local
    let _4: u8; // anonymous local
    let _5: usize; // anonymous local
    let _6: bool; // anonymous local
    let _7: u8; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local
    let _11: &'_ [u8]; // anonymous local
    let _12: &'_ u8; // anonymous local
    let _13: &'_ [u8]; // anonymous local
    let _14: &'_ u8; // anonymous local

    storage_live(_9)
    storage_live(_10)
    storage_live(sampled_2)
    sampled_2 := const (0 : usize)
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _5 := const (0 : usize)
    storage_live(_13)
    _13 := &*(a_1) with_metadata(copy (a_1.metadata))
    storage_live(_14)
    _14 := @SliceIndexShared<'_, u8>(move (_13), copy (_5))
    _4 := copy (*(_14))
    _3 := move (_4) < const (42 : u8)
    if move (_3) {
        storage_dead(_5)
        storage_dead(_4)
        storage_live(_6)
        storage_live(_7)
        storage_live(_8)
        _8 := const (1 : usize)
        storage_live(_11)
        _11 := &*(a_1) with_metadata(copy (a_1.metadata))
        storage_live(_12)
        _12 := @SliceIndexShared<'_, u8>(move (_11), copy (_8))
        _7 := copy (*(_12))
        _6 := move (_7) < const (16 : u8)
        if move (_6) {
            storage_dead(_8)
            storage_dead(_7)
            _9 := copy (sampled_2) panic.+ const (100 : usize)
            sampled_2 := move (_9)
        } else {
            storage_dead(_8)
            storage_dead(_7)
        }
    } else {
        storage_dead(_5)
        storage_dead(_4)
    }
    storage_dead(_6)
    storage_dead(_3)
    _10 := copy (sampled_2) panic.+ const (101 : usize)
    sampled_2 := move (_10)
    _0 := copy (sampled_2)
    storage_dead(sampled_2)
    return
}

// Full name: test_crate::FIELD_MODULUS
fn FIELD_MODULUS() -> i16
{
    let _0: i16; // return

    _0 := const (8 : i16)
    return
}

// Full name: test_crate::FIELD_MODULUS
const FIELD_MODULUS: i16 = FIELD_MODULUS()

// Full name: test_crate::f2
fn f2<'_0, '_1>(@1: &'_0 [u8], @2: &'_1 mut [i16]) -> usize
{
    let _0: usize; // return
    let a_1: &'0 [u8]; // arg #1
    let result_2: &'1 mut [i16]; // arg #2
    let sampled_3: usize; // local
    let _4: Chunks<'2, u8>[{built_in impl Sized for u8}]; // anonymous local
    let _5: Chunks<'2, u8>[{built_in impl Sized for u8}]; // anonymous local
    let _6: &'0 [u8]; // anonymous local
    let iter_7: Chunks<'2, u8>[{built_in impl Sized for u8}]; // local
    let _8: Option<&'0 [u8]>[{built_in impl Sized for &'0 [u8]}]; // anonymous local
    let _9: &'5 mut Chunks<'2, u8>[{built_in impl Sized for u8}]; // anonymous local
    let _10: &'5 mut Chunks<'2, u8>[{built_in impl Sized for u8}]; // anonymous local
    let bytes_11: &'0 [u8]; // local
    let b1_12: i16; // local
    let _13: u8; // anonymous local
    let _14: usize; // anonymous local
    let b2_15: i16; // local
    let _16: u8; // anonymous local
    let _17: usize; // anonymous local
    let b3_18: i16; // local
    let _19: u8; // anonymous local
    let _20: usize; // anonymous local
    let d1_21: i16; // local
    let _22: i16; // anonymous local
    let _23: i16; // anonymous local
    let _24: i16; // anonymous local
    let _25: i16; // anonymous local
    let d2_26: i16; // local
    let _27: i16; // anonymous local
    let _28: i16; // anonymous local
    let _29: i16; // anonymous local
    let _30: i16; // anonymous local
    let _31: bool; // anonymous local
    let _32: i16; // anonymous local
    let _33: bool; // anonymous local
    let _34: usize; // anonymous local
    let _35: i16; // anonymous local
    let _36: usize; // anonymous local
    let _37: usize; // anonymous local
    let _38: bool; // anonymous local
    let _39: i16; // anonymous local
    let _40: bool; // anonymous local
    let _41: usize; // anonymous local
    let _42: i16; // anonymous local
    let _43: usize; // anonymous local
    let _44: usize; // anonymous local
    let _45: &'_ mut [i16]; // anonymous local
    let _46: &'_ mut i16; // anonymous local
    let _47: &'_ mut [i16]; // anonymous local
    let _48: &'_ mut i16; // anonymous local
    let _49: &'_ [u8]; // anonymous local
    let _50: &'_ u8; // anonymous local
    let _51: &'_ [u8]; // anonymous local
    let _52: &'_ u8; // anonymous local
    let _53: &'_ [u8]; // anonymous local
    let _54: &'_ u8; // anonymous local

    storage_live(_37)
    storage_live(_44)
    storage_live(sampled_3)
    sampled_3 := const (0 : usize)
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _6 := &*(a_1) with_metadata(copy (a_1.metadata))
    _5 := chunks<'_, u8>[{built_in impl Sized for u8}](move (_6), const (3 : usize))
    storage_dead(_6)
    _4 := {impl IntoIterator for I}::into_iter<Chunks<'2, u8>[{built_in impl Sized for u8}]>[{built_in impl Sized for Chunks<'2, u8>[{built_in impl Sized for u8}]}, {impl Iterator for Chunks<'a, T>[@TraitClause0]}<'2, u8>[{built_in impl Sized for u8}]](move (_5))
    storage_dead(_5)
    storage_live(iter_7)
    iter_7 := move (_4)
    loop {
        storage_live(_8)
        storage_live(_9)
        storage_live(_10)
        _10 := &mut iter_7
        _9 := &two-phase-mut *(_10)
        _8 := {impl Iterator for Chunks<'a, T>[@TraitClause0]}::next<'10, '_, u8>[{built_in impl Sized for u8}](move (_9))
        storage_dead(_9)
        match _8 {
            Option::None => {
                break 0
            },
            Option::Some => {
                storage_live(bytes_11)
                bytes_11 := copy ((_8 as variant Option::Some).0)
                storage_live(b1_12)
                storage_live(_13)
                storage_live(_14)
                _14 := const (0 : usize)
                storage_live(_49)
                _49 := &*(bytes_11) with_metadata(copy (bytes_11.metadata))
                storage_live(_50)
                _50 := @SliceIndexShared<'_, u8>(move (_49), copy (_14))
                _13 := copy (*(_50))
                b1_12 := cast<u8, i16>(move (_13))
                storage_dead(_13)
                storage_dead(_14)
                storage_live(b2_15)
                storage_live(_16)
                storage_live(_17)
                _17 := const (1 : usize)
                storage_live(_51)
                _51 := &*(bytes_11) with_metadata(copy (bytes_11.metadata))
                storage_live(_52)
                _52 := @SliceIndexShared<'_, u8>(move (_51), copy (_17))
                _16 := copy (*(_52))
                b2_15 := cast<u8, i16>(move (_16))
                storage_dead(_16)
                storage_dead(_17)
                storage_live(b3_18)
                storage_live(_19)
                storage_live(_20)
                _20 := const (2 : usize)
                storage_live(_53)
                _53 := &*(bytes_11) with_metadata(copy (bytes_11.metadata))
                storage_live(_54)
                _54 := @SliceIndexShared<'_, u8>(move (_53), copy (_20))
                _19 := copy (*(_54))
                b3_18 := cast<u8, i16>(move (_19))
                storage_dead(_19)
                storage_dead(_20)
                storage_live(d1_21)
                storage_live(_22)
                storage_live(_23)
                storage_live(_24)
                _24 := copy (b2_15)
                _23 := move (_24) & const (15 : i16)
                storage_dead(_24)
                _22 := move (_23) panic.<< const (8 : i32)
                storage_dead(_23)
                storage_live(_25)
                _25 := copy (b1_12)
                d1_21 := move (_22) | move (_25)
                storage_dead(_25)
                storage_dead(_22)
                storage_live(d2_26)
                storage_live(_27)
                storage_live(_28)
                _28 := copy (b3_18)
                _27 := move (_28) panic.<< const (4 : i32)
                storage_dead(_28)
                storage_live(_29)
                storage_live(_30)
                _30 := copy (b2_15)
                _29 := move (_30) panic.>> const (4 : i32)
                storage_dead(_30)
                d2_26 := move (_27) | move (_29)
                storage_dead(_29)
                storage_dead(_27)
                storage_live(_31)
                storage_live(_32)
                _32 := copy (d1_21)
                _31 := move (_32) < copy (FIELD_MODULUS)
                if move (_31) {
                    storage_dead(_32)
                    storage_live(_33)
                    storage_live(_34)
                    _34 := copy (sampled_3)
                    _33 := move (_34) < const (16 : usize)
                    if move (_33) {
                        storage_dead(_34)
                        storage_live(_35)
                        _35 := copy (d1_21)
                        storage_live(_36)
                        _36 := copy (sampled_3)
                        storage_live(_45)
                        _45 := &mut *(result_2) with_metadata(copy (result_2.metadata))
                        storage_live(_46)
                        _46 := @SliceIndexMut<'_, i16>(move (_45), copy (_36))
                        *(_46) := move (_35)
                        storage_dead(_35)
                        storage_dead(_36)
                        _37 := copy (sampled_3) panic.+ const (1 : usize)
                        sampled_3 := move (_37)
                    } else {
                        storage_dead(_34)
                    }
                } else {
                    storage_dead(_32)
                }
                storage_dead(_33)
                storage_dead(_31)
                storage_live(_38)
                storage_live(_39)
                _39 := copy (d2_26)
                _38 := move (_39) < copy (FIELD_MODULUS)
                if move (_38) {
                    storage_dead(_39)
                    storage_live(_40)
                    storage_live(_41)
                    _41 := copy (sampled_3)
                    _40 := move (_41) < const (16 : usize)
                    if move (_40) {
                        storage_dead(_41)
                        storage_live(_42)
                        _42 := copy (d2_26)
                        storage_live(_43)
                        _43 := copy (sampled_3)
                        storage_live(_47)
                        _47 := &mut *(result_2) with_metadata(copy (result_2.metadata))
                        storage_live(_48)
                        _48 := @SliceIndexMut<'_, i16>(move (_47), copy (_43))
                        *(_48) := move (_42)
                        storage_dead(_42)
                        storage_dead(_43)
                        _44 := copy (sampled_3) panic.+ const (1 : usize)
                        sampled_3 := move (_44)
                    } else {
                        storage_dead(_41)
                    }
                } else {
                    storage_dead(_39)
                }
                storage_dead(_40)
                storage_dead(_38)
                storage_dead(d2_26)
                storage_dead(d1_21)
                storage_dead(b3_18)
                storage_dead(b2_15)
                storage_dead(b1_12)
                storage_dead(bytes_11)
                storage_dead(_10)
                storage_dead(_8)
                continue 0
            },
        }
    }
    storage_dead(_10)
    storage_dead(_8)
    storage_dead(iter_7)
    storage_dead(_4)
    _0 := copy (sampled_3)
    storage_dead(sampled_3)
    return
}



