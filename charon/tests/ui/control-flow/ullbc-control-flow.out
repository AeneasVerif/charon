# Final ULLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <opaque>

// Full name: core::clone::impls::{impl Clone for i32}::clone
pub fn {impl Clone for i32}::clone<'_0>(@1: &'_0 i32) -> i32
= <opaque>

// Full name: core::clone::impls::{impl Clone for i32}
impl Clone for i32 {
    parent_clause0 = {built_in impl Sized for i32}
    fn clone<'_0_1> = {impl Clone for i32}::clone<'_0_1>
    non-dyn-compatible
}

// Full name: core::clone::impls::{impl Clone for usize}::clone
pub fn {impl Clone for usize}::clone<'_0>(@1: &'_0 usize) -> usize
= <opaque>

// Full name: core::clone::impls::{impl Clone for usize}
impl Clone for usize {
    parent_clause0 = {built_in impl Sized for usize}
    fn clone<'_0_1> = {impl Clone for usize}::clone<'_0_1>
    non-dyn-compatible
}

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0_1, '_1_1> = core::cmp::PartialEq::eq<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

#[lang_item("cmp_partialeq_eq")]
pub fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,
= <opaque>

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0_1, '_1_1> = core::cmp::PartialOrd::partial_cmp<'_0_1, '_1_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

#[lang_item("cmp_partialord_cmp")]
pub fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 Self, @2: &'_1 Rhs) -> Option<Ordering>[{built_in impl Sized for Ordering}]
where
    [@TraitClause0]: PartialOrd<Self, Rhs>,
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<i32> for i32}::eq
pub fn {impl PartialEq<i32> for i32}::eq<'_0, '_1>(@1: &'_0 i32, @2: &'_1 i32) -> bool
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<i32> for i32}
impl PartialEq<i32> for i32 {
    fn eq<'_0_1, '_1_1> = {impl PartialEq<i32> for i32}::eq<'_0_1, '_1_1>
    vtable: {impl PartialEq<i32> for i32}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialEq<usize> for usize}::eq
pub fn {impl PartialEq<usize> for usize}::eq<'_0, '_1>(@1: &'_0 usize, @2: &'_1 usize) -> bool
= <opaque>

// Full name: core::cmp::impls::{impl PartialEq<usize> for usize}
impl PartialEq<usize> for usize {
    fn eq<'_0_1, '_1_1> = {impl PartialEq<usize> for usize}::eq<'_0_1, '_1_1>
    vtable: {impl PartialEq<usize> for usize}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialOrd<i32> for i32}::partial_cmp
pub fn {impl PartialOrd<i32> for i32}::partial_cmp<'_0, '_1>(@1: &'_0 i32, @2: &'_1 i32) -> Option<Ordering>[{built_in impl Sized for Ordering}]
= <opaque>

// Full name: core::cmp::impls::{impl PartialOrd<i32> for i32}
impl PartialOrd<i32> for i32 {
    parent_clause0 = {impl PartialEq<i32> for i32}
    fn partial_cmp<'_0_1, '_1_1> = {impl PartialOrd<i32> for i32}::partial_cmp<'_0_1, '_1_1>
    vtable: {impl PartialOrd<i32> for i32}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialOrd<usize> for usize}::partial_cmp
pub fn {impl PartialOrd<usize> for usize}::partial_cmp<'_0, '_1>(@1: &'_0 usize, @2: &'_1 usize) -> Option<Ordering>[{built_in impl Sized for Ordering}]
= <opaque>

// Full name: core::cmp::impls::{impl PartialOrd<usize> for usize}
impl PartialOrd<usize> for usize {
    parent_clause0 = {impl PartialEq<usize> for usize}
    fn partial_cmp<'_0_1, '_1_1> = {impl PartialOrd<usize> for usize}::partial_cmp<'_0_1, '_1_1>
    vtable: {impl PartialOrd<usize> for usize}::{vtable}
}

// Full name: core::iter::range::Step
#[lang_item("range_step")]
pub trait Step<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    parent_clause2 : [@TraitClause2]: PartialOrd<Self, Self>
    fn steps_between<'_0_1, '_1_1> = core::iter::range::Step::steps_between<'_0_1, '_1_1, Self>[Self]
    fn forward_checked = core::iter::range::Step::forward_checked<Self>[Self]
    fn backward_checked = core::iter::range::Step::backward_checked<Self>[Self]
    non-dyn-compatible
}

pub fn core::iter::range::Step::steps_between<'_0, '_1, Self>(@1: &'_0 Self, @2: &'_1 Self) -> (usize, Option<usize>[{built_in impl Sized for usize}])
where
    [@TraitClause0]: Step<Self>,
= <opaque>

pub fn core::iter::range::Step::forward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,
= <opaque>

pub fn core::iter::range::Step::backward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,
= <opaque>

// Full name: core::iter::range::{impl Step for usize}::backward_checked
pub fn {impl Step for usize}::backward_checked(@1: usize, @2: usize) -> Option<usize>[{built_in impl Sized for usize}]
= <opaque>

// Full name: core::iter::range::{impl Step for usize}::forward_checked
pub fn {impl Step for usize}::forward_checked(@1: usize, @2: usize) -> Option<usize>[{built_in impl Sized for usize}]
= <opaque>

// Full name: core::iter::range::{impl Step for usize}::steps_between
pub fn {impl Step for usize}::steps_between<'_0, '_1>(@1: &'_0 usize, @2: &'_1 usize) -> (usize, Option<usize>[{built_in impl Sized for usize}])
= <opaque>

// Full name: core::iter::range::{impl Step for usize}
impl Step for usize {
    parent_clause0 = {built_in impl Sized for usize}
    parent_clause1 = {impl Clone for usize}
    parent_clause2 = {impl PartialOrd<usize> for usize}
    fn steps_between<'_0_1, '_1_1> = {impl Step for usize}::steps_between<'_0_1, '_1_1>
    fn forward_checked = {impl Step for usize}::forward_checked
    fn backward_checked = {impl Step for usize}::backward_checked
    non-dyn-compatible
}

// Full name: core::iter::range::{impl Step for i32}::backward_checked
pub fn {impl Step for i32}::backward_checked(@1: i32, @2: usize) -> Option<i32>[{built_in impl Sized for i32}]
= <opaque>

// Full name: core::iter::range::{impl Step for i32}::forward_checked
pub fn {impl Step for i32}::forward_checked(@1: i32, @2: usize) -> Option<i32>[{built_in impl Sized for i32}]
= <opaque>

// Full name: core::iter::range::{impl Step for i32}::steps_between
pub fn {impl Step for i32}::steps_between<'_0, '_1>(@1: &'_0 i32, @2: &'_1 i32) -> (usize, Option<usize>[{built_in impl Sized for usize}])
= <opaque>

// Full name: core::iter::range::{impl Step for i32}
impl Step for i32 {
    parent_clause0 = {built_in impl Sized for i32}
    parent_clause1 = {impl Clone for i32}
    parent_clause2 = {impl PartialOrd<i32> for i32}
    fn steps_between<'_0_1, '_1_1> = {impl Step for i32}::steps_between<'_0_1, '_1_1>
    fn forward_checked = {impl Step for i32}::forward_checked
    fn backward_checked = {impl Step for i32}::backward_checked
    non-dyn-compatible
}

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0_1> = core::iter::traits::iterator::Iterator::next<'_0_1, Self>[Self]
    vtable: core::iter::traits::iterator::Iterator::{vtable}<Self::Item>
}

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}::next
pub fn {impl Iterator for Range<A>[@TraitClause0]}::next<'_0, A>(@1: &'_0 mut Range<A>[@TraitClause0]) -> Option<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,
= <opaque>

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}
impl<A> Iterator for Range<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,
{
    parent_clause0 = {built_in impl MetaSized for Range<A>[@TraitClause0]}
    parent_clause1 = @TraitClause0
    type Item = A
    fn next<'_0_1> = {impl Iterator for Range<A>[@TraitClause0]}::next<'_0_1, A>[@TraitClause0, @TraitClause1]
    vtable: {impl Iterator for Range<A>[@TraitClause0]}::{vtable}<A>[@TraitClause0, @TraitClause1]
}

// Full name: core::iter::traits::collect::{impl IntoIterator for I}::into_iter
pub fn {impl IntoIterator for I}::into_iter<I>(@1: I) -> I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
= <opaque>

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut Self) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    bb0: {
        _0 = ();
        return;
    }
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::nested_loops_enum
pub fn nested_loops_enum(@1: usize, @2: usize) -> usize
{
    let _0: usize; // return
    let step_out_1: usize; // arg #1
    let step_in_2: usize; // arg #2
    let s_3: usize; // local
    let _4: Range<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _5: Range<i32>[{built_in impl Sized for i32}]; // anonymous local
    let iter_6: Range<i32>[{built_in impl Sized for i32}]; // local
    let _7: Option<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _8: &'0 mut Range<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _9: &'0 mut Range<i32>[{built_in impl Sized for i32}]; // anonymous local
    let _10: isize; // anonymous local
    let _11: usize; // anonymous local
    let _12: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _13: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _14: usize; // anonymous local
    let iter_15: Range<usize>[{built_in impl Sized for usize}]; // local
    let _16: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _17: &'1 mut Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _18: &'1 mut Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _19: isize; // anonymous local
    let _20: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _21: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _22: usize; // anonymous local
    let iter_23: Range<usize>[{built_in impl Sized for usize}]; // local
    let _24: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _25: &'1 mut Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _26: &'1 mut Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _27: isize; // anonymous local
    let _28: usize; // anonymous local
    let _29: bool; // anonymous local
    let _30: usize; // anonymous local

    bb0: {
        storage_live(_10);
        storage_live(_11);
        storage_live(_19);
        storage_live(_27);
        storage_live(_28);
        storage_live(s_3);
        s_3 = const 0 : usize;
        storage_live(_4);
        storage_live(_5);
        _5 = Range { start: const 0 : i32, end: const 128 : i32 };
        _4 = {impl IntoIterator for I}::into_iter<Range<i32>[{built_in impl Sized for i32}]>[{built_in impl Sized for Range<i32>[{built_in impl Sized for i32}]}, {impl Iterator for Range<A>[@TraitClause0]}<i32>[{built_in impl Sized for i32}, {impl Step for i32}]](move _5) -> bb2 (unwind: bb1);
    }

    bb1: {
        unwind_continue;
    }

    bb2: {
        storage_dead(_5);
        storage_live(iter_6);
        iter_6 = move _4;
        goto bb3;
    }

    bb3: {
        storage_live(_7);
        storage_live(_8);
        storage_live(_9);
        _9 = &mut iter_6;
        _8 = &two-phase-mut (*_9);
        _7 = {impl Iterator for Range<A>[@TraitClause0]}::next<'3, i32>[{built_in impl Sized for i32}, {impl Step for i32}](move _8) -> bb4 (unwind: bb1);
    }

    bb4: {
        storage_dead(_8);
        _10 = @discriminant(_7);
        switch move _10 -> 0 : isize: bb5, 1 : isize: bb6, otherwise: bb7;
    }

    bb5: {
        storage_dead(_9);
        storage_dead(_7);
        storage_dead(iter_6);
        storage_dead(_4);
        storage_live(_12);
        storage_live(_13);
        storage_live(_14);
        _14 = copy step_out_1;
        _13 = Range { start: const 0 : usize, end: move _14 };
        storage_dead(_14);
        _12 = {impl IntoIterator for I}::into_iter<Range<usize>[{built_in impl Sized for usize}]>[{built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl Iterator for Range<A>[@TraitClause0]}<usize>[{built_in impl Sized for usize}, {impl Step for usize}]](move _13) -> bb8 (unwind: bb1);
    }

    bb6: {
        _11 = copy s_3 panic.+ const 1 : usize;
        s_3 = move _11;
        storage_dead(_9);
        storage_dead(_7);
        goto bb3;
    }

    bb7: {
        undefined_behavior;
    }

    bb8: {
        storage_dead(_13);
        storage_live(iter_15);
        iter_15 = move _12;
        goto bb9;
    }

    bb9: {
        storage_live(_16);
        storage_live(_17);
        storage_live(_18);
        _18 = &mut iter_15;
        _17 = &two-phase-mut (*_18);
        _16 = {impl Iterator for Range<A>[@TraitClause0]}::next<'5, usize>[{built_in impl Sized for usize}, {impl Step for usize}](move _17) -> bb10 (unwind: bb1);
    }

    bb10: {
        storage_dead(_17);
        _19 = @discriminant(_16);
        switch move _19 -> 0 : isize: bb11, 1 : isize: bb12, otherwise: bb13;
    }

    bb11: {
        // Test comment
        storage_dead(_18);
        storage_dead(_16);
        storage_dead(iter_15);
        storage_dead(_12);
        _0 = copy s_3;
        storage_dead(s_3);
        return;
    }

    bb12: {
        storage_live(_20);
        storage_live(_21);
        storage_live(_22);
        _22 = copy step_in_2;
        _21 = Range { start: const 0 : usize, end: move _22 };
        storage_dead(_22);
        _20 = {impl IntoIterator for I}::into_iter<Range<usize>[{built_in impl Sized for usize}]>[{built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl Iterator for Range<A>[@TraitClause0]}<usize>[{built_in impl Sized for usize}, {impl Step for usize}]](move _21) -> bb14 (unwind: bb1);
    }

    bb13: {
        undefined_behavior;
    }

    bb14: {
        storage_dead(_21);
        storage_live(iter_23);
        iter_23 = move _20;
        goto bb15;
    }

    bb15: {
        storage_live(_24);
        storage_live(_25);
        storage_live(_26);
        _26 = &mut iter_23;
        _25 = &two-phase-mut (*_26);
        _24 = {impl Iterator for Range<A>[@TraitClause0]}::next<'7, usize>[{built_in impl Sized for usize}, {impl Step for usize}](move _25) -> bb16 (unwind: bb1);
    }

    bb16: {
        storage_dead(_25);
        _27 = @discriminant(_24);
        switch move _27 -> 0 : isize: bb17, 1 : isize: bb18, otherwise: bb19;
    }

    bb17: {
        storage_dead(_26);
        storage_dead(_24);
        storage_dead(iter_23);
        storage_dead(_20);
        storage_dead(_18);
        storage_dead(_16);
        goto bb9;
    }

    bb18: {
        _28 = copy s_3 panic.+ const 1 : usize;
        s_3 = move _28;
        storage_live(_29);
        storage_live(_30);
        _30 = copy s_3;
        _29 = move _30 >= const 1 : usize;
        if move _29 -> bb20 else -> bb21;
    }

    bb19: {
        undefined_behavior;
    }

    bb20: {
        storage_dead(_30);
        storage_dead(_29);
        storage_dead(_26);
        storage_dead(_24);
        goto bb15;
    }

    bb21: {
        storage_dead(_30);
        panic(core::panicking::panic);
    }
}



