# Final LLBC before serialization:

#[lang_item("sized")]
pub trait core::marker::Sized<Self>

fn core::intrinsics::copy_nonoverlapping::precondition_check(@1: *const (), @2: *mut (), @3: usize, @4: usize, @5: usize)

#[lang_item("ptr_copy_nonoverlapping")]
pub unsafe fn core::intrinsics::copy_nonoverlapping<T>(@1: *const T, @2: *mut T, @3: usize)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: (); // return
    let src@1: *const T; // arg #1
    let dst@2: *mut T; // arg #2
    let count@3: usize; // arg #3
    let @4: bool; // anonymous local
    let @5: (); // anonymous local
    let @6: *const (); // anonymous local
    let @7: *mut (); // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local
    let @10: (); // anonymous local

    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@4)
    @4 := ub_checks<bool>
    if move (@4) {
        storage_live(@6)
        @6 := cast<*const T, *const ()>(copy (src@1))
        storage_live(@7)
        @7 := cast<*mut T, *mut ()>(copy (dst@2))
        storage_live(@8)
        @8 := size_of<T>
        storage_live(@9)
        @9 := align_of<T>
        @5 := core::intrinsics::copy_nonoverlapping::precondition_check(move (@6), move (@7), move (@8), move (@9), copy (count@3))
        storage_dead(@9)
        storage_dead(@8)
        storage_dead(@7)
        storage_dead(@6)
    }
    else {
    }
    storage_dead(@4)
    @10 := @CopyNonOverlapping<T>(copy (src@1), copy (dst@2), copy (count@3))
    @0 := ()
    return
}

pub unsafe fn core::ptr::const_ptr::{*const T}::copy_to_nonoverlapping<T>(@1: *const T, @2: *mut T, @3: usize)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: (); // return
    let self@1: *const T; // arg #1
    let dest@2: *mut T; // arg #2
    let count@3: usize; // arg #3

    @0 := core::intrinsics::copy_nonoverlapping<T>[@TraitClause0](move (self@1), move (dest@2), move (count@3))
    @0 := ()
    return
}

fn test_crate::main()
{
    let @0: (); // return
    let src@1: u32; // local
    let src_ptr@2: *const u32; // local
    let @3: &'_ (u32); // anonymous local
    let dst@4: u32; // local
    let dst_ptr@5: *mut u32; // local
    let @6: &'_ mut (u32); // anonymous local
    let @7: (); // anonymous local
    let @8: *const u32; // anonymous local
    let @9: *mut u32; // anonymous local

    storage_live(src@1)
    src@1 := const (1 : u32)
    storage_live(src_ptr@2)
    storage_live(@3)
    @3 := &src@1
    src_ptr@2 := &raw const *(@3)
    storage_dead(@3)
    storage_live(dst@4)
    dst@4 := const (2 : u32)
    storage_live(dst_ptr@5)
    storage_live(@6)
    @6 := &mut dst@4
    dst_ptr@5 := &raw mut *(@6)
    storage_dead(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (src_ptr@2)
    storage_live(@9)
    @9 := copy (dst_ptr@5)
    @7 := core::ptr::const_ptr::{*const T}::copy_to_nonoverlapping<u32>[core::marker::Sized<u32>](move (@8), move (@9), const (1 : usize))
    storage_dead(@9)
    storage_dead(@8)
    storage_dead(@7)
    @0 := ()
    storage_dead(dst_ptr@5)
    storage_dead(dst@4)
    storage_dead(src_ptr@2)
    storage_dead(src@1)
    @0 := ()
    return
}



