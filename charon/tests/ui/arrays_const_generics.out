# Final LLBC before serialization:

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::index_array_generic
pub fn index_array_generic<const N : usize>(@1: [u32; N], @2: usize) -> u32
{
    let @0: u32; // return
    let s@1: [u32; N]; // arg #1
    let i@2: usize; // arg #2
    let @3: usize; // anonymous local
    let @4: &'_ [u32; N]; // anonymous local
    let @5: &'_ u32; // anonymous local

    storage_live(@3)
    @3 := copy (i@2)
    storage_live(@4)
    @4 := &s@1
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, N>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(@3)
    return
}

// Full name: test_crate::index_array_generic_call
pub fn index_array_generic_call<const N : usize>(@1: [u32; N], @2: usize) -> u32
{
    let @0: u32; // return
    let s@1: [u32; N]; // arg #1
    let i@2: usize; // arg #2
    let @3: [u32; N]; // anonymous local
    let @4: usize; // anonymous local

    storage_live(@3)
    @3 := copy (s@1)
    storage_live(@4)
    @4 := copy (i@2)
    @0 := index_array_generic<N>(move (@3), move (@4))
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::const_gen_ret
pub fn const_gen_ret<const N : usize>() -> usize
{
    let @0: usize; // return

    @0 := const (N)
    return
}

// Full name: test_crate::init_array_variable_len
pub fn init_array_variable_len<const LEN : usize>() -> [u8; LEN]
{
    let @0: [u8; LEN]; // return

    @0 := @ArrayRepeat<'_, u8, LEN>(const (0 : u8))
    return
}



