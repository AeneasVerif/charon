# Final LLBC before serialization:

// Full name: core::marker::MetaSized::<&'_ u32>
#[lang_item("meta_sized")]
pub trait MetaSized::<&'_ u32>

// Full name: core::marker::Sized::<&'_ u32>
#[lang_item("sized")]
pub trait Sized::<&'_ u32>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<&'_ u32>
    non-dyn-compatible
}

// Full name: core::option::Option::<&'_ u32>
#[lang_item("Option")]
pub enum Option::<&'_ u32> {
  None,
  Some(&'_ u32),
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::foo
fn foo<'_0>(@1: &'_0 u32) -> Option::<&'_ u32>
{
    let _0: Option::<&'_ u32>; // return
    let x_1: &'0 u32; // arg #1
    let _2: &'0 u32; // anonymous local

    storage_live(_2)
    _2 = &*(x_1)
    _0 = Option::<&'_ u32>::Some { 0: move (_2) }
    storage_dead(_2)
    return
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let _1: Option::<&'_ u32>; // anonymous local
    let _2: &'0 u32; // anonymous local
    let _3: &'0 u32; // anonymous local
    let _4: &'0 u32; // anonymous local
    let _5: &'_ u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_5)
    storage_live(_6)
    _6 = const (42 : u32)
    _5 = &_6
    storage_live(_4)
    _0 = ()
    storage_live(_1)
    storage_live(_2)
    storage_live(_3)
    _4 = move (_5)
    _3 = &*(_4)
    _2 = &*(_3)
    _1 = foo<'_>(move (_2))
    storage_dead(_2)
    storage_dead(_3)
    storage_dead(_1)
    _0 = ()
    return
}



