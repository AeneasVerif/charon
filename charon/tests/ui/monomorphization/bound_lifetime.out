# Final LLBC before serialization:

// Full name: core::marker::MetaSized::<&'_ (u32)>
#[lang_item("meta_sized")]
pub trait MetaSized::<&'_ (u32)>

// Full name: core::marker::Sized::<&'_ (u32)>
#[lang_item("sized")]
pub trait Sized::<&'_ (u32)>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<&'_ (u32)>
    non-dyn-compatible
}

// Full name: core::option::Option::<&'_ (u32)>
#[lang_item("Option")]
pub enum Option::<&'_ (u32)> {
  None,
  Some(&'_ (u32)),
}

// Full name: test_crate::foo
fn foo<'_0>(@1: &'_0 (u32)) -> Option::<&'_ (u32)>
{
    let @0: Option::<&'_ (u32)>; // return
    let x@1: &'_ (u32); // arg #1
    let @2: &'_ (u32); // anonymous local
    let @3: (); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := ()
    @2 := &(*(x@1), move (@3))
    @0 := Option::<&'_ (u32)>::Some { 0: move (@2) }
    storage_dead(@2)
    return
}

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let @1: Option::<&'_ (u32)>; // anonymous local
    let @2: &'_ (u32); // anonymous local
    let @3: &'_ (u32); // anonymous local
    let @4: u32; // anonymous local
    let @5: (); // anonymous local
    let @6: (); // anonymous local

    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := const (42 : u32)
    storage_live(@6)
    @6 := ()
    @3 := &(@4, move (@6))
    storage_live(@5)
    @5 := ()
    @2 := &(*(@3), move (@5))
    @1 := foo<'_>(move (@2))
    storage_dead(@2)
    storage_dead(@4)
    storage_dead(@3)
    storage_dead(@1)
    @0 := ()
    @0 := ()
    return
}



