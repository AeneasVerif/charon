# Final LLBC before serialization:

// Full name: core::option::Option::<&'_ u32>
#[lang_item("Option")]
pub enum Option::<&'_ u32> {
  None,
  Some(&'_ u32),
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::foo
fn foo<'_0>(@1: &'_0 u32) -> Option::<&'_ u32>
{
    let _0: Option::<&'_ u32>; // return
    let x_1: &'1 u32; // arg #1
    let _2: &'2 u32; // anonymous local

    storage_live(_2)
    _2 = &(*x_1)
    _0 = Option::<&'_ u32>::Some { 0: move _2 }
    storage_dead(_2)
    return
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let _1: Option::<&'_ u32>; // anonymous local
    let _2: &'1 u32; // anonymous local
    let _3: &'2 u32; // anonymous local
    let _4: &'3 u32; // anonymous local
    let _5: &'7 u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_5)
    storage_live(_6)
    _6 = const 42 : u32
    _5 = &_6
    storage_live(_4)
    _0 = ()
    storage_live(_1)
    storage_live(_2)
    storage_live(_3)
    _4 = move _5
    _3 = &(*_4)
    _2 = &(*_3)
    _1 = foo<'6>(move _2)
    storage_dead(_2)
    storage_dead(_3)
    storage_dead(_1)
    _0 = ()
    return
}



