# Final LLBC before serialization:

// Full name: core::marker::MetaSized::<&'_ (u32)>
#[lang_item("meta_sized")]
pub trait MetaSized::<&'_ (u32)>

// Full name: core::marker::Sized::<&'_ (u32)>
#[lang_item("sized")]
pub trait Sized::<&'_ (u32)>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<&'_ (u32)>
    non-dyn-compatible
}

// Full name: core::option::Option::<&'_ (u32)>
#[lang_item("Option")]
pub enum Option::<&'_ (u32)> {
  None,
  Some(&'_ (u32)),
}

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::foo
fn foo<'_0>(@1: &'_0 (u32)) -> Option::<&'_ (u32)>
{
    let @0: Option::<&'_ (u32)>; // return
    let x@1: &'0 (u32); // arg #1
    let @2: &'0 (u32); // anonymous local

    storage_live(@2)
    @2 := &*(x@1)
    @0 := Option::<&'_ (u32)>::Some { 0: move (@2) }
    storage_dead(@2)
    return
}

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let @1: Option::<&'_ (u32)>; // anonymous local
    let @2: &'0 (u32); // anonymous local
    let @3: &'0 (u32); // anonymous local
    let @4: &'0 (u32); // anonymous local
    let @5: &'_ (u32); // anonymous local
    let @6: u32; // anonymous local

    storage_live(@5)
    storage_live(@6)
    @6 := const (42 : u32)
    @5 := &@6
    storage_live(@4)
    @0 := ()
    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    @4 := move (@5)
    @3 := &*(@4)
    @2 := &*(@3)
    @1 := foo<'_>(move (@2))
    storage_dead(@2)
    storage_dead(@3)
    storage_dead(@1)
    @0 := ()
    return
}



