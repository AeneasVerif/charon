# Final LLBC before serialization:

// Full name: core::marker::MetaSized::<u8>
#[lang_item("meta_sized")]
pub trait MetaSized::<u8>

// Full name: core::marker::Sized::<u8>
#[lang_item("sized")]
pub trait Sized::<u8>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<u8>
    non-dyn-compatible
}

// Full name: core::marker::MetaSized::<char>
#[lang_item("meta_sized")]
pub trait MetaSized::<char>

// Full name: core::marker::Sized::<char>
#[lang_item("sized")]
pub trait Sized::<char>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<char>
    non-dyn-compatible
}

// Full name: core::marker::MetaSized::<u32>
#[lang_item("meta_sized")]
pub trait MetaSized::<u32>

// Full name: core::marker::Sized::<u32>
#[lang_item("sized")]
pub trait Sized::<u32>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<u32>
    non-dyn-compatible
}

// Full name: core::marker::MetaSized::<for<'_0_1> foo::<u32><'_0_1>>
#[lang_item("meta_sized")]
pub trait MetaSized::<for<'_0_1> foo::<u32><'_0_1>>

// Full name: core::marker::Sized::<for<'_0_1> foo::<u32><'_0_1>>
#[lang_item("sized")]
pub trait Sized::<for<'_0_1> foo::<u32><'_0_1>>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<for<'_0_1> foo::<u32><'_0_1>>
    non-dyn-compatible
}

// Full name: core::marker::MetaSized::<(&'_ (u32))>
#[lang_item("meta_sized")]
pub trait MetaSized::<(&'_ (u32))>

// Full name: core::marker::Sized::<(&'_ (u32))>
#[lang_item("sized")]
pub trait Sized::<(&'_ (u32))>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<(&'_ (u32))>
    non-dyn-compatible
}

// Full name: test_crate::foo::<u32>
fn foo::<u32><'_0>(@1: &'_0 (u32))
{
    let @0: (); // return
    let x@1: &'_ (u32); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: core::marker::Destruct::<for<'_0_1> foo::<u32><'_0_1>>
#[lang_item("destruct")]
pub trait Destruct::<for<'_0_1> foo::<u32><'_0_1>>
{
    fn drop_in_place = drop_in_place::<for<'_0_1> foo::<u32><'_0_1>>
    vtable: core::marker::Destruct::{vtable}::<for<'_0_1> foo::<u32><'_0_1>>
}

// Full name: core::marker::Destruct::drop_in_place::<for<'_0_1> foo::<u32><'_0_1>>
fn drop_in_place::<for<'_0_1> foo::<u32><'_0_1>>(@1: *mut for<'_0_1> foo::<u32><'_0_1>)
= <opaque>

// Full name: core::marker::Tuple::<(&'_ (u32))>
#[lang_item("tuple_trait")]
pub trait Tuple::<(&'_ (u32))>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<(&'_ (u32))>
    vtable: core::marker::Tuple::{vtable}::<(&'_ (u32))>
}

// Full name: core::ops::function::FnOnce::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
#[lang_item("fn_once")]
pub trait FnOnce::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<for<'_0_1> foo::<u32><'_0_1>>
    parent_clause1 : [@TraitClause1]: Sized::<(&'_ (u32))>
    parent_clause2 : [@TraitClause2]: Tuple::<(&'_ (u32))>
    fn call_once = call_once::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
    vtable: core::ops::function::FnOnce::{vtable}::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))><()>
}

// Full name: core::ops::function::FnMut::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
#[lang_item("fn_mut")]
pub trait FnMut::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<for<'_0_1> foo::<u32><'_0_1>>
    parent_clause1 : [@TraitClause1]: FnOnce::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
    parent_clause2 : [@TraitClause2]: Sized::<(&'_ (u32))>
    parent_clause3 : [@TraitClause3]: Tuple::<(&'_ (u32))>
    fn call_mut<'_0_1> = call_mut::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))><'_0_1>
    vtable: core::ops::function::FnMut::{vtable}::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))><()>
}

// Full name: core::ops::function::Fn::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
#[lang_item("r#fn")]
pub trait Fn::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<for<'_0_1> foo::<u32><'_0_1>>
    parent_clause1 : [@TraitClause1]: FnMut::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
    parent_clause2 : [@TraitClause2]: Sized::<(&'_ (u32))>
    parent_clause3 : [@TraitClause3]: Tuple::<(&'_ (u32))>
    fn call<'_0_1> = call::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))><'_0_1>
    vtable: core::ops::function::Fn::{vtable}::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))><()>
}

// Full name: core::ops::function::Fn::call
pub fn call<'_0>(@1: &'_0 (for<'_0_1> foo::<u32><'_0_1>), @2: (&'_ (u32)))
= <opaque>

// Full name: core::ops::function::Fn::call::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
pub fn call::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))><'_0>(@1: &'_0 (for<'_0_1> foo::<u32><'_0_1>), @2: (&'_ (u32)))
= <opaque>

// Full name: core::ops::function::FnMut::call_mut::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
pub fn call_mut::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))><'_0>(@1: &'_0 mut (for<'_0_1> foo::<u32><'_0_1>), @2: (&'_ (u32)))
= <opaque>

// Full name: core::ops::function::FnOnce::call_once::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>
pub fn call_once::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>(@1: for<'_0_1> foo::<u32><'_0_1>, @2: (&'_ (u32)))
= <opaque>

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun1()

// Full name: test_crate::foo::<u8>
fn foo::<u8><'_0>(@1: &'_0 (u8))
{
    let @0: (); // return
    let x@1: &'_ (u8); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::foo::<char>
fn foo::<char><'_0>(@1: &'_0 (char))
{
    let @0: (); // return
    let x@1: &'_ (char); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::takes_closure::<for<'_0_1> foo::<u32><'_0_1>>
fn takes_closure::<for<'_0_1> foo::<u32><'_0_1>>(@1: for<'_0_1> foo::<u32><'_0_1>)
{
    let @0: (); // return
    let c@1: for<'_0_1> foo::<u32><'_0_1>; // arg #1
    let @2: &'_ (for<'_0_1> foo::<u32><'_0_1>); // anonymous local
    let @3: (&'_ (u32)); // anonymous local
    let @4: &'_ (u32); // anonymous local
    let @5: &'_ (u32); // anonymous local
    let @6: &'_ (u32); // anonymous local
    let @7: &'_ (u32); // anonymous local
    let @8: u32; // anonymous local

    storage_live(@7)
    storage_live(@8)
    @8 := const (13 : u32)
    @7 := &@8
    storage_live(@6)
    @0 := ()
    storage_live(@2)
    @2 := &c@1
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @6 := move (@7)
    @5 := &*(@6)
    @4 := &*(@5)
    @3 := (move (@4))
    @0 := {built_in impl Fn::<for<'_0_1> foo::<u32><'_0_1>, (&'_ (u32))>}::call<'_>(move (@2), move (@3))
    storage_dead(@4)
    storage_dead(@3)
    storage_dead(@2)
    storage_dead(@5)
    return
}

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let fooint1@1: fn<'_0_1>(&'_0_1 (u8)); // local
    let fooint2@2: fn<'_0_1>(&'_0_1 (u8)); // local
    let foochar@3: fn<'_0_1>(&'_0_1 (char)); // local
    let a@4: u8; // local
    let @5: (); // anonymous local
    let @6: fn<'_0_1>(&'_0_1 (u8)); // anonymous local
    let @7: &'_ (u8); // anonymous local
    let @8: &'_ (u8); // anonymous local
    let b@9: u8; // local
    let @10: (); // anonymous local
    let @11: fn<'_0_1>(&'_0_1 (u8)); // anonymous local
    let @12: &'_ (u8); // anonymous local
    let @13: &'_ (u8); // anonymous local
    let @14: (); // anonymous local
    let @15: fn<'_0_1>(&'_0_1 (u8)); // anonymous local
    let @16: &'_ (u8); // anonymous local
    let @17: &'_ (u8); // anonymous local
    let @18: (); // anonymous local
    let @19: fn<'_0_1>(&'_0_1 (u8)); // anonymous local
    let @20: &'_ (u8); // anonymous local
    let @21: &'_ (u8); // anonymous local
    let @22: (); // anonymous local
    let @23: fn<'_0_1>(&'_0_1 (char)); // anonymous local
    let @24: &'_ (char); // anonymous local
    let @25: &'_ (char); // anonymous local
    let @26: (); // anonymous local
    let @27: &'_ (char); // anonymous local
    let @28: &'_ (char); // anonymous local
    let @29: char; // anonymous local

    storage_live(@27)
    @0 := ()
    storage_live(fooint1@1)
    fooint1@1 := cast<for<'_0_1> foo::<u8><'_0_1>, fn<'_0_1>(&'_0_1 (u8))>(const (foo::<u8><'_>))
    storage_live(fooint2@2)
    fooint2@2 := cast<for<'_0_1> foo::<u8><'_0_1>, fn<'_0_1>(&'_0_1 (u8))>(const (foo::<u8><'_>))
    storage_live(foochar@3)
    foochar@3 := cast<for<'_0_1> foo::<char><'_0_1>, fn<'_0_1>(&'_0_1 (char))>(const (foo::<char><'_>))
    storage_live(a@4)
    a@4 := const (11 : u8)
    storage_live(@5)
    storage_live(@6)
    @6 := copy (fooint1@1)
    storage_live(@7)
    storage_live(@8)
    @8 := &a@4
    @7 := &*(@8)
    @5 := (move (@6))(move (@7))
    storage_dead(@7)
    storage_dead(@6)
    storage_dead(@8)
    storage_dead(@5)
    storage_live(b@9)
    b@9 := const (12 : u8)
    storage_live(@10)
    storage_live(@11)
    @11 := copy (fooint1@1)
    storage_live(@12)
    storage_live(@13)
    @13 := &a@4
    @12 := &*(@13)
    @10 := (move (@11))(move (@12))
    storage_dead(@12)
    storage_dead(@11)
    storage_dead(@13)
    storage_dead(@10)
    storage_live(@14)
    storage_live(@15)
    @15 := copy (fooint1@1)
    storage_live(@16)
    storage_live(@17)
    @17 := &b@9
    @16 := &*(@17)
    @14 := (move (@15))(move (@16))
    storage_dead(@16)
    storage_dead(@15)
    storage_dead(@17)
    storage_dead(@14)
    storage_live(@18)
    storage_live(@19)
    @19 := copy (fooint2@2)
    storage_live(@20)
    storage_live(@21)
    @21 := &b@9
    @20 := &*(@21)
    @18 := (move (@19))(move (@20))
    storage_live(@28)
    storage_live(@29)
    @29 := const (x)
    @28 := &@29
    storage_dead(@20)
    storage_dead(@19)
    storage_dead(@21)
    storage_dead(@18)
    storage_live(@22)
    storage_live(@23)
    @23 := copy (foochar@3)
    storage_live(@24)
    storage_live(@25)
    @27 := move (@28)
    @25 := &*(@27)
    @24 := &*(@25)
    @22 := (move (@23))(move (@24))
    storage_dead(@24)
    storage_dead(@23)
    storage_dead(@25)
    storage_dead(@22)
    storage_live(@26)
    @26 := takes_closure::<for<'_0_1> foo::<u32><'_0_1>>(const (foo::<u32><'_>))
    storage_dead(@26)
    @0 := ()
    storage_dead(b@9)
    storage_dead(a@4)
    storage_dead(foochar@3)
    storage_dead(fooint2@2)
    storage_dead(fooint1@1)
    return
}



