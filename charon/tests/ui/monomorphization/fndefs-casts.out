# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    vtable: core::ops::function::FnOnce::{vtable}
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    vtable: core::ops::function::FnMut::{vtable}
}

// Full name: core::ops::function::Fn
#[lang_item("fn")]
pub trait Fn<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnMut<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    vtable: core::ops::function::Fn::{vtable}
}

// Full name: test_crate::foo::<u32>
fn foo::<u32><'a>(@1: &'a u32)
{
    let _0: (); // return
    let x_1: &'1 u32; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: core::ops::function::Fn::call
pub fn call<'_0>(@1: &'_0 for<'a> foo::<u32><'a>, @2: (&'_ u32,))
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun1()

// Full name: test_crate::foo::<u8>
fn foo::<u8><'a>(@1: &'a u8)
{
    let _0: (); // return
    let x_1: &'1 u8; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::foo::<char>
fn foo::<char><'a>(@1: &'a char)
{
    let _0: (); // return
    let x_1: &'1 char; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::takes_closure::<for<'a> foo::<u32><'a>>
fn takes_closure::<for<'a> foo::<u32><'a>>(@1: for<'a> foo::<u32><'a>)
{
    let _0: (); // return
    let c_1: for<'a> foo::<u32><'a>; // arg #1
    let _2: &'1 for<'a> foo::<u32><'a>; // anonymous local
    let _3: (&'4 u32,); // anonymous local
    let _4: &'5 u32; // anonymous local
    let _5: &'6 u32; // anonymous local
    let _6: &'7 u32; // anonymous local
    let _7: &'64 u32; // anonymous local
    let _8: u32; // anonymous local

    storage_live(_7)
    storage_live(_8)
    _8 = const 13 : u32
    _7 = &_8
    storage_live(_6)
    _0 = ()
    storage_live(_2)
    _2 = &c_1
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _6 = move _7
    _5 = &(*_6)
    _4 = &(*_5)
    _3 = (move _4,)
    _0 = {built_in impl Fn<(&'13 u32,)> for for<'a> foo::<u32><'a>}::call<'61>(move _2, move _3)
    storage_dead(_4)
    storage_dead(_3)
    storage_dead(_2)
    storage_dead(_5)
    return
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let fooint1_1: fn<'_0_1>(&'_0_1 u8); // local
    let fooint2_2: fn<'_0_1>(&'_0_1 u8); // local
    let foochar_3: fn<'_0_1>(&'_0_1 char); // local
    let a_4: u8; // local
    let _5: (); // anonymous local
    let _6: fn<'_0_1>(&'_0_1 u8); // anonymous local
    let _7: &'1 u8; // anonymous local
    let _8: &'2 u8; // anonymous local
    let b_9: u8; // local
    let _10: (); // anonymous local
    let _11: fn<'_0_1>(&'_0_1 u8); // anonymous local
    let _12: &'3 u8; // anonymous local
    let _13: &'4 u8; // anonymous local
    let _14: (); // anonymous local
    let _15: fn<'_0_1>(&'_0_1 u8); // anonymous local
    let _16: &'5 u8; // anonymous local
    let _17: &'6 u8; // anonymous local
    let _18: (); // anonymous local
    let _19: fn<'_0_1>(&'_0_1 u8); // anonymous local
    let _20: &'7 u8; // anonymous local
    let _21: &'8 u8; // anonymous local
    let _22: (); // anonymous local
    let _23: fn<'_0_1>(&'_0_1 char); // anonymous local
    let _24: &'10 char; // anonymous local
    let _25: &'11 char; // anonymous local
    let _26: (); // anonymous local
    let _27: &'12 char; // anonymous local
    let _28: &'25 char; // anonymous local
    let _29: char; // anonymous local

    storage_live(_27)
    _0 = ()
    storage_live(fooint1_1)
    fooint1_1 = cast<for<'a> foo::<u8><'a>, fn<'_0_1>(&'_0_1 u8)>(const foo::<u8><'15>)
    storage_live(fooint2_2)
    fooint2_2 = cast<for<'a> foo::<u8><'a>, fn<'_0_1>(&'_0_1 u8)>(const foo::<u8><'17>)
    storage_live(foochar_3)
    foochar_3 = cast<for<'a> foo::<char><'a>, fn<'_0_1>(&'_0_1 char)>(const foo::<char><'20>)
    storage_live(a_4)
    a_4 = const 11 : u8
    storage_live(_5)
    storage_live(_6)
    _6 = copy fooint1_1
    storage_live(_7)
    storage_live(_8)
    _8 = &a_4
    _7 = &(*_8)
    _5 = (move _6)(move _7)
    storage_dead(_7)
    storage_dead(_6)
    storage_dead(_8)
    storage_dead(_5)
    storage_live(b_9)
    b_9 = const 12 : u8
    storage_live(_10)
    storage_live(_11)
    _11 = copy fooint1_1
    storage_live(_12)
    storage_live(_13)
    _13 = &a_4
    _12 = &(*_13)
    _10 = (move _11)(move _12)
    storage_dead(_12)
    storage_dead(_11)
    storage_dead(_13)
    storage_dead(_10)
    storage_live(_14)
    storage_live(_15)
    _15 = copy fooint1_1
    storage_live(_16)
    storage_live(_17)
    _17 = &b_9
    _16 = &(*_17)
    _14 = (move _15)(move _16)
    storage_dead(_16)
    storage_dead(_15)
    storage_dead(_17)
    storage_dead(_14)
    storage_live(_18)
    storage_live(_19)
    _19 = copy fooint2_2
    storage_live(_20)
    storage_live(_21)
    _21 = &b_9
    _20 = &(*_21)
    _18 = (move _19)(move _20)
    storage_live(_28)
    storage_live(_29)
    _29 = const x
    _28 = &_29
    storage_dead(_20)
    storage_dead(_19)
    storage_dead(_21)
    storage_dead(_18)
    storage_live(_22)
    storage_live(_23)
    _23 = copy foochar_3
    storage_live(_24)
    storage_live(_25)
    _27 = move _28
    _25 = &(*_27)
    _24 = &(*_25)
    _22 = (move _23)(move _24)
    storage_dead(_24)
    storage_dead(_23)
    storage_dead(_25)
    storage_dead(_22)
    storage_live(_26)
    _26 = takes_closure::<for<'a> foo::<u32><'a>>(const foo::<u32><'24>)
    storage_dead(_26)
    _0 = ()
    storage_dead(b_9)
    storage_dead(a_4)
    storage_dead(foochar_3)
    storage_dead(fooint2_2)
    storage_dead(fooint1_1)
    return
}



