# Final LLBC before serialization:

// Full name: core::marker::MetaSized::<u8>
#[lang_item("meta_sized")]
pub trait MetaSized::<u8>

// Full name: core::marker::Sized::<u8>
#[lang_item("sized")]
pub trait Sized::<u8>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<u8>
    non-dyn-compatible
}

// Full name: core::marker::MetaSized::<NonNull::<Node::<u8>>>
#[lang_item("meta_sized")]
pub trait MetaSized::<NonNull::<Node::<u8>>>

// Full name: core::marker::Sized::<NonNull::<Node::<u8>>>
#[lang_item("sized")]
pub trait Sized::<NonNull::<Node::<u8>>>
{
    parent_clause0 : [@TraitClause0]: MetaSized::<NonNull::<Node::<u8>>>
    non-dyn-compatible
}

// Full name: core::ptr::non_null::NonNull::<Node::<u8>>
#[lang_item("NonNull")]
pub opaque type NonNull::<Node::<u8>>

// Full name: core::option::Option::<NonNull::<Node::<u8>>>
#[lang_item("Option")]
pub enum Option::<NonNull::<Node::<u8>>> {
  None,
  Some(NonNull::<Node::<u8>>),
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 := ()
    return
}

const UNIT_METADATA: () = @Fun1()

// Full name: test_crate::LinkedList::<u8>
pub struct LinkedList::<u8> {
  head: Option::<NonNull::<Node::<u8>>>,
}

// Full name: test_crate::Node::<u8>
struct Node::<u8> {
  next: Option::<NonNull::<Node::<u8>>>,
  element: u8,
}

// Full name: test_crate::{LinkedList::<u8>}::new::<u8>
fn new::<u8>() -> LinkedList::<u8>
{
    let _0: LinkedList::<u8>; // return
    let _1: Option::<NonNull::<Node::<u8>>>; // anonymous local

    storage_live(_1)
    _1 := Option::<NonNull::<Node::<u8>>>::None {  }
    _0 := LinkedList::<u8> { head: move (_1) }
    storage_dead(_1)
    return
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let list_1: LinkedList::<u8>; // local

    _0 := ()
    storage_live(list_1)
    list_1 := new::<u8>()
    _0 := ()
    storage_dead(list_1)
    return
}



