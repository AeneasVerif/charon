# Final ULLBC before serialization:

// Full name: core::cmp::impls::{impl#0}::eq
pub fn {impl#0}::eq<'_0, '_1>(@1: &'_0 bool, @2: &'_1 bool) -> bool
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    bb0: {
        _0 = ();
        return;
    }
}

const UNIT_METADATA: () = @Fun1()

// Full name: test_crate::do_test::<bool>
fn do_test::<bool>(@1: bool, @2: bool)
{
    let _0: (); // return
    let init_1: bool; // arg #1
    let expected_2: bool; // arg #2
    let _3: bool; // anonymous local
    let _4: &'0 bool; // anonymous local
    let _5: &'0 bool; // anonymous local

    bb0: {
        _0 = ();
        storage_live(_3);
        storage_live(_4);
        _4 = &expected_2;
        storage_live(_5);
        _5 = &init_1;
        _3 = {impl#0}::eq<'3, '4>(move _4, move _5) -> bb1 (unwind: bb2);
    }

    bb1: {
        if move _3 -> bb3 else -> bb4;
    }

    bb2: {
        unwind_continue;
    }

    bb3: {
        storage_dead(_5);
        storage_dead(_4);
        storage_dead(_3);
        _0 = ();
        return;
    }

    bb4: {
        storage_dead(_5);
        storage_dead(_4);
        panic(core::panicking::panic);
    }
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let _1: (); // anonymous local

    bb0: {
        _0 = ();
        storage_live(_1);
        _1 = do_test::<bool>(const true, const true) -> bb1 (unwind: bb2);
    }

    bb1: {
        storage_dead(_1);
        _0 = ();
        return;
    }

    bb2: {
        unwind_continue;
    }
}



