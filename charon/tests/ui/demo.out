# Final LLBC before serialization:

#[lang_item("sized")]
pub trait core::marker::Sized<Self>

pub fn test_crate::choose<'a, T>(@1: bool, @2: &'a mut (T), @3: &'a mut (T)) -> &'a mut (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (T); // return
    let b@1: bool; // arg #1
    let x@2: &'_ mut (T); // arg #2
    let y@3: &'_ mut (T); // arg #3
    let @4: &'_ mut (T); // anonymous local
    let @5: &'_ mut (T); // anonymous local
    let @6: bool; // anonymous local
    let @7: &'_ mut (T); // anonymous local

    storage_live(@7)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := copy (b@1)
    if move (@6) {
        storage_live(@7)
        @7 := &mut *(x@2)
        @5 := &mut *(@7)
        storage_dead(@7)
    }
    else {
        @5 := &mut *(y@3)
    }
    @4 := &mut *(@5)
    storage_dead(@6)
    @0 := &mut *(@4)
    storage_dead(@5)
    storage_dead(@4)
    return
}

pub fn test_crate::mul2_add1(@1: u32) -> u32
{
    let @0: u32; // return
    let x@1: u32; // arg #1
    let @2: u32; // anonymous local
    let @3: u32; // anonymous local
    let @4: u32; // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := copy (x@1)
    storage_live(@4)
    @4 := copy (x@1)
    @2 := copy (@3) + copy (@4)
    storage_dead(@4)
    storage_dead(@3)
    @0 := copy (@2) + const (1 : u32)
    storage_dead(@2)
    return
}

pub fn test_crate::use_mul2_add1(@1: u32, @2: u32) -> u32
{
    let @0: u32; // return
    let x@1: u32; // arg #1
    let y@2: u32; // arg #2
    let @3: u32; // anonymous local
    let @4: u32; // anonymous local
    let @5: u32; // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := copy (x@1)
    @3 := test_crate::mul2_add1(move (@4))
    storage_dead(@4)
    storage_live(@5)
    @5 := copy (y@2)
    @0 := copy (@3) + copy (@5)
    storage_dead(@5)
    storage_dead(@3)
    return
}

pub fn test_crate::incr<'a>(@1: &'a mut (u32))
{
    let @0: (); // return
    let x@1: &'_ mut (u32); // arg #1

    *(x@1) := copy (*(x@1)) + const (1 : u32)
    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::use_incr()
{
    let @0: (); // return
    let x@1: u32; // local
    let @2: (); // anonymous local
    let @3: &'_ mut (u32); // anonymous local
    let @4: &'_ mut (u32); // anonymous local
    let @5: (); // anonymous local
    let @6: &'_ mut (u32); // anonymous local
    let @7: &'_ mut (u32); // anonymous local
    let @8: (); // anonymous local
    let @9: &'_ mut (u32); // anonymous local
    let @10: &'_ mut (u32); // anonymous local

    storage_live(x@1)
    x@1 := const (0 : u32)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := &mut x@1
    @3 := &two-phase-mut *(@4)
    @2 := test_crate::incr<'_>(move (@3))
    storage_dead(@3)
    storage_dead(@4)
    storage_dead(@2)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &mut x@1
    @6 := &two-phase-mut *(@7)
    @5 := test_crate::incr<'_>(move (@6))
    storage_dead(@6)
    storage_dead(@7)
    storage_dead(@5)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    @10 := &mut x@1
    @9 := &two-phase-mut *(@10)
    @8 := test_crate::incr<'_>(move (@9))
    storage_dead(@9)
    storage_dead(@10)
    storage_dead(@8)
    @0 := ()
    storage_dead(x@1)
    @0 := ()
    return
}

#[lang_item("global_alloc_ty")]
pub struct alloc::alloc::Global = {}

pub enum test_crate::CList<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,
 =
|  CCons(T, alloc::boxed::Box<test_crate::CList<T>[@TraitClause0]>[core::marker::Sized<alloc::alloc::Global>])
|  CNil()


pub fn test_crate::list_nth<'a, T>(@1: &'a (test_crate::CList<T>[@TraitClause0]), @2: u32) -> &'a (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ (T); // return
    let l@1: &'_ (test_crate::CList<T>[@TraitClause0]); // arg #1
    let i@2: u32; // arg #2
    let x@3: &'_ (T); // local
    let tl@4: &'_ (alloc::boxed::Box<test_crate::CList<T>[@TraitClause0]>[core::marker::Sized<alloc::alloc::Global>]); // local
    let @5: bool; // anonymous local
    let @6: u32; // anonymous local
    let @7: &'_ (T); // anonymous local
    let @8: &'_ (test_crate::CList<T>[@TraitClause0]); // anonymous local
    let @9: u32; // anonymous local
    let @10: u32; // anonymous local

    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    match *(l@1) {
        0 => {
        },
        1 => {
            panic(core::panicking::panic_explicit)
        },
    }
    storage_live(x@3)
    x@3 := &(*(l@1) as variant @0).0
    storage_live(tl@4)
    tl@4 := &(*(l@1) as variant @0).1
    storage_live(@5)
    storage_live(@6)
    @6 := copy (i@2)
    @5 := move (@6) == const (0 : u32)
    if move (@5) {
        storage_dead(@6)
        @0 := &*(x@3)
    }
    else {
        storage_dead(@6)
        storage_live(@7)
        storage_live(@8)
        @8 := &*(*(tl@4))
        storage_live(@9)
        storage_live(@10)
        @10 := copy (i@2)
        @9 := copy (@10) - const (1 : u32)
        storage_dead(@10)
        @7 := test_crate::list_nth<'_, T>[@TraitClause0](move (@8), move (@9))
        @0 := &*(@7)
        storage_dead(@9)
        storage_dead(@8)
        storage_dead(@7)
    }
    storage_dead(@5)
    storage_dead(tl@4)
    storage_dead(x@3)
    return
}

pub fn test_crate::list_nth_mut<'a, T>(@1: &'a mut (test_crate::CList<T>[@TraitClause0]), @2: u32) -> &'a mut (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (T); // return
    let l@1: &'_ mut (test_crate::CList<T>[@TraitClause0]); // arg #1
    let i@2: u32; // arg #2
    let @3: &'_ mut (T); // anonymous local
    let @4: &'_ mut (T); // anonymous local
    let x@5: &'_ mut (T); // local
    let tl@6: &'_ mut (alloc::boxed::Box<test_crate::CList<T>[@TraitClause0]>[core::marker::Sized<alloc::alloc::Global>]); // local
    let @7: &'_ mut (T); // anonymous local
    let @8: &'_ mut (T); // anonymous local
    let @9: bool; // anonymous local
    let @10: u32; // anonymous local
    let @11: &'_ mut (T); // anonymous local
    let @12: &'_ mut (T); // anonymous local
    let @13: &'_ mut (test_crate::CList<T>[@TraitClause0]); // anonymous local
    let @14: u32; // anonymous local
    let @15: u32; // anonymous local

    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@3)
    storage_live(@4)
    match *(l@1) {
        0 => {
        },
        1 => {
            panic(core::panicking::panic_explicit)
        },
    }
    storage_live(x@5)
    x@5 := &mut (*(l@1) as variant @0).0
    storage_live(tl@6)
    tl@6 := &mut (*(l@1) as variant @0).1
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    @10 := copy (i@2)
    @9 := move (@10) == const (0 : u32)
    if move (@9) {
        storage_dead(@10)
        storage_live(@11)
        @11 := &mut *(x@5)
        @8 := &mut *(@11)
        storage_dead(@11)
    }
    else {
        storage_dead(@10)
        storage_live(@12)
        storage_live(@13)
        @13 := &two-phase-mut *(*(tl@6))
        storage_live(@14)
        storage_live(@15)
        @15 := copy (i@2)
        @14 := copy (@15) - const (1 : u32)
        storage_dead(@15)
        @12 := test_crate::list_nth_mut<'_, T>[@TraitClause0](move (@13), move (@14))
        @8 := &mut *(@12)
        storage_dead(@14)
        storage_dead(@13)
        storage_dead(@12)
    }
    @7 := &mut *(@8)
    storage_dead(@9)
    @4 := &mut *(@7)
    storage_dead(@8)
    storage_dead(@7)
    storage_dead(tl@6)
    storage_dead(x@5)
    @3 := &mut *(@4)
    @0 := &mut *(@3)
    storage_dead(@4)
    storage_dead(@3)
    return
}

pub fn test_crate::list_nth_mut1<'a, T>(@1: &'a mut (test_crate::CList<T>[@TraitClause0]), @2: u32) -> &'a mut (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (T); // return
    let l@1: &'_ mut (test_crate::CList<T>[@TraitClause0]); // arg #1
    let i@2: u32; // arg #2
    let @3: (); // anonymous local
    let x@4: &'_ mut (T); // local
    let tl@5: &'_ mut (alloc::boxed::Box<test_crate::CList<T>[@TraitClause0]>[core::marker::Sized<alloc::alloc::Global>]); // local
    let @6: (); // anonymous local
    let @7: bool; // anonymous local
    let @8: u32; // anonymous local
    let @9: &'_ mut (test_crate::CList<T>[@TraitClause0]); // anonymous local
    let @10: (); // anonymous local

    storage_live(x@4)
    storage_live(tl@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@3)
    loop {
        match *(l@1) {
            0 => {
                storage_live(x@4)
                x@4 := &mut (*(l@1) as variant @0).0
                storage_live(tl@5)
                tl@5 := &mut (*(l@1) as variant @0).1
                storage_live(@6)
                storage_live(@7)
                storage_live(@8)
                @8 := copy (i@2)
                @7 := move (@8) == const (0 : u32)
                if move (@7) {
                }
                else {
                    storage_dead(@8)
                    storage_dead(@7)
                    storage_dead(@6)
                    i@2 := copy (i@2) - const (1 : u32)
                    storage_live(@9)
                    @9 := &mut *(*(tl@5))
                    l@1 := move (@9)
                    storage_dead(@9)
                    storage_dead(tl@5)
                    storage_dead(x@4)
                    continue 0
                }
                storage_dead(@8)
                @0 := &mut *(x@4)
                storage_dead(@7)
                storage_dead(@6)
                storage_dead(tl@5)
                storage_dead(x@4)
                storage_dead(@3)
                return
            },
            _ => {
                storage_live(@10)
                storage_dead(@10)
                storage_dead(@3)
                panic(core::panicking::panic_explicit)
            },
        }
    }
}

pub fn test_crate::i32_id(@1: i32) -> i32
{
    let @0: i32; // return
    let i@1: i32; // arg #1
    let @2: bool; // anonymous local
    let @3: i32; // anonymous local
    let @4: i32; // anonymous local
    let @5: i32; // anonymous local
    let @6: i32; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@2)
    storage_live(@3)
    @3 := copy (i@1)
    @2 := move (@3) == const (0 : i32)
    if move (@2) {
        storage_dead(@3)
        @0 := const (0 : i32)
    }
    else {
        storage_dead(@3)
        storage_live(@4)
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@1)
        @5 := copy (@6) - const (1 : i32)
        storage_dead(@6)
        @4 := test_crate::i32_id(move (@5))
        storage_dead(@5)
        @0 := copy (@4) + const (1 : i32)
        storage_dead(@4)
    }
    storage_dead(@2)
    return
}

pub fn test_crate::list_tail<'a, T>(@1: &'a mut (test_crate::CList<T>[@TraitClause0])) -> &'a mut (test_crate::CList<T>[@TraitClause0])
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (test_crate::CList<T>[@TraitClause0]); // return
    let l@1: &'_ mut (test_crate::CList<T>[@TraitClause0]); // arg #1
    let @2: &'_ mut (test_crate::CList<T>[@TraitClause0]); // anonymous local
    let @3: &'_ mut (test_crate::CList<T>[@TraitClause0]); // anonymous local
    let tl@4: &'_ mut (alloc::boxed::Box<test_crate::CList<T>[@TraitClause0]>[core::marker::Sized<alloc::alloc::Global>]); // local
    let @5: &'_ mut (test_crate::CList<T>[@TraitClause0]); // anonymous local
    let @6: &'_ mut (test_crate::CList<T>[@TraitClause0]); // anonymous local

    storage_live(tl@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@2)
    storage_live(@3)
    match *(l@1) {
        0 => {
            storage_live(tl@4)
            tl@4 := &mut (*(l@1) as variant @0).1
            storage_live(@5)
            storage_live(@6)
            @6 := &two-phase-mut *(*(tl@4))
            @5 := test_crate::list_tail<'_, T>[@TraitClause0](move (@6))
            @3 := &mut *(@5)
            storage_dead(@6)
            storage_dead(@5)
            storage_dead(tl@4)
        },
        1 => {
            @3 := move (l@1)
        },
    }
    @2 := &mut *(@3)
    @0 := &mut *(@2)
    storage_dead(@3)
    storage_dead(@2)
    return
}

pub trait test_crate::Counter<Self>
{
    fn incr<'_0> = test_crate::Counter::incr<'_0_0, Self>
}

pub fn test_crate::{impl test_crate::Counter for usize}::incr<'_0>(@1: &'_0 mut (usize)) -> usize
{
    let @0: usize; // return
    let self@1: &'_ mut (usize); // arg #1
    let x@2: usize; // local

    storage_live(x@2)
    x@2 := copy (*(self@1))
    *(self@1) := copy (*(self@1)) + const (1 : usize)
    @0 := copy (x@2)
    storage_dead(x@2)
    return
}

impl test_crate::{impl test_crate::Counter for usize} : test_crate::Counter<usize>
{
    fn incr<'_0> = test_crate::{impl test_crate::Counter for usize}::incr<'_0_0>
}

pub fn test_crate::Counter::incr<'_0, Self>(@1: &'_0 mut (Self)) -> usize

pub fn test_crate::use_counter<'a, T>(@1: &'a mut (T)) -> usize
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: test_crate::Counter<T>,
{
    let @0: usize; // return
    let cnt@1: &'_ mut (T); // arg #1
    let @2: &'_ mut (T); // anonymous local

    storage_live(@2)
    @2 := &two-phase-mut *(cnt@1)
    @0 := @TraitClause1::incr<'_>(move (@2))
    storage_dead(@2)
    return
}



