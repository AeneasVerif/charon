# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::choose
pub fn choose<'a, T>(@1: bool, @2: &'a mut T, @3: &'a mut T) -> &'a mut T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut T; // return
    let b_1: bool; // arg #1
    let x_2: &'0 mut T; // arg #2
    let y_3: &'0 mut T; // arg #3
    let _4: &'0 mut T; // anonymous local
    let _5: &'0 mut T; // anonymous local
    let _6: bool; // anonymous local
    let _7: &'0 mut T; // anonymous local

    loop {
        storage_live(_4)
        storage_live(_5)
        storage_live(_6)
        _6 = copy b_1
        if move _6 {
            storage_live(_7)
            _7 = &mut (*x_2)
            _5 = &mut (*_7)
            storage_dead(_7)
        } else {
            _5 = &mut (*y_3)
        }
        break 0
    }
    _4 = &mut (*_5)
    storage_dead(_6)
    _0 = &mut (*_4)
    storage_dead(_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::mul2_add1
pub fn mul2_add1(@1: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let _2: u32; // anonymous local
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_5)
    storage_live(_6)
    storage_live(_2)
    storage_live(_3)
    _3 = copy x_1
    storage_live(_4)
    _4 = copy x_1
    _5 = copy _3 panic.+ copy _4
    _2 = move _5
    storage_dead(_4)
    storage_dead(_3)
    _6 = copy _2 panic.+ const 1 : u32
    _0 = move _6
    storage_dead(_2)
    return
}

// Full name: test_crate::use_mul2_add1
pub fn use_mul2_add1(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_6)
    storage_live(_3)
    storage_live(_4)
    _4 = copy x_1
    _3 = mul2_add1(move _4)
    storage_dead(_4)
    storage_live(_5)
    _5 = copy y_2
    _6 = copy _3 panic.+ copy _5
    _0 = move _6
    storage_dead(_5)
    storage_dead(_3)
    return
}

pub fn test_crate::incr<'a>(@1: &'a mut u32)
{
    let _0: (); // return
    let x_1: &'0 mut u32; // arg #1
    let _2: u32; // anonymous local

    storage_live(_2)
    _0 = ()
    _2 = copy (*x_1) panic.+ const 1 : u32
    (*x_1) = move _2
    _0 = ()
    return
}

// Full name: test_crate::use_incr
pub fn use_incr()
{
    let _0: (); // return
    let x_1: u32; // local
    let _2: (); // anonymous local
    let _3: &'0 mut u32; // anonymous local
    let _4: &'0 mut u32; // anonymous local
    let _5: (); // anonymous local
    let _6: &'0 mut u32; // anonymous local
    let _7: &'0 mut u32; // anonymous local
    let _8: (); // anonymous local
    let _9: &'0 mut u32; // anonymous local
    let _10: &'0 mut u32; // anonymous local

    _0 = ()
    storage_live(x_1)
    x_1 = const 0 : u32
    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    _4 = &mut x_1
    _3 = &two-phase-mut (*_4)
    _2 = test_crate::incr<'_>(move _3)
    storage_dead(_3)
    storage_dead(_4)
    storage_dead(_2)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    _7 = &mut x_1
    _6 = &two-phase-mut (*_7)
    _5 = test_crate::incr<'_>(move _6)
    storage_dead(_6)
    storage_dead(_7)
    storage_dead(_5)
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    _10 = &mut x_1
    _9 = &two-phase-mut (*_10)
    _8 = test_crate::incr<'_>(move _9)
    storage_dead(_9)
    storage_dead(_10)
    storage_dead(_8)
    _0 = ()
    storage_dead(x_1)
    return
}

// Full name: test_crate::CList
pub enum CList<T>
where
    [@TraitClause0]: Sized<T>,
{
  CCons(T, alloc::boxed::Box<CList<T>[@TraitClause0]>[{built_in impl MetaSized for CList<T>[@TraitClause0]}, {built_in impl Sized for Global}]),
  CNil,
}

// Full name: test_crate::list_nth
pub fn list_nth<'a, T>(@1: &'a CList<T>[@TraitClause0], @2: u32) -> &'a T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 T; // return
    let l_1: &'1 CList<T>[@TraitClause0]; // arg #1
    let i_2: u32; // arg #2
    let x_3: &'0 T; // local
    let tl_4: &'2 alloc::boxed::Box<CList<T>[@TraitClause0]>[{built_in impl MetaSized for CList<T>[@TraitClause0]}, {built_in impl Sized for Global}]; // local
    let _5: bool; // anonymous local
    let _6: u32; // anonymous local
    let _7: &'0 T; // anonymous local
    let _8: &'1 CList<T>[@TraitClause0]; // anonymous local
    let _9: u32; // anonymous local
    let _10: u32; // anonymous local
    let _11: u32; // anonymous local

    storage_live(_11)
    match (*l_1) {
        CList::CCons => {
        },
        CList::CNil => {
            panic(core::panicking::panic)
        },
    }
    loop {
        storage_live(x_3)
        x_3 = &((*l_1) as variant CList::CCons).0
        storage_live(tl_4)
        tl_4 = &((*l_1) as variant CList::CCons).1
        storage_live(_5)
        storage_live(_6)
        _6 = copy i_2
        _5 = move _6 == const 0 : u32
        if move _5 {
            storage_dead(_6)
            _0 = &(*x_3)
        } else {
            storage_dead(_6)
            storage_live(_7)
            storage_live(_8)
            _8 = &(*(*tl_4))
            storage_live(_9)
            storage_live(_10)
            _10 = copy i_2
            _11 = copy _10 panic.- const 1 : u32
            _9 = move _11
            storage_dead(_10)
            _7 = list_nth<'_, T>[@TraitClause0](move _8, move _9)
            _0 = &(*_7)
            storage_dead(_9)
            storage_dead(_8)
            storage_dead(_7)
        }
        break 0
    }
    storage_dead(_5)
    storage_dead(tl_4)
    storage_dead(x_3)
    return
}

// Full name: test_crate::list_nth_mut
pub fn list_nth_mut<'a, T>(@1: &'a mut CList<T>[@TraitClause0], @2: u32) -> &'a mut T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut T; // return
    let l_1: &'1 mut CList<T>[@TraitClause0]; // arg #1
    let i_2: u32; // arg #2
    let _3: &'0 mut T; // anonymous local
    let _4: &'0 mut T; // anonymous local
    let x_5: &'0 mut T; // local
    let tl_6: &'2 mut alloc::boxed::Box<CList<T>[@TraitClause0]>[{built_in impl MetaSized for CList<T>[@TraitClause0]}, {built_in impl Sized for Global}]; // local
    let _7: &'0 mut T; // anonymous local
    let _8: &'0 mut T; // anonymous local
    let _9: bool; // anonymous local
    let _10: u32; // anonymous local
    let _11: &'0 mut T; // anonymous local
    let _12: &'0 mut T; // anonymous local
    let _13: &'1 mut CList<T>[@TraitClause0]; // anonymous local
    let _14: u32; // anonymous local
    let _15: u32; // anonymous local
    let _16: u32; // anonymous local

    storage_live(_16)
    storage_live(_3)
    storage_live(_4)
    match (*l_1) {
        CList::CCons => {
        },
        CList::CNil => {
            panic(core::panicking::panic)
        },
    }
    loop {
        storage_live(x_5)
        x_5 = &mut ((*l_1) as variant CList::CCons).0
        storage_live(tl_6)
        tl_6 = &mut ((*l_1) as variant CList::CCons).1
        storage_live(_7)
        storage_live(_8)
        storage_live(_9)
        storage_live(_10)
        _10 = copy i_2
        _9 = move _10 == const 0 : u32
        if move _9 {
            storage_dead(_10)
            storage_live(_11)
            _11 = &mut (*x_5)
            _8 = &mut (*_11)
            storage_dead(_11)
        } else {
            storage_dead(_10)
            storage_live(_12)
            storage_live(_13)
            _13 = &two-phase-mut (*(*tl_6))
            storage_live(_14)
            storage_live(_15)
            _15 = copy i_2
            _16 = copy _15 panic.- const 1 : u32
            _14 = move _16
            storage_dead(_15)
            _12 = list_nth_mut<'_, T>[@TraitClause0](move _13, move _14)
            _8 = &mut (*_12)
            storage_dead(_14)
            storage_dead(_13)
            storage_dead(_12)
        }
        break 0
    }
    _7 = &mut (*_8)
    storage_dead(_9)
    _4 = &mut (*_7)
    storage_dead(_8)
    storage_dead(_7)
    storage_dead(tl_6)
    storage_dead(x_5)
    _3 = &mut (*_4)
    _0 = &mut (*_3)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::list_nth_mut1
pub fn list_nth_mut1<'a, T>(@1: &'a mut CList<T>[@TraitClause0], @2: u32) -> &'a mut T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut T; // return
    let l_1: &'1 mut CList<T>[@TraitClause0]; // arg #1
    let i_2: u32; // arg #2
    let x_3: &'0 mut T; // local
    let tl_4: &'2 mut alloc::boxed::Box<CList<T>[@TraitClause0]>[{built_in impl MetaSized for CList<T>[@TraitClause0]}, {built_in impl Sized for Global}]; // local
    let _5: bool; // anonymous local
    let _6: u32; // anonymous local
    let _7: u32; // anonymous local
    let _8: &'1 mut CList<T>[@TraitClause0]; // anonymous local

    loop {
        storage_live(_7)
        break 0
    }
    loop {
        match (*l_1) {
            CList::CCons => {
                storage_live(x_3)
                x_3 = &mut ((*l_1) as variant CList::CCons).0
                storage_live(tl_4)
                tl_4 = &mut ((*l_1) as variant CList::CCons).1
                storage_live(_5)
                storage_live(_6)
                _6 = copy i_2
                _5 = move _6 == const 0 : u32
                if move _5 {
                    storage_dead(_6)
                    _0 = &mut (*x_3)
                    storage_dead(_5)
                    storage_dead(tl_4)
                    storage_dead(x_3)
                    return
                } else {
                }
                storage_dead(_6)
                storage_dead(_5)
                _7 = copy i_2 panic.- const 1 : u32
                i_2 = move _7
                storage_live(_8)
                _8 = &mut (*(*tl_4))
                l_1 = move _8
                storage_dead(_8)
                storage_dead(tl_4)
                storage_dead(x_3)
            },
            _ => {
                break 0
            },
        }
    }
    panic(core::panicking::panic)
}

// Full name: test_crate::i32_id
pub fn i32_id(@1: i32) -> i32
{
    let _0: i32; // return
    let i_1: i32; // arg #1
    let _2: bool; // anonymous local
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local
    let _6: i32; // anonymous local
    let _7: i32; // anonymous local
    let _8: i32; // anonymous local

    loop {
        storage_live(_7)
        storage_live(_8)
        storage_live(_2)
        storage_live(_3)
        _3 = copy i_1
        _2 = move _3 == const 0 : i32
        if move _2 {
            storage_dead(_3)
            _0 = const 0 : i32
        } else {
            storage_dead(_3)
            storage_live(_4)
            storage_live(_5)
            storage_live(_6)
            _6 = copy i_1
            _7 = copy _6 panic.- const 1 : i32
            _5 = move _7
            storage_dead(_6)
            _4 = i32_id(move _5)
            storage_dead(_5)
            _8 = copy _4 panic.+ const 1 : i32
            _0 = move _8
            storage_dead(_4)
        }
        break 0
    }
    storage_dead(_2)
    return
}

// Full name: test_crate::list_tail
pub fn list_tail<'a, T>(@1: &'a mut CList<T>[@TraitClause0]) -> &'a mut CList<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut CList<T>[@TraitClause0]; // return
    let l_1: &'0 mut CList<T>[@TraitClause0]; // arg #1
    let _2: &'0 mut CList<T>[@TraitClause0]; // anonymous local
    let _3: &'0 mut CList<T>[@TraitClause0]; // anonymous local
    let tl_4: &'1 mut alloc::boxed::Box<CList<T>[@TraitClause0]>[{built_in impl MetaSized for CList<T>[@TraitClause0]}, {built_in impl Sized for Global}]; // local
    let _5: &'0 mut CList<T>[@TraitClause0]; // anonymous local
    let _6: &'0 mut CList<T>[@TraitClause0]; // anonymous local

    loop {
        storage_live(_2)
        storage_live(_3)
        match (*l_1) {
            CList::CCons => {
                storage_live(tl_4)
                tl_4 = &mut ((*l_1) as variant CList::CCons).1
                storage_live(_5)
                storage_live(_6)
                _6 = &two-phase-mut (*(*tl_4))
                _5 = list_tail<'_, T>[@TraitClause0](move _6)
                _3 = &mut (*_5)
                storage_dead(_6)
                storage_dead(_5)
                storage_dead(tl_4)
            },
            CList::CNil => {
                _3 = move l_1
            },
        }
        break 0
    }
    _2 = &mut (*_3)
    _0 = &mut (*_2)
    storage_dead(_3)
    storage_dead(_2)
    return
}

// Full name: test_crate::Counter
pub trait Counter<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn incr<'_0_1> = test_crate::Counter::incr<'_0_1, Self>[Self]
    vtable: test_crate::Counter::{vtable}
}

pub fn test_crate::Counter::incr<'_0, Self>(@1: &'_0 mut Self) -> usize
where
    [@TraitClause0]: Counter<Self>,
= <method_without_default_body>

// Full name: test_crate::{impl Counter for usize}::incr
pub fn {impl Counter for usize}::incr<'_0>(@1: &'_0 mut usize) -> usize
{
    let _0: usize; // return
    let self_1: &'0 mut usize; // arg #1
    let x_2: usize; // local
    let _3: usize; // anonymous local

    storage_live(_3)
    storage_live(x_2)
    x_2 = copy (*self_1)
    _3 = copy (*self_1) panic.+ const 1 : usize
    (*self_1) = move _3
    _0 = copy x_2
    storage_dead(x_2)
    return
}

// Full name: test_crate::{impl Counter for usize}
impl Counter for usize {
    parent_clause0 = {built_in impl MetaSized for usize}
    fn incr<'_0_1> = {impl Counter for usize}::incr<'_0_1>
    vtable: {impl Counter for usize}::{vtable}
}

// Full name: test_crate::use_counter
pub fn use_counter<'a, T>(@1: &'a mut T) -> usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Counter<T>,
{
    let _0: usize; // return
    let cnt_1: &'0 mut T; // arg #1
    let _2: &'0 mut T; // anonymous local

    storage_live(_2)
    _2 = &two-phase-mut (*cnt_1)
    _0 = @TraitClause1::incr<'_>(move _2)
    storage_dead(_2)
    return
}



