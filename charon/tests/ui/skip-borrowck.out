# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::choose
fn choose<'a, T>(@1: bool, @2: &'a mut T, @3: &'a mut T) -> &'a mut T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut T; // return
    let b_1: bool; // arg #1
    let x_2: &'0 mut T; // arg #2
    let y_3: &'0 mut T; // arg #3
    let _4: &'0 mut T; // anonymous local
    let _5: &'0 mut T; // anonymous local
    let _6: bool; // anonymous local
    let _7: &'0 mut T; // anonymous local

    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _6 = copy b_1
    if move _6 {
        storage_live(_7)
        _7 = &mut (*x_2)
        _5 = &mut (*_7)
        storage_dead(_7)
    } else {
        _5 = &mut (*y_3)
    }
    _4 = &mut (*_5)
    storage_dead(_6)
    _0 = &mut (*_4)
    storage_dead(_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::choose_test
pub fn choose_test()
{
    let _0: (); // return
    let x_1: i32; // local
    let y_2: i32; // local
    let z_3: &'0 mut i32; // local
    let _4: &'0 mut i32; // anonymous local
    let _5: &'0 mut i32; // anonymous local
    let _6: &'0 mut i32; // anonymous local
    let _7: &'0 mut i32; // anonymous local
    let _8: i32; // anonymous local
    let _9: bool; // anonymous local
    let _10: i32; // anonymous local
    let _11: bool; // anonymous local
    let _12: i32; // anonymous local
    let _13: bool; // anonymous local
    let _14: i32; // anonymous local
    let _15: bool; // anonymous local
    let _16: i32; // anonymous local

    storage_live(_8)
    _0 = ()
    storage_live(x_1)
    x_1 = const 0 : i32
    storage_live(y_2)
    y_2 = const 0 : i32
    storage_live(z_3)
    storage_live(_4)
    storage_live(_5)
    _5 = &mut x_1
    _4 = &two-phase-mut (*_5)
    storage_live(_6)
    storage_live(_7)
    _7 = &mut y_2
    _6 = &two-phase-mut (*_7)
    z_3 = choose<'2, i32>[{built_in impl Sized for i32}](const true, move _4, move _6)
    storage_dead(_6)
    storage_dead(_4)
    storage_dead(_7)
    storage_dead(_5)
    _8 = copy (*z_3) panic.+ const 1 : i32
    (*z_3) = move _8
    storage_live(_9)
    storage_live(_10)
    _10 = copy (*z_3)
    _9 = move _10 == const 1 : i32
    if move _9 {
    } else {
        storage_dead(_10)
        panic(core::panicking::panic)
    }
    storage_dead(_10)
    storage_dead(_9)
    storage_live(_11)
    storage_live(_12)
    // drop(z)
    _12 = copy x_1
    _11 = move _12 == const 1 : i32
    if move _11 {
    } else {
        storage_dead(_12)
        panic(core::panicking::panic)
    }
    storage_dead(_12)
    storage_dead(_11)
    storage_live(_13)
    storage_live(_14)
    _14 = copy y_2
    _13 = move _14 == const 0 : i32
    if move _13 {
    } else {
        storage_dead(_14)
        panic(core::panicking::panic)
    }
    storage_dead(_14)
    storage_dead(_13)
    storage_live(_15)
    storage_live(_16)
    _16 = copy (*z_3)
    _15 = move _16 == const 1 : i32
    if move _15 {
    } else {
        storage_dead(_16)
        panic(core::panicking::panic)
    }
    storage_dead(_16)
    storage_dead(_15)
    _0 = ()
    storage_dead(z_3)
    storage_dead(y_2)
    storage_dead(x_1)
    return
}



