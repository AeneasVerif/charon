# Final LLBC before serialization:

#[lang_item("sized")]
pub trait core::marker::Sized<Self>

fn test_crate::choose<'a, T>(@1: bool, @2: &'a mut (T), @3: &'a mut (T)) -> &'a mut (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (T); // return
    let b@1: bool; // arg #1
    let x@2: &'_ mut (T); // arg #2
    let y@3: &'_ mut (T); // arg #3
    let @4: &'_ mut (T); // anonymous local
    let @5: &'_ mut (T); // anonymous local
    let @6: bool; // anonymous local
    let @7: &'_ mut (T); // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := copy (b@1)
    if move (@6) {
        storage_live(@7)
        @7 := &mut *(x@2)
        @5 := &mut *(@7)
        storage_dead(@7)
    }
    else {
        @5 := &mut *(y@3)
    }
    @4 := &mut *(@5)
    storage_dead(@6)
    @0 := &mut *(@4)
    storage_dead(@5)
    storage_dead(@4)
    return
}

pub fn test_crate::choose_test()
{
    let @0: (); // return
    let x@1: i32; // local
    let y@2: i32; // local
    let z@3: &'_ mut (i32); // local
    let @4: &'_ mut (i32); // anonymous local
    let @5: &'_ mut (i32); // anonymous local
    let @6: &'_ mut (i32); // anonymous local
    let @7: &'_ mut (i32); // anonymous local
    let @8: (); // anonymous local
    let @9: bool; // anonymous local
    let @10: i32; // anonymous local
    let @11: (); // anonymous local
    let @12: bool; // anonymous local
    let @13: i32; // anonymous local
    let @14: (); // anonymous local
    let @15: bool; // anonymous local
    let @16: i32; // anonymous local
    let @17: (); // anonymous local
    let @18: bool; // anonymous local
    let @19: i32; // anonymous local

    storage_live(x@1)
    x@1 := const (0 : i32)
    @fake_read(x@1)
    storage_live(y@2)
    y@2 := const (0 : i32)
    @fake_read(y@2)
    storage_live(z@3)
    storage_live(@4)
    storage_live(@5)
    @5 := &mut x@1
    @4 := &two-phase-mut *(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &mut y@2
    @6 := &two-phase-mut *(@7)
    z@3 := test_crate::choose<'_, i32>[core::marker::Sized<i32>](const (true), move (@4), move (@6))
    storage_dead(@6)
    storage_dead(@4)
    @fake_read(z@3)
    storage_dead(@7)
    storage_dead(@5)
    *(z@3) := copy (*(z@3)) + const (1 : i32)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    @10 := copy (*(z@3))
    @9 := move (@10) == const (1 : i32)
    if move (@9) {
    }
    else {
        storage_dead(@10)
        panic(core::panicking::panic)
    }
    storage_dead(@10)
    storage_dead(@9)
    storage_dead(@8)
    storage_live(@11)
    storage_live(@12)
    storage_live(@13)
    // drop(z)
    @13 := copy (x@1)
    @12 := move (@13) == const (1 : i32)
    if move (@12) {
    }
    else {
        storage_dead(@13)
        panic(core::panicking::panic)
    }
    storage_dead(@13)
    storage_dead(@12)
    storage_dead(@11)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    @16 := copy (y@2)
    @15 := move (@16) == const (0 : i32)
    if move (@15) {
    }
    else {
        storage_dead(@16)
        panic(core::panicking::panic)
    }
    storage_dead(@16)
    storage_dead(@15)
    storage_dead(@14)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    @19 := copy (*(z@3))
    @18 := move (@19) == const (1 : i32)
    if move (@18) {
    }
    else {
        storage_dead(@19)
        panic(core::panicking::panic)
    }
    storage_dead(@19)
    storage_dead(@18)
    storage_dead(@17)
    @0 := ()
    storage_dead(z@3)
    storage_dead(y@2)
    storage_dead(x@1)
    @0 := ()
    return
}



