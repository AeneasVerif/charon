# Final LLBC before serialization:

struct test_crate::Pair<T1, T2> =
{
  x: T1,
  y: T2
}

enum test_crate::List<T> =
|  Cons(T, alloc::boxed::Box<test_crate::List<T>>)
|  Nil()


enum test_crate::One<T1> =
|  One(T1)


enum test_crate::EmptyEnum =
|  Empty()


enum test_crate::Enum =
|  Variant1()
|  Variant2()


struct test_crate::EmptyStruct = {}

enum test_crate::Sum<T1, T2> =
|  Left(T1)
|  Right(T2)


struct test_crate::Tuple<T1, T2> =
{
  T1,
  T2
}

fn test_crate::use_tuple_struct<'_0>(@1: &'_0 mut (test_crate::Tuple<u32, u32>))
{
    let @0: (); // return
    let x@1: &'_ mut (test_crate::Tuple<u32, u32>); // arg #1
    let @2: (); // anonymous local

    (*(x@1)).0 := const (1 : u32)
    @2 := ()
    @0 := move (@2)
    @0 := ()
    return
}

fn test_crate::create_tuple_struct(@1: u32, @2: u64) -> test_crate::Tuple<u32, u64>
{
    let @0: test_crate::Tuple<u32, u64>; // return
    let x@1: u32; // arg #1
    let y@2: u64; // arg #2
    let @3: u32; // anonymous local
    let @4: u64; // anonymous local

    @3 := copy (x@1)
    @4 := copy (y@2)
    @0 := test_crate::Tuple { 0: move (@3), 1: move (@4) }
    drop @4
    drop @3
    return
}

fn test_crate::create_pair(@1: u32, @2: u64) -> test_crate::Pair<u32, u64>
{
    let @0: test_crate::Pair<u32, u64>; // return
    let x@1: u32; // arg #1
    let y@2: u64; // arg #2
    let @3: u32; // anonymous local
    let @4: u64; // anonymous local

    @3 := copy (x@1)
    @4 := copy (y@2)
    @0 := test_crate::Pair { x: move (@3), y: move (@4) }
    drop @4
    drop @3
    return
}

struct test_crate::IdType<T> =
{
  T
}

fn test_crate::use_id_type<T>(@1: test_crate::IdType<T>) -> T
{
    let @0: T; // return
    let x@1: test_crate::IdType<T>; // arg #1

    @0 := move ((x@1).0)
    drop x@1
    return
}

fn test_crate::create_id_type<T>(@1: T) -> test_crate::IdType<T>
{
    let @0: test_crate::IdType<T>; // return
    let x@1: T; // arg #1
    let @2: T; // anonymous local

    @2 := move (x@1)
    @0 := test_crate::IdType { 0: move (@2) }
    drop @2
    drop @2
    drop x@1
    return
}

fn test_crate::cast_u32_to_i32(@1: u32) -> i32
{
    let @0: i32; // return
    let x@1: u32; // arg #1
    let @2: u32; // anonymous local

    @2 := copy (x@1)
    @0 := cast<u32,i32>(move (@2))
    drop @2
    return
}

fn test_crate::cast_bool_to_i32(@1: bool) -> i32
{
    let @0: i32; // return
    let x@1: bool; // arg #1
    let @2: bool; // anonymous local

    @2 := copy (x@1)
    @0 := cast<bool,i32>(move (@2))
    drop @2
    return
}

fn test_crate::cast_bool_to_bool(@1: bool) -> bool
{
    let @0: bool; // return
    let x@1: bool; // arg #1

    @0 := copy (x@1)
    return
}

fn test_crate::test2()
{
    let @0: (); // return
    let x@1: u32; // local
    let y@2: u32; // local
    let z@3: u32; // local
    let @4: u32; // anonymous local
    let @5: u32; // anonymous local
    let p@6: test_crate::Pair<u32, u32>; // local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let s@9: test_crate::Sum<u32, bool>; // local
    let o@10: test_crate::One<u64>; // local
    let e0@11: test_crate::EmptyEnum; // local
    let e1@12: test_crate::EmptyEnum; // local
    let enum0@13: test_crate::Enum; // local
    let @14: (); // anonymous local

    x@1 := const (23 : u32)
    @fake_read(x@1)
    y@2 := const (44 : u32)
    @fake_read(y@2)
    @4 := copy (x@1)
    @5 := copy (y@2)
    z@3 := move (@4) + move (@5)
    drop @5
    drop @4
    @fake_read(z@3)
    @7 := copy (x@1)
    @8 := copy (z@3)
    p@6 := test_crate::Pair { x: move (@7), y: move (@8) }
    drop @8
    drop @7
    @fake_read(p@6)
    s@9 := test_crate::Sum::Right { 0: const (true) }
    @fake_read(s@9)
    o@10 := test_crate::One::One { 0: const (3 : u64) }
    @fake_read(o@10)
    e0@11 := test_crate::EmptyEnum::Empty {  }
    @fake_read(e0@11)
    e1@12 := move (e0@11)
    @fake_read(e1@12)
    enum0@13 := test_crate::Enum::Variant1 {  }
    @fake_read(enum0@13)
    @14 := ()
    @0 := move (@14)
    drop enum0@13
    drop e1@12
    drop e0@11
    drop o@10
    drop s@9
    drop p@6
    drop z@3
    drop y@2
    drop x@1
    @0 := ()
    return
}

fn test_crate::get_max(@1: u32, @2: u32) -> u32
{
    let @0: u32; // return
    let x@1: u32; // arg #1
    let y@2: u32; // arg #2
    let @3: bool; // anonymous local
    let @4: u32; // anonymous local
    let @5: u32; // anonymous local

    @4 := copy (x@1)
    @5 := copy (y@2)
    @3 := move (@4) >= move (@5)
    if move (@3) {
        drop @5
        drop @4
        @0 := copy (x@1)
    }
    else {
        drop @5
        drop @4
        @0 := copy (y@2)
    }
    drop @3
    return
}

fn test_crate::test_list1()
{
    let @0: (); // return
    let l@1: test_crate::List<i32>; // local
    let @2: alloc::boxed::Box<test_crate::List<i32>>; // anonymous local
    let @3: test_crate::List<i32>; // anonymous local
    let @4: (); // anonymous local

    @3 := test_crate::List::Nil {  }
    @2 := @BoxNew<test_crate::List<i32>>(move (@3))
    drop @3
    l@1 := test_crate::List::Cons { 0: const (0 : i32), 1: move (@2) }
    drop @2
    drop @2
    @fake_read(l@1)
    @4 := ()
    @0 := move (@4)
    drop l@1
    drop l@1
    @0 := ()
    return
}

trait core::ops::deref::Deref<Self>
{
    type Target
    fn deref : core::ops::deref::Deref::deref
}

trait core::ops::deref::DerefMut<Self>
{
    parent_clause_0 : [@TraitClause0]: core::ops::deref::Deref<Self>
    fn deref_mut : core::ops::deref::DerefMut::deref_mut
}

fn alloc::boxed::{impl core::ops::deref::Deref for alloc::boxed::Box<T>#38}::deref<'_0, T, A>(@1: &'_0 (alloc::boxed::Box<T>)) -> &'_0 (T)

impl<T, A> alloc::boxed::{impl core::ops::deref::Deref for alloc::boxed::Box<T>#38}<T, A> : core::ops::deref::Deref<alloc::boxed::Box<T>>
{
    type Target = T with []
    fn deref = alloc::boxed::{impl core::ops::deref::Deref for alloc::boxed::Box<T>#38}::deref
}

fn alloc::boxed::{impl core::ops::deref::DerefMut for alloc::boxed::Box<T>#39}::deref_mut<'_0, T, A>(@1: &'_0 mut (alloc::boxed::Box<T>)) -> &'_0 mut (T)

impl<T, A> alloc::boxed::{impl core::ops::deref::DerefMut for alloc::boxed::Box<T>#39}<T, A> : core::ops::deref::DerefMut<alloc::boxed::Box<T>>
{
    parent_clause0 = alloc::boxed::{impl core::ops::deref::Deref for alloc::boxed::Box<T>#38}<T, A>
    fn deref_mut = alloc::boxed::{impl core::ops::deref::DerefMut for alloc::boxed::Box<T>#39}::deref_mut
}

struct alloc::alloc::Global = {}

fn core::ops::deref::DerefMut::deref_mut<'_0, Self>(@1: &'_0 mut (Self)) -> &'_0 mut ((parents(Self)::[@TraitClause0])::Target)

fn core::ops::deref::Deref::deref<'_0, Self>(@1: &'_0 (Self)) -> &'_0 (Self::Target)

fn test_crate::test_box1()
{
    let @0: (); // return
    let b@1: alloc::boxed::Box<i32>; // local
    let x@2: &'_ mut (i32); // local
    let @3: &'_ mut (alloc::boxed::Box<i32>); // anonymous local
    let x@4: &'_ (i32); // local
    let @5: &'_ (alloc::boxed::Box<i32>); // anonymous local
    let @6: (); // anonymous local
    let @7: bool; // anonymous local
    let @8: i32; // anonymous local
    let @9: (); // anonymous local
    let @10: (); // anonymous local

    b@1 := @BoxNew<i32>(const (0 : i32))
    @fake_read(b@1)
    @3 := &two-phase-mut b@1
    x@2 := alloc::boxed::{impl core::ops::deref::DerefMut for alloc::boxed::Box<T>#39}<i32, alloc::alloc::Global>::deref_mut(move (@3))
    drop @3
    @fake_read(x@2)
    *(x@2) := const (1 : i32)
    @5 := &b@1
    x@4 := alloc::boxed::{impl core::ops::deref::Deref for alloc::boxed::Box<T>#38}<i32, alloc::alloc::Global>::deref(move (@5))
    drop @5
    @fake_read(x@4)
    @8 := copy (*(x@4))
    @7 := move (@8) == const (1 : i32)
    if move (@7) {
        nop
    }
    else {
        drop @8
        panic(core::panicking::panic)
    }
    drop @8
    @9 := ()
    @6 := move (@9)
    drop @7
    drop @6
    @10 := ()
    @0 := move (@10)
    drop x@4
    drop x@2
    drop b@1
    drop b@1
    @0 := ()
    return
}

fn test_crate::copy_int(@1: i32) -> i32
{
    let @0: i32; // return
    let x@1: i32; // arg #1

    @0 := copy (x@1)
    return
}

fn test_crate::test_unreachable(@1: bool)
{
    let @0: (); // return
    let b@1: bool; // arg #1
    let @2: bool; // anonymous local
    let @3: (); // anonymous local

    @2 := copy (b@1)
    if move (@2) {
        nop
    }
    else {
        @3 := ()
        @0 := move (@3)
        drop @2
        @0 := ()
        return
    }
    panic(core::panicking::panic)
}

fn test_crate::is_cons<'_0, T>(@1: &'_0 (test_crate::List<T>)) -> bool
{
    let @0: bool; // return
    let l@1: &'_ (test_crate::List<T>); // arg #1

    @fake_read(l@1)
    match *(l@1) {
        0 => {
            @0 := const (true)
        },
        1 => {
            @0 := const (false)
        }
    }
    return
}

fn test_crate::split_list<T>(@1: test_crate::List<T>) -> (T, test_crate::List<T>)
{
    let @0: (T, test_crate::List<T>); // return
    let l@1: test_crate::List<T>; // arg #1
    let hd@2: T; // local
    let tl@3: alloc::boxed::Box<test_crate::List<T>>; // local
    let @4: T; // anonymous local
    let @5: test_crate::List<T>; // anonymous local

    @fake_read(l@1)
    match l@1 {
        0 => {
            nop
        },
        _ => {
            panic(core::panicking::panic_explicit)
        }
    }
    hd@2 := move ((l@1 as variant @0).0)
    tl@3 := move ((l@1 as variant @0).1)
    @4 := move (hd@2)
    @5 := move (deref_box (tl@3))
    @0 := (move (@4), move (@5))
    drop @5
    drop @5
    drop @4
    drop @4
    drop tl@3
    drop tl@3
    drop hd@2
    drop hd@2
    drop l@1
    return
}

fn test_crate::test_char() -> char
{
    let @0: char; // return

    @0 := const (a)
    return
}

enum test_crate::Tree<T> =
|  Leaf(T)
|  Node(T, test_crate::NodeElem<T>, alloc::boxed::Box<test_crate::Tree<T>>)


enum test_crate::NodeElem<T> =
|  Cons(alloc::boxed::Box<test_crate::Tree<T>>, alloc::boxed::Box<test_crate::NodeElem<T>>)
|  Nil()


fn test_crate::even(@1: u32) -> bool
{
    let @0: bool; // return
    let x@1: u32; // arg #1
    let @2: bool; // anonymous local
    let @3: u32; // anonymous local
    let @4: u32; // anonymous local
    let @5: u32; // anonymous local

    @3 := copy (x@1)
    @2 := move (@3) == const (0 : u32)
    if move (@2) {
        drop @3
        @0 := const (true)
    }
    else {
        drop @3
        @5 := copy (x@1)
        @4 := move (@5) - const (1 : u32)
        drop @5
        @0 := test_crate::odd(move (@4))
        drop @4
    }
    drop @2
    return
}

fn test_crate::odd(@1: u32) -> bool
{
    let @0: bool; // return
    let x@1: u32; // arg #1
    let @2: bool; // anonymous local
    let @3: u32; // anonymous local
    let @4: u32; // anonymous local
    let @5: u32; // anonymous local

    @3 := copy (x@1)
    @2 := move (@3) == const (0 : u32)
    if move (@2) {
        drop @3
        @0 := const (false)
    }
    else {
        drop @3
        @5 := copy (x@1)
        @4 := move (@5) - const (1 : u32)
        drop @5
        @0 := test_crate::even(move (@4))
        drop @4
    }
    drop @2
    return
}

fn test_crate::test_even_odd()
{
    let @0: (); // return
    let @1: (); // anonymous local
    let @2: bool; // anonymous local
    let @3: (); // anonymous local
    let @4: bool; // anonymous local
    let @5: (); // anonymous local
    let @6: bool; // anonymous local
    let @7: (); // anonymous local
    let @8: bool; // anonymous local
    let @9: (); // anonymous local
    let @10: (); // anonymous local
    let @11: (); // anonymous local
    let @12: (); // anonymous local
    let @13: (); // anonymous local

    @2 := test_crate::even(const (0 : u32))
    if move (@2) {
        nop
    }
    else {
        panic(core::panicking::panic)
    }
    @9 := ()
    @1 := move (@9)
    drop @2
    drop @1
    @4 := test_crate::even(const (4 : u32))
    if move (@4) {
        nop
    }
    else {
        panic(core::panicking::panic)
    }
    @10 := ()
    @3 := move (@10)
    drop @4
    drop @3
    @6 := test_crate::odd(const (1 : u32))
    if move (@6) {
        nop
    }
    else {
        panic(core::panicking::panic)
    }
    @11 := ()
    @5 := move (@11)
    drop @6
    drop @5
    @8 := test_crate::odd(const (5 : u32))
    if move (@8) {
        nop
    }
    else {
        panic(core::panicking::panic)
    }
    @12 := ()
    @7 := move (@12)
    drop @8
    drop @7
    @13 := ()
    @0 := move (@13)
    @0 := ()
    return
}

struct test_crate::StructWithTuple<T1, T2> =
{
  p: (T1, T2)
}

fn test_crate::new_tuple1() -> test_crate::StructWithTuple<u32, u32>
{
    let @0: test_crate::StructWithTuple<u32, u32>; // return
    let @1: (u32, u32); // anonymous local

    @1 := (const (1 : u32), const (2 : u32))
    @0 := test_crate::StructWithTuple { p: move (@1) }
    drop @1
    return
}

fn test_crate::new_tuple2() -> test_crate::StructWithTuple<i16, i16>
{
    let @0: test_crate::StructWithTuple<i16, i16>; // return
    let @1: (i16, i16); // anonymous local

    @1 := (const (1 : i16), const (2 : i16))
    @0 := test_crate::StructWithTuple { p: move (@1) }
    drop @1
    return
}

fn test_crate::new_tuple3() -> test_crate::StructWithTuple<u64, i64>
{
    let @0: test_crate::StructWithTuple<u64, i64>; // return
    let @1: (u64, i64); // anonymous local

    @1 := (const (1 : u64), const (2 : i64))
    @0 := test_crate::StructWithTuple { p: move (@1) }
    drop @1
    return
}

struct test_crate::StructWithPair<T1, T2> =
{
  p: test_crate::Pair<T1, T2>
}

fn test_crate::new_pair1() -> test_crate::StructWithPair<u32, u32>
{
    let @0: test_crate::StructWithPair<u32, u32>; // return
    let @1: test_crate::Pair<u32, u32>; // anonymous local

    @1 := test_crate::Pair { x: const (1 : u32), y: const (2 : u32) }
    @0 := test_crate::StructWithPair { p: move (@1) }
    drop @1
    return
}

fn test_crate::incr<'_0>(@1: &'_0 mut (u32))
{
    let @0: (); // return
    let x@1: &'_ mut (u32); // arg #1
    let @2: (); // anonymous local

    *(x@1) := copy (*(x@1)) + const (1 : u32)
    @2 := ()
    @0 := move (@2)
    @0 := ()
    return
}

fn test_crate::read_then_incr<'_0>(@1: &'_0 mut (u32)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ mut (u32); // arg #1
    let r@2: u32; // local

    r@2 := copy (*(x@1))
    @fake_read(r@2)
    *(x@1) := copy (*(x@1)) + const (1 : u32)
    @0 := copy (r@2)
    drop r@2
    return
}



