# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: alloc::alloc::Global
#[lang_item("global_alloc_ty")]
pub struct Global {}

// Full name: alloc::boxed::Box::{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop_in_place
unsafe fn {impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop_in_place<T, A>(@1: *mut alloc::boxed::Box<T>[@TraitClause0, @TraitClause1])
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
= <opaque>

// Full name: alloc::boxed::Box::{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}
impl<T, A> Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
{
    fn drop_in_place = {impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::drop_in_place<T, A>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: alloc::boxed::{impl Deref for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::deref
pub fn {impl Deref for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::deref<'_0, T, A>(@1: &'_0 alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]) -> &'_0 T
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
= <opaque>

// Full name: alloc::boxed::{impl DerefMut for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::deref_mut
pub fn {impl DerefMut for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::deref_mut<'_0, T, A>(@1: &'_0 mut alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]) -> &'_0 mut T
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Sized<A>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::Pair
pub struct Pair<T1, T2>
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
{
  x: T1,
  y: T2,
}

// Full name: test_crate::List
pub enum List<T>
where
    [@TraitClause0]: Sized<T>,
{
  Cons(T, alloc::boxed::Box<List<T>[@TraitClause0]>[{built_in impl MetaSized for List<T>[@TraitClause0]}, {built_in impl Sized for Global}]),
  Nil,
}

// Full name: test_crate::List::{impl Destruct for List<T>[@TraitClause0]}::drop_in_place
unsafe fn {impl Destruct for List<T>[@TraitClause0]}::drop_in_place<T>(@1: *mut List<T>[@TraitClause0])
where
    [@TraitClause0]: Sized<T>,
= <missing>

// Full name: test_crate::List::{impl Destruct for List<T>[@TraitClause0]}
impl<T> Destruct for List<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    fn drop_in_place = {impl Destruct for List<T>[@TraitClause0]}::drop_in_place<T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::One
pub enum One<T1>
where
    [@TraitClause0]: Sized<T1>,
{
  One(T1),
}

// Full name: test_crate::EmptyEnum
pub enum EmptyEnum {
  Empty,
}

// Full name: test_crate::Enum
pub enum Enum {
  Variant1,
  Variant2,
}

// Full name: test_crate::EmptyStruct
pub struct EmptyStruct {}

// Full name: test_crate::Sum
pub enum Sum<T1, T2>
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
{
  Left(T1),
  Right(T2),
}

// Full name: test_crate::Tuple
pub struct Tuple<T1, T2>
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
{
  T1,
  T2,
}

// Full name: test_crate::use_tuple_struct
pub fn use_tuple_struct<'_0>(@1: &'_0 mut Tuple<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}])
{
    let _0: (); // return
    let x_1: &'0 mut Tuple<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // arg #1

    _0 = ()
    ((*x_1)).0 = const 1 : u32
    _0 = ()
    return
}

// Full name: test_crate::create_tuple_struct
pub fn create_tuple_struct(@1: u32, @2: u64) -> Tuple<u32, u64>[{built_in impl Sized for u32}, {built_in impl Sized for u64}]
{
    let _0: Tuple<u32, u64>[{built_in impl Sized for u32}, {built_in impl Sized for u64}]; // return
    let x_1: u32; // arg #1
    let y_2: u64; // arg #2
    let _3: u32; // anonymous local
    let _4: u64; // anonymous local

    storage_live(_3)
    _3 = copy x_1
    storage_live(_4)
    _4 = copy y_2
    _0 = Tuple { 0: move _3, 1: move _4 }
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::create_pair
pub fn create_pair(@1: u32, @2: u64) -> Pair<u32, u64>[{built_in impl Sized for u32}, {built_in impl Sized for u64}]
{
    let _0: Pair<u32, u64>[{built_in impl Sized for u32}, {built_in impl Sized for u64}]; // return
    let x_1: u32; // arg #1
    let y_2: u64; // arg #2
    let _3: u32; // anonymous local
    let _4: u64; // anonymous local

    storage_live(_3)
    _3 = copy x_1
    storage_live(_4)
    _4 = copy y_2
    _0 = Pair { x: move _3, y: move _4 }
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::IdType
pub struct IdType<T>
where
    [@TraitClause0]: Sized<T>,
{
  T,
}

// Full name: test_crate::IdType::{impl Destruct for IdType<T>[@TraitClause0]}::drop_in_place
unsafe fn {impl Destruct for IdType<T>[@TraitClause0]}::drop_in_place<T>(@1: *mut IdType<T>[@TraitClause0])
where
    [@TraitClause0]: Sized<T>,
= <missing>

// Full name: test_crate::IdType::{impl Destruct for IdType<T>[@TraitClause0]}
impl<T> Destruct for IdType<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    fn drop_in_place = {impl Destruct for IdType<T>[@TraitClause0]}::drop_in_place<T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::use_id_type
pub fn use_id_type<T>(@1: IdType<T>[@TraitClause0]) -> T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: T; // return
    let x_1: IdType<T>[@TraitClause0]; // arg #1

    _0 = move (x_1).0
    conditional_drop[{impl Destruct for IdType<T>[@TraitClause0]}<T>[@TraitClause0]] x_1
    return
}

// Full name: test_crate::create_id_type
pub fn create_id_type<T>(@1: T) -> IdType<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: IdType<T>[@TraitClause0]; // return
    let x_1: T; // arg #1
    let _2: T; // anonymous local

    storage_live(_2)
    _2 = move x_1
    _0 = IdType { 0: move _2 }
    conditional_drop[{built_in impl Destruct for T}] _2
    storage_dead(_2)
    conditional_drop[{built_in impl Destruct for T}] x_1
    return
}

// Full name: test_crate::cast_u32_to_i32
pub fn cast_u32_to_i32(@1: u32) -> i32
{
    let _0: i32; // return
    let x_1: u32; // arg #1
    let _2: u32; // anonymous local

    storage_live(_2)
    _2 = copy x_1
    _0 = cast<u32, i32>(move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::cast_bool_to_i32
pub fn cast_bool_to_i32(@1: bool) -> i32
{
    let _0: i32; // return
    let x_1: bool; // arg #1
    let _2: bool; // anonymous local

    storage_live(_2)
    _2 = copy x_1
    _0 = cast<bool, i32>(move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::cast_bool_to_bool
pub fn cast_bool_to_bool(@1: bool) -> bool
{
    let _0: bool; // return
    let x_1: bool; // arg #1

    _0 = copy x_1
    return
}

// Full name: test_crate::test2
pub fn test2()
{
    let _0: (); // return
    let x_1: u32; // local
    let y_2: u32; // local
    let z_3: u32; // local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local
    let p_7: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // local
    let _8: u32; // anonymous local
    let _9: u32; // anonymous local
    let s_10: Sum<u32, bool>[{built_in impl Sized for u32}, {built_in impl Sized for bool}]; // local
    let o_11: One<u64>[{built_in impl Sized for u64}]; // local
    let e0_12: EmptyEnum; // local
    let e1_13: EmptyEnum; // local
    let enum0_14: Enum; // local

    storage_live(_6)
    _0 = ()
    storage_live(x_1)
    x_1 = const 23 : u32
    storage_live(y_2)
    y_2 = const 44 : u32
    storage_live(z_3)
    storage_live(_4)
    _4 = copy x_1
    storage_live(_5)
    _5 = copy y_2
    _6 = copy _4 panic.+ copy _5
    z_3 = move _6
    storage_dead(_5)
    storage_dead(_4)
    storage_live(p_7)
    storage_live(_8)
    _8 = copy x_1
    storage_live(_9)
    _9 = copy z_3
    p_7 = Pair { x: move _8, y: move _9 }
    storage_dead(_9)
    storage_dead(_8)
    storage_live(s_10)
    s_10 = Sum::Right { 0: const true }
    storage_live(o_11)
    o_11 = One::One { 0: const 3 : u64 }
    storage_live(e0_12)
    e0_12 = EmptyEnum::Empty {  }
    storage_live(e1_13)
    e1_13 = move e0_12
    storage_live(enum0_14)
    enum0_14 = Enum::Variant1 {  }
    _0 = ()
    storage_dead(enum0_14)
    storage_dead(e1_13)
    storage_dead(e0_12)
    storage_dead(o_11)
    storage_dead(s_10)
    storage_dead(p_7)
    storage_dead(z_3)
    storage_dead(y_2)
    storage_dead(x_1)
    return
}

// Full name: test_crate::get_max
pub fn get_max(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1
    let y_2: u32; // arg #2
    let _3: bool; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy x_1
    storage_live(_5)
    _5 = copy y_2
    _3 = move _4 >= move _5
    if move _3 {
        storage_dead(_5)
        storage_dead(_4)
        _0 = copy x_1
    } else {
        storage_dead(_5)
        storage_dead(_4)
        _0 = copy y_2
    }
    storage_dead(_3)
    return
}

// Full name: test_crate::test_list1
pub fn test_list1()
{
    let _0: (); // return
    let l_1: List<i32>[{built_in impl Sized for i32}]; // local
    let _2: alloc::boxed::Box<List<i32>[{built_in impl Sized for i32}]>[{built_in impl MetaSized for List<i32>[{built_in impl Sized for i32}]}, {built_in impl Sized for Global}]; // anonymous local
    let _3: List<i32>[{built_in impl Sized for i32}]; // anonymous local

    _0 = ()
    storage_live(l_1)
    storage_live(_2)
    storage_live(_3)
    _3 = List::Nil {  }
    _2 = @BoxNew<List<i32>[{built_in impl Sized for i32}]>[{built_in impl Sized for List<i32>[{built_in impl Sized for i32}]}](move _3)
    storage_dead(_3)
    l_1 = List::Cons { 0: const 0 : i32, 1: move _2 }
    conditional_drop[{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<List<i32>[{built_in impl Sized for i32}], Global>[{built_in impl MetaSized for List<i32>[{built_in impl Sized for i32}]}, {built_in impl Sized for Global}]] _2
    storage_dead(_2)
    _0 = ()
    conditional_drop[{impl Destruct for List<T>[@TraitClause0]}<i32>[{built_in impl Sized for i32}]] l_1
    storage_dead(l_1)
    return
}

// Full name: test_crate::test_box1
pub fn test_box1()
{
    let _0: (); // return
    let b_1: alloc::boxed::Box<i32>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}]; // local
    let x_2: &'0 mut i32; // local
    let _3: &'1 mut alloc::boxed::Box<i32>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}]; // anonymous local
    let x_4: &'2 i32; // local
    let _5: &'3 alloc::boxed::Box<i32>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}]; // anonymous local
    let _6: bool; // anonymous local
    let _7: i32; // anonymous local

    _0 = ()
    storage_live(b_1)
    b_1 = @BoxNew<i32>[{built_in impl Sized for i32}](const 0 : i32)
    storage_live(x_2)
    storage_live(_3)
    _3 = &two-phase-mut b_1
    x_2 = {impl DerefMut for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::deref_mut<'5, i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}](move _3)
    storage_dead(_3)
    (*x_2) = const 1 : i32
    storage_live(x_4)
    storage_live(_5)
    _5 = &b_1
    x_4 = {impl Deref for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}::deref<'7, i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}](move _5)
    storage_dead(_5)
    storage_live(_6)
    storage_live(_7)
    _7 = copy (*x_4)
    _6 = move _7 == const 1 : i32
    if move _6 {
    } else {
        storage_dead(_7)
        panic(core::panicking::panic)
    }
    storage_dead(_7)
    storage_dead(_6)
    _0 = ()
    storage_dead(x_4)
    storage_dead(x_2)
    conditional_drop[{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<i32, Global>[{built_in impl MetaSized for i32}, {built_in impl Sized for Global}]] b_1
    storage_dead(b_1)
    return
}

// Full name: test_crate::copy_int
pub fn copy_int(@1: i32) -> i32
{
    let _0: i32; // return
    let x_1: i32; // arg #1

    _0 = copy x_1
    return
}

// Full name: test_crate::test_unreachable
pub fn test_unreachable(@1: bool)
{
    let _0: (); // return
    let b_1: bool; // arg #1
    let _2: bool; // anonymous local

    _0 = ()
    storage_live(_2)
    _2 = copy b_1
    assert(move _2 == false) else panic(core::panicking::panic)
    _0 = ()
    storage_dead(_2)
    return
}

// Full name: test_crate::is_cons
pub fn is_cons<'_0, T>(@1: &'_0 List<T>[@TraitClause0]) -> bool
where
    [@TraitClause0]: Sized<T>,
{
    let _0: bool; // return
    let l_1: &'0 List<T>[@TraitClause0]; // arg #1

    match (*l_1) {
        List::Cons => {
        },
        List::Nil => {
            _0 = const false
            return
        },
    }
    _0 = const true
    return
}

// Full name: test_crate::split_list
pub fn split_list<T>(@1: List<T>[@TraitClause0]) -> (T, List<T>[@TraitClause0])
where
    [@TraitClause0]: Sized<T>,
{
    let _0: (T, List<T>[@TraitClause0]); // return
    let l_1: List<T>[@TraitClause0]; // arg #1
    let hd_2: T; // local
    let tl_3: alloc::boxed::Box<List<T>[@TraitClause0]>[{built_in impl MetaSized for List<T>[@TraitClause0]}, {built_in impl Sized for Global}]; // local
    let _4: T; // anonymous local
    let _5: List<T>[@TraitClause0]; // anonymous local

    match l_1 {
        List::Cons => {
        },
        _ => {
            panic(core::panicking::panic)
        },
    }
    storage_live(hd_2)
    hd_2 = move (l_1 as variant List::Cons).0
    storage_live(tl_3)
    tl_3 = move (l_1 as variant List::Cons).1
    storage_live(_4)
    _4 = move hd_2
    storage_live(_5)
    _5 = move (*tl_3)
    _0 = (move _4, move _5)
    conditional_drop[{impl Destruct for List<T>[@TraitClause0]}<T>[@TraitClause0]] _5
    storage_dead(_5)
    conditional_drop[{built_in impl Destruct for T}] _4
    storage_dead(_4)
    conditional_drop[{impl Destruct for alloc::boxed::Box<T>[@TraitClause0, @TraitClause1]}<List<T>[@TraitClause0], Global>[{built_in impl MetaSized for List<T>[@TraitClause0]}, {built_in impl Sized for Global}]] tl_3
    storage_dead(tl_3)
    conditional_drop[{built_in impl Destruct for T}] hd_2
    storage_dead(hd_2)
    conditional_drop[{impl Destruct for List<T>[@TraitClause0]}<T>[@TraitClause0]] l_1
    return
}

// Full name: test_crate::test_char
pub fn test_char() -> char
{
    let _0: char; // return

    _0 = const a
    return
}

// Full name: test_crate::Tree
pub enum Tree<T>
where
    [@TraitClause0]: Sized<T>,
{
  Leaf(T),
  Node(T, NodeElem<T>[@TraitClause0], alloc::boxed::Box<Tree<T>[@TraitClause0]>[{built_in impl MetaSized for Tree<T>[@TraitClause0]}, {built_in impl Sized for Global}]),
}

// Full name: test_crate::NodeElem
pub enum NodeElem<T>
where
    [@TraitClause0]: Sized<T>,
{
  Cons(alloc::boxed::Box<Tree<T>[@TraitClause0]>[{built_in impl MetaSized for Tree<T>[@TraitClause0]}, {built_in impl Sized for Global}], alloc::boxed::Box<NodeElem<T>[@TraitClause0]>[{built_in impl MetaSized for NodeElem<T>[@TraitClause0]}, {built_in impl Sized for Global}]),
  Nil,
}

// Full name: test_crate::even
pub fn even(@1: u32) -> bool
{
    let _0: bool; // return
    let x_1: u32; // arg #1
    let _2: bool; // anonymous local
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_6)
    storage_live(_2)
    storage_live(_3)
    _3 = copy x_1
    _2 = move _3 == const 0 : u32
    if move _2 {
        storage_dead(_3)
        _0 = const true
    } else {
        storage_dead(_3)
        storage_live(_4)
        storage_live(_5)
        _5 = copy x_1
        _6 = copy _5 panic.- const 1 : u32
        _4 = move _6
        storage_dead(_5)
        _0 = odd(move _4)
        storage_dead(_4)
    }
    storage_dead(_2)
    return
}

// Full name: test_crate::odd
pub fn odd(@1: u32) -> bool
{
    let _0: bool; // return
    let x_1: u32; // arg #1
    let _2: bool; // anonymous local
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local

    storage_live(_6)
    storage_live(_2)
    storage_live(_3)
    _3 = copy x_1
    _2 = move _3 == const 0 : u32
    if move _2 {
        storage_dead(_3)
        _0 = const false
    } else {
        storage_dead(_3)
        storage_live(_4)
        storage_live(_5)
        _5 = copy x_1
        _6 = copy _5 panic.- const 1 : u32
        _4 = move _6
        storage_dead(_5)
        _0 = even(move _4)
        storage_dead(_4)
    }
    storage_dead(_2)
    return
}

// Full name: test_crate::test_even_odd
pub fn test_even_odd()
{
    let _0: (); // return
    let _1: bool; // anonymous local
    let _2: bool; // anonymous local
    let _3: bool; // anonymous local
    let _4: bool; // anonymous local

    _0 = ()
    storage_live(_1)
    _1 = even(const 0 : u32)
    assert(move _1 == true) else panic(core::panicking::panic)
    storage_dead(_1)
    storage_live(_2)
    _2 = even(const 4 : u32)
    assert(move _2 == true) else panic(core::panicking::panic)
    storage_dead(_2)
    storage_live(_3)
    _3 = odd(const 1 : u32)
    assert(move _3 == true) else panic(core::panicking::panic)
    storage_dead(_3)
    storage_live(_4)
    _4 = odd(const 5 : u32)
    assert(move _4 == true) else panic(core::panicking::panic)
    storage_dead(_4)
    _0 = ()
    return
}

// Full name: test_crate::StructWithTuple
pub struct StructWithTuple<T1, T2>
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
{
  p: (T1, T2),
}

// Full name: test_crate::new_tuple1
pub fn new_tuple1() -> StructWithTuple<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]
{
    let _0: StructWithTuple<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // return
    let _1: (u32, u32); // anonymous local

    storage_live(_1)
    _1 = (const 1 : u32, const 2 : u32)
    _0 = StructWithTuple { p: move _1 }
    storage_dead(_1)
    return
}

// Full name: test_crate::new_tuple2
pub fn new_tuple2() -> StructWithTuple<i16, i16>[{built_in impl Sized for i16}, {built_in impl Sized for i16}]
{
    let _0: StructWithTuple<i16, i16>[{built_in impl Sized for i16}, {built_in impl Sized for i16}]; // return
    let _1: (i16, i16); // anonymous local

    storage_live(_1)
    _1 = (const 1 : i16, const 2 : i16)
    _0 = StructWithTuple { p: move _1 }
    storage_dead(_1)
    return
}

// Full name: test_crate::new_tuple3
pub fn new_tuple3() -> StructWithTuple<u64, i64>[{built_in impl Sized for u64}, {built_in impl Sized for i64}]
{
    let _0: StructWithTuple<u64, i64>[{built_in impl Sized for u64}, {built_in impl Sized for i64}]; // return
    let _1: (u64, i64); // anonymous local

    storage_live(_1)
    _1 = (const 1 : u64, const 2 : i64)
    _0 = StructWithTuple { p: move _1 }
    storage_dead(_1)
    return
}

// Full name: test_crate::StructWithPair
pub struct StructWithPair<T1, T2>
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
{
  p: Pair<T1, T2>[@TraitClause0, @TraitClause1],
}

// Full name: test_crate::new_pair1
pub fn new_pair1() -> StructWithPair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]
{
    let _0: StructWithPair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // return
    let _1: Pair<u32, u32>[{built_in impl Sized for u32}, {built_in impl Sized for u32}]; // anonymous local

    storage_live(_1)
    // This actually doesn't make rustc generate a constant...
    // I guess it only happens for tuples.
    _1 = Pair { x: const 1 : u32, y: const 2 : u32 }
    _0 = StructWithPair { p: move _1 }
    storage_dead(_1)
    return
}

// Full name: test_crate::incr
pub fn incr<'_0>(@1: &'_0 mut u32)
{
    let _0: (); // return
    let x_1: &'0 mut u32; // arg #1
    let _2: u32; // anonymous local

    storage_live(_2)
    _0 = ()
    _2 = copy (*x_1) panic.+ const 1 : u32
    (*x_1) = move _2
    _0 = ()
    return
}

// Full name: test_crate::read_then_incr
pub fn read_then_incr<'_0>(@1: &'_0 mut u32) -> u32
{
    let _0: u32; // return
    let x_1: &'0 mut u32; // arg #1
    let r_2: u32; // local
    let _3: u32; // anonymous local

    storage_live(_3)
    storage_live(r_2)
    r_2 = copy (*x_1)
    _3 = copy (*x_1) panic.+ const 1 : u32
    (*x_1) = move _3
    _0 = copy r_2
    storage_dead(r_2)
    return
}



