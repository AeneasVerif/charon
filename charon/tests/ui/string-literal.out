# Final LLBC before serialization:

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::Display
#[lang_item("Display")]
pub trait Display<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::Display::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::Display::{vtable}
}

pub fn core::fmt::Display::fmt<'_0, '_1, '_2, Self>(@1: &'_0 (Self), @2: &'_1 mut (Formatter<'_2>)) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: Display<Self>,
= <opaque>

// Full name: core::fmt::{impl Display for Str}::fmt
pub fn {impl Display for Str}::fmt<'_0, '_1, '_2>(@1: &'_0 (Str), @2: &'_1 mut (Formatter<'_2>)) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <opaque>

// Full name: core::fmt::{impl Display for Str}
impl Display for Str {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl Display for Str}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl Display for Str}::{vtable}
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: alloc::string::String::{impl Destruct for String}::drop_in_place
fn {impl Destruct for String}::drop_in_place(@1: *mut String)
= <opaque>

// Full name: alloc::string::String::{impl Destruct for String}
impl Destruct for String {
    fn drop_in_place = {impl Destruct for String}::drop_in_place
    non-dyn-compatible
}

// Full name: alloc::string::ToString
#[lang_item("ToString")]
pub trait ToString<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn to_string<'_0_1> = alloc::string::ToString::to_string<'_0_1, Self>[Self]
    vtable: alloc::string::ToString::{vtable}
}

#[lang_item("to_string_method")]
pub fn alloc::string::ToString::to_string<'_0, Self>(@1: &'_0 (Self)) -> String
where
    [@TraitClause0]: ToString<Self>,
= <opaque>

// Full name: alloc::string::{impl ToString for T}::to_string
pub fn {impl ToString for T}::to_string<'_0, T>(@1: &'_0 (T)) -> String
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Display<T>,
= <opaque>

// Full name: alloc::string::{impl ToString for T}
impl<T> ToString for T
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Display<T>,
{
    parent_clause0 = @TraitClause0
    fn to_string<'_0_1> = {impl ToString for T}::to_string<'_0_1, T>[@TraitClause0, @TraitClause1]
    vtable: {impl ToString for T}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::FOO
fn FOO() -> &'static (Str)
{
    let @0: &'_ (Str); // return

    @0 := const ("hello")
    return
}

// Full name: test_crate::FOO
static FOO: &'static (Str) = FOO()

// Full name: test_crate::BAR
fn BAR() -> &'static (Slice<u8>)
{
    let @0: &'_ (Slice<u8>); // return
    let @1: &'_ (Array<u8, 5 : usize>); // anonymous local
    let @2: &'_ (Array<u8, 5 : usize>); // anonymous local
    let @3: Array<u8, 5 : usize>; // anonymous local
    let @4: &'_ (Array<u8, 5 : usize>); // anonymous local

    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    @3 := [const (104 : u8), const (101 : u8), const (108 : u8), const (108 : u8), const (111 : u8)]
    storage_live(@4)
    @4 := &@3
    @2 := move (@4)
    @1 := &*(@2)
    @0 := @ArrayToSliceShared<'_, u8, 5 : usize>(move (@1))
    storage_dead(@2)
    storage_dead(@1)
    return
}

// Full name: test_crate::BAR
static BAR: &'static (Slice<u8>) = BAR()

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let _s@1: String; // local
    let @2: &'_ (Str); // anonymous local
    let @3: &'_ (Str); // anonymous local

    @0 := ()
    storage_live(_s@1)
    storage_live(@2)
    storage_live(@3)
    @3 := const ("Hello")
    @2 := &*(@3) with_metadata(copy (@3.metadata))
    _s@1 := {impl ToString for T}::to_string<'_, Str>[{built_in impl MetaSized for Str}, {impl Display for Str}](move (@2))
    storage_dead(@2)
    storage_dead(@3)
    @0 := ()
    drop[{impl Destruct for String}] _s@1
    storage_dead(_s@1)
    return
}



