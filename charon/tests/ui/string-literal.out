# Final LLBC before serialization:

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::fmt::Formatter
#[lang_item("Formatter")]
pub opaque type Formatter<'a>
where
    'a : 'a,

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::Display
#[lang_item("Display")]
pub trait Display<Self>
{
    fn fmt<'_0, '_1, '_2> = core::fmt::Display::fmt<'_0_0, '_0_1, '_0_2, Self>[Self]
}

pub fn core::fmt::Display::fmt<'_0, '_1, '_2, Self>(@1: &'_0 (Self), @2: &'_1 mut (Formatter<'_2>)) -> Result<(), Error>[Sized<()>, Sized<Error>]
where
    [@TraitClause0]: Display<Self>,

// Full name: core::fmt::{impl Display for Str}#19::fmt
pub fn {impl Display for Str}#19::fmt<'_0, '_1, '_2>(@1: &'_0 (Str), @2: &'_1 mut (Formatter<'_2>)) -> Result<(), Error>[Sized<()>, Sized<Error>]

// Full name: core::fmt::{impl Display for Str}#19
impl Display for Str {
    fn fmt<'_0, '_1, '_2> = {impl Display for Str}#19::fmt<'_0_0, '_0_1, '_0_2>
}

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: alloc::string::ToString
#[lang_item("ToString")]
pub trait ToString<Self>
{
    fn to_string<'_0> = alloc::string::ToString::to_string<'_0_0, Self>[Self]
}

#[lang_item("to_string_method")]
pub fn alloc::string::ToString::to_string<'_0, Self>(@1: &'_0 (Self)) -> String
where
    [@TraitClause0]: ToString<Self>,

// Full name: alloc::string::{impl ToString for T}#34::to_string
pub fn {impl ToString for T}#34::to_string<'_0, T>(@1: &'_0 (T)) -> String
where
    [@TraitClause0]: Display<T>,

// Full name: alloc::string::{impl ToString for T}#34
impl<T> ToString for T
where
    [@TraitClause0]: Display<T>,
{
    fn to_string<'_0> = {impl ToString for T}#34::to_string<'_0_0, T>[@TraitClause0]
}

fn test_crate::FOO() -> &'static (Str)
{
    let @0: &'_ (Str); // return

    @0 := const ("hello")
    return
}

static test_crate::FOO: &'static (Str) = test_crate::FOO()

fn test_crate::BAR() -> &'static (Slice<u8>)
{
    let @0: &'_ (Slice<u8>); // return
    let @1: &'_ (Array<u8, 5 : usize>); // anonymous local
    let @2: &'_ (Array<u8, 5 : usize>); // anonymous local
    let @3: Array<u8, 5 : usize>; // anonymous local
    let @4: &'_ (Array<u8, 5 : usize>); // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@1)
    storage_live(@2)
    @3 := [const (104 : u8), const (101 : u8), const (108 : u8), const (108 : u8), const (111 : u8)]
    @4 := &@3
    @2 := move (@4)
    @1 := &*(@2)
    @0 := @ArrayToSliceShared<'_, u8, 5 : usize>(move (@1))
    storage_dead(@2)
    storage_dead(@1)
    return
}

static test_crate::BAR: &'static (Slice<u8>) = test_crate::BAR()

// Full name: test_crate::main
fn main()
{
    let @0: (); // return
    let _s@1: String; // local
    let @2: &'_ (Str); // anonymous local
    let @3: &'_ (Str); // anonymous local

    storage_live(_s@1)
    storage_live(@2)
    storage_live(@3)
    @3 := const ("Hello")
    @2 := &*(@3)
    _s@1 := {impl ToString for T}#34::to_string<'_, Str>[{impl Display for Str}#19](move (@2))
    storage_dead(@2)
    storage_dead(@3)
    @0 := ()
    drop _s@1
    storage_dead(_s@1)
    @0 := ()
    return
}



