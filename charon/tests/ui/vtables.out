# Final LLBC before serialization:

opaque type core::marker::MetaSized::{vtable}

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <opaque>

// Full name: core::clone::impls::{impl Clone for i32}::clone
pub fn {impl Clone for i32}::clone<'_0>(@1: &'_0 i32) -> i32
= <opaque>

// Full name: core::clone::impls::{impl Clone for i32}
impl Clone for i32 {
    parent_clause0 = {built_in impl Sized for i32}
    fn clone<'_0_1> = {impl Clone for i32}::clone<'_0_1>
    non-dyn-compatible
}

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::Display
#[lang_item("Display")]
pub trait Display<Self>
{
    fn fmt<'_0_1, '_1_1, '_2_1> = core::fmt::Display::fmt<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: core::fmt::Display::{vtable}
}

pub fn core::fmt::Display::fmt<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
where
    [@TraitClause0]: Display<Self>,
= <opaque>

// Full name: core::fmt::{impl Display for Str}::fmt
pub fn {impl Display for Str}::fmt<'_0, '_1, '_2>(@1: &'_0 Str, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <opaque>

// Full name: core::fmt::{impl Display for Str}
impl Display for Str {
    fn fmt<'_0_1, '_1_1, '_2_1> = {impl Display for Str}::fmt<'_0_1, '_1_1, '_2_1>
    vtable: {impl Display for Str}::{vtable}
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::panicking::AssertKind
pub enum AssertKind {
  Eq,
  Ne,
  Match,
}

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: alloc::string::String::{impl Destruct for String}::drop_in_place
unsafe fn {impl Destruct for String}::drop_in_place(@1: *mut String)
= <opaque>

// Full name: alloc::string::String::{impl Destruct for String}
impl Destruct for String {
    fn drop_in_place = {impl Destruct for String}::drop_in_place
    non-dyn-compatible
}

// Full name: alloc::string::{String}::is_empty
pub fn is_empty<'_0>(@1: &'_0 String) -> bool
= <opaque>

// Full name: alloc::string::{impl Clone for String}::clone
pub fn {impl Clone for String}::clone<'_0>(@1: &'_0 String) -> String
= <opaque>

// Full name: alloc::string::{impl Clone for String}
impl Clone for String {
    parent_clause0 = {built_in impl Sized for String}
    fn clone<'_0_1> = {impl Clone for String}::clone<'_0_1>
    non-dyn-compatible
}

// Full name: alloc::string::ToString
#[lang_item("ToString")]
pub trait ToString<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn to_string<'_0_1> = alloc::string::ToString::to_string<'_0_1, Self>[Self]
    vtable: alloc::string::ToString::{vtable}
}

#[lang_item("to_string_method")]
pub fn alloc::string::ToString::to_string<'_0, Self>(@1: &'_0 Self) -> String
where
    [@TraitClause0]: ToString<Self>,
= <opaque>

// Full name: alloc::string::{impl ToString for T}::to_string
pub fn {impl ToString for T}::to_string<'_0, T>(@1: &'_0 T) -> String
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Display<T>,
= <opaque>

// Full name: alloc::string::{impl ToString for T}
impl<T> ToString for T
where
    [@TraitClause0]: MetaSized<T>,
    [@TraitClause1]: Display<T>,
{
    parent_clause0 = @TraitClause0
    fn to_string<'_0_1> = {impl ToString for T}::to_string<'_0_1, T>[@TraitClause0, @TraitClause1]
    vtable: {impl ToString for T}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

struct test_crate::Super::{vtable}<T> {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn Super<T>)),
  method_super_method: fn<'_0_1>(&'_0_1 (dyn Super<T>), T) -> i32,
  super_trait_0: &'static core::marker::MetaSized::{vtable},
}

// Full name: test_crate::Super
trait Super<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn super_method<'_0_1> = test_crate::Super::super_method<'_0_1, Self, T>[Self]
    vtable: test_crate::Super::{vtable}<T>
}

fn test_crate::Super::super_method<'_0, Self, T>(@1: &'_0 Self, @2: T) -> i32
where
    [@TraitClause0]: Super<Self, T>,
= <method_without_default_body>

struct test_crate::Checkable::{vtable}<T> {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn Checkable<T>)),
  method_check: fn<'_0_1>(&'_0_1 (dyn Checkable<T>)) -> bool,
  super_trait_0: &'static core::marker::MetaSized::{vtable},
  super_trait_1: &'static test_crate::Super::{vtable}<T>,
}

// Full name: test_crate::Checkable
trait Checkable<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Super<Self, T>
    parent_clause2 : [@TraitClause2]: Sized<T>
    fn check<'_0_1> = test_crate::Checkable::check<'_0_1, Self, T>[Self]
    vtable: test_crate::Checkable::{vtable}<T>
}

fn test_crate::Checkable::check<'_0, Self, T>(@1: &'_0 Self) -> bool
where
    [@TraitClause0]: Checkable<Self, T>,
= <method_without_default_body>

// Full name: test_crate::{impl Super<i32> for i32}::super_method
fn {impl Super<i32> for i32}::super_method<'_0>(@1: &'_0 i32, @2: i32) -> i32
{
    let _0: i32; // return
    let self_1: &'0 i32; // arg #1
    let arg_2: i32; // arg #2
    let _3: i32; // anonymous local
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local

    storage_live(_5)
    storage_live(_3)
    _3 = copy (*self_1)
    storage_live(_4)
    _4 = copy arg_2
    _5 = copy _3 panic.+ copy _4
    _0 = move _5
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::{impl Super<i32> for i32}::super_method::{vtable_method}
fn {impl Super<i32> for i32}::super_method::{vtable_method}<'_0>(@1: &'_0 (dyn Super<i32>), @2: i32) -> i32
{
    let _0: i32; // return
    let _1: &'_0 (dyn Super<i32> + '0); // arg #1
    let _2: i32; // arg #2
    let _3: &'_0 i32; // anonymous local

    storage_live(_3)
    _3 = concretize<&'_0 (dyn Super<i32> + '1), &'_0 i32>(move _1)
    _0 = {impl Super<i32> for i32}::super_method<'_0>(move _3, move _2)
    return
}

// Full name: test_crate::{impl Super<i32> for i32}::{vtable_drop_shim}
unsafe fn {impl Super<i32> for i32}::{vtable_drop_shim}(@1: *mut (dyn Super<i32>))
{
    let ret_0: (); // return
    let dyn_self_1: *mut (dyn Super<i32> + '0); // arg #1
    let target_self_2: *mut i32; // local

    ret_0 = ()
    storage_live(target_self_2)
    target_self_2 = concretize<*mut (dyn Super<i32> + '1), *mut i32>(move dyn_self_1)
    return
}

// Full name: test_crate::{impl Super<i32> for i32}::{vtable}
fn {impl Super<i32> for i32}::{vtable}() -> test_crate::Super::{vtable}<i32>
{
    let ret_0: test_crate::Super::{vtable}<i32>; // return
    let size_1: usize; // local
    let align_2: usize; // local

    storage_live(size_1)
    size_1 = size_of<i32>
    storage_live(align_2)
    align_2 = align_of<i32>
    ret_0 = test_crate::Super::{vtable} { size: move size_1, align: move align_2, drop: const {impl Super<i32> for i32}::{vtable_drop_shim}, method_super_method: const {impl Super<i32> for i32}::super_method::{vtable_method}<'1>, super_trait_0: const Opaque(missing supertrait vtable) }
    return
}

// Full name: test_crate::{impl Super<i32> for i32}::{vtable}
static {impl Super<i32> for i32}::{vtable}: test_crate::Super::{vtable}<i32> = {impl Super<i32> for i32}::{vtable}()

// Full name: test_crate::{impl Super<i32> for i32}
impl Super<i32> for i32 {
    parent_clause0 = {built_in impl MetaSized for i32}
    parent_clause1 = {built_in impl Sized for i32}
    fn super_method<'_0_1> = {impl Super<i32> for i32}::super_method<'_0_1>
    vtable: {impl Super<i32> for i32}::{vtable}
}

// Full name: test_crate::{impl Checkable<i32> for i32}::check
fn {impl Checkable<i32> for i32}::check<'_0>(@1: &'_0 i32) -> bool
{
    let _0: bool; // return
    let self_1: &'0 i32; // arg #1
    let _2: i32; // anonymous local
    let _3: &'0 i32; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = &(*self_1)
    _2 = {impl Super<i32> for i32}::super_method<'2>(move _3, const 10 : i32)
    storage_dead(_3)
    _0 = move _2 > const 0 : i32
    storage_dead(_2)
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::check::{vtable_method}
fn {impl Checkable<i32> for i32}::check::{vtable_method}<'_0>(@1: &'_0 (dyn Checkable<i32>)) -> bool
{
    let _0: bool; // return
    let _1: &'_0 (dyn Checkable<i32> + '0); // arg #1
    let _2: &'_0 i32; // anonymous local

    storage_live(_2)
    _2 = concretize<&'_0 (dyn Checkable<i32> + '1), &'_0 i32>(move _1)
    _0 = {impl Checkable<i32> for i32}::check<'_0>(move _2)
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::{vtable_drop_shim}
unsafe fn {impl Checkable<i32> for i32}::{vtable_drop_shim}(@1: *mut (dyn Checkable<i32>))
{
    let ret_0: (); // return
    let dyn_self_1: *mut (dyn Checkable<i32> + '0); // arg #1
    let target_self_2: *mut i32; // local

    ret_0 = ()
    storage_live(target_self_2)
    target_self_2 = concretize<*mut (dyn Checkable<i32> + '1), *mut i32>(move dyn_self_1)
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::{vtable}
fn {impl Checkable<i32> for i32}::{vtable}() -> test_crate::Checkable::{vtable}<i32>
{
    let ret_0: test_crate::Checkable::{vtable}<i32>; // return
    let size_1: usize; // local
    let align_2: usize; // local
    let _3: &'static test_crate::Super::{vtable}<i32>; // anonymous local

    storage_live(size_1)
    size_1 = size_of<i32>
    storage_live(align_2)
    align_2 = align_of<i32>
    storage_live(_3)
    _3 = &{impl Super<i32> for i32}::{vtable}
    ret_0 = test_crate::Checkable::{vtable} { size: move size_1, align: move align_2, drop: const {impl Checkable<i32> for i32}::{vtable_drop_shim}, method_check: const {impl Checkable<i32> for i32}::check::{vtable_method}<'1>, super_trait_0: const Opaque(missing supertrait vtable), super_trait_1: move _3 }
    return
}

// Full name: test_crate::{impl Checkable<i32> for i32}::{vtable}
static {impl Checkable<i32> for i32}::{vtable}: test_crate::Checkable::{vtable}<i32> = {impl Checkable<i32> for i32}::{vtable}()

// Full name: test_crate::{impl Checkable<i32> for i32}
impl Checkable<i32> for i32 {
    parent_clause0 = {built_in impl MetaSized for i32}
    parent_clause1 = {impl Super<i32> for i32}
    parent_clause2 = {built_in impl Sized for i32}
    fn check<'_0_1> = {impl Checkable<i32> for i32}::check<'_0_1>
    vtable: {impl Checkable<i32> for i32}::{vtable}
}

struct test_crate::NoParam::{vtable} {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn NoParam)),
  method_dummy: fn<'_0_1>(&'_0_1 (dyn NoParam)),
  super_trait_0: &'static core::marker::MetaSized::{vtable},
}

// Full name: test_crate::NoParam
trait NoParam<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn dummy<'_0_1> = test_crate::NoParam::dummy<'_0_1, Self>[Self]
    vtable: test_crate::NoParam::{vtable}
}

fn test_crate::NoParam::dummy<'_0, Self>(@1: &'_0 Self)
where
    [@TraitClause0]: NoParam<Self>,
= <method_without_default_body>

// Full name: test_crate::{impl NoParam for i32}::dummy
fn {impl NoParam for i32}::dummy<'_0>(@1: &'_0 i32)
{
    let _0: (); // return
    let self_1: &'0 i32; // arg #1
    let _2: bool; // anonymous local
    let _3: i32; // anonymous local

    _0 = ()
    storage_live(_2)
    storage_live(_3)
    _3 = copy (*self_1)
    _2 = move _3 > const 0 : i32
    if move _2 {
    } else {
        storage_dead(_3)
        panic(core::panicking::panic)
    }
    storage_dead(_3)
    storage_dead(_2)
    _0 = ()
    return
}

// Full name: test_crate::{impl NoParam for i32}
impl NoParam for i32 {
    parent_clause0 = {built_in impl MetaSized for i32}
    fn dummy<'_0_1> = {impl NoParam for i32}::dummy<'_0_1>
    vtable: {impl NoParam for i32}::{vtable}
}

// Full name: test_crate::to_dyn_obj
fn to_dyn_obj<'_0, T>(@1: &'_0 T) -> &'_0 (dyn NoParam + '_0)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: NoParam<T>,
{
    let _0: &'0 (dyn NoParam + '1); // return
    let arg_1: &'2 T; // arg #1
    let _2: &'0 (dyn NoParam + '1); // anonymous local
    let _3: &'0 (dyn NoParam + '1); // anonymous local
    let _4: &'2 T; // anonymous local

    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    _4 = &(*arg_1)
    _3 = unsize_cast<&'2 T, &'0 (dyn NoParam + '1), @TraitClause1 with ?>(move _4)
    storage_dead(_4)
    _2 = &(*_3) with_metadata(copy _3.metadata)
    _0 = unsize_cast<&'0 (dyn NoParam + '1), &'0 (dyn NoParam + '1),  at []>(move _2)
    storage_dead(_3)
    storage_dead(_2)
    return
}

struct test_crate::Modifiable::{vtable}<T> {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn Modifiable<T>)),
  method_modify: fn<'_0_1, '_1_1>(&'_0_1 mut (dyn Modifiable<T>), &'_1_1 T) -> T,
  super_trait_0: &'static core::marker::MetaSized::{vtable},
}

// Full name: test_crate::Modifiable
trait Modifiable<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn modify<'_0_1, '_1_1> = test_crate::Modifiable::modify<'_0_1, '_1_1, Self, T>[Self]
    vtable: test_crate::Modifiable::{vtable}<T>
}

fn test_crate::Modifiable::modify<'_0, '_1, Self, T>(@1: &'_0 mut Self, @2: &'_1 T) -> T
where
    [@TraitClause0]: Modifiable<Self, T>,
= <method_without_default_body>

// Full name: test_crate::{impl Modifiable<T> for i32}::modify
fn {impl Modifiable<T> for i32}::modify<'_0, '_1, T>(@1: &'_0 mut i32, @2: &'_1 T) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let self_1: &'0 mut i32; // arg #1
    let arg_2: &'1 T; // arg #2
    let _3: i32; // anonymous local
    let _4: &'1 T; // anonymous local

    storage_live(_3)
    _3 = copy (*self_1) panic.+ const 1 : i32
    (*self_1) = move _3
    storage_live(_4)
    _4 = &(*arg_2)
    _0 = @TraitClause1::clone<'3>(move _4)
    storage_dead(_4)
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::modify::{vtable_method}
fn {impl Modifiable<T> for i32}::modify::{vtable_method}<'_0, '_1, T>(@1: &'_0 mut (dyn Modifiable<T>), @2: &'_1 T) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let _1: &'_0 mut (dyn Modifiable<T> + '0); // arg #1
    let _2: &'_1 T; // arg #2
    let _3: &'_0 mut i32; // anonymous local

    storage_live(_3)
    _3 = concretize<&'_0 mut (dyn Modifiable<T> + '1), &'_0 mut i32>(move _1)
    _0 = {impl Modifiable<T> for i32}::modify<'_0, '_1, T>[@TraitClause0, @TraitClause1](move _3, move _2)
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::{vtable_drop_shim}
unsafe fn {impl Modifiable<T> for i32}::{vtable_drop_shim}<T>(@1: *mut (dyn Modifiable<T>))
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let ret_0: (); // return
    let dyn_self_1: *mut (dyn Modifiable<T> + '0); // arg #1
    let target_self_2: *mut i32; // local

    ret_0 = ()
    storage_live(target_self_2)
    target_self_2 = concretize<*mut (dyn Modifiable<T> + '1), *mut i32>(move dyn_self_1)
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::{vtable}
fn {impl Modifiable<T> for i32}::{vtable}<T>() -> test_crate::Modifiable::{vtable}<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let ret_0: test_crate::Modifiable::{vtable}<T>; // return
    let size_1: usize; // local
    let align_2: usize; // local

    storage_live(size_1)
    size_1 = size_of<i32>
    storage_live(align_2)
    align_2 = align_of<i32>
    ret_0 = test_crate::Modifiable::{vtable} { size: move size_1, align: move align_2, drop: const {impl Modifiable<T> for i32}::{vtable_drop_shim}<T>[@TraitClause0, @TraitClause1], method_modify: const {impl Modifiable<T> for i32}::modify::{vtable_method}<'1, '2, T>[@TraitClause0, @TraitClause1], super_trait_0: const Opaque(missing supertrait vtable) }
    return
}

// Full name: test_crate::{impl Modifiable<T> for i32}::{vtable}
static {impl Modifiable<T> for i32}::{vtable}<T>: test_crate::Modifiable::{vtable}<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
 = {impl Modifiable<T> for i32}::{vtable}()

// Full name: test_crate::{impl Modifiable<T> for i32}
impl<T> Modifiable<T> for i32
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    parent_clause0 = {built_in impl MetaSized for i32}
    parent_clause1 = @TraitClause0
    fn modify<'_0_1, '_1_1> = {impl Modifiable<T> for i32}::modify<'_0_1, '_1_1, T>[@TraitClause0, @TraitClause1]
    vtable: {impl Modifiable<T> for i32}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

// Full name: test_crate::modify_trait_object
fn modify_trait_object<'_0, T>(@1: &'_0 T) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Clone<T>,
{
    let _0: T; // return
    let arg_1: &'0 T; // arg #1
    let x_2: &'1 mut (dyn Modifiable<T> + '2); // local
    let _3: &'3 mut i32; // anonymous local
    let _4: &'3 mut i32; // anonymous local
    let _5: i32; // anonymous local
    let _6: &'1 mut (dyn Modifiable<T> + '2); // anonymous local
    let _7: &'0 T; // anonymous local

    storage_live(x_2)
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = const 199 : i32
    _4 = &mut _5
    _3 = &mut (*_4)
    x_2 = unsize_cast<&'3 mut i32, &'1 mut (dyn Modifiable<T> + '2), {impl Modifiable<T> for i32}<T>[@TraitClause0, @TraitClause1] with {impl Modifiable<T> for i32}::{vtable}<T>[@TraitClause0, @TraitClause1]>(move _3)
    storage_dead(_3)
    storage_dead(_4)
    storage_live(_6)
    _6 = &two-phase-mut (*x_2) with_metadata(copy x_2.metadata)
    storage_live(_7)
    _7 = &(*arg_1)
    _0 = (copy ((*_6.metadata)).method_modify)(move _6, move _7)
    storage_dead(_7)
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(x_2)
    return
}

struct test_crate::BaseOn::{vtable}<T> {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn BaseOn<T>)),
  method_operate_on: fn<'_0_1, '_1_1>(&'_0_1 (dyn BaseOn<T>), &'_1_1 T),
  super_trait_0: &'static core::marker::MetaSized::{vtable},
}

// Full name: test_crate::BaseOn
trait BaseOn<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn operate_on<'_0_1, '_1_1> = test_crate::BaseOn::operate_on<'_0_1, '_1_1, Self, T>[Self]
    vtable: test_crate::BaseOn::{vtable}<T>
}

fn test_crate::BaseOn::operate_on<'_0, '_1, Self, T>(@1: &'_0 Self, @2: &'_1 T)
where
    [@TraitClause0]: BaseOn<Self, T>,
= <method_without_default_body>

struct test_crate::Both32And64::{vtable} {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn Both32And64)),
  method_both_operate: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 (dyn Both32And64), &'_1_1 i32, &'_2_1 i64),
  super_trait_0: &'static core::marker::MetaSized::{vtable},
  super_trait_1: &'static test_crate::BaseOn::{vtable}<i32>,
  super_trait_2: &'static test_crate::BaseOn::{vtable}<i64>,
}

// Full name: test_crate::Both32And64
trait Both32And64<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: BaseOn<Self, i32>
    parent_clause2 : [@TraitClause2]: BaseOn<Self, i64>
    fn both_operate<'_0_1, '_1_1, '_2_1> = test_crate::Both32And64::both_operate<'_0_1, '_1_1, '_2_1, Self>[Self]
    vtable: test_crate::Both32And64::{vtable}
}

fn test_crate::Both32And64::both_operate<'_0, '_1, '_2, Self>(@1: &'_0 Self, @2: &'_1 i32, @3: &'_2 i64)
where
    [@TraitClause0]: Both32And64<Self>,
{
    let _0: (); // return
    let self_1: &'0 Self; // arg #1
    let t32_2: &'1 i32; // arg #2
    let t64_3: &'2 i64; // arg #3
    let _4: (); // anonymous local
    let _5: &'0 Self; // anonymous local
    let _6: &'1 i32; // anonymous local
    let _7: (); // anonymous local
    let _8: &'0 Self; // anonymous local
    let _9: &'2 i64; // anonymous local

    _0 = ()
    storage_live(_4)
    storage_live(_5)
    _5 = &(*self_1) with_metadata(copy self_1.metadata)
    storage_live(_6)
    _6 = &(*t32_2)
    _4 = @TraitClause0::parent_clause1::operate_on<'5, '6>(move _5, move _6)
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_4)
    storage_live(_7)
    storage_live(_8)
    _8 = &(*self_1) with_metadata(copy self_1.metadata)
    storage_live(_9)
    _9 = &(*t64_3)
    _7 = @TraitClause0::parent_clause2::operate_on<'9, '10>(move _8, move _9)
    storage_dead(_9)
    storage_dead(_8)
    storage_dead(_7)
    _0 = ()
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}::operate_on
fn {impl BaseOn<i32> for i32}::operate_on<'_0, '_1>(@1: &'_0 i32, @2: &'_1 i32)
{
    let _0: (); // return
    let self_1: &'0 i32; // arg #1
    let t_2: &'0 i32; // arg #2
    let _3: bool; // anonymous local
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local

    _0 = ()
    storage_live(_3)
    storage_live(_4)
    _4 = copy (*self_1)
    storage_live(_5)
    _5 = copy (*t_2)
    _3 = move _4 > move _5
    if move _3 {
    } else {
        storage_dead(_5)
        storage_dead(_4)
        panic(core::panicking::panic)
    }
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    _0 = ()
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}::operate_on::{vtable_method}
fn {impl BaseOn<i32> for i32}::operate_on::{vtable_method}<'_0, '_1>(@1: &'_0 (dyn BaseOn<i32>), @2: &'_1 i32)
{
    let _0: (); // return
    let _1: &'_0 (dyn BaseOn<i32> + '0); // arg #1
    let _2: &'_1 i32; // arg #2
    let _3: &'_0 i32; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = concretize<&'_0 (dyn BaseOn<i32> + '1), &'_0 i32>(move _1)
    _0 = {impl BaseOn<i32> for i32}::operate_on<'_0, '_1>(move _3, move _2)
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}::{vtable_drop_shim}
unsafe fn {impl BaseOn<i32> for i32}::{vtable_drop_shim}(@1: *mut (dyn BaseOn<i32>))
{
    let ret_0: (); // return
    let dyn_self_1: *mut (dyn BaseOn<i32> + '0); // arg #1
    let target_self_2: *mut i32; // local

    ret_0 = ()
    storage_live(target_self_2)
    target_self_2 = concretize<*mut (dyn BaseOn<i32> + '1), *mut i32>(move dyn_self_1)
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}::{vtable}
fn {impl BaseOn<i32> for i32}::{vtable}() -> test_crate::BaseOn::{vtable}<i32>
{
    let ret_0: test_crate::BaseOn::{vtable}<i32>; // return
    let size_1: usize; // local
    let align_2: usize; // local

    storage_live(size_1)
    size_1 = size_of<i32>
    storage_live(align_2)
    align_2 = align_of<i32>
    ret_0 = test_crate::BaseOn::{vtable} { size: move size_1, align: move align_2, drop: const {impl BaseOn<i32> for i32}::{vtable_drop_shim}, method_operate_on: const {impl BaseOn<i32> for i32}::operate_on::{vtable_method}<'1, '2>, super_trait_0: const Opaque(missing supertrait vtable) }
    return
}

// Full name: test_crate::{impl BaseOn<i32> for i32}::{vtable}
static {impl BaseOn<i32> for i32}::{vtable}: test_crate::BaseOn::{vtable}<i32> = {impl BaseOn<i32> for i32}::{vtable}()

// Full name: test_crate::{impl BaseOn<i32> for i32}
impl BaseOn<i32> for i32 {
    parent_clause0 = {built_in impl MetaSized for i32}
    parent_clause1 = {built_in impl Sized for i32}
    fn operate_on<'_0_1, '_1_1> = {impl BaseOn<i32> for i32}::operate_on<'_0_1, '_1_1>
    vtable: {impl BaseOn<i32> for i32}::{vtable}
}

// Full name: test_crate::{impl BaseOn<i64> for i32}::operate_on
fn {impl BaseOn<i64> for i32}::operate_on<'_0, '_1>(@1: &'_0 i32, @2: &'_1 i64)
{
    let _0: (); // return
    let self_1: &'0 i32; // arg #1
    let t_2: &'1 i64; // arg #2
    let _3: bool; // anonymous local
    let _4: i64; // anonymous local
    let _5: i32; // anonymous local
    let _6: i64; // anonymous local

    _0 = ()
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = copy (*self_1)
    _4 = cast<i32, i64>(move _5)
    storage_dead(_5)
    storage_live(_6)
    _6 = copy (*t_2)
    _3 = move _4 > move _6
    if move _3 {
    } else {
        storage_dead(_6)
        storage_dead(_4)
        panic(core::panicking::panic)
    }
    storage_dead(_6)
    storage_dead(_4)
    storage_dead(_3)
    _0 = ()
    return
}

// Full name: test_crate::{impl BaseOn<i64> for i32}::operate_on::{vtable_method}
fn {impl BaseOn<i64> for i32}::operate_on::{vtable_method}<'_0, '_1>(@1: &'_0 (dyn BaseOn<i64>), @2: &'_1 i64)
{
    let _0: (); // return
    let _1: &'_0 (dyn BaseOn<i64> + '0); // arg #1
    let _2: &'_1 i64; // arg #2
    let _3: &'_0 i32; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = concretize<&'_0 (dyn BaseOn<i64> + '1), &'_0 i32>(move _1)
    _0 = {impl BaseOn<i64> for i32}::operate_on<'_0, '_1>(move _3, move _2)
    return
}

// Full name: test_crate::{impl BaseOn<i64> for i32}::{vtable_drop_shim}
unsafe fn {impl BaseOn<i64> for i32}::{vtable_drop_shim}(@1: *mut (dyn BaseOn<i64>))
{
    let ret_0: (); // return
    let dyn_self_1: *mut (dyn BaseOn<i64> + '0); // arg #1
    let target_self_2: *mut i32; // local

    ret_0 = ()
    storage_live(target_self_2)
    target_self_2 = concretize<*mut (dyn BaseOn<i64> + '1), *mut i32>(move dyn_self_1)
    return
}

// Full name: test_crate::{impl BaseOn<i64> for i32}::{vtable}
fn {impl BaseOn<i64> for i32}::{vtable}() -> test_crate::BaseOn::{vtable}<i64>
{
    let ret_0: test_crate::BaseOn::{vtable}<i64>; // return
    let size_1: usize; // local
    let align_2: usize; // local

    storage_live(size_1)
    size_1 = size_of<i32>
    storage_live(align_2)
    align_2 = align_of<i32>
    ret_0 = test_crate::BaseOn::{vtable} { size: move size_1, align: move align_2, drop: const {impl BaseOn<i64> for i32}::{vtable_drop_shim}, method_operate_on: const {impl BaseOn<i64> for i32}::operate_on::{vtable_method}<'1, '2>, super_trait_0: const Opaque(missing supertrait vtable) }
    return
}

// Full name: test_crate::{impl BaseOn<i64> for i32}::{vtable}
static {impl BaseOn<i64> for i32}::{vtable}: test_crate::BaseOn::{vtable}<i64> = {impl BaseOn<i64> for i32}::{vtable}()

// Full name: test_crate::{impl BaseOn<i64> for i32}
impl BaseOn<i64> for i32 {
    parent_clause0 = {built_in impl MetaSized for i32}
    parent_clause1 = {built_in impl Sized for i64}
    fn operate_on<'_0_1, '_1_1> = {impl BaseOn<i64> for i32}::operate_on<'_0_1, '_1_1>
    vtable: {impl BaseOn<i64> for i32}::{vtable}
}

// Full name: test_crate::{impl Both32And64 for i32}::{vtable_drop_shim}
unsafe fn {impl Both32And64 for i32}::{vtable_drop_shim}(@1: *mut (dyn Both32And64))
{
    let ret_0: (); // return
    let dyn_self_1: *mut (dyn Both32And64 + '0); // arg #1
    let target_self_2: *mut i32; // local

    ret_0 = ()
    storage_live(target_self_2)
    target_self_2 = concretize<*mut (dyn Both32And64 + '1), *mut i32>(move dyn_self_1)
    return
}

// Full name: test_crate::{impl Both32And64 for i32}::{vtable}
fn {impl Both32And64 for i32}::{vtable}() -> test_crate::Both32And64::{vtable}
{
    let ret_0: test_crate::Both32And64::{vtable}; // return
    let size_1: usize; // local
    let align_2: usize; // local
    let _3: &'static test_crate::BaseOn::{vtable}<i32>; // anonymous local
    let _4: &'static test_crate::BaseOn::{vtable}<i64>; // anonymous local

    storage_live(size_1)
    size_1 = size_of<i32>
    storage_live(align_2)
    align_2 = align_of<i32>
    storage_live(_3)
    _3 = &{impl BaseOn<i32> for i32}::{vtable}
    storage_live(_4)
    _4 = &{impl BaseOn<i64> for i32}::{vtable}
    ret_0 = test_crate::Both32And64::{vtable} { size: move size_1, align: move align_2, drop: const {impl Both32And64 for i32}::{vtable_drop_shim}, method_both_operate: const Opaque(shim for default methods aren't yet supported), super_trait_0: const Opaque(missing supertrait vtable), super_trait_1: move _3, super_trait_2: move _4 }
    return
}

// Full name: test_crate::{impl Both32And64 for i32}::{vtable}
static {impl Both32And64 for i32}::{vtable}: test_crate::Both32And64::{vtable} = {impl Both32And64 for i32}::{vtable}()

// Full name: test_crate::{impl Both32And64 for i32}::both_operate
fn {impl Both32And64 for i32}::both_operate<'_0, '_1, '_2>(@1: &'_0 i32, @2: &'_1 i32, @3: &'_2 i64)
{
    let _0: (); // return
    let self_1: &'0 i32; // arg #1
    let t32_2: &'1 i32; // arg #2
    let t64_3: &'2 i64; // arg #3
    let _4: (); // anonymous local
    let _5: &'0 i32; // anonymous local
    let _6: &'1 i32; // anonymous local
    let _7: (); // anonymous local
    let _8: &'0 i32; // anonymous local
    let _9: &'2 i64; // anonymous local

    _0 = ()
    storage_live(_4)
    storage_live(_5)
    _5 = &(*self_1)
    storage_live(_6)
    _6 = &(*t32_2)
    _4 = {impl Both32And64 for i32}::parent_clause1::operate_on<'5, '6>(move _5, move _6)
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_4)
    storage_live(_7)
    storage_live(_8)
    _8 = &(*self_1)
    storage_live(_9)
    _9 = &(*t64_3)
    _7 = {impl Both32And64 for i32}::parent_clause2::operate_on<'9, '10>(move _8, move _9)
    storage_dead(_9)
    storage_dead(_8)
    storage_dead(_7)
    _0 = ()
    return
}

// Full name: test_crate::{impl Both32And64 for i32}
impl Both32And64 for i32 {
    parent_clause0 = {built_in impl MetaSized for i32}
    parent_clause1 = {impl BaseOn<i32> for i32}
    parent_clause2 = {impl BaseOn<i64> for i32}
    fn both_operate<'_0_1, '_1_1, '_2_1> = {impl Both32And64 for i32}::both_operate<'_0_1, '_1_1, '_2_1>
    vtable: {impl Both32And64 for i32}::{vtable}
}

// Full name: test_crate::Alias
trait Alias<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Both32And64<Self>
    vtable: test_crate::Alias::{vtable}
}

struct test_crate::LifetimeTrait::{vtable}<Ty0> {
  size: usize,
  align: usize,
  drop: unsafe fn(*mut (dyn LifetimeTrait<Ty = Ty0>)),
  method_lifetime_method: fn<'a, '_1_1>(&'_1_1 (dyn LifetimeTrait<Ty = Ty0>), &'a Ty0) -> &'a Ty0,
  super_trait_0: &'static core::marker::MetaSized::{vtable},
}

// Full name: test_crate::LifetimeTrait
trait LifetimeTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Ty>
    type Ty
    fn lifetime_method<'a, '_1_1> = test_crate::LifetimeTrait::lifetime_method<'a, '_1_1, Self>[Self]
    vtable: test_crate::LifetimeTrait::{vtable}<Self::Ty>
}

fn test_crate::LifetimeTrait::lifetime_method<'a, '_1, Self>(@1: &'_1 Self, @2: &'a @TraitClause0::Ty) -> &'a @TraitClause0::Ty
where
    [@TraitClause0]: LifetimeTrait<Self>,
= <method_without_default_body>

// Full name: test_crate::{impl LifetimeTrait for i32}::lifetime_method
fn {impl LifetimeTrait for i32}::lifetime_method<'a, '_1>(@1: &'_1 i32, @2: &'a i32) -> &'a i32
{
    let _0: &'0 i32; // return
    let self_1: &'0 i32; // arg #1
    let arg_2: &'0 i32; // arg #2
    let _3: bool; // anonymous local
    let _4: i32; // anonymous local
    let _5: i32; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy (*self_1)
    storage_live(_5)
    _5 = copy (*arg_2)
    _3 = move _4 > move _5
    if move _3 {
    } else {
        storage_dead(_5)
        storage_dead(_4)
        panic(core::panicking::panic)
    }
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    _0 = copy arg_2
    return
}

// Full name: test_crate::{impl LifetimeTrait for i32}::lifetime_method::{vtable_method}
fn {impl LifetimeTrait for i32}::lifetime_method::{vtable_method}<'a, '_1>(@1: &'_1 (dyn LifetimeTrait<Ty = i32>), @2: &'a i32) -> &'a i32
{
    let _0: &'a i32; // return
    let _1: &'_1 (dyn LifetimeTrait<Ty = i32> + '0); // arg #1
    let _2: &'a i32; // arg #2
    let _3: &'_1 i32; // anonymous local

    storage_live(_3)
    _3 = concretize<&'_1 (dyn LifetimeTrait<Ty = i32> + '1), &'_1 i32>(move _1)
    _0 = {impl LifetimeTrait for i32}::lifetime_method<'a, '_1>(move _3, move _2)
    return
}

// Full name: test_crate::{impl LifetimeTrait for i32}::{vtable_drop_shim}
unsafe fn {impl LifetimeTrait for i32}::{vtable_drop_shim}(@1: *mut (dyn LifetimeTrait<Ty = i32>))
{
    let ret_0: (); // return
    let dyn_self_1: *mut (dyn LifetimeTrait<Ty = i32> + '0); // arg #1
    let target_self_2: *mut i32; // local

    ret_0 = ()
    storage_live(target_self_2)
    target_self_2 = concretize<*mut (dyn LifetimeTrait<Ty = i32> + '1), *mut i32>(move dyn_self_1)
    return
}

// Full name: test_crate::{impl LifetimeTrait for i32}::{vtable}
fn {impl LifetimeTrait for i32}::{vtable}() -> test_crate::LifetimeTrait::{vtable}<i32>
{
    let ret_0: test_crate::LifetimeTrait::{vtable}<i32>; // return
    let size_1: usize; // local
    let align_2: usize; // local

    storage_live(size_1)
    size_1 = size_of<i32>
    storage_live(align_2)
    align_2 = align_of<i32>
    ret_0 = test_crate::LifetimeTrait::{vtable} { size: move size_1, align: move align_2, drop: const {impl LifetimeTrait for i32}::{vtable_drop_shim}, method_lifetime_method: const {impl LifetimeTrait for i32}::lifetime_method::{vtable_method}<'1, '2>, super_trait_0: const Opaque(missing supertrait vtable) }
    return
}

// Full name: test_crate::{impl LifetimeTrait for i32}::{vtable}
static {impl LifetimeTrait for i32}::{vtable}: test_crate::LifetimeTrait::{vtable}<i32> = {impl LifetimeTrait for i32}::{vtable}()

// Full name: test_crate::{impl LifetimeTrait for i32}
impl LifetimeTrait for i32 {
    parent_clause0 = {built_in impl MetaSized for i32}
    parent_clause1 = {built_in impl Sized for i32}
    type Ty = i32
    fn lifetime_method<'a, '_1_1> = {impl LifetimeTrait for i32}::lifetime_method<'a, '_1_1>
    vtable: {impl LifetimeTrait for i32}::{vtable}
}

// Full name: test_crate::use_lifetime_trait
fn use_lifetime_trait<'a, '_1>(@1: &'_1 (dyn LifetimeTrait<Ty = i32> + '_1), @2: &'a i32) -> &'a i32
{
    let _0: &'0 i32; // return
    let x_1: &'1 (dyn LifetimeTrait<Ty = i32> + '2); // arg #1
    let y_2: &'0 i32; // arg #2
    let _3: &'0 i32; // anonymous local
    let _4: &'1 (dyn LifetimeTrait<Ty = i32> + '2); // anonymous local
    let _5: &'0 i32; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = &(*x_1) with_metadata(copy x_1.metadata)
    storage_live(_5)
    _5 = &(*y_2)
    _3 = (copy ((*_4.metadata)).method_lifetime_method)(move _4, move _5)
    _0 = &(*_3)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::use_alias
fn use_alias<'_0>(@1: &'_0 (dyn Both32And64 + '_0))
{
    let _0: (); // return
    let x_1: &'0 (dyn Both32And64 + '1); // arg #1
    let _2: (); // anonymous local
    let _3: &'0 (dyn Both32And64 + '1); // anonymous local
    let _4: &'2 i32; // anonymous local
    let _5: &'2 i32; // anonymous local
    let _6: &'3 i64; // anonymous local
    let _7: &'3 i64; // anonymous local
    let _8: &'3 i64; // anonymous local
    let _9: &'2 i32; // anonymous local
    let _10: &'_ i32; // anonymous local
    let _11: i32; // anonymous local
    let _12: &'_ i64; // anonymous local
    let _13: i64; // anonymous local

    storage_live(_10)
    storage_live(_11)
    _11 = const 100 : i32
    _10 = &_11
    storage_live(_12)
    storage_live(_13)
    _13 = const 200 : i64
    _12 = &_13
    storage_live(_8)
    storage_live(_9)
    _0 = ()
    storage_live(_2)
    storage_live(_3)
    _3 = &(*x_1) with_metadata(copy x_1.metadata)
    storage_live(_4)
    storage_live(_5)
    _9 = move _10
    _5 = &(*_9)
    _4 = &(*_5)
    storage_live(_6)
    storage_live(_7)
    _8 = move _12
    _7 = &(*_8)
    _6 = &(*_7)
    _2 = (copy ((*_3.metadata)).method_both_operate)(move _3, move _4, move _6)
    storage_dead(_6)
    storage_dead(_4)
    storage_dead(_3)
    storage_dead(_7)
    storage_dead(_5)
    storage_dead(_2)
    _0 = ()
    return
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let x_1: &'0 (dyn Checkable<i32> + '1); // local
    let _2: &'2 i32; // anonymous local
    let _3: &'2 i32; // anonymous local
    let _4: bool; // anonymous local
    let _5: &'0 (dyn Checkable<i32> + '1); // anonymous local
    let y_6: &'3 mut (dyn Modifiable<i32> + '4); // local
    let _7: &'5 mut i32; // anonymous local
    let _8: &'5 mut i32; // anonymous local
    let _9: i32; // anonymous local
    let _10: bool; // anonymous local
    let _11: &'6 String; // anonymous local
    let _12: String; // anonymous local
    let _13: &'6 String; // anonymous local
    let _14: &'6 String; // anonymous local
    let _15: String; // anonymous local
    let _16: &'7 Str; // anonymous local
    let _17: &'7 Str; // anonymous local
    let _18: (&'2 i32, &'2 i32); // anonymous local
    let _19: &'2 i32; // anonymous local
    let _20: i32; // anonymous local
    let _21: &'3 mut (dyn Modifiable<i32> + '4); // anonymous local
    let _22: &'2 i32; // anonymous local
    let _23: &'5 mut i32; // anonymous local
    let _24: i32; // anonymous local
    let _25: &'2 i32; // anonymous local
    let left_val_26: &'2 i32; // local
    let right_val_27: &'2 i32; // local
    let _28: bool; // anonymous local
    let _29: i32; // anonymous local
    let _30: i32; // anonymous local
    let kind_31: AssertKind; // local
    let _32: AssertKind; // anonymous local
    let _33: &'2 i32; // anonymous local
    let _34: &'2 i32; // anonymous local
    let _35: &'2 i32; // anonymous local
    let _36: &'2 i32; // anonymous local
    let _37: Option<Arguments<'8>>[{built_in impl Sized for Arguments<'8>}]; // anonymous local
    let z_38: &'11 (dyn NoParam + '12); // local
    let _39: &'11 (dyn NoParam + '12); // anonymous local
    let _40: &'11 (dyn NoParam + '12); // anonymous local
    let _41: &'2 i32; // anonymous local
    let _42: &'2 i32; // anonymous local
    let _43: (); // anonymous local
    let _44: &'11 (dyn NoParam + '12); // anonymous local
    let a_45: &'13 (dyn Both32And64 + '14); // local
    let _46: &'2 i32; // anonymous local
    let _47: &'2 i32; // anonymous local
    let _48: (); // anonymous local
    let _49: &'13 (dyn Both32And64 + '14); // anonymous local
    let _50: &'2 i32; // anonymous local
    let _51: &'2 i32; // anonymous local
    let _52: &'15 i64; // anonymous local
    let _53: &'15 i64; // anonymous local
    let b_54: &'16 (dyn LifetimeTrait<Ty = i32> + '17); // local
    let _55: &'2 i32; // anonymous local
    let _56: &'2 i32; // anonymous local
    let _57: (&'2 i32, &'2 i32); // anonymous local
    let _58: &'2 i32; // anonymous local
    let _59: &'2 i32; // anonymous local
    let _60: &'16 (dyn LifetimeTrait<Ty = i32> + '17); // anonymous local
    let _61: &'16 (dyn LifetimeTrait<Ty = i32> + '17); // anonymous local
    let _62: &'2 i32; // anonymous local
    let _63: &'2 i32; // anonymous local
    let _64: &'2 i32; // anonymous local
    let left_val_65: &'2 i32; // local
    let right_val_66: &'2 i32; // local
    let _67: bool; // anonymous local
    let _68: i32; // anonymous local
    let _69: i32; // anonymous local
    let kind_70: AssertKind; // local
    let _71: AssertKind; // anonymous local
    let _72: &'2 i32; // anonymous local
    let _73: &'2 i32; // anonymous local
    let _74: &'2 i32; // anonymous local
    let _75: &'2 i32; // anonymous local
    let _76: Option<Arguments<'8>>[{built_in impl Sized for Arguments<'8>}]; // anonymous local
    let _77: &'2 i32; // anonymous local
    let _78: &'2 i32; // anonymous local
    let _79: &'2 i32; // anonymous local
    let _80: &'15 i64; // anonymous local
    let _81: &'2 i32; // anonymous local
    let _82: &'2 i32; // anonymous local
    let _83: &'2 i32; // anonymous local
    let _84: &'2 i32; // anonymous local
    let _85: &'2 i32; // anonymous local
    let _86: &'_ i32; // anonymous local
    let _87: i32; // anonymous local
    let _88: &'_ i32; // anonymous local
    let _89: i32; // anonymous local
    let _90: &'_ i32; // anonymous local
    let _91: i32; // anonymous local
    let _92: &'_ i32; // anonymous local
    let _93: i32; // anonymous local
    let _94: &'_ i32; // anonymous local
    let _95: i32; // anonymous local
    let _96: &'_ i64; // anonymous local
    let _97: i64; // anonymous local
    let _98: &'_ i32; // anonymous local
    let _99: i32; // anonymous local
    let _100: &'_ i32; // anonymous local
    let _101: i32; // anonymous local
    let _102: &'_ i32; // anonymous local
    let _103: i32; // anonymous local

    storage_live(_86)
    storage_live(_87)
    _87 = const 42 : i32
    _86 = &_87
    storage_live(_77)
    storage_live(_78)
    storage_live(_79)
    storage_live(_80)
    storage_live(_81)
    storage_live(_82)
    storage_live(_83)
    storage_live(_84)
    storage_live(_85)
    _0 = ()
    storage_live(x_1)
    storage_live(_2)
    storage_live(_3)
    _85 = move _86
    _3 = &(*_85)
    _2 = &(*_3)
    x_1 = unsize_cast<&'2 i32, &'0 (dyn Checkable<i32> + '1), {impl Checkable<i32> for i32} with {impl Checkable<i32> for i32}::{vtable}>(move _2)
    storage_dead(_2)
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = &(*x_1) with_metadata(copy x_1.metadata)
    _4 = (copy ((*_5.metadata)).method_check)(move _5)
    if move _4 {
    } else {
        storage_dead(_5)
        panic(core::panicking::panic)
    }
    storage_dead(_5)
    storage_dead(_4)
    storage_live(y_6)
    storage_live(_7)
    storage_live(_8)
    storage_live(_9)
    _9 = const 99 : i32
    _8 = &mut _9
    _7 = &mut (*_8)
    y_6 = unsize_cast<&'5 mut i32, &'3 mut (dyn Modifiable<i32> + '4), {impl Modifiable<T> for i32}<i32>[{built_in impl Sized for i32}, {impl Clone for i32}] with {impl Modifiable<T> for i32}::{vtable}<i32>[{built_in impl Sized for i32}, {impl Clone for i32}]>(move _7)
    storage_dead(_7)
    storage_dead(_8)
    storage_live(_10)
    storage_live(_11)
    storage_live(_12)
    storage_live(_13)
    storage_live(_14)
    storage_live(_15)
    storage_live(_16)
    storage_live(_17)
    _17 = const "Hello"
    _16 = &(*_17) with_metadata(copy _17.metadata)
    _15 = {impl ToString for T}::to_string<'22, Str>[{built_in impl MetaSized for Str}, {impl Display for Str}](move _16)
    storage_dead(_16)
    _14 = &_15
    _13 = &(*_14)
    _12 = modify_trait_object<'24, String>[{built_in impl Sized for String}, {impl Clone for String}](move _13)
    _11 = &_12
    storage_dead(_13)
    _10 = is_empty<'26>(move _11)
    if move _10 {
    } else {
        storage_dead(_11)
        conditional_drop[{impl Destruct for String}] _12
        conditional_drop[{impl Destruct for String}] _15
        storage_dead(_17)
        storage_dead(_15)
        storage_dead(_14)
        storage_dead(_12)
        storage_dead(_10)
        storage_live(_18)
        storage_live(_19)
        storage_live(_20)
        storage_live(_21)
        _21 = &two-phase-mut (*y_6) with_metadata(copy y_6.metadata)
        storage_live(_22)
        storage_live(_23)
        storage_live(_24)
        _24 = const 100 : i32
        _23 = &mut _24
        _22 = &(*_23)
        _20 = (copy ((*_21.metadata)).method_modify)(move _21, move _22)
        storage_live(_88)
        storage_live(_89)
        _89 = const 100 : i32
        _88 = &_89
        storage_dead(_22)
        storage_dead(_21)
        _19 = &_20
        storage_live(_25)
        _84 = move _88
        _25 = &(*_84)
        _18 = (move _19, move _25)
        storage_dead(_25)
        storage_dead(_19)
        storage_live(left_val_26)
        left_val_26 = copy _18.0
        storage_live(right_val_27)
        right_val_27 = copy _18.1
        storage_live(_28)
        storage_live(_29)
        _29 = copy (*left_val_26)
        storage_live(_30)
        _30 = copy (*right_val_27)
        _28 = move _29 == move _30
        if move _28 {
        } else {
            storage_dead(_30)
            storage_dead(_29)
            storage_live(kind_31)
            kind_31 = AssertKind::Eq {  }
            storage_live(_32)
            _32 = move kind_31
            storage_live(_33)
            storage_live(_34)
            _34 = &(*left_val_26)
            _33 = &(*_34)
            storage_live(_35)
            storage_live(_36)
            _36 = &(*right_val_27)
            _35 = &(*_36)
            storage_live(_37)
            _37 = Option::None {  }
            panic(core::panicking::assert_failed)
        }
        storage_live(_90)
        storage_live(_91)
        _91 = const 42 : i32
        _90 = &_91
        storage_dead(_30)
        storage_dead(_29)
        storage_dead(_28)
        storage_dead(right_val_27)
        storage_dead(left_val_26)
        storage_dead(_24)
        storage_dead(_23)
        storage_dead(_20)
        storage_dead(_18)
        storage_live(z_38)
        storage_live(_39)
        storage_live(_40)
        storage_live(_41)
        storage_live(_42)
        _83 = move _90
        _42 = &(*_83)
        _41 = &(*_42)
        _40 = to_dyn_obj<'33, i32>[{built_in impl Sized for i32}, {impl NoParam for i32}](move _41)
        _39 = &(*_40) with_metadata(copy _40.metadata)
        z_38 = unsize_cast<&'11 (dyn NoParam + '12), &'11 (dyn NoParam + '12),  at []>(move _39)
        storage_dead(_41)
        storage_dead(_39)
        storage_dead(_42)
        storage_dead(_40)
        storage_live(_43)
        storage_live(_44)
        _44 = &(*z_38) with_metadata(copy z_38.metadata)
        _43 = (copy ((*_44.metadata)).method_dummy)(move _44)
        storage_live(_92)
        storage_live(_93)
        _93 = const 42 : i32
        _92 = &_93
        storage_live(_94)
        storage_live(_95)
        _95 = const 100 : i32
        _94 = &_95
        storage_live(_96)
        storage_live(_97)
        _97 = const 200 : i64
        _96 = &_97
        storage_dead(_44)
        storage_dead(_43)
        storage_live(a_45)
        storage_live(_46)
        storage_live(_47)
        _82 = move _92
        _47 = &(*_82)
        _46 = &(*_47)
        a_45 = unsize_cast<&'2 i32, &'13 (dyn Both32And64 + '14), {impl Both32And64 for i32} with {impl Both32And64 for i32}::{vtable}>(move _46)
        storage_dead(_46)
        storage_dead(_47)
        storage_live(_48)
        storage_live(_49)
        _49 = &(*a_45) with_metadata(copy a_45.metadata)
        storage_live(_50)
        storage_live(_51)
        _81 = move _94
        _51 = &(*_81)
        _50 = &(*_51)
        storage_live(_52)
        storage_live(_53)
        _80 = move _96
        _53 = &(*_80)
        _52 = &(*_53)
        _48 = (copy ((*_49.metadata)).method_both_operate)(move _49, move _50, move _52)
        storage_live(_98)
        storage_live(_99)
        _99 = const 42 : i32
        _98 = &_99
        storage_live(_100)
        storage_live(_101)
        _101 = const 10 : i32
        _100 = &_101
        storage_dead(_52)
        storage_dead(_50)
        storage_dead(_49)
        storage_dead(_53)
        storage_dead(_51)
        storage_dead(_48)
        storage_live(b_54)
        storage_live(_55)
        storage_live(_56)
        _79 = move _98
        _56 = &(*_79)
        _55 = &(*_56)
        b_54 = unsize_cast<&'2 i32, &'16 (dyn LifetimeTrait<Ty = i32> + '17), {impl LifetimeTrait for i32} with {impl LifetimeTrait for i32}::{vtable}>(move _55)
        storage_dead(_55)
        storage_dead(_56)
        storage_live(_57)
        storage_live(_58)
        storage_live(_59)
        storage_live(_60)
        storage_live(_61)
        _61 = &(*b_54) with_metadata(copy b_54.metadata)
        _60 = unsize_cast<&'16 (dyn LifetimeTrait<Ty = i32> + '17), &'16 (dyn LifetimeTrait<Ty = i32> + '17),  at []>(move _61)
        storage_dead(_61)
        storage_live(_62)
        storage_live(_63)
        _78 = move _100
        _63 = &(*_78)
        _62 = &(*_63)
        _59 = use_lifetime_trait<'48, '49>(move _60, move _62)
        storage_live(_102)
        storage_live(_103)
        _103 = const 10 : i32
        _102 = &_103
        storage_dead(_62)
        storage_dead(_60)
        _58 = &(*_59)
        storage_live(_64)
        _77 = move _102
        _64 = &(*_77)
        _57 = (move _58, move _64)
        storage_dead(_64)
        storage_dead(_58)
        storage_live(left_val_65)
        left_val_65 = copy _57.0
        storage_live(right_val_66)
        right_val_66 = copy _57.1
        storage_live(_67)
        storage_live(_68)
        _68 = copy (*left_val_65)
        storage_live(_69)
        _69 = copy (*right_val_66)
        _67 = move _68 == move _69
        if move _67 {
        } else {
            storage_dead(_69)
            storage_dead(_68)
            storage_live(kind_70)
            kind_70 = AssertKind::Eq {  }
            storage_live(_71)
            _71 = move kind_70
            storage_live(_72)
            storage_live(_73)
            _73 = &(*left_val_65)
            _72 = &(*_73)
            storage_live(_74)
            storage_live(_75)
            _75 = &(*right_val_66)
            _74 = &(*_75)
            storage_live(_76)
            _76 = Option::None {  }
            panic(core::panicking::assert_failed)
        }
        storage_dead(_69)
        storage_dead(_68)
        storage_dead(_67)
        storage_dead(right_val_66)
        storage_dead(left_val_65)
        storage_dead(_63)
        storage_dead(_59)
        storage_dead(_57)
        _0 = ()
        storage_dead(b_54)
        storage_dead(a_45)
        storage_dead(z_38)
        storage_dead(_9)
        storage_dead(y_6)
        storage_dead(x_1)
        return
    }
    storage_dead(_11)
    conditional_drop[{impl Destruct for String}] _12
    conditional_drop[{impl Destruct for String}] _15
    storage_dead(_17)
    storage_dead(_15)
    storage_dead(_14)
    storage_dead(_12)
    panic(core::panicking::panic)
}



