# Final LLBC before serialization:

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub opaque type Layout

// Full name: core::alloc::layout::{Layout}::from_size_align_unchecked
pub unsafe fn from_size_align_unchecked(@1: usize, @2: usize) -> Layout
= <opaque>

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = drop_in_place<Self>
    non-dyn-compatible
}

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0_1> = core::clone::Clone::clone<'_0_1, Self>[Self]
    fn clone_from<'_0_1, '_1_1, [@TraitClause0_1]: Destruct<Self>> = core::clone::Clone::clone_from<'_0_1, '_1_1, Self>[Self, @TraitClause0_1]
    non-dyn-compatible
}

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 Self) -> Self
where
    [@TraitClause0]: Clone<Self>,
= <method_without_default_body>

pub fn core::clone::Clone::clone_from<'_0, '_1, Self>(@1: &'_0 mut Self, @2: &'_1 Self)
where
    [@TraitClause0]: Clone<Self>,
    [@TraitClause1]: Destruct<Self>,
{
    let _0: (); // return
    let self_1: &'1 mut Self; // arg #1
    let source_2: &'3 Self; // arg #2
    let _3: Self; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = @TraitClause0::clone<'5>(move source_2)
    drop[@TraitClause1] (*self_1)
    (*self_1) = move _3
    storage_dead(_3)
    return
}

// Full name: core::clone::impls::{impl Clone for usize}::clone
pub fn {impl Clone for usize}::clone<'_0>(@1: &'_0 usize) -> usize
{
    let _0: usize; // return
    let self_1: &'1 usize; // arg #1

    _0 = copy (*self_1)
    return
}

// Full name: core::clone::impls::{impl Clone for usize}::clone_from
pub fn {impl Clone for usize}::clone_from<'_0, '_1>(@1: &'_0 mut usize, @2: &'_1 usize)
where
    [@TraitClause0]: Destruct<usize>,
{
    let _0: (); // return
    let self_1: &'1 mut usize; // arg #1
    let source_2: &'3 usize; // arg #2
    let _3: usize; // anonymous local

    _0 = ()
    storage_live(_3)
    _3 = {impl Clone for usize}::clone<'5>(move source_2)
    drop[@TraitClause0] (*self_1)
    (*self_1) = move _3
    storage_dead(_3)
    return
}

// Full name: core::clone::impls::{impl Clone for usize}
impl Clone for usize {
    parent_clause0 = {built_in impl Sized for usize}
    fn clone<'_0_1> = {impl Clone for usize}::clone<'_0_1>
    fn clone_from<'_0_1, '_1_1, [@TraitClause0_1]: Destruct<usize>> = {impl Clone for usize}::clone_from<'_0_1, '_1_1>[@TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub struct NonNull<T> {
  pointer: *const T,
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::marker::PhantomData
#[lang_item("phantom_data")]
pub struct PhantomData<T> {}

// Full name: core::fmt::rt::ArgumentType
enum ArgumentType<'a> {
  Placeholder(value: NonNull<()>, formatter: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], _lifetime: PhantomData<&'a ()>),
  Count(u16),
}

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub struct Argument<'a> {
  ty: ArgumentType<'a>,
}

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub struct Arguments<'a> {
  template: NonNull<u8>,
  args: NonNull<Argument<'a>>,
}

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::intrinsics::ctpop
pub fn ctpop<T>(@1: T) -> u32
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Copy<T>,
{
    let _0: u32; // return
    let x_1: T; // arg #1

    undefined_behavior
}

// Full name: core::panicking::panic_nounwind_fmt::compiletime
fn compiletime<'_0>(@1: Arguments<'_0>, @2: bool) -> !
{
    let _0: !; // return
    let fmt_1: Arguments<'1>; // arg #1
    let force_no_backtrace_2: bool; // arg #2

    panic(core::panicking::panic_fmt)
}

// Full name: core::intrinsics::size_of
pub fn size_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    undefined_behavior
}

pub fn core::intrinsics::align_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    undefined_behavior
}

// Full name: core::marker::{impl Copy for usize}
impl Copy for usize {
    parent_clause0 = {built_in impl MetaSized for usize}
    parent_clause1 = {impl Clone for usize}
    non-dyn-compatible
}

// Full name: core::marker::Destruct::drop_in_place
unsafe fn drop_in_place<Self>(@1: *mut Self)
= <missing>

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
{
    let _0: !; // return
    let fmt_1: Arguments<'1>; // arg #1
    let force_no_backtrace_2: bool; // arg #2
    let _3: (Arguments<'3>, bool); // anonymous local
    let _4: Arguments<'4>; // anonymous local
    let _5: bool; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy fmt_1
    storage_live(_5)
    _5 = copy force_no_backtrace_2
    _3 = (move _4, move _5)
    storage_dead(_5)
    storage_dead(_4)
    _0 = compiletime<'6>(move _3.0, move _3.1)
}

fn core::ptr::alignment::{Alignment}::new_unchecked::precondition_check(@1: usize)
{
    let _0: (); // return
    let align_1: usize; // arg #1
    let msg_2: &'1 Str; // local
    let _3: !; // anonymous local
    let _4: Arguments<'3>; // anonymous local
    let _5: u32; // anonymous local
    let _6: NonNull<u8>; // anonymous local
    let _7: *const u8; // anonymous local
    let _8: NonNull<Argument<'6>>; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local
    let _11: usize; // anonymous local
    let _12: *const Str; // anonymous local
    let _13: &'8 [u8]; // anonymous local

    storage_live(msg_2)
    storage_live(_3)
    _0 = ()
    storage_live(_5)
    _5 = ctpop<usize>[{built_in impl Sized for usize}, {impl Copy for usize}](move align_1)
    switch copy _5 {
        1 : u32 => {
        },
        _ => {
            storage_dead(_5)
            msg_2 = const "unsafe precondition(s) violated: Alignment::new_unchecked requires a power of two\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
            storage_live(_4)
            storage_live(_6)
            storage_live(_7)
            storage_live(_12)
            _12 = &raw const (*msg_2) with_metadata(copy msg_2.metadata)
            _7 = cast<*const Str, *const u8>(copy _12)
            storage_dead(_12)
            _6 = transmute<*const u8, NonNull<u8>>(copy _7)
            storage_dead(_7)
            storage_live(_8)
            storage_live(_9)
            storage_live(_10)
            storage_live(_11)
            storage_live(_13)
            _13 = transmute<&'11 Str, &'10 [u8]>(const "unsafe precondition(s) violated: Alignment::new_unchecked requires a power of two\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
            _11 = copy _13.metadata
            storage_dead(_13)
            _10 = move _11 wrap.<< const 1 : i32
            storage_dead(_11)
            _9 = move _10 | const 1 : usize
            storage_dead(_10)
            _8 = transmute<usize, NonNull<Argument<'12>>>(move _9)
            storage_dead(_9)
            _4 = Arguments { template: move _6, args: move _8 }
            storage_dead(_8)
            storage_dead(_6)
            _3 = panic_nounwind_fmt<'15>(move _4, const false)
        },
    }
    storage_dead(_5)
    return
}

// Full name: core::ptr::alignment::AlignmentEnum
enum AlignmentEnum {
  _Align1Shl0,
  _Align1Shl1,
  _Align1Shl2,
  _Align1Shl3,
  _Align1Shl4,
  _Align1Shl5,
  _Align1Shl6,
  _Align1Shl7,
  _Align1Shl8,
  _Align1Shl9,
  _Align1Shl10,
  _Align1Shl11,
  _Align1Shl12,
  _Align1Shl13,
  _Align1Shl14,
  _Align1Shl15,
  _Align1Shl16,
  _Align1Shl17,
  _Align1Shl18,
  _Align1Shl19,
  _Align1Shl20,
  _Align1Shl21,
  _Align1Shl22,
  _Align1Shl23,
  _Align1Shl24,
  _Align1Shl25,
  _Align1Shl26,
  _Align1Shl27,
  _Align1Shl28,
  _Align1Shl29,
  _Align1Shl30,
  _Align1Shl31,
  _Align1Shl32,
  _Align1Shl33,
  _Align1Shl34,
  _Align1Shl35,
  _Align1Shl36,
  _Align1Shl37,
  _Align1Shl38,
  _Align1Shl39,
  _Align1Shl40,
  _Align1Shl41,
  _Align1Shl42,
  _Align1Shl43,
  _Align1Shl44,
  _Align1Shl45,
  _Align1Shl46,
  _Align1Shl47,
  _Align1Shl48,
  _Align1Shl49,
  _Align1Shl50,
  _Align1Shl51,
  _Align1Shl52,
  _Align1Shl53,
  _Align1Shl54,
  _Align1Shl55,
  _Align1Shl56,
  _Align1Shl57,
  _Align1Shl58,
  _Align1Shl59,
  _Align1Shl60,
  _Align1Shl61,
  _Align1Shl62,
  _Align1Shl63,
}

// Full name: core::ptr::alignment::Alignment
pub struct Alignment {
  _inner_repr_trick: AlignmentEnum,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::ptr::alignment::{Alignment}::new
pub fn new(@1: usize) -> Option<Alignment>[{built_in impl Sized for Alignment}]
{
    let _0: Option<Alignment>[{built_in impl Sized for Alignment}]; // return
    let align_1: usize; // arg #1
    let _2: Alignment; // anonymous local
    let _3: u32; // anonymous local
    let _4: (); // anonymous local
    let _5: bool; // anonymous local
    let _6: Option<Alignment>[{built_in impl Sized for Alignment}]; // anonymous local

    storage_live(_4)
    storage_live(_3)
    _3 = ctpop<usize>[{built_in impl Sized for usize}, {impl Copy for usize}](copy align_1)
    switch copy _3 {
        1 : u32 => {
        },
        _ => {
            storage_dead(_3)
            storage_live(_6)
            _6 = Option::None {  }
            _0 = move _6
            return
        },
    }
    storage_dead(_3)
    storage_live(_2)
    storage_live(_5)
    _5 = ub_checks<bool>
    if move _5 {
        _4 = core::ptr::alignment::{Alignment}::new_unchecked::precondition_check(copy align_1)
    } else {
    }
    _2 = transmute<usize, Alignment>(copy align_1)
    _0 = Option::Some { 0: move _2 }
    storage_dead(_2)
    return
}

// Full name: core::option::unwrap_failed
fn unwrap_failed() -> !
{
    let _0: !; // return

    panic(core::panicking::panic)
}

// Full name: core::option::{Option<T>[@TraitClause0]}::unwrap
#[lang_item("option_unwrap")]
pub fn unwrap<T>(@1: Option<T>[@TraitClause0]) -> T
where
    [@TraitClause0]: Sized<T>,
{
    let val_0: T; // return
    let self_1: Option<T>[@TraitClause0]; // arg #1
    let _2: !; // anonymous local

    storage_live(_2)
    match self_1 {
        Option::None => {
        },
        Option::Some => {
            val_0 = move (self_1 as variant Option::Some).0
            return
        },
    }
    _2 = unwrap_failed()
}

pub fn core::num::{usize}::MAX() -> usize
{
    let _0: usize; // return

    _0 = ~(const 0 : usize)
    return
}

pub const core::num::{usize}::MAX: usize = core::num::{usize}::MAX()

pub fn core::num::{isize}::MAX() -> isize
{
    let _0: isize; // return
    let _1: usize; // anonymous local

    storage_live(_1)
    _1 = copy core::num::{usize}::MAX panic.>> const 1 : i32
    _0 = cast<usize, isize>(move _1)
    storage_dead(_1)
    return
}

pub const core::num::{isize}::MAX: isize = core::num::{isize}::MAX()

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const ALIGNMENT : Alignment
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return
    let _1: usize; // anonymous local
    let n_2: usize; // local
    let _3: usize; // anonymous local
    let _4: usize; // anonymous local

    storage_live(_1)
    _1 = const @TraitClause0::SIZE
    switch copy _1 {
        0 : usize => {
            _0 = copy core::num::{usize}::MAX
        },
        _ => {
            storage_live(n_2)
            n_2 = copy _1
            storage_live(_3)
            _3 = cast<isize, usize>(copy core::num::{isize}::MAX)
            storage_live(_4)
            _4 = copy n_2
            _0 = move _3 panic./ move _4
            storage_dead(_4)
            storage_dead(_3)
            storage_dead(n_2)
        },
    }
    storage_dead(_1)
    return
}

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: Layout; // return

    _0 = from_size_align_unchecked(const @TraitClause0::SIZE, const @TraitClause0::ALIGN)
    return
}

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: bool; // return

    _0 = const @TraitClause0::SIZE == const 0 : usize
    return
}

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return

    _0 = core::intrinsics::align_of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return

    _0 = size_of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

#[lang_item("mem_align_of")]
pub fn core::mem::align_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    _0 = const {impl SizedTypeProperties for T}<T>[@TraitClause0]::ALIGN
    return
}

// Full name: core::mem::SizedTypeProperties::ALIGNMENT
pub fn ALIGNMENT<Self>() -> Alignment
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: Alignment; // return

    _0 = of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::ALIGNMENT
pub const ALIGNMENT<Self>: Alignment
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGNMENT()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGNMENT = ALIGNMENT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::ptr::alignment::{Alignment}::of
pub fn of<T>() -> Alignment
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Alignment; // return
    let _1: Alignment; // anonymous local
    let _2: Option<Alignment>[{built_in impl Sized for Alignment}]; // anonymous local
    let _3: usize; // anonymous local

    storage_live(_1)
    storage_live(_2)
    storage_live(_3)
    _3 = core::mem::align_of<T>[@TraitClause0]()
    _2 = new(move _3)
    storage_dead(_3)
    _1 = unwrap<Alignment>[{built_in impl Sized for Alignment}](move _2)
    storage_dead(_2)
    _0 = move _1
    return
}

fn core::ptr::copy_nonoverlapping::precondition_check(@1: *const (), @2: *mut (), @3: usize, @4: usize, @5: usize)
= <opaque>

// Full name: core::ptr::copy_nonoverlapping
#[lang_item("ptr_copy_nonoverlapping")]
pub unsafe fn copy_nonoverlapping<T>(@1: *const T, @2: *mut T, @3: usize)
where
    [@TraitClause0]: Sized<T>,
{
    let _0: (); // return
    let src_1: *const T; // arg #1
    let dst_2: *mut T; // arg #2
    let count_3: usize; // arg #3
    let _4: (); // anonymous local
    let _5: *const (); // anonymous local
    let _6: *mut (); // anonymous local
    let _7: bool; // anonymous local

    storage_live(_4)
    _0 = ()
    storage_live(_7)
    _7 = ub_checks<bool>
    if move _7 {
        storage_live(_5)
        _5 = cast<*const T, *const ()>(copy src_1)
        storage_live(_6)
        _6 = cast<*mut T, *mut ()>(copy dst_2)
        _4 = core::ptr::copy_nonoverlapping::precondition_check(move _5, move _6, const {impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE, const {impl SizedTypeProperties for T}<T>[@TraitClause0]::ALIGN, copy count_3)
        storage_dead(_6)
        storage_dead(_5)
    } else {
    }
    copy_nonoverlapping(copy src_1, copy dst_2, copy count_3)
    return
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::write
fn write<'_0, '_1, T>(@1: &'_0 mut T, @2: &'_1 T)
where
    [@TraitClause0]: Sized<T>,
{
    let _0: (); // return
    let x_1: &'1 mut T; // arg #1
    let y_2: &'3 T; // arg #2
    let _3: (); // anonymous local
    let _4: *const T; // anonymous local
    let _5: *mut T; // anonymous local

    _0 = ()
    storage_live(_3)
    storage_live(_4)
    _4 = &raw const (*y_2)
    storage_live(_5)
    _5 = &raw mut (*x_1)
    _3 = copy_nonoverlapping<T>[@TraitClause0](move _4, move _5, const 1 : usize)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    _0 = ()
    return
}



