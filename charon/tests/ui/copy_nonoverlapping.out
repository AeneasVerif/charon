# Final LLBC before serialization:

// Full name: core::alloc::layout::Layout
#[lang_item("alloc_layout")]
pub opaque type Layout

// Full name: core::alloc::layout::{Layout}::from_size_align_unchecked
pub unsafe fn from_size_align_unchecked(@1: usize, @2: usize) -> Layout
= <opaque>

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::intrinsics::size_of
pub fn size_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    undefined_behavior
}

// Full name: core::intrinsics::align_of
pub fn align_of<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    undefined_behavior
}

// Full name: core::mem::SizedTypeProperties
pub trait SizedTypeProperties<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const SIZE : usize
    const ALIGN : usize
    const IS_ZST : bool
    const LAYOUT : Layout
    const MAX_SLICE_LEN : usize
    non-dyn-compatible
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub fn SIZE<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return

    _0 = size_of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::SIZE
#[lang_item("mem_size_const")]
pub const SIZE<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = SIZE()

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub fn ALIGN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return

    _0 = align_of<Self>[@TraitClause0::parent_clause0]()
    return
}

// Full name: core::mem::SizedTypeProperties::ALIGN
#[lang_item("mem_align_const")]
pub const ALIGN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = ALIGN()

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub fn IS_ZST<Self>() -> bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: bool; // return

    _0 = const @TraitClause0::SIZE == const 0 : usize
    return
}

// Full name: core::mem::SizedTypeProperties::IS_ZST
pub const IS_ZST<Self>: bool
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = IS_ZST()

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub fn LAYOUT<Self>() -> Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: Layout; // return

    _0 = from_size_align_unchecked(const @TraitClause0::SIZE, const @TraitClause0::ALIGN)
    return
}

// Full name: core::mem::SizedTypeProperties::LAYOUT
pub const LAYOUT<Self>: Layout
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = LAYOUT()

pub fn core::num::{usize}::MAX() -> usize
{
    let _0: usize; // return

    _0 = ~(const 0 : usize)
    return
}

pub const core::num::{usize}::MAX: usize = core::num::{usize}::MAX()

pub fn core::num::{isize}::MAX() -> isize
{
    let _0: isize; // return
    let _1: usize; // anonymous local

    storage_live(_1)
    _1 = copy core::num::{usize}::MAX panic.>> const 1 : i32
    _0 = cast<usize, isize>(move _1)
    storage_dead(_1)
    return
}

pub const core::num::{isize}::MAX: isize = core::num::{isize}::MAX()

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub fn MAX_SLICE_LEN<Self>() -> usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
{
    let _0: usize; // return
    let _1: usize; // anonymous local
    let n_2: usize; // local
    let _3: usize; // anonymous local
    let _4: usize; // anonymous local

    storage_live(_1)
    _1 = const @TraitClause0::SIZE
    switch copy _1 {
        0 : usize => {
            _0 = copy core::num::{usize}::MAX
        },
        _ => {
            storage_live(n_2)
            n_2 = copy _1
            storage_live(_3)
            _3 = cast<isize, usize>(copy core::num::{isize}::MAX)
            storage_live(_4)
            _4 = copy n_2
            _0 = move _3 panic./ move _4
            storage_dead(_4)
            storage_dead(_3)
            storage_dead(n_2)
        },
    }
    storage_dead(_1)
    return
}

// Full name: core::mem::SizedTypeProperties::MAX_SLICE_LEN
pub const MAX_SLICE_LEN<Self>: usize
where
    [@TraitClause0]: SizedTypeProperties<Self>,
 = MAX_SLICE_LEN()

// Full name: core::mem::{impl SizedTypeProperties for T}
impl<T> SizedTypeProperties for T
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = @TraitClause0
    const SIZE = SIZE<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const ALIGN = ALIGN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const IS_ZST = IS_ZST<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const LAYOUT = LAYOUT<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    const MAX_SLICE_LEN = MAX_SLICE_LEN<T>[{impl SizedTypeProperties for T}<T>[@TraitClause0]]
    non-dyn-compatible
}

// Full name: core::ptr::copy_nonoverlapping::precondition_check
fn precondition_check(@1: *const (), @2: *mut (), @3: usize, @4: usize, @5: usize)
= <opaque>

// Full name: core::ptr::copy_nonoverlapping
#[lang_item("ptr_copy_nonoverlapping")]
pub unsafe fn copy_nonoverlapping<T>(@1: *const T, @2: *mut T, @3: usize)
where
    [@TraitClause0]: Sized<T>,
{
    let _0: (); // return
    let src_1: *const T; // arg #1
    let dst_2: *mut T; // arg #2
    let count_3: usize; // arg #3
    let _4: (); // anonymous local
    let _5: *const (); // anonymous local
    let _6: *mut (); // anonymous local
    let _7: bool; // anonymous local

    storage_live(_4)
    _0 = ()
    storage_live(_7)
    _7 = ub_checks<bool>
    if move _7 {
        storage_live(_5)
        _5 = cast<*const T, *const ()>(copy src_1)
        storage_live(_6)
        _6 = cast<*mut T, *mut ()>(copy dst_2)
        _4 = precondition_check(move _5, move _6, const {impl SizedTypeProperties for T}<T>[@TraitClause0]::SIZE, const {impl SizedTypeProperties for T}<T>[@TraitClause0]::ALIGN, copy count_3)
        storage_dead(_6)
        storage_dead(_5)
    } else {
    }
    copy_nonoverlapping(copy src_1, copy dst_2, copy count_3)
    return
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::write
fn write<'_0, '_1, T>(@1: &'_0 mut T, @2: &'_1 T)
where
    [@TraitClause0]: Sized<T>,
{
    let _0: (); // return
    let x_1: &'1 mut T; // arg #1
    let y_2: &'3 T; // arg #2
    let _3: (); // anonymous local
    let _4: *const T; // anonymous local
    let _5: *mut T; // anonymous local

    _0 = ()
    storage_live(_3)
    storage_live(_4)
    _4 = &raw const (*y_2)
    storage_live(_5)
    _5 = &raw mut (*x_1)
    _3 = copy_nonoverlapping<T>[@TraitClause0](move _4, move _5, const 1 : usize)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    _0 = ()
    return
}



