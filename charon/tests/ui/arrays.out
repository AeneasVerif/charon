# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::ops::index::Index
#[lang_item("index")]
pub trait Index<Self, Idx, Self_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: MetaSized<Idx>
    parent_clause2 : [@TraitClause2]: MetaSized<Self_Output>
    fn index<'_0> = core::ops::index::Index::index<'_0_0, Self, Idx, Self_Output>[Self]
    non-dyn-compatible
}

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::array::{impl Index<I, Clause2_Output> for Array<T, const N : usize>}::index
pub fn {impl Index<I, Clause2_Output> for Array<T, const N : usize>}::index<'_0, T, I, Clause2_Output, const N : usize>(@1: &'_0 (Array<T, const N : usize>), @2: I) -> &'_0 (Clause2_Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Index<Slice<T>, I, Clause2_Output>,

// Full name: core::array::{impl Index<I, Clause2_Output> for Array<T, const N : usize>}
impl<T, I, Clause2_Output, const N : usize> Index<I, Clause2_Output> for Array<T, const N : usize>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Index<Slice<T>, I, Clause2_Output>,
{
    parent_clause0 = MetaSized<Array<T, const N : usize>>
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause2
    fn index<'_0> = {impl Index<I, Clause2_Output> for Array<T, const N : usize>}::index<'_0_0, T, I, Clause2_Output, const N : usize>[@TraitClause0, @TraitClause1, @TraitClause2]
    non-dyn-compatible
}

// Full name: core::ops::index::IndexMut
#[lang_item("index_mut")]
pub trait IndexMut<Self, Idx, Self_Clause1_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Index<Self, Idx, Self_Clause1_Output>
    parent_clause2 : [@TraitClause2]: MetaSized<Idx>
    fn index_mut<'_0> = core::ops::index::IndexMut::index_mut<'_0_0, Self, Idx, Self_Clause1_Output>[Self]
    non-dyn-compatible
}

// Full name: core::array::{impl IndexMut<I, Clause2_Clause1_Output> for Array<T, const N : usize>}::index_mut
pub fn {impl IndexMut<I, Clause2_Clause1_Output> for Array<T, const N : usize>}::index_mut<'_0, T, I, Clause2_Clause1_Output, const N : usize>(@1: &'_0 mut (Array<T, const N : usize>), @2: I) -> &'_0 mut (Clause2_Clause1_Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: IndexMut<Slice<T>, I, Clause2_Clause1_Output>,

// Full name: core::array::{impl IndexMut<I, Clause2_Clause1_Output> for Array<T, const N : usize>}
impl<T, I, Clause2_Clause1_Output, const N : usize> IndexMut<I, Clause2_Clause1_Output> for Array<T, const N : usize>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: IndexMut<Slice<T>, I, Clause2_Clause1_Output>,
{
    parent_clause0 = MetaSized<Array<T, const N : usize>>
    parent_clause1 = {impl Index<I, Clause2_Output> for Array<T, const N : usize>}<T, I, Clause2_Clause1_Output, const N : usize>[@TraitClause0, @TraitClause1, @TraitClause2::parent_clause1]
    parent_clause2 = @TraitClause1::parent_clause0
    fn index_mut<'_0> = {impl IndexMut<I, Clause2_Clause1_Output> for Array<T, const N : usize>}::index_mut<'_0_0, T, I, Clause2_Clause1_Output, const N : usize>[@TraitClause0, @TraitClause1, @TraitClause2]
    non-dyn-compatible
}

// Full name: core::ops::drop::Drop
#[lang_item("drop")]
pub trait Drop<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn drop<'_0> = drop<'_0_0, Self>[Self]
    vtable: core::ops::drop::Drop::{vtable}
}

// Full name: core::ops::drop::Drop::drop
pub fn drop<'_0, Self>(@1: &'_0 mut (Self))
where
    [@TraitClause0]: Drop<Self>,

pub fn core::ops::index::Index::index<'_0, Self, Idx, Clause0_Output>(@1: &'_0 (Self), @2: Idx) -> &'_0 (Clause0_Output)
where
    [@TraitClause0]: Index<Self, Idx, Clause0_Output>,

pub fn core::ops::index::IndexMut::index_mut<'_0, Self, Idx, Clause0_Clause1_Output>(@1: &'_0 mut (Self), @2: Idx) -> &'_0 mut (Clause0_Clause1_Output)
where
    [@TraitClause0]: IndexMut<Self, Idx, Clause0_Clause1_Output>,

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::slice::index::private_slice_index::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::slice::index::private_slice_index::Sealed::{vtable}
}

// Full name: core::slice::index::SliceIndex
#[lang_item("SliceIndex")]
pub trait SliceIndex<Self, T, Self_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sealed<Self>
    parent_clause2 : [@TraitClause2]: MetaSized<T>
    parent_clause3 : [@TraitClause3]: MetaSized<Self_Output>
    fn get<'_0> = core::slice::index::SliceIndex::get<'_0_0, Self, T, Self_Output>[Self]
    fn get_mut<'_0> = core::slice::index::SliceIndex::get_mut<'_0_0, Self, T, Self_Output>[Self]
    fn get_unchecked = core::slice::index::SliceIndex::get_unchecked<Self, T, Self_Output>[Self]
    fn get_unchecked_mut = core::slice::index::SliceIndex::get_unchecked_mut<Self, T, Self_Output>[Self]
    fn index<'_0> = core::slice::index::SliceIndex::index<'_0_0, Self, T, Self_Output>[Self]
    fn index_mut<'_0> = core::slice::index::SliceIndex::index_mut<'_0_0, Self, T, Self_Output>[Self]
    non-dyn-compatible
}

// Full name: core::slice::index::{impl Index<I, Clause2_Output> for Slice<T>}::index
pub fn {impl Index<I, Clause2_Output> for Slice<T>}::index<'_0, T, I, Clause2_Output>(@1: &'_0 (Slice<T>), @2: I) -> &'_0 (Clause2_Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, Slice<T>, Clause2_Output>,

// Full name: core::slice::index::{impl Index<I, Clause2_Output> for Slice<T>}
impl<T, I, Clause2_Output> Index<I, Clause2_Output> for Slice<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, Slice<T>, Clause2_Output>,
{
    parent_clause0 = MetaSized<Slice<T>>
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause3
    fn index<'_0> = {impl Index<I, Clause2_Output> for Slice<T>}::index<'_0_0, T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    non-dyn-compatible
}

// Full name: core::slice::index::{impl IndexMut<I, Clause2_Output> for Slice<T>}::index_mut
pub fn {impl IndexMut<I, Clause2_Output> for Slice<T>}::index_mut<'_0, T, I, Clause2_Output>(@1: &'_0 mut (Slice<T>), @2: I) -> &'_0 mut (Clause2_Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, Slice<T>, Clause2_Output>,

// Full name: core::slice::index::{impl IndexMut<I, Clause2_Output> for Slice<T>}
impl<T, I, Clause2_Output> IndexMut<I, Clause2_Output> for Slice<T>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, Slice<T>, Clause2_Output>,
{
    parent_clause0 = MetaSized<Slice<T>>
    parent_clause1 = {impl Index<I, Clause2_Output> for Slice<T>}<T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    parent_clause2 = @TraitClause1::parent_clause0
    fn index_mut<'_0> = {impl IndexMut<I, Clause2_Output> for Slice<T>}::index_mut<'_0_0, T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    non-dyn-compatible
}

// Full name: core::slice::index::private_slice_index::{impl Sealed for Range<usize>[Sized<usize>]}
impl Sealed for Range<usize>[Sized<usize>] {
    parent_clause0 = MetaSized<Range<usize>[Sized<usize>]>
    vtable: {impl Sealed for Range<usize>[Sized<usize>]}::{vtable}
}

pub fn core::slice::index::SliceIndex::get<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 (T)) -> Option<&'_0 (Clause0_Output)>[Sized<&'_0 (Clause0_Output)>]
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,

pub fn core::slice::index::SliceIndex::get_mut<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 mut (T)) -> Option<&'_0 mut (Clause0_Output)>[Sized<&'_0 mut (Clause0_Output)>]
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,

pub unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T, Clause0_Output>(@1: Self, @2: *const T) -> *const Clause0_Output
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,

pub unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T, Clause0_Output>(@1: Self, @2: *mut T) -> *mut Clause0_Output
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,

pub fn core::slice::index::SliceIndex::index<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 (T)) -> &'_0 (Clause0_Output)
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,

pub fn core::slice::index::SliceIndex::index_mut<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 mut (T)) -> &'_0 mut (Clause0_Output)
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get
pub fn {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get<'_0, T>(@1: Range<usize>[Sized<usize>], @2: &'_0 (Slice<T>)) -> Option<&'_0 (Slice<T>)>[Sized<&'_0 (Slice<T>)>]
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_mut
pub fn {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_mut<'_0, T>(@1: Range<usize>[Sized<usize>], @2: &'_0 mut (Slice<T>)) -> Option<&'_0 mut (Slice<T>)>[Sized<&'_0 mut (Slice<T>)>]
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_unchecked
pub unsafe fn {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_unchecked<T>(@1: Range<usize>[Sized<usize>], @2: *const Slice<T>) -> *const Slice<T>
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_unchecked_mut
pub unsafe fn {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_unchecked_mut<T>(@1: Range<usize>[Sized<usize>], @2: *mut Slice<T>) -> *mut Slice<T>
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::index
pub fn {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::index<'_0, T>(@1: Range<usize>[Sized<usize>], @2: &'_0 (Slice<T>)) -> &'_0 (Slice<T>)
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::index_mut
pub fn {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::index_mut<'_0, T>(@1: Range<usize>[Sized<usize>], @2: &'_0 mut (Slice<T>)) -> &'_0 mut (Slice<T>)
where
    [@TraitClause0]: Sized<T>,

// Full name: core::slice::index::{impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}
impl<T> SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = MetaSized<Range<usize>[Sized<usize>]>
    parent_clause1 = {impl Sealed for Range<usize>[Sized<usize>]}
    parent_clause2 = MetaSized<Slice<T>>
    parent_clause3 = MetaSized<Slice<T>>
    fn get<'_0> = {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get<'_0_0, T>[@TraitClause0]
    fn get_mut<'_0> = {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_mut<'_0_0, T>[@TraitClause0]
    fn get_unchecked = {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0> = {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::index<'_0_0, T>[@TraitClause0]
    fn index_mut<'_0> = {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}::index_mut<'_0_0, T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: core::slice::{Slice<T>}::len
#[lang_item("slice_len_fn")]
pub fn len<'_0, T>(@1: &'_0 (Slice<T>)) -> usize
where
    [@TraitClause0]: Sized<T>,

// Full name: test_crate::AB
pub enum AB {
  A,
  B,
}

// Full name: test_crate::incr
pub fn incr<'_0>(@1: &'_0 mut (u32))
{
    let @0: (); // return
    let x@1: &'_ mut (u32); // arg #1
    let @2: u32; // anonymous local

    storage_live(@2)
    @2 := copy (*(x@1)) panic.+ const (1 : u32)
    *(x@1) := move (@2)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::array_to_shared_slice_
pub fn array_to_shared_slice_<'_0, T>(@1: &'_0 (Array<T, 32 : usize>)) -> &'_0 (Slice<T>)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ (Slice<T>); // return
    let s@1: &'_ (Array<T, 32 : usize>); // arg #1
    let @2: &'_ (Array<T, 32 : usize>); // anonymous local

    storage_live(@2)
    @2 := &*(s@1)
    @0 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::array_to_mut_slice_
pub fn array_to_mut_slice_<'_0, T>(@1: &'_0 mut (Array<T, 32 : usize>)) -> &'_0 mut (Slice<T>)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ mut (Slice<T>); // return
    let s@1: &'_ mut (Array<T, 32 : usize>); // arg #1
    let @2: &'_ mut (Slice<T>); // anonymous local
    let @3: &'_ mut (Array<T, 32 : usize>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &mut *(s@1)
    @2 := @ArrayToSliceMut<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := &mut *(@2)
    storage_dead(@2)
    return
}

// Full name: test_crate::array_len
pub fn array_len<T>(@1: Array<T, 32 : usize>) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return
    let s@1: Array<T, 32 : usize>; // arg #1
    let @2: &'_ (Slice<T>); // anonymous local
    let @3: &'_ (Array<T, 32 : usize>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &s@1
    @2 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    drop[Drop<Array<T, 32 : usize>>] s@1
    return
}

// Full name: test_crate::shared_array_len
pub fn shared_array_len<'_0, T>(@1: &'_0 (Array<T, 32 : usize>)) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return
    let s@1: &'_ (Array<T, 32 : usize>); // arg #1
    let @2: &'_ (Slice<T>); // anonymous local
    let @3: &'_ (Array<T, 32 : usize>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &*(s@1)
    @2 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::shared_slice_len
pub fn shared_slice_len<'_0, T>(@1: &'_0 (Slice<T>)) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return
    let s@1: &'_ (Slice<T>); // arg #1
    let @2: &'_ (Slice<T>); // anonymous local

    storage_live(@2)
    @2 := &*(s@1)
    @0 := len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_array_shared
pub fn index_array_shared<'_0, T>(@1: &'_0 (Array<T, 32 : usize>), @2: usize) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ (T); // return
    let s@1: &'_ (Array<T, 32 : usize>); // arg #1
    let i@2: usize; // arg #2
    let @3: &'_ (T); // anonymous local
    let @4: usize; // anonymous local
    let @5: &'_ (Array<T, 32 : usize>); // anonymous local
    let @6: &'_ (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := &*(s@1)
    storage_live(@6)
    @6 := @ArrayIndexShared<'_, T, 32 : usize>(move (@5), copy (@4))
    @3 := &*(@6)
    @0 := &*(@3)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::index_array_u32
pub fn index_array_u32(@1: Array<u32, 32 : usize>, @2: usize) -> u32
{
    let @0: u32; // return
    let s@1: Array<u32, 32 : usize>; // arg #1
    let i@2: usize; // arg #2
    let @3: usize; // anonymous local
    let @4: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(@3)
    @3 := copy (i@2)
    storage_live(@4)
    @4 := &s@1
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(@3)
    return
}

// Full name: test_crate::index_array_copy
pub fn index_array_copy<'_0>(@1: &'_0 (Array<u32, 32 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_mut_array
pub fn index_mut_array<'_0, T>(@1: &'_0 mut (Array<T, 32 : usize>), @2: usize) -> &'_0 mut (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ mut (T); // return
    let s@1: &'_ mut (Array<T, 32 : usize>); // arg #1
    let i@2: usize; // arg #2
    let @3: &'_ mut (T); // anonymous local
    let @4: &'_ mut (T); // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut (Array<T, 32 : usize>); // anonymous local
    let @7: &'_ mut (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (i@2)
    storage_live(@6)
    @6 := &mut *(s@1)
    storage_live(@7)
    @7 := @ArrayIndexMut<'_, T, 32 : usize>(move (@6), copy (@5))
    @4 := &mut *(@7)
    @3 := &mut *(@4)
    @0 := &mut *(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::index_slice
pub fn index_slice<'_0, T>(@1: &'_0 (Slice<T>), @2: usize) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ (T); // return
    let s@1: &'_ (Slice<T>); // arg #1
    let i@2: usize; // arg #2
    let @3: &'_ (T); // anonymous local
    let @4: usize; // anonymous local
    let @5: &'_ (Slice<T>); // anonymous local
    let @6: &'_ (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := &*(s@1)
    storage_live(@6)
    @6 := @SliceIndexShared<'_, T>(move (@5), copy (@4))
    @3 := &*(@6)
    @0 := &*(@3)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::index_mut_slice
pub fn index_mut_slice<'_0, T>(@1: &'_0 mut (Slice<T>), @2: usize) -> &'_0 mut (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ mut (T); // return
    let s@1: &'_ mut (Slice<T>); // arg #1
    let i@2: usize; // arg #2
    let @3: &'_ mut (T); // anonymous local
    let @4: &'_ mut (T); // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut (Slice<T>); // anonymous local
    let @7: &'_ mut (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (i@2)
    storage_live(@6)
    @6 := &mut *(s@1)
    storage_live(@7)
    @7 := @SliceIndexMut<'_, T>(move (@6), copy (@5))
    @4 := &mut *(@7)
    @3 := &mut *(@4)
    @0 := &mut *(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::slice_subslice_shared_
pub fn slice_subslice_shared_<'_0>(@1: &'_0 (Slice<u32>), @2: usize, @3: usize) -> &'_0 (Slice<u32>)
{
    let @0: &'_ (Slice<u32>); // return
    let x@1: &'_ (Slice<u32>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ (Slice<u32>); // anonymous local
    let @5: &'_ (Slice<u32>); // anonymous local
    let @6: &'_ (Slice<u32>); // anonymous local
    let @7: Range<usize>[Sized<usize>]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := {impl Index<I, Clause2_Output> for Slice<T>}::index<'_, u32, Range<usize>[Sized<usize>], Slice<u32>>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}<u32>[Sized<u32>]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5)
    @0 := &*(@4)
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::slice_subslice_mut_
pub fn slice_subslice_mut_<'_0>(@1: &'_0 mut (Slice<u32>), @2: usize, @3: usize) -> &'_0 mut (Slice<u32>)
{
    let @0: &'_ mut (Slice<u32>); // return
    let x@1: &'_ mut (Slice<u32>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ mut (Slice<u32>); // anonymous local
    let @5: &'_ mut (Slice<u32>); // anonymous local
    let @6: &'_ mut (Slice<u32>); // anonymous local
    let @7: &'_ mut (Slice<u32>); // anonymous local
    let @8: Range<usize>[Sized<usize>]; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &mut *(x@1)
    storage_live(@8)
    storage_live(@9)
    @9 := copy (y@2)
    storage_live(@10)
    @10 := copy (z@3)
    @8 := Range { start: move (@9), end: move (@10) }
    storage_dead(@10)
    storage_dead(@9)
    @6 := {impl IndexMut<I, Clause2_Output> for Slice<T>}::index_mut<'_, u32, Range<usize>[Sized<usize>], Slice<u32>>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}<u32>[Sized<u32>]](move (@7), move (@8))
    storage_dead(@8)
    storage_dead(@7)
    @5 := &mut *(@6)
    @4 := &mut *(@5)
    @0 := &mut *(@4)
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::array_to_slice_shared_
pub fn array_to_slice_shared_<'_0>(@1: &'_0 (Array<u32, 32 : usize>)) -> &'_0 (Slice<u32>)
{
    let @0: &'_ (Slice<u32>); // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let @2: &'_ (Array<u32, 32 : usize>); // anonymous local

    storage_live(@2)
    @2 := &*(x@1)
    @0 := @ArrayToSliceShared<'_, u32, 32 : usize>(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::array_to_slice_mut_
pub fn array_to_slice_mut_<'_0>(@1: &'_0 mut (Array<u32, 32 : usize>)) -> &'_0 mut (Slice<u32>)
{
    let @0: &'_ mut (Slice<u32>); // return
    let x@1: &'_ mut (Array<u32, 32 : usize>); // arg #1
    let @2: &'_ mut (Slice<u32>); // anonymous local
    let @3: &'_ mut (Array<u32, 32 : usize>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &mut *(x@1)
    @2 := @ArrayToSliceMut<'_, u32, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := &mut *(@2)
    storage_dead(@2)
    return
}

// Full name: test_crate::array_subslice_shared_
pub fn array_subslice_shared_<'_0>(@1: &'_0 (Array<u32, 32 : usize>), @2: usize, @3: usize) -> &'_0 (Slice<u32>)
{
    let @0: &'_ (Slice<u32>); // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ (Slice<u32>); // anonymous local
    let @5: &'_ (Slice<u32>); // anonymous local
    let @6: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @7: Range<usize>[Sized<usize>]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := {impl Index<I, Clause2_Output> for Array<T, const N : usize>}::index<'_, u32, Range<usize>[Sized<usize>], Slice<u32>, 32 : usize>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl Index<I, Clause2_Output> for Slice<T>}<u32, Range<usize>[Sized<usize>], Slice<u32>>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}<u32>[Sized<u32>]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5)
    @0 := &*(@4)
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::array_subslice_mut_
pub fn array_subslice_mut_<'_0>(@1: &'_0 mut (Array<u32, 32 : usize>), @2: usize, @3: usize) -> &'_0 mut (Slice<u32>)
{
    let @0: &'_ mut (Slice<u32>); // return
    let x@1: &'_ mut (Array<u32, 32 : usize>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ mut (Slice<u32>); // anonymous local
    let @5: &'_ mut (Slice<u32>); // anonymous local
    let @6: &'_ mut (Slice<u32>); // anonymous local
    let @7: &'_ mut (Array<u32, 32 : usize>); // anonymous local
    let @8: Range<usize>[Sized<usize>]; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &mut *(x@1)
    storage_live(@8)
    storage_live(@9)
    @9 := copy (y@2)
    storage_live(@10)
    @10 := copy (z@3)
    @8 := Range { start: move (@9), end: move (@10) }
    storage_dead(@10)
    storage_dead(@9)
    @6 := {impl IndexMut<I, Clause2_Clause1_Output> for Array<T, const N : usize>}::index_mut<'_, u32, Range<usize>[Sized<usize>], Slice<u32>, 32 : usize>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl IndexMut<I, Clause2_Output> for Slice<T>}<u32, Range<usize>[Sized<usize>], Slice<u32>>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}<u32>[Sized<u32>]]](move (@7), move (@8))
    storage_dead(@8)
    storage_dead(@7)
    @5 := &mut *(@6)
    @4 := &mut *(@5)
    @0 := &mut *(@4)
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::index_slice_0
pub fn index_slice_0<'_0, T>(@1: &'_0 (Slice<T>)) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ (T); // return
    let s@1: &'_ (Slice<T>); // arg #1
    let @2: &'_ (T); // anonymous local
    let @3: usize; // anonymous local
    let @4: &'_ (Slice<T>); // anonymous local
    let @5: &'_ (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &*(s@1)
    storage_live(@5)
    @5 := @SliceIndexShared<'_, T>(move (@4), copy (@3))
    @2 := &*(@5)
    @0 := &*(@2)
    storage_dead(@3)
    storage_dead(@2)
    return
}

// Full name: test_crate::index_array_0
pub fn index_array_0<'_0, T>(@1: &'_0 (Array<T, 32 : usize>)) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'_ (T); // return
    let s@1: &'_ (Array<T, 32 : usize>); // arg #1
    let @2: &'_ (T); // anonymous local
    let @3: usize; // anonymous local
    let @4: &'_ (Array<T, 32 : usize>); // anonymous local
    let @5: &'_ (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &*(s@1)
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, T, 32 : usize>(move (@4), copy (@3))
    @2 := &*(@5)
    @0 := &*(@2)
    storage_dead(@3)
    storage_dead(@2)
    return
}

// Full name: test_crate::index_index_array
pub fn index_index_array(@1: Array<Array<u32, 32 : usize>, 32 : usize>, @2: usize, @3: usize) -> u32
{
    let @0: u32; // return
    let s@1: Array<Array<u32, 32 : usize>, 32 : usize>; // arg #1
    let i@2: usize; // arg #2
    let j@3: usize; // arg #3
    let @4: usize; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ (Array<Array<u32, 32 : usize>, 32 : usize>); // anonymous local
    let @7: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @8: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @9: &'_ (u32); // anonymous local

    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := copy (j@3)
    storage_live(@6)
    @6 := &s@1
    storage_live(@7)
    @7 := @ArrayIndexShared<'_, Array<u32, 32 : usize>, 32 : usize>(move (@6), copy (@4))
    storage_live(@8)
    @8 := &*(@7)
    storage_live(@9)
    @9 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@8), copy (@5))
    @0 := copy (*(@9))
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::update_update_array
pub fn update_update_array(@1: Array<Array<u32, 32 : usize>, 32 : usize>, @2: usize, @3: usize)
{
    let @0: (); // return
    let s@1: Array<Array<u32, 32 : usize>, 32 : usize>; // arg #1
    let i@2: usize; // arg #2
    let j@3: usize; // arg #3
    let @4: usize; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut (Array<Array<u32, 32 : usize>, 32 : usize>); // anonymous local
    let @7: &'_ mut (Array<u32, 32 : usize>); // anonymous local
    let @8: &'_ mut (Array<u32, 32 : usize>); // anonymous local
    let @9: &'_ mut (u32); // anonymous local

    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := copy (j@3)
    storage_live(@6)
    @6 := &mut s@1
    storage_live(@7)
    @7 := @ArrayIndexMut<'_, Array<u32, 32 : usize>, 32 : usize>(move (@6), copy (@4))
    storage_live(@8)
    @8 := &mut *(@7)
    storage_live(@9)
    @9 := @ArrayIndexMut<'_, u32, 32 : usize>(move (@8), copy (@5))
    *(@9) := const (0 : u32)
    storage_dead(@5)
    storage_dead(@4)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::incr_array_self
pub fn incr_array_self<'_0>(@1: &'_0 mut (Array<u32, 2 : usize>))
{
    let @0: (); // return
    let s@1: &'_ mut (Array<u32, 2 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: u32; // anonymous local
    let @4: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @5: &'_ mut (u32); // anonymous local
    let @6: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @7: &'_ (u32); // anonymous local

    storage_live(@3)
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@6)
    @6 := &*(s@1)
    storage_live(@7)
    @7 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@6), copy (@2))
    @3 := copy (*(@7)) panic.+ const (1 : u32)
    storage_live(@4)
    @4 := &mut *(s@1)
    storage_live(@5)
    @5 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@4), copy (@2))
    *(@5) := move (@3)
    storage_dead(@2)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::incr_slice_self
pub fn incr_slice_self<'_0>(@1: &'_0 mut (Slice<u32>))
{
    let @0: (); // return
    let s@1: &'_ mut (Slice<u32>); // arg #1
    let @2: usize; // anonymous local
    let @3: u32; // anonymous local
    let @4: &'_ mut (Slice<u32>); // anonymous local
    let @5: &'_ mut (u32); // anonymous local
    let @6: &'_ (Slice<u32>); // anonymous local
    let @7: &'_ (u32); // anonymous local

    storage_live(@3)
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@6)
    @6 := &*(s@1)
    storage_live(@7)
    @7 := @SliceIndexShared<'_, u32>(move (@6), copy (@2))
    @3 := copy (*(@7)) panic.+ const (1 : u32)
    storage_live(@4)
    @4 := &mut *(s@1)
    storage_live(@5)
    @5 := @SliceIndexMut<'_, u32>(move (@4), copy (@2))
    *(@5) := move (@3)
    storage_dead(@2)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::array_local_deep_copy
pub fn array_local_deep_copy<'_0>(@1: &'_0 (Array<u32, 32 : usize>))
{
    let @0: (); // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let _y@2: Array<u32, 32 : usize>; // local

    storage_live(_y@2)
    _y@2 := copy (*(x@1))
    @0 := ()
    storage_dead(_y@2)
    @0 := ()
    return
}

// Full name: test_crate::take_array
pub fn take_array(@1: Array<u32, 2 : usize>)
{
    let @0: (); // return
    let @1: Array<u32, 2 : usize>; // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::take_array_borrow
pub fn take_array_borrow<'_0>(@1: &'_0 (Array<u32, 2 : usize>))
{
    let @0: (); // return
    let @1: &'_ (Array<u32, 2 : usize>); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::take_slice
pub fn take_slice<'_0>(@1: &'_0 (Slice<u32>))
{
    let @0: (); // return
    let @1: &'_ (Slice<u32>); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::take_mut_slice
pub fn take_mut_slice<'_0>(@1: &'_0 mut (Slice<u32>))
{
    let @0: (); // return
    let @1: &'_ mut (Slice<u32>); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::const_array
pub fn const_array() -> Array<u32, 2 : usize>
{
    let @0: Array<u32, 2 : usize>; // return

    @0 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    return
}

// Full name: test_crate::const_slice
pub fn const_slice()
{
    let @0: (); // return
    let @1: &'_ (Slice<u32>); // anonymous local
    let @2: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @3: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @4: Array<u32, 2 : usize>; // anonymous local

    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    @3 := &@4
    @2 := &*(@3)
    @1 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@2))
    storage_dead(@2)
    storage_dead(@3)
    storage_dead(@1)
    @0 := ()
    storage_dead(@4)
    @0 := ()
    return
}

// Full name: test_crate::take_all
pub fn take_all()
{
    let @0: (); // return
    let x@1: Array<u32, 2 : usize>; // local
    let @2: (); // anonymous local
    let @3: Array<u32, 2 : usize>; // anonymous local
    let @4: (); // anonymous local
    let @5: Array<u32, 2 : usize>; // anonymous local
    let @6: (); // anonymous local
    let @7: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @8: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @9: (); // anonymous local
    let @10: &'_ (Slice<u32>); // anonymous local
    let @11: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @12: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @13: (); // anonymous local
    let @14: &'_ mut (Slice<u32>); // anonymous local
    let @15: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @16: &'_ mut (Array<u32, 2 : usize>); // anonymous local

    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    // x is deep copied (copy node appears in Charon, followed by a move)
    @3 := copy (x@1)
    @2 := take_array(move (@3))
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (x@1)
    @4 := take_array(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    // x passed by address, there is a reborrow here
    @8 := &x@1
    @7 := &*(@8)
    @6 := take_array_borrow<'_>(move (@7))
    storage_dead(@7)
    storage_dead(@8)
    storage_dead(@6)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    // automatic cast from array to slice (spanning entire array)
    @12 := &x@1
    @11 := &*(@12)
    @10 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@11))
    storage_dead(@11)
    @9 := take_slice<'_>(move (@10))
    storage_dead(@10)
    storage_dead(@12)
    storage_dead(@9)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    // note that both appear as SliceNew expressions, meaning the SliceNew UnOp is overloaded for
    // mut and non-mut cases
    @16 := &mut x@1
    @15 := &mut *(@16)
    @14 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@15))
    storage_dead(@15)
    @13 := take_mut_slice<'_>(move (@14))
    storage_dead(@14)
    storage_dead(@16)
    storage_dead(@13)
    @0 := ()
    storage_dead(x@1)
    @0 := ()
    return
}

// Full name: test_crate::index_array
pub fn index_array(@1: Array<u32, 2 : usize>) -> u32
{
    let @0: u32; // return
    let x@1: Array<u32, 2 : usize>; // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &x@1
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_array_borrow
pub fn index_array_borrow<'_0>(@1: &'_0 (Array<u32, 2 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Array<u32, 2 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_slice_u32_0
pub fn index_slice_u32_0<'_0>(@1: &'_0 (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Slice<u32>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Slice<u32>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @SliceIndexShared<'_, u32>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_mut_slice_u32_0
pub fn index_mut_slice_u32_0<'_0>(@1: &'_0 mut (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ mut (Slice<u32>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Slice<u32>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @SliceIndexShared<'_, u32>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_all
pub fn index_all() -> u32
{
    let @0: u32; // return
    let x@1: Array<u32, 2 : usize>; // local
    let @2: (); // anonymous local
    let @3: bool; // anonymous local
    let _y@4: Array<u32, 2 : usize>; // local
    let _z@5: Array<u32, 1 : usize>; // local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: Array<u32, 2 : usize>; // anonymous local
    let @11: u32; // anonymous local
    let @12: Array<u32, 2 : usize>; // anonymous local
    let @13: u32; // anonymous local
    let @14: u32; // anonymous local
    let @15: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @16: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @17: u32; // anonymous local
    let @18: u32; // anonymous local
    let @19: &'_ (Slice<u32>); // anonymous local
    let @20: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @21: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @22: u32; // anonymous local
    let @23: u32; // anonymous local
    let @24: &'_ mut (Slice<u32>); // anonymous local
    let @25: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @26: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @27: u32; // anonymous local

    storage_live(_y@4)
    storage_live(_z@5)
    storage_live(@13)
    storage_live(@17)
    storage_live(@22)
    storage_live(@27)
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    @3 := const (true)
    if move (@3) {
        storage_live(_y@4)
        _y@4 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
        storage_dead(_y@4)
    }
    else {
        storage_live(_z@5)
        _z@5 := [const (0 : u32)]
        storage_dead(_z@5)
    }
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    @10 := copy (x@1)
    @9 := index_array(move (@10))
    storage_dead(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := copy (x@1)
    @11 := index_array(move (@12))
    storage_dead(@12)
    @13 := copy (@9) panic.+ copy (@11)
    @8 := move (@13)
    storage_dead(@11)
    storage_dead(@9)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    @16 := &x@1
    @15 := &*(@16)
    @14 := index_array_borrow<'_>(move (@15))
    storage_dead(@15)
    @17 := copy (@8) panic.+ copy (@14)
    @7 := move (@17)
    storage_dead(@14)
    storage_dead(@8)
    storage_live(@18)
    storage_live(@19)
    storage_live(@20)
    storage_live(@21)
    @21 := &x@1
    @20 := &*(@21)
    @19 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@20))
    storage_dead(@20)
    @18 := index_slice_u32_0<'_>(move (@19))
    storage_dead(@19)
    @22 := copy (@7) panic.+ copy (@18)
    @6 := move (@22)
    storage_dead(@18)
    storage_dead(@7)
    storage_live(@23)
    storage_live(@24)
    storage_live(@25)
    storage_live(@26)
    @26 := &mut x@1
    @25 := &mut *(@26)
    @24 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@25))
    storage_dead(@25)
    @23 := index_mut_slice_u32_0<'_>(move (@24))
    storage_dead(@24)
    @27 := copy (@6) panic.+ copy (@23)
    @0 := move (@27)
    storage_dead(@23)
    storage_dead(@6)
    storage_dead(x@1)
    storage_dead(@26)
    storage_dead(@21)
    storage_dead(@16)
    return
}

// Full name: test_crate::update_array
pub fn update_array(@1: Array<u32, 2 : usize>)
{
    let @0: (); // return
    let x@1: Array<u32, 2 : usize>; // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut x@1
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    @0 := ()
    return
}

// Full name: test_crate::update_array_mut_borrow
pub fn update_array_mut_borrow<'_0>(@1: &'_0 mut (Array<u32, 2 : usize>))
{
    let @0: (); // return
    let x@1: &'_ mut (Array<u32, 2 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut *(x@1)
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    @0 := ()
    return
}

// Full name: test_crate::update_mut_slice
pub fn update_mut_slice<'_0>(@1: &'_0 mut (Slice<u32>))
{
    let @0: (); // return
    let x@1: &'_ mut (Slice<u32>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut (Slice<u32>); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut *(x@1)
    storage_live(@4)
    @4 := @SliceIndexMut<'_, u32>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    @0 := ()
    return
}

// Full name: test_crate::update_all
pub fn update_all()
{
    let @0: (); // return
    let x@1: Array<u32, 2 : usize>; // local
    let @2: (); // anonymous local
    let @3: Array<u32, 2 : usize>; // anonymous local
    let @4: (); // anonymous local
    let @5: Array<u32, 2 : usize>; // anonymous local
    let @6: (); // anonymous local
    let @7: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @8: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @9: (); // anonymous local
    let @10: &'_ mut (Slice<u32>); // anonymous local
    let @11: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @12: &'_ mut (Array<u32, 2 : usize>); // anonymous local

    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    @3 := copy (x@1)
    @2 := update_array(move (@3))
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (x@1)
    @4 := update_array(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := &mut x@1
    @7 := &two-phase-mut *(@8)
    @6 := update_array_mut_borrow<'_>(move (@7))
    storage_dead(@7)
    storage_dead(@8)
    storage_dead(@6)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := &mut x@1
    @11 := &mut *(@12)
    @10 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@11))
    storage_dead(@11)
    @9 := update_mut_slice<'_>(move (@10))
    storage_dead(@10)
    storage_dead(@12)
    storage_dead(@9)
    @0 := ()
    storage_dead(x@1)
    @0 := ()
    return
}

// Full name: test_crate::range_all
pub fn range_all()
{
    let @0: (); // return
    let x@1: Array<u32, 4 : usize>; // local
    let @2: (); // anonymous local
    let @3: &'_ mut (Slice<u32>); // anonymous local
    let @4: &'_ mut (Slice<u32>); // anonymous local
    let @5: &'_ mut (Slice<u32>); // anonymous local
    let @6: &'_ mut (Array<u32, 4 : usize>); // anonymous local
    let @7: Range<usize>[Sized<usize>]; // anonymous local

    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 4 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    // CONFIRM: there is no way to shrink [T;N] into [T;M] with M<N?
    @6 := &mut x@1
    storage_live(@7)
    @7 := Range { start: const (1 : usize), end: const (3 : usize) }
    @5 := {impl IndexMut<I, Clause2_Clause1_Output> for Array<T, const N : usize>}::index_mut<'_, u32, Range<usize>[Sized<usize>], Slice<u32>, 4 : usize>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl IndexMut<I, Clause2_Output> for Slice<T>}<u32, Range<usize>[Sized<usize>], Slice<u32>>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}<u32>[Sized<u32>]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &mut *(@5)
    @3 := &two-phase-mut *(@4)
    @2 := update_mut_slice<'_>(move (@3))
    storage_dead(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@2)
    @0 := ()
    storage_dead(x@1)
    @0 := ()
    return
}

// Full name: test_crate::deref_array_borrow
pub fn deref_array_borrow<'_0>(@1: &'_0 (Array<u32, 2 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Array<u32, 2 : usize>); // arg #1
    let x@2: Array<u32, 2 : usize>; // local
    let @3: usize; // anonymous local
    let @4: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(x@2)
    x@2 := copy (*(x@1))
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &x@2
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(x@2)
    storage_dead(@3)
    return
}

// Full name: test_crate::deref_array_mut_borrow
pub fn deref_array_mut_borrow<'_0>(@1: &'_0 mut (Array<u32, 2 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ mut (Array<u32, 2 : usize>); // arg #1
    let x@2: Array<u32, 2 : usize>; // local
    let @3: usize; // anonymous local
    let @4: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(x@2)
    x@2 := copy (*(x@1))
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &x@2
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(x@2)
    storage_dead(@3)
    return
}

// Full name: test_crate::take_array_t
pub fn take_array_t(@1: Array<AB, 2 : usize>)
{
    let @0: (); // return
    let @1: Array<AB, 2 : usize>; // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::non_copyable_array
pub fn non_copyable_array()
{
    let @0: (); // return
    let x@1: Array<AB, 2 : usize>; // local
    let @2: AB; // anonymous local
    let @3: AB; // anonymous local
    let @4: (); // anonymous local
    let @5: Array<AB, 2 : usize>; // anonymous local

    storage_live(x@1)
    storage_live(@2)
    @2 := AB::A {  }
    storage_live(@3)
    @3 := AB::B {  }
    x@1 := [move (@2), move (@3)]
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    // x is moved (not deep copied!)
    // TODO: determine whether the translation needs to be aware of that and pass by ref instead of by copy
    @5 := move (x@1)
    @4 := take_array_t(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    @0 := ()
    // this fails, naturally:
    // take_array_t(x);
    storage_dead(x@1)
    @0 := ()
    return
}

// Full name: test_crate::sum
pub fn sum<'_0>(@1: &'_0 (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let s@1: &'_ (Slice<u32>); // arg #1
    let sum@2: u32; // local
    let i@3: usize; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: &'_ (Slice<u32>); // anonymous local
    let @9: u32; // anonymous local
    let @10: usize; // anonymous local
    let @11: u32; // anonymous local
    let @12: usize; // anonymous local
    let @13: (); // anonymous local
    let @14: &'_ (Slice<u32>); // anonymous local
    let @15: &'_ (u32); // anonymous local

    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@14)
    storage_live(@15)
    storage_live(sum@2)
    sum@2 := const (0 : u32)
    storage_live(i@3)
    i@3 := const (0 : usize)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@3)
        storage_live(@7)
        storage_live(@8)
        @8 := &*(s@1)
        @7 := len<'_, u32>[Sized<u32>](move (@8))
        storage_dead(@8)
        @5 := move (@6) < move (@7)
        if move (@5) {
        }
        else {
            break 0
        }
        storage_dead(@7)
        storage_dead(@6)
        storage_live(@9)
        storage_live(@10)
        @10 := copy (i@3)
        storage_live(@14)
        @14 := &*(s@1)
        storage_live(@15)
        @15 := @SliceIndexShared<'_, u32>(move (@14), copy (@10))
        @9 := copy (*(@15))
        @11 := copy (sum@2) panic.+ copy (@9)
        sum@2 := move (@11)
        storage_dead(@9)
        storage_dead(@10)
        @12 := copy (i@3) panic.+ const (1 : usize)
        i@3 := move (@12)
        storage_dead(@5)
        continue 0
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@13)
    storage_dead(@13)
    storage_dead(@5)
    storage_dead(@4)
    @0 := copy (sum@2)
    storage_dead(i@3)
    storage_dead(sum@2)
    return
}

// Full name: test_crate::sum2
pub fn sum2<'_0, '_1>(@1: &'_0 (Slice<u32>), @2: &'_1 (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let s@1: &'_ (Slice<u32>); // arg #1
    let s2@2: &'_ (Slice<u32>); // arg #2
    let sum@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: &'_ (Slice<u32>); // anonymous local
    let @8: usize; // anonymous local
    let @9: &'_ (Slice<u32>); // anonymous local
    let i@10: usize; // local
    let @11: (); // anonymous local
    let @12: bool; // anonymous local
    let @13: usize; // anonymous local
    let @14: usize; // anonymous local
    let @15: &'_ (Slice<u32>); // anonymous local
    let @16: u32; // anonymous local
    let @17: u32; // anonymous local
    let @18: usize; // anonymous local
    let @19: u32; // anonymous local
    let @20: usize; // anonymous local
    let @21: u32; // anonymous local
    let @22: u32; // anonymous local
    let @23: usize; // anonymous local
    let @24: (); // anonymous local
    let @25: &'_ (Slice<u32>); // anonymous local
    let @26: &'_ (u32); // anonymous local
    let @27: &'_ (Slice<u32>); // anonymous local
    let @28: &'_ (u32); // anonymous local

    storage_live(@15)
    storage_live(@16)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    storage_live(@20)
    storage_live(@21)
    storage_live(@22)
    storage_live(@23)
    storage_live(@25)
    storage_live(@26)
    storage_live(@27)
    storage_live(@28)
    storage_live(sum@3)
    sum@3 := const (0 : u32)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &*(s@1)
    @6 := len<'_, u32>[Sized<u32>](move (@7))
    storage_dead(@7)
    storage_live(@8)
    storage_live(@9)
    @9 := &*(s2@2)
    @8 := len<'_, u32>[Sized<u32>](move (@9))
    storage_dead(@9)
    @5 := move (@6) == move (@8)
    if move (@5) {
    }
    else {
        storage_dead(@8)
        storage_dead(@6)
        panic(core::panicking::panic)
    }
    storage_dead(@8)
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_live(i@10)
    i@10 := const (0 : usize)
    storage_live(@11)
    loop {
        storage_live(@12)
        storage_live(@13)
        @13 := copy (i@10)
        storage_live(@14)
        storage_live(@15)
        @15 := &*(s@1)
        @14 := len<'_, u32>[Sized<u32>](move (@15))
        storage_dead(@15)
        @12 := move (@13) < move (@14)
        if move (@12) {
        }
        else {
            break 0
        }
        storage_dead(@14)
        storage_dead(@13)
        storage_live(@16)
        storage_live(@17)
        storage_live(@18)
        @18 := copy (i@10)
        storage_live(@27)
        @27 := &*(s@1)
        storage_live(@28)
        @28 := @SliceIndexShared<'_, u32>(move (@27), copy (@18))
        @17 := copy (*(@28))
        storage_live(@19)
        storage_live(@20)
        @20 := copy (i@10)
        storage_live(@25)
        @25 := &*(s2@2)
        storage_live(@26)
        @26 := @SliceIndexShared<'_, u32>(move (@25), copy (@20))
        @19 := copy (*(@26))
        @21 := copy (@17) panic.+ copy (@19)
        @16 := move (@21)
        storage_dead(@19)
        storage_dead(@17)
        @22 := copy (sum@3) panic.+ copy (@16)
        sum@3 := move (@22)
        storage_dead(@16)
        storage_dead(@20)
        storage_dead(@18)
        @23 := copy (i@10) panic.+ const (1 : usize)
        i@10 := move (@23)
        storage_dead(@12)
        continue 0
    }
    storage_dead(@14)
    storage_dead(@13)
    storage_live(@24)
    storage_dead(@24)
    storage_dead(@12)
    storage_dead(@11)
    @0 := copy (sum@3)
    storage_dead(i@10)
    storage_dead(sum@3)
    return
}

// Full name: test_crate::f0
pub fn f0()
{
    let @0: (); // return
    let s@1: &'_ mut (Slice<u32>); // local
    let @2: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @3: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @4: Array<u32, 2 : usize>; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut (Slice<u32>); // anonymous local
    let @7: &'_ mut (u32); // anonymous local

    storage_live(s@1)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := [const (1 : u32), const (2 : u32)]
    @3 := &mut @4
    @2 := &mut *(@3)
    s@1 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@2))
    storage_dead(@2)
    storage_dead(@3)
    storage_live(@5)
    @5 := const (0 : usize)
    storage_live(@6)
    @6 := &mut *(s@1)
    storage_live(@7)
    @7 := @SliceIndexMut<'_, u32>(move (@6), copy (@5))
    *(@7) := const (1 : u32)
    storage_dead(@5)
    @0 := ()
    storage_dead(@4)
    storage_dead(s@1)
    @0 := ()
    return
}

// Full name: test_crate::f1
pub fn f1()
{
    let @0: (); // return
    let s@1: Array<u32, 2 : usize>; // local
    let @2: usize; // anonymous local
    let @3: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    storage_live(s@1)
    s@1 := [const (1 : u32), const (2 : u32)]
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut s@1
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    storage_dead(@2)
    @0 := ()
    storage_dead(s@1)
    @0 := ()
    return
}

// Full name: test_crate::f2
pub fn f2(@1: u32)
{
    let @0: (); // return
    let @1: u32; // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::f4
pub fn f4<'_0>(@1: &'_0 (Array<u32, 32 : usize>), @2: usize, @3: usize) -> &'_0 (Slice<u32>)
{
    let @0: &'_ (Slice<u32>); // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ (Slice<u32>); // anonymous local
    let @5: &'_ (Slice<u32>); // anonymous local
    let @6: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @7: Range<usize>[Sized<usize>]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := {impl Index<I, Clause2_Output> for Array<T, const N : usize>}::index<'_, u32, Range<usize>[Sized<usize>], Slice<u32>, 32 : usize>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl Index<I, Clause2_Output> for Slice<T>}<u32, Range<usize>[Sized<usize>], Slice<u32>>[Sized<u32>, Sized<Range<usize>[Sized<usize>]>, {impl SliceIndex<Slice<T>, Slice<T>> for Range<usize>[Sized<usize>]}<u32>[Sized<u32>]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5)
    @0 := &*(@4)
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::f3
pub fn f3() -> u32
{
    let @0: u32; // return
    let a@1: Array<u32, 2 : usize>; // local
    let @2: (); // anonymous local
    let @3: u32; // anonymous local
    let @4: usize; // anonymous local
    let b@5: Array<u32, 32 : usize>; // local
    let @6: &'_ (Slice<u32>); // anonymous local
    let @7: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @8: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @9: &'_ (Slice<u32>); // anonymous local
    let @10: &'_ (Slice<u32>); // anonymous local
    let @11: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @12: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @13: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @14: &'_ (u32); // anonymous local

    storage_live(a@1)
    a@1 := [const (1 : u32), const (2 : u32)]
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := const (0 : usize)
    storage_live(@13)
    @13 := &a@1
    storage_live(@14)
    @14 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@13), copy (@4))
    @3 := copy (*(@14))
    @2 := f2(move (@3))
    storage_dead(@3)
    storage_dead(@4)
    storage_dead(@2)
    storage_live(b@5)
    b@5 := @ArrayRepeat<'_, u32, 32 : usize>(const (0 : u32))
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := &a@1
    @7 := &*(@8)
    @6 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@7))
    storage_dead(@7)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := &b@5
    @11 := &*(@12)
    @10 := f4<'_>(move (@11), const (16 : usize), const (18 : usize))
    @9 := &*(@10)
    storage_dead(@11)
    @0 := sum2<'_, '_>(move (@6), move (@9))
    storage_dead(@9)
    storage_dead(@6)
    storage_dead(b@5)
    storage_dead(a@1)
    storage_dead(@12)
    storage_dead(@10)
    storage_dead(@8)
    return
}

// Full name: test_crate::SZ
pub fn SZ() -> usize
{
    let @0: usize; // return

    @0 := const (32 : usize)
    return
}

// Full name: test_crate::SZ
pub const SZ: usize = SZ()

// Full name: test_crate::f5
pub fn f5<'_0>(@1: &'_0 (Array<u32, 32 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::ite
pub fn ite()
{
    let @0: (); // return
    let x@1: Array<u32, 2 : usize>; // local
    let @2: bool; // anonymous local
    let y@3: Array<u32, 2 : usize>; // local
    let @4: u32; // anonymous local
    let @5: &'_ mut (Slice<u32>); // anonymous local
    let @6: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @7: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @8: u32; // anonymous local
    let @9: &'_ mut (Slice<u32>); // anonymous local
    let @10: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @11: &'_ mut (Array<u32, 2 : usize>); // anonymous local

    storage_live(y@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    @2 := const (true)
    if move (@2) {
        storage_live(y@3)
        y@3 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
        storage_live(@4)
        storage_live(@5)
        storage_live(@6)
        storage_live(@7)
        @7 := &mut x@1
        @6 := &mut *(@7)
        @5 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@6))
        storage_dead(@6)
        @4 := index_mut_slice_u32_0<'_>(move (@5))
        storage_dead(@5)
        storage_dead(@7)
        storage_dead(@4)
        storage_live(@8)
        storage_live(@9)
        storage_live(@10)
        storage_live(@11)
        @11 := &mut y@3
        @10 := &mut *(@11)
        @9 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@10))
        storage_dead(@10)
        @8 := index_mut_slice_u32_0<'_>(move (@9))
        storage_dead(@9)
        storage_dead(@11)
        storage_dead(@8)
        @0 := ()
        storage_dead(y@3)
    }
    else {
        @0 := ()
    }
    storage_dead(@2)
    storage_dead(x@1)
    @0 := ()
    return
}

// Full name: test_crate::zero_slice
pub fn zero_slice<'_0>(@1: &'_0 mut (Slice<u8>))
{
    let @0: (); // return
    let a@1: &'_ mut (Slice<u8>); // arg #1
    let i@2: usize; // local
    let len@3: usize; // local
    let @4: &'_ (Slice<u8>); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local
    let @10: (); // anonymous local
    let @11: &'_ mut (Slice<u8>); // anonymous local
    let @12: &'_ mut (u8); // anonymous local

    storage_live(@8)
    storage_live(@9)
    storage_live(@11)
    storage_live(@12)
    storage_live(i@2)
    i@2 := const (0 : usize)
    storage_live(len@3)
    storage_live(@4)
    @4 := &*(a@1)
    len@3 := len<'_, u8>[Sized<u8>](move (@4))
    storage_dead(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        @7 := copy (len@3)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@8)
            @8 := copy (i@2)
            storage_live(@11)
            @11 := &mut *(a@1)
            storage_live(@12)
            @12 := @SliceIndexMut<'_, u8>(move (@11), copy (@8))
            *(@12) := const (0 : u8)
            storage_dead(@8)
            @9 := copy (i@2) panic.+ const (1 : usize)
            i@2 := move (@9)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@10)
    @0 := ()
    storage_dead(@10)
    storage_dead(@5)
    storage_dead(len@3)
    storage_dead(i@2)
    @0 := ()
    return
}

// Full name: test_crate::iter_mut_slice
pub fn iter_mut_slice<'_0>(@1: &'_0 mut (Slice<u8>))
{
    let @0: (); // return
    let a@1: &'_ mut (Slice<u8>); // arg #1
    let len@2: usize; // local
    let @3: &'_ (Slice<u8>); // anonymous local
    let i@4: usize; // local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: usize; // anonymous local
    let @9: (); // anonymous local

    storage_live(@8)
    storage_live(len@2)
    storage_live(@3)
    @3 := &*(a@1)
    len@2 := len<'_, u8>[Sized<u8>](move (@3))
    storage_dead(@3)
    storage_live(i@4)
    i@4 := const (0 : usize)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@4)
        storage_live(@7)
        @7 := copy (len@2)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            @8 := copy (i@4) panic.+ const (1 : usize)
            i@4 := move (@8)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@9)
    @0 := ()
    storage_dead(@9)
    storage_dead(@5)
    storage_dead(i@4)
    storage_dead(len@2)
    @0 := ()
    return
}

// Full name: test_crate::sum_mut_slice
pub fn sum_mut_slice<'_0>(@1: &'_0 mut (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let a@1: &'_ mut (Slice<u32>); // arg #1
    let i@2: usize; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: &'_ (Slice<u32>); // anonymous local
    let @9: u32; // anonymous local
    let @10: usize; // anonymous local
    let @11: u32; // anonymous local
    let @12: usize; // anonymous local
    let @13: (); // anonymous local
    let @14: &'_ (Slice<u32>); // anonymous local
    let @15: &'_ (u32); // anonymous local

    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    storage_live(@14)
    storage_live(@15)
    storage_live(i@2)
    i@2 := const (0 : usize)
    storage_live(s@3)
    s@3 := const (0 : u32)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        storage_live(@8)
        @8 := &*(a@1)
        @7 := len<'_, u32>[Sized<u32>](move (@8))
        storage_dead(@8)
        @5 := move (@6) < move (@7)
        if move (@5) {
        }
        else {
            break 0
        }
        storage_dead(@7)
        storage_dead(@6)
        storage_live(@9)
        storage_live(@10)
        @10 := copy (i@2)
        storage_live(@14)
        @14 := &*(a@1)
        storage_live(@15)
        @15 := @SliceIndexShared<'_, u32>(move (@14), copy (@10))
        @9 := copy (*(@15))
        @11 := copy (s@3) panic.+ copy (@9)
        s@3 := move (@11)
        storage_dead(@9)
        storage_dead(@10)
        @12 := copy (i@2) panic.+ const (1 : usize)
        i@2 := move (@12)
        storage_dead(@5)
        continue 0
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@13)
    storage_dead(@13)
    storage_dead(@5)
    storage_dead(@4)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::slice_pattern_1
fn slice_pattern_1(@1: Array<(), 1 : usize>)
{
    let @0: (); // return
    let x@1: Array<(), 1 : usize>; // arg #1
    let _named@2: (); // local
    let @3: &'_ (Array<(), 1 : usize>); // anonymous local
    let @4: &'_ (()); // anonymous local

    storage_live(_named@2)
    storage_live(@3)
    @3 := &x@1
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, (), 1 : usize>(move (@3), const (0 : usize))
    _named@2 := copy (*(@4))
    @0 := ()
    storage_dead(_named@2)
    @0 := ()
    return
}

// Full name: test_crate::slice_pattern_2
fn slice_pattern_2<'_0, T>(@1: Array<&'_0 mut (T), 3 : usize>)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: (); // return
    let x@1: Array<&'_ mut (T), 3 : usize>; // arg #1
    let _a@2: &'_ mut (T); // local
    let _b@3: &'_ mut (T); // local
    let _c@4: &'_ mut (T); // local
    let @5: &'_ mut (Array<&'_ mut (T), 3 : usize>); // anonymous local
    let @6: &'_ mut (&'_ mut (T)); // anonymous local
    let @7: &'_ mut (Array<&'_ mut (T), 3 : usize>); // anonymous local
    let @8: &'_ mut (&'_ mut (T)); // anonymous local
    let @9: &'_ mut (Array<&'_ mut (T), 3 : usize>); // anonymous local
    let @10: &'_ mut (&'_ mut (T)); // anonymous local

    storage_live(_a@2)
    storage_live(@9)
    @9 := &mut x@1
    storage_live(@10)
    @10 := @ArrayIndexMut<'_, &'_ mut (T), 3 : usize>(move (@9), const (0 : usize))
    _a@2 := move (*(@10))
    storage_live(_b@3)
    storage_live(@7)
    @7 := &mut x@1
    storage_live(@8)
    @8 := @ArrayIndexMut<'_, &'_ mut (T), 3 : usize>(move (@7), const (1 : usize))
    _b@3 := move (*(@8))
    storage_live(_c@4)
    storage_live(@5)
    @5 := &mut x@1
    storage_live(@6)
    @6 := @ArrayIndexMut<'_, &'_ mut (T), 3 : usize>(move (@5), const (2 : usize))
    _c@4 := move (*(@6))
    @0 := ()
    storage_dead(_c@4)
    storage_dead(_b@3)
    storage_dead(_a@2)
    @0 := ()
    return
}

// Full name: test_crate::slice_pattern_3
fn slice_pattern_3<'_0>(@1: &'_0 (Array<(), 1 : usize>))
{
    let @0: (); // return
    let x@1: &'_ (Array<(), 1 : usize>); // arg #1
    let _named@2: &'_ (()); // local
    let @3: &'_ (Array<(), 1 : usize>); // anonymous local
    let @4: &'_ (()); // anonymous local

    storage_live(_named@2)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, (), 1 : usize>(move (@3), const (0 : usize))
    _named@2 := &*(@4)
    @0 := ()
    storage_dead(_named@2)
    @0 := ()
    return
}

// Full name: test_crate::slice_pattern_4
fn slice_pattern_4<'_0>(@1: &'_0 (Slice<()>))
{
    let @0: (); // return
    let x@1: &'_ (Slice<()>); // arg #1
    let @2: usize; // anonymous local
    let @3: usize; // anonymous local
    let @4: bool; // anonymous local
    let _named@5: &'_ (()); // local
    let @6: &'_ (Slice<()>); // anonymous local
    let @7: &'_ (()); // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @2 := len(*(x@1))
    @3 := const (1 : usize)
    @4 := move (@2) == move (@3)
    if move (@4) {
    }
    else {
        @0 := ()
        @0 := ()
        return
    }
    storage_live(_named@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    @7 := @SliceIndexShared<'_, ()>(move (@6), const (0 : usize))
    _named@5 := &*(@7)
    @0 := ()
    storage_dead(_named@5)
    @0 := ()
    return
}



