# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::ops::index::Index
#[lang_item("index")]
pub trait Index<Self, Idx, Self_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: MetaSized<Idx>
    parent_clause2 : [@TraitClause2]: MetaSized<Self_Output>
    fn index<'_0_1> = core::ops::index::Index::index<'_0_1, Self, Idx, Self_Output>[Self]
    vtable: core::ops::index::Index::{vtable}<Idx, Self_Output>
}

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::array::{impl Index<I, Clause2_Output> for [T; N]}::index
pub fn {impl Index<I, Clause2_Output> for [T; N]}::index<'_0, T, I, Clause2_Output, const N : usize>(@1: &'_0 ([T; N]), @2: I) -> &'_0 (Clause2_Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Index<[T], I, Clause2_Output>,
= <opaque>

// Full name: core::array::{impl Index<I, Clause2_Output> for [T; N]}
impl<T, I, Clause2_Output, const N : usize> Index<I, Clause2_Output> for [T; N]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Index<[T], I, Clause2_Output>,
{
    parent_clause0 = {built_in impl MetaSized for [T; N]}
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause2
    fn index<'_0_1> = {impl Index<I, Clause2_Output> for [T; N]}::index<'_0_1, T, I, Clause2_Output, N>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl Index<I, Clause2_Output> for [T; N]}::{vtable}<T, I, N>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::ops::index::IndexMut
#[lang_item("index_mut")]
pub trait IndexMut<Self, Idx, Self_Clause1_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Index<Self, Idx, Self_Clause1_Output>
    parent_clause2 : [@TraitClause2]: MetaSized<Idx>
    fn index_mut<'_0_1> = core::ops::index::IndexMut::index_mut<'_0_1, Self, Idx, Self_Clause1_Output>[Self]
    vtable: core::ops::index::IndexMut::{vtable}<Idx, Self_Clause1_Output>
}

// Full name: core::array::{impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut
pub fn {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut<'_0, T, I, Clause2_Clause1_Output, const N : usize>(@1: &'_0 mut ([T; N]), @2: I) -> &'_0 mut (Clause2_Clause1_Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: IndexMut<[T], I, Clause2_Clause1_Output>,
= <opaque>

// Full name: core::array::{impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}
impl<T, I, Clause2_Clause1_Output, const N : usize> IndexMut<I, Clause2_Clause1_Output> for [T; N]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: IndexMut<[T], I, Clause2_Clause1_Output>,
{
    parent_clause0 = {built_in impl MetaSized for [T; N]}
    parent_clause1 = {impl Index<I, Clause2_Output> for [T; N]}<T, I, Clause2_Clause1_Output, N>[@TraitClause0, @TraitClause1, @TraitClause2::parent_clause1]
    parent_clause2 = @TraitClause1::parent_clause0
    fn index_mut<'_0_1> = {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut<'_0_1, T, I, Clause2_Clause1_Output, N>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::{vtable}<T, I, N>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

pub fn core::ops::index::Index::index<'_0, Self, Idx, Clause0_Output>(@1: &'_0 (Self), @2: Idx) -> &'_0 (Clause0_Output)
where
    [@TraitClause0]: Index<Self, Idx, Clause0_Output>,
= <opaque>

pub fn core::ops::index::IndexMut::index_mut<'_0, Self, Idx, Clause0_Clause1_Output>(@1: &'_0 mut (Self), @2: Idx) -> &'_0 mut (Clause0_Clause1_Output)
where
    [@TraitClause0]: IndexMut<Self, Idx, Clause0_Clause1_Output>,
= <opaque>

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::slice::index::private_slice_index::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::slice::index::private_slice_index::Sealed::{vtable}
}

// Full name: core::slice::index::SliceIndex
#[lang_item("SliceIndex")]
pub trait SliceIndex<Self, T, Self_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sealed<Self>
    parent_clause2 : [@TraitClause2]: MetaSized<T>
    parent_clause3 : [@TraitClause3]: MetaSized<Self_Output>
    fn get<'_0_1> = core::slice::index::SliceIndex::get<'_0_1, Self, T, Self_Output>[Self]
    fn get_mut<'_0_1> = core::slice::index::SliceIndex::get_mut<'_0_1, Self, T, Self_Output>[Self]
    fn get_unchecked = core::slice::index::SliceIndex::get_unchecked<Self, T, Self_Output>[Self]
    fn get_unchecked_mut = core::slice::index::SliceIndex::get_unchecked_mut<Self, T, Self_Output>[Self]
    fn index<'_0_1> = core::slice::index::SliceIndex::index<'_0_1, Self, T, Self_Output>[Self]
    fn index_mut<'_0_1> = core::slice::index::SliceIndex::index_mut<'_0_1, Self, T, Self_Output>[Self]
    vtable: core::slice::index::SliceIndex::{vtable}<T, Self_Output>
}

// Full name: core::slice::index::{impl Index<I, Clause2_Output> for [T]}::index
pub fn {impl Index<I, Clause2_Output> for [T]}::index<'_0, T, I, Clause2_Output>(@1: &'_0 ([T]), @2: I) -> &'_0 (Clause2_Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T], Clause2_Output>,
= <opaque>

// Full name: core::slice::index::{impl Index<I, Clause2_Output> for [T]}
impl<T, I, Clause2_Output> Index<I, Clause2_Output> for [T]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T], Clause2_Output>,
{
    parent_clause0 = {built_in impl MetaSized for [T]}
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause3
    fn index<'_0_1> = {impl Index<I, Clause2_Output> for [T]}::index<'_0_1, T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl Index<I, Clause2_Output> for [T]}::{vtable}<T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::slice::index::{impl IndexMut<I, Clause2_Output> for [T]}::index_mut
pub fn {impl IndexMut<I, Clause2_Output> for [T]}::index_mut<'_0, T, I, Clause2_Output>(@1: &'_0 mut ([T]), @2: I) -> &'_0 mut (Clause2_Output)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T], Clause2_Output>,
= <opaque>

// Full name: core::slice::index::{impl IndexMut<I, Clause2_Output> for [T]}
impl<T, I, Clause2_Output> IndexMut<I, Clause2_Output> for [T]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T], Clause2_Output>,
{
    parent_clause0 = {built_in impl MetaSized for [T]}
    parent_clause1 = {impl Index<I, Clause2_Output> for [T]}<T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    parent_clause2 = @TraitClause1::parent_clause0
    fn index_mut<'_0_1> = {impl IndexMut<I, Clause2_Output> for [T]}::index_mut<'_0_1, T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl IndexMut<I, Clause2_Output> for [T]}::{vtable}<T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::slice::index::private_slice_index::{impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
impl Sealed for Range<usize>[{built_in impl Sized for usize}] {
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    vtable: {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}::{vtable}
}

pub fn core::slice::index::SliceIndex::get<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 (T)) -> Option<&'_0 (Clause0_Output)>[{built_in impl Sized for &'_0 (Clause0_Output)}]
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub fn core::slice::index::SliceIndex::get_mut<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 mut (T)) -> Option<&'_0 mut (Clause0_Output)>[{built_in impl Sized for &'_0 mut (Clause0_Output)}]
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T, Clause0_Output>(@1: Self, @2: *const T) -> *const Clause0_Output
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T, Clause0_Output>(@1: Self, @2: *mut T) -> *mut Clause0_Output
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub fn core::slice::index::SliceIndex::index<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 (T)) -> &'_0 (Clause0_Output)
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub fn core::slice::index::SliceIndex::index_mut<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 mut (T)) -> &'_0 mut (Clause0_Output)
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get
pub fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 ([T])) -> Option<&'_0 ([T])>[{built_in impl Sized for &'_0 ([T])}]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut
pub fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut ([T])) -> Option<&'_0 mut ([T])>[{built_in impl Sized for &'_0 mut ([T])}]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked
pub unsafe fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *const [T]) -> *const [T]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut
pub unsafe fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *mut [T]) -> *mut [T]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index
pub fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 ([T])) -> &'_0 ([T])
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut
pub fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut ([T])) -> &'_0 mut ([T])
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}
impl<T> SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause1 = {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause2 = {built_in impl MetaSized for [T]}
    parent_clause3 = {built_in impl MetaSized for [T]}
    fn get<'_0_1> = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0_1, T>[@TraitClause0]
    fn get_mut<'_0_1> = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0_1, T>[@TraitClause0]
    fn get_unchecked = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0_1> = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0_1, T>[@TraitClause0]
    fn index_mut<'_0_1> = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0_1, T>[@TraitClause0]
    vtable: {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::{vtable}<T>[@TraitClause0]
}

// Full name: core::slice::{[T]}::len
#[lang_item("slice_len_fn")]
pub fn len<'_0, T>(@1: &'_0 ([T])) -> usize
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let @0: (); // return

    @0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::<array>::{impl Destruct for [T; N]}::drop_in_place
unsafe fn {impl Destruct for [T; N]}::drop_in_place<T, const N : usize>(@1: *mut [T; N])
where
    [@TraitClause0]: Sized<T>,
{
    let @0: (); // return
    let @1: *mut [T; N]; // arg #1
    let @2: &'0 mut ([T; N]); // anonymous local
    let @3: *mut [T; N]; // anonymous local
    let @4: *mut [T]; // anonymous local
    let @5: usize; // anonymous local
    let @6: usize; // anonymous local
    let @7: *mut T; // anonymous local
    let @8: bool; // anonymous local
    let @9: &'_ mut ([T]); // anonymous local
    let @10: &'_ mut (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @0 := ()
    @2 := &mut *(@1)
    @3 := &raw mut *(@2)
    @4 := unsize_cast<*mut [T; N], *mut [T], N>(move (@3))
    @5 := copy (@4.metadata)
    @6 := const (0 : usize)
    loop {
        @8 := copy (@6) == copy (@5)
        if move (@8) {
            break 0
        } else {
            storage_live(@9)
            @9 := &mut *(@4) with_metadata(copy (@4.metadata))
            storage_live(@10)
            @10 := @SliceIndexMut<'_, T>(move (@9), copy (@6))
            @7 := &raw mut *(@10)
            @6 := move (@6) wrap.+ const (1 : usize)
            drop[{built_in impl Destruct for T}] *(@7)
            continue 0
        }
    }
    return
}

// Full name: test_crate::<array>::{impl Destruct for [T; N]}
impl<T, const N : usize> Destruct for [T; N]
where
    [@TraitClause0]: Sized<T>,
{
    fn drop_in_place = {impl Destruct for [T; N]}::drop_in_place<T, N>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::AB
pub enum AB {
  A,
  B,
}

// Full name: test_crate::incr
pub fn incr<'_0>(@1: &'_0 mut (u32))
{
    let @0: (); // return
    let x@1: &'0 mut (u32); // arg #1
    let @2: u32; // anonymous local

    storage_live(@2)
    @0 := ()
    @2 := copy (*(x@1)) panic.+ const (1 : u32)
    *(x@1) := move (@2)
    @0 := ()
    return
}

// Full name: test_crate::array_to_shared_slice_
pub fn array_to_shared_slice_<'_0, T>(@1: &'_0 ([T; 32 : usize])) -> &'_0 ([T])
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'0 ([T]); // return
    let s@1: &'1 ([T; 32 : usize]); // arg #1
    let @2: &'1 ([T; 32 : usize]); // anonymous local

    storage_live(@2)
    @2 := &*(s@1)
    @0 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::array_to_mut_slice_
pub fn array_to_mut_slice_<'_0, T>(@1: &'_0 mut ([T; 32 : usize])) -> &'_0 mut ([T])
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'0 mut ([T]); // return
    let s@1: &'1 mut ([T; 32 : usize]); // arg #1
    let @2: &'0 mut ([T]); // anonymous local
    let @3: &'1 mut ([T; 32 : usize]); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &mut *(s@1)
    @2 := @ArrayToSliceMut<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := &mut *(@2) with_metadata(copy (@2.metadata))
    storage_dead(@2)
    return
}

// Full name: test_crate::array_len
pub fn array_len<T>(@1: [T; 32 : usize]) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return
    let s@1: [T; 32 : usize]; // arg #1
    let @2: &'0 ([T]); // anonymous local
    let @3: &'1 ([T; 32 : usize]); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &s@1
    @2 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    conditional_drop[{impl Destruct for [T; N]}<T, 32 : usize>[@TraitClause0]] s@1
    return
}

// Full name: test_crate::shared_array_len
pub fn shared_array_len<'_0, T>(@1: &'_0 ([T; 32 : usize])) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return
    let s@1: &'0 ([T; 32 : usize]); // arg #1
    let @2: &'1 ([T]); // anonymous local
    let @3: &'0 ([T; 32 : usize]); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &*(s@1)
    @2 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::shared_slice_len
pub fn shared_slice_len<'_0, T>(@1: &'_0 ([T])) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return
    let s@1: &'0 ([T]); // arg #1
    let @2: &'0 ([T]); // anonymous local

    storage_live(@2)
    @2 := &*(s@1) with_metadata(copy (s@1.metadata))
    @0 := len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_array_shared
pub fn index_array_shared<'_0, T>(@1: &'_0 ([T; 32 : usize]), @2: usize) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'0 (T); // return
    let s@1: &'1 ([T; 32 : usize]); // arg #1
    let i@2: usize; // arg #2
    let @3: &'0 (T); // anonymous local
    let @4: usize; // anonymous local
    let @5: &'_ ([T; 32 : usize]); // anonymous local
    let @6: &'_ (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := &*(s@1)
    storage_live(@6)
    @6 := @ArrayIndexShared<'_, T, 32 : usize>(move (@5), copy (@4))
    @3 := &*(@6)
    @0 := &*(@3)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::index_array_u32
pub fn index_array_u32(@1: [u32; 32 : usize], @2: usize) -> u32
{
    let @0: u32; // return
    let s@1: [u32; 32 : usize]; // arg #1
    let i@2: usize; // arg #2
    let @3: usize; // anonymous local
    let @4: &'_ ([u32; 32 : usize]); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(@3)
    @3 := copy (i@2)
    storage_live(@4)
    @4 := &s@1
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(@3)
    return
}

// Full name: test_crate::index_array_copy
pub fn index_array_copy<'_0>(@1: &'_0 ([u32; 32 : usize])) -> u32
{
    let @0: u32; // return
    let x@1: &'0 ([u32; 32 : usize]); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ ([u32; 32 : usize]); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_mut_array
pub fn index_mut_array<'_0, T>(@1: &'_0 mut ([T; 32 : usize]), @2: usize) -> &'_0 mut (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'0 mut (T); // return
    let s@1: &'1 mut ([T; 32 : usize]); // arg #1
    let i@2: usize; // arg #2
    let @3: &'0 mut (T); // anonymous local
    let @4: &'0 mut (T); // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut ([T; 32 : usize]); // anonymous local
    let @7: &'_ mut (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (i@2)
    storage_live(@6)
    @6 := &mut *(s@1)
    storage_live(@7)
    @7 := @ArrayIndexMut<'_, T, 32 : usize>(move (@6), copy (@5))
    @4 := &mut *(@7)
    @3 := &mut *(@4)
    @0 := &mut *(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::index_slice
pub fn index_slice<'_0, T>(@1: &'_0 ([T]), @2: usize) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'0 (T); // return
    let s@1: &'1 ([T]); // arg #1
    let i@2: usize; // arg #2
    let @3: &'0 (T); // anonymous local
    let @4: usize; // anonymous local
    let @5: &'_ ([T]); // anonymous local
    let @6: &'_ (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := &*(s@1) with_metadata(copy (s@1.metadata))
    storage_live(@6)
    @6 := @SliceIndexShared<'_, T>(move (@5), copy (@4))
    @3 := &*(@6)
    @0 := &*(@3)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::index_mut_slice
pub fn index_mut_slice<'_0, T>(@1: &'_0 mut ([T]), @2: usize) -> &'_0 mut (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'0 mut (T); // return
    let s@1: &'1 mut ([T]); // arg #1
    let i@2: usize; // arg #2
    let @3: &'0 mut (T); // anonymous local
    let @4: &'0 mut (T); // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut ([T]); // anonymous local
    let @7: &'_ mut (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (i@2)
    storage_live(@6)
    @6 := &mut *(s@1) with_metadata(copy (s@1.metadata))
    storage_live(@7)
    @7 := @SliceIndexMut<'_, T>(move (@6), copy (@5))
    @4 := &mut *(@7)
    @3 := &mut *(@4)
    @0 := &mut *(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

// Full name: test_crate::slice_subslice_shared_
pub fn slice_subslice_shared_<'_0>(@1: &'_0 ([u32]), @2: usize, @3: usize) -> &'_0 ([u32])
{
    let @0: &'0 ([u32]); // return
    let x@1: &'0 ([u32]); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'0 ([u32]); // anonymous local
    let @5: &'0 ([u32]); // anonymous local
    let @6: &'0 ([u32]); // anonymous local
    let @7: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1) with_metadata(copy (x@1.metadata))
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := {impl Index<I, Clause2_Output> for [T]}::index<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5) with_metadata(copy (@5.metadata))
    @0 := &*(@4) with_metadata(copy (@4.metadata))
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::slice_subslice_mut_
pub fn slice_subslice_mut_<'_0>(@1: &'_0 mut ([u32]), @2: usize, @3: usize) -> &'_0 mut ([u32])
{
    let @0: &'0 mut ([u32]); // return
    let x@1: &'0 mut ([u32]); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'0 mut ([u32]); // anonymous local
    let @5: &'0 mut ([u32]); // anonymous local
    let @6: &'0 mut ([u32]); // anonymous local
    let @7: &'0 mut ([u32]); // anonymous local
    let @8: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &mut *(x@1) with_metadata(copy (x@1.metadata))
    storage_live(@8)
    storage_live(@9)
    @9 := copy (y@2)
    storage_live(@10)
    @10 := copy (z@3)
    @8 := Range { start: move (@9), end: move (@10) }
    storage_dead(@10)
    storage_dead(@9)
    @6 := {impl IndexMut<I, Clause2_Output> for [T]}::index_mut<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]](move (@7), move (@8))
    storage_dead(@8)
    storage_dead(@7)
    @5 := &mut *(@6) with_metadata(copy (@6.metadata))
    @4 := &mut *(@5) with_metadata(copy (@5.metadata))
    @0 := &mut *(@4) with_metadata(copy (@4.metadata))
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::array_to_slice_shared_
pub fn array_to_slice_shared_<'_0>(@1: &'_0 ([u32; 32 : usize])) -> &'_0 ([u32])
{
    let @0: &'0 ([u32]); // return
    let x@1: &'1 ([u32; 32 : usize]); // arg #1
    let @2: &'1 ([u32; 32 : usize]); // anonymous local

    storage_live(@2)
    @2 := &*(x@1)
    @0 := @ArrayToSliceShared<'_, u32, 32 : usize>(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::array_to_slice_mut_
pub fn array_to_slice_mut_<'_0>(@1: &'_0 mut ([u32; 32 : usize])) -> &'_0 mut ([u32])
{
    let @0: &'0 mut ([u32]); // return
    let x@1: &'1 mut ([u32; 32 : usize]); // arg #1
    let @2: &'0 mut ([u32]); // anonymous local
    let @3: &'1 mut ([u32; 32 : usize]); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &mut *(x@1)
    @2 := @ArrayToSliceMut<'_, u32, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := &mut *(@2) with_metadata(copy (@2.metadata))
    storage_dead(@2)
    return
}

// Full name: test_crate::array_subslice_shared_
pub fn array_subslice_shared_<'_0>(@1: &'_0 ([u32; 32 : usize]), @2: usize, @3: usize) -> &'_0 ([u32])
{
    let @0: &'0 ([u32]); // return
    let x@1: &'1 ([u32; 32 : usize]); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'0 ([u32]); // anonymous local
    let @5: &'0 ([u32]); // anonymous local
    let @6: &'1 ([u32; 32 : usize]); // anonymous local
    let @7: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := {impl Index<I, Clause2_Output> for [T; N]}::index<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32], 32 : usize>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl Index<I, Clause2_Output> for [T]}<u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5) with_metadata(copy (@5.metadata))
    @0 := &*(@4) with_metadata(copy (@4.metadata))
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::array_subslice_mut_
pub fn array_subslice_mut_<'_0>(@1: &'_0 mut ([u32; 32 : usize]), @2: usize, @3: usize) -> &'_0 mut ([u32])
{
    let @0: &'0 mut ([u32]); // return
    let x@1: &'1 mut ([u32; 32 : usize]); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'0 mut ([u32]); // anonymous local
    let @5: &'0 mut ([u32]); // anonymous local
    let @6: &'0 mut ([u32]); // anonymous local
    let @7: &'1 mut ([u32; 32 : usize]); // anonymous local
    let @8: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &mut *(x@1)
    storage_live(@8)
    storage_live(@9)
    @9 := copy (y@2)
    storage_live(@10)
    @10 := copy (z@3)
    @8 := Range { start: move (@9), end: move (@10) }
    storage_dead(@10)
    storage_dead(@9)
    @6 := {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32], 32 : usize>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl IndexMut<I, Clause2_Output> for [T]}<u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]]](move (@7), move (@8))
    storage_dead(@8)
    storage_dead(@7)
    @5 := &mut *(@6) with_metadata(copy (@6.metadata))
    @4 := &mut *(@5) with_metadata(copy (@5.metadata))
    @0 := &mut *(@4) with_metadata(copy (@4.metadata))
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::index_slice_0
pub fn index_slice_0<'_0, T>(@1: &'_0 ([T])) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'0 (T); // return
    let s@1: &'1 ([T]); // arg #1
    let @2: &'0 (T); // anonymous local
    let @3: usize; // anonymous local
    let @4: &'_ ([T]); // anonymous local
    let @5: &'_ (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &*(s@1) with_metadata(copy (s@1.metadata))
    storage_live(@5)
    @5 := @SliceIndexShared<'_, T>(move (@4), copy (@3))
    @2 := &*(@5)
    @0 := &*(@2)
    storage_dead(@3)
    storage_dead(@2)
    return
}

// Full name: test_crate::index_array_0
pub fn index_array_0<'_0, T>(@1: &'_0 ([T; 32 : usize])) -> &'_0 (T)
where
    [@TraitClause0]: Sized<T>,
{
    let @0: &'0 (T); // return
    let s@1: &'1 ([T; 32 : usize]); // arg #1
    let @2: &'0 (T); // anonymous local
    let @3: usize; // anonymous local
    let @4: &'_ ([T; 32 : usize]); // anonymous local
    let @5: &'_ (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &*(s@1)
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, T, 32 : usize>(move (@4), copy (@3))
    @2 := &*(@5)
    @0 := &*(@2)
    storage_dead(@3)
    storage_dead(@2)
    return
}

// Full name: test_crate::index_index_array
pub fn index_index_array(@1: [[u32; 32 : usize]; 32 : usize], @2: usize, @3: usize) -> u32
{
    let @0: u32; // return
    let s@1: [[u32; 32 : usize]; 32 : usize]; // arg #1
    let i@2: usize; // arg #2
    let j@3: usize; // arg #3
    let @4: usize; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ ([[u32; 32 : usize]; 32 : usize]); // anonymous local
    let @7: &'_ ([u32; 32 : usize]); // anonymous local
    let @8: &'_ ([u32; 32 : usize]); // anonymous local
    let @9: &'_ (u32); // anonymous local

    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := copy (j@3)
    storage_live(@6)
    @6 := &s@1
    storage_live(@7)
    @7 := @ArrayIndexShared<'_, [u32; 32 : usize], 32 : usize>(move (@6), copy (@4))
    storage_live(@8)
    @8 := &*(@7)
    storage_live(@9)
    @9 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@8), copy (@5))
    @0 := copy (*(@9))
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::update_update_array
pub fn update_update_array(@1: [[u32; 32 : usize]; 32 : usize], @2: usize, @3: usize)
{
    let @0: (); // return
    let s@1: [[u32; 32 : usize]; 32 : usize]; // arg #1
    let i@2: usize; // arg #2
    let j@3: usize; // arg #3
    let @4: usize; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut ([[u32; 32 : usize]; 32 : usize]); // anonymous local
    let @7: &'_ mut ([u32; 32 : usize]); // anonymous local
    let @8: &'_ mut ([u32; 32 : usize]); // anonymous local
    let @9: &'_ mut (u32); // anonymous local

    @0 := ()
    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := copy (j@3)
    storage_live(@6)
    @6 := &mut s@1
    storage_live(@7)
    @7 := @ArrayIndexMut<'_, [u32; 32 : usize], 32 : usize>(move (@6), copy (@4))
    storage_live(@8)
    @8 := &mut *(@7)
    storage_live(@9)
    @9 := @ArrayIndexMut<'_, u32, 32 : usize>(move (@8), copy (@5))
    *(@9) := const (0 : u32)
    storage_dead(@5)
    storage_dead(@4)
    @0 := ()
    return
}

// Full name: test_crate::incr_array_self
pub fn incr_array_self<'_0>(@1: &'_0 mut ([u32; 2 : usize]))
{
    let @0: (); // return
    let s@1: &'0 mut ([u32; 2 : usize]); // arg #1
    let @2: usize; // anonymous local
    let @3: u32; // anonymous local
    let @4: &'_ ([u32; 2 : usize]); // anonymous local
    let @5: &'_ (u32); // anonymous local
    let @6: &'_ mut ([u32; 2 : usize]); // anonymous local
    let @7: &'_ mut (u32); // anonymous local

    storage_live(@3)
    @0 := ()
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@4)
    @4 := &*(s@1)
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@4), copy (@2))
    @3 := copy (*(@5)) panic.+ const (1 : u32)
    storage_live(@6)
    @6 := &mut *(s@1)
    storage_live(@7)
    @7 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@6), copy (@2))
    *(@7) := move (@3)
    storage_dead(@2)
    @0 := ()
    return
}

// Full name: test_crate::incr_slice_self
pub fn incr_slice_self<'_0>(@1: &'_0 mut ([u32]))
{
    let @0: (); // return
    let s@1: &'0 mut ([u32]); // arg #1
    let @2: usize; // anonymous local
    let @3: u32; // anonymous local
    let @4: &'_ ([u32]); // anonymous local
    let @5: &'_ (u32); // anonymous local
    let @6: &'_ mut ([u32]); // anonymous local
    let @7: &'_ mut (u32); // anonymous local

    storage_live(@3)
    @0 := ()
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@4)
    @4 := &*(s@1) with_metadata(copy (s@1.metadata))
    storage_live(@5)
    @5 := @SliceIndexShared<'_, u32>(move (@4), copy (@2))
    @3 := copy (*(@5)) panic.+ const (1 : u32)
    storage_live(@6)
    @6 := &mut *(s@1) with_metadata(copy (s@1.metadata))
    storage_live(@7)
    @7 := @SliceIndexMut<'_, u32>(move (@6), copy (@2))
    *(@7) := move (@3)
    storage_dead(@2)
    @0 := ()
    return
}

// Full name: test_crate::array_local_deep_copy
pub fn array_local_deep_copy<'_0>(@1: &'_0 ([u32; 32 : usize]))
{
    let @0: (); // return
    let x@1: &'0 ([u32; 32 : usize]); // arg #1
    let _y@2: [u32; 32 : usize]; // local

    @0 := ()
    storage_live(_y@2)
    _y@2 := copy (*(x@1))
    @0 := ()
    storage_dead(_y@2)
    return
}

// Full name: test_crate::take_array
pub fn take_array(@1: [u32; 2 : usize])
{
    let @0: (); // return
    let @1: [u32; 2 : usize]; // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::take_array_borrow
pub fn take_array_borrow<'_0>(@1: &'_0 ([u32; 2 : usize]))
{
    let @0: (); // return
    let @1: &'0 ([u32; 2 : usize]); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::take_slice
pub fn take_slice<'_0>(@1: &'_0 ([u32]))
{
    let @0: (); // return
    let @1: &'0 ([u32]); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::take_mut_slice
pub fn take_mut_slice<'_0>(@1: &'_0 mut ([u32]))
{
    let @0: (); // return
    let @1: &'0 mut ([u32]); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::const_array
pub fn const_array() -> [u32; 2 : usize]
{
    let @0: [u32; 2 : usize]; // return

    @0 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    return
}

// Full name: test_crate::const_slice
pub fn const_slice()
{
    let @0: (); // return
    let @1: &'0 ([u32]); // anonymous local
    let @2: &'1 ([u32; 2 : usize]); // anonymous local
    let @3: &'1 ([u32; 2 : usize]); // anonymous local
    let @4: &'1 ([u32; 2 : usize]); // anonymous local
    let @5: &'_ ([u32; 2 : usize]); // anonymous local
    let @6: [u32; 2 : usize]; // anonymous local

    storage_live(@5)
    storage_live(@6)
    @6 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    @5 := &@6
    storage_live(@4)
    @0 := ()
    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    @4 := move (@5)
    @3 := &*(@4)
    @2 := &*(@3)
    @1 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@2))
    storage_dead(@2)
    storage_dead(@3)
    storage_dead(@1)
    @0 := ()
    return
}

// Full name: test_crate::take_all
pub fn take_all()
{
    let @0: (); // return
    let x@1: [u32; 2 : usize]; // local
    let @2: (); // anonymous local
    let @3: [u32; 2 : usize]; // anonymous local
    let @4: (); // anonymous local
    let @5: [u32; 2 : usize]; // anonymous local
    let @6: (); // anonymous local
    let @7: &'0 ([u32; 2 : usize]); // anonymous local
    let @8: &'0 ([u32; 2 : usize]); // anonymous local
    let @9: (); // anonymous local
    let @10: &'1 ([u32]); // anonymous local
    let @11: &'0 ([u32; 2 : usize]); // anonymous local
    let @12: &'0 ([u32; 2 : usize]); // anonymous local
    let @13: (); // anonymous local
    let @14: &'2 mut ([u32]); // anonymous local
    let @15: &'3 mut ([u32; 2 : usize]); // anonymous local
    let @16: &'3 mut ([u32; 2 : usize]); // anonymous local

    @0 := ()
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    // x is deep copied (copy node appears in Charon, followed by a move)
    @3 := copy (x@1)
    @2 := take_array(move (@3))
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (x@1)
    @4 := take_array(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    // x passed by address, there is a reborrow here
    @8 := &x@1
    @7 := &*(@8)
    @6 := take_array_borrow<'_>(move (@7))
    storage_dead(@7)
    storage_dead(@8)
    storage_dead(@6)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    // automatic cast from array to slice (spanning entire array)
    @12 := &x@1
    @11 := &*(@12)
    @10 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@11))
    storage_dead(@11)
    @9 := take_slice<'_>(move (@10))
    storage_dead(@10)
    storage_dead(@12)
    storage_dead(@9)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    // note that both appear as SliceNew expressions, meaning the SliceNew UnOp is overloaded for
    // mut and non-mut cases
    @16 := &mut x@1
    @15 := &mut *(@16)
    @14 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@15))
    storage_dead(@15)
    @13 := take_mut_slice<'_>(move (@14))
    storage_dead(@14)
    storage_dead(@16)
    storage_dead(@13)
    @0 := ()
    storage_dead(x@1)
    return
}

// Full name: test_crate::index_array
pub fn index_array(@1: [u32; 2 : usize]) -> u32
{
    let @0: u32; // return
    let x@1: [u32; 2 : usize]; // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ ([u32; 2 : usize]); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &x@1
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_array_borrow
pub fn index_array_borrow<'_0>(@1: &'_0 ([u32; 2 : usize])) -> u32
{
    let @0: u32; // return
    let x@1: &'0 ([u32; 2 : usize]); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ ([u32; 2 : usize]); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_slice_u32_0
pub fn index_slice_u32_0<'_0>(@1: &'_0 ([u32])) -> u32
{
    let @0: u32; // return
    let x@1: &'0 ([u32]); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ ([u32]); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1) with_metadata(copy (x@1.metadata))
    storage_live(@4)
    @4 := @SliceIndexShared<'_, u32>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_mut_slice_u32_0
pub fn index_mut_slice_u32_0<'_0>(@1: &'_0 mut ([u32])) -> u32
{
    let @0: u32; // return
    let x@1: &'0 mut ([u32]); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ ([u32]); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1) with_metadata(copy (x@1.metadata))
    storage_live(@4)
    @4 := @SliceIndexShared<'_, u32>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::index_all
pub fn index_all() -> u32
{
    let @0: u32; // return
    let x@1: [u32; 2 : usize]; // local
    let @2: bool; // anonymous local
    let _y@3: [u32; 2 : usize]; // local
    let _z@4: [u32; 1 : usize]; // local
    let @5: u32; // anonymous local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: [u32; 2 : usize]; // anonymous local
    let @10: u32; // anonymous local
    let @11: [u32; 2 : usize]; // anonymous local
    let @12: u32; // anonymous local
    let @13: u32; // anonymous local
    let @14: &'0 ([u32; 2 : usize]); // anonymous local
    let @15: &'0 ([u32; 2 : usize]); // anonymous local
    let @16: u32; // anonymous local
    let @17: u32; // anonymous local
    let @18: &'1 ([u32]); // anonymous local
    let @19: &'0 ([u32; 2 : usize]); // anonymous local
    let @20: &'0 ([u32; 2 : usize]); // anonymous local
    let @21: u32; // anonymous local
    let @22: u32; // anonymous local
    let @23: &'2 mut ([u32]); // anonymous local
    let @24: &'3 mut ([u32; 2 : usize]); // anonymous local
    let @25: &'3 mut ([u32; 2 : usize]); // anonymous local
    let @26: u32; // anonymous local

    storage_live(@12)
    storage_live(@16)
    storage_live(@21)
    storage_live(@26)
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    @2 := const (true)
    if move (@2) {
        storage_live(_y@3)
        _y@3 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
        storage_dead(_y@3)
    } else {
        storage_live(_z@4)
        _z@4 := [const (0 : u32)]
        storage_dead(_z@4)
    }
    storage_dead(@2)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    @9 := copy (x@1)
    @8 := index_array(move (@9))
    storage_dead(@9)
    storage_live(@10)
    storage_live(@11)
    @11 := copy (x@1)
    @10 := index_array(move (@11))
    storage_dead(@11)
    @12 := copy (@8) panic.+ copy (@10)
    @7 := move (@12)
    storage_dead(@10)
    storage_dead(@8)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    @15 := &x@1
    @14 := &*(@15)
    @13 := index_array_borrow<'_>(move (@14))
    storage_dead(@14)
    @16 := copy (@7) panic.+ copy (@13)
    @6 := move (@16)
    storage_dead(@13)
    storage_dead(@7)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    storage_live(@20)
    @20 := &x@1
    @19 := &*(@20)
    @18 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@19))
    storage_dead(@19)
    @17 := index_slice_u32_0<'_>(move (@18))
    storage_dead(@18)
    @21 := copy (@6) panic.+ copy (@17)
    @5 := move (@21)
    storage_dead(@17)
    storage_dead(@6)
    storage_live(@22)
    storage_live(@23)
    storage_live(@24)
    storage_live(@25)
    @25 := &mut x@1
    @24 := &mut *(@25)
    @23 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@24))
    storage_dead(@24)
    @22 := index_mut_slice_u32_0<'_>(move (@23))
    storage_dead(@23)
    @26 := copy (@5) panic.+ copy (@22)
    @0 := move (@26)
    storage_dead(@22)
    storage_dead(@5)
    storage_dead(x@1)
    storage_dead(@25)
    storage_dead(@20)
    storage_dead(@15)
    return
}

// Full name: test_crate::update_array
pub fn update_array(@1: [u32; 2 : usize])
{
    let @0: (); // return
    let x@1: [u32; 2 : usize]; // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut ([u32; 2 : usize]); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    @0 := ()
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut x@1
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    return
}

// Full name: test_crate::update_array_mut_borrow
pub fn update_array_mut_borrow<'_0>(@1: &'_0 mut ([u32; 2 : usize]))
{
    let @0: (); // return
    let x@1: &'0 mut ([u32; 2 : usize]); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut ([u32; 2 : usize]); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    @0 := ()
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut *(x@1)
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    return
}

// Full name: test_crate::update_mut_slice
pub fn update_mut_slice<'_0>(@1: &'_0 mut ([u32]))
{
    let @0: (); // return
    let x@1: &'0 mut ([u32]); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut ([u32]); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    @0 := ()
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut *(x@1) with_metadata(copy (x@1.metadata))
    storage_live(@4)
    @4 := @SliceIndexMut<'_, u32>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    return
}

// Full name: test_crate::update_all
pub fn update_all()
{
    let @0: (); // return
    let x@1: [u32; 2 : usize]; // local
    let @2: (); // anonymous local
    let @3: [u32; 2 : usize]; // anonymous local
    let @4: (); // anonymous local
    let @5: [u32; 2 : usize]; // anonymous local
    let @6: (); // anonymous local
    let @7: &'0 mut ([u32; 2 : usize]); // anonymous local
    let @8: &'0 mut ([u32; 2 : usize]); // anonymous local
    let @9: (); // anonymous local
    let @10: &'1 mut ([u32]); // anonymous local
    let @11: &'0 mut ([u32; 2 : usize]); // anonymous local
    let @12: &'0 mut ([u32; 2 : usize]); // anonymous local

    @0 := ()
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    @3 := copy (x@1)
    @2 := update_array(move (@3))
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (x@1)
    @4 := update_array(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := &mut x@1
    @7 := &two-phase-mut *(@8)
    @6 := update_array_mut_borrow<'_>(move (@7))
    storage_dead(@7)
    storage_dead(@8)
    storage_dead(@6)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := &mut x@1
    @11 := &mut *(@12)
    @10 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@11))
    storage_dead(@11)
    @9 := update_mut_slice<'_>(move (@10))
    storage_dead(@10)
    storage_dead(@12)
    storage_dead(@9)
    @0 := ()
    storage_dead(x@1)
    return
}

// Full name: test_crate::range_all
pub fn range_all()
{
    let @0: (); // return
    let x@1: [u32; 4 : usize]; // local
    let @2: (); // anonymous local
    let @3: &'0 mut ([u32]); // anonymous local
    let @4: &'0 mut ([u32]); // anonymous local
    let @5: &'0 mut ([u32]); // anonymous local
    let @6: &'1 mut ([u32; 4 : usize]); // anonymous local
    let @7: Range<usize>[{built_in impl Sized for usize}]; // anonymous local

    @0 := ()
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 4 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    // CONFIRM: there is no way to shrink [T;N] into [T;M] with M<N?
    @6 := &mut x@1
    storage_live(@7)
    @7 := Range { start: const (1 : usize), end: const (3 : usize) }
    @5 := {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32], 4 : usize>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl IndexMut<I, Clause2_Output> for [T]}<u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &mut *(@5) with_metadata(copy (@5.metadata))
    @3 := &two-phase-mut *(@4) with_metadata(copy (@4.metadata))
    @2 := update_mut_slice<'_>(move (@3))
    storage_dead(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@2)
    @0 := ()
    storage_dead(x@1)
    return
}

// Full name: test_crate::deref_array_borrow
pub fn deref_array_borrow<'_0>(@1: &'_0 ([u32; 2 : usize])) -> u32
{
    let @0: u32; // return
    let x@1: &'0 ([u32; 2 : usize]); // arg #1
    let x@2: [u32; 2 : usize]; // local
    let @3: usize; // anonymous local
    let @4: &'_ ([u32; 2 : usize]); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(x@2)
    x@2 := copy (*(x@1))
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &x@2
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(x@2)
    storage_dead(@3)
    return
}

// Full name: test_crate::deref_array_mut_borrow
pub fn deref_array_mut_borrow<'_0>(@1: &'_0 mut ([u32; 2 : usize])) -> u32
{
    let @0: u32; // return
    let x@1: &'0 mut ([u32; 2 : usize]); // arg #1
    let x@2: [u32; 2 : usize]; // local
    let @3: usize; // anonymous local
    let @4: &'_ ([u32; 2 : usize]); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(x@2)
    x@2 := copy (*(x@1))
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &x@2
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(x@2)
    storage_dead(@3)
    return
}

// Full name: test_crate::take_array_t
pub fn take_array_t(@1: [AB; 2 : usize])
{
    let @0: (); // return
    let @1: [AB; 2 : usize]; // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::non_copyable_array
pub fn non_copyable_array()
{
    let @0: (); // return
    let x@1: [AB; 2 : usize]; // local
    let @2: AB; // anonymous local
    let @3: AB; // anonymous local
    let @4: (); // anonymous local
    let @5: [AB; 2 : usize]; // anonymous local

    @0 := ()
    storage_live(x@1)
    storage_live(@2)
    @2 := AB::A {  }
    storage_live(@3)
    @3 := AB::B {  }
    x@1 := [move (@2), move (@3)]
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    // x is moved (not deep copied!)
    // TODO: determine whether the translation needs to be aware of that and pass by ref instead of by copy
    @5 := move (x@1)
    @4 := take_array_t(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    @0 := ()
    // this fails, naturally:
    // take_array_t(x);
    storage_dead(x@1)
    return
}

// Full name: test_crate::sum
pub fn sum<'_0>(@1: &'_0 ([u32])) -> u32
{
    let @0: u32; // return
    let s@1: &'0 ([u32]); // arg #1
    let sum@2: u32; // local
    let i@3: usize; // local
    let @4: bool; // anonymous local
    let @5: usize; // anonymous local
    let @6: usize; // anonymous local
    let @7: &'0 ([u32]); // anonymous local
    let @8: u32; // anonymous local
    let @9: usize; // anonymous local
    let @10: u32; // anonymous local
    let @11: usize; // anonymous local
    let @12: &'_ ([u32]); // anonymous local
    let @13: &'_ (u32); // anonymous local

    storage_live(@10)
    storage_live(@11)
    storage_live(sum@2)
    sum@2 := const (0 : u32)
    storage_live(i@3)
    i@3 := const (0 : usize)
    loop {
        storage_live(@4)
        storage_live(@5)
        @5 := copy (i@3)
        storage_live(@6)
        storage_live(@7)
        @7 := &*(s@1) with_metadata(copy (s@1.metadata))
        @6 := len<'_, u32>[{built_in impl Sized for u32}](move (@7))
        storage_dead(@7)
        @4 := move (@5) < move (@6)
        if move (@4) {
        } else {
            break 0
        }
        storage_dead(@6)
        storage_dead(@5)
        storage_live(@8)
        storage_live(@9)
        @9 := copy (i@3)
        storage_live(@12)
        @12 := &*(s@1) with_metadata(copy (s@1.metadata))
        storage_live(@13)
        @13 := @SliceIndexShared<'_, u32>(move (@12), copy (@9))
        @8 := copy (*(@13))
        @10 := copy (sum@2) panic.+ copy (@8)
        sum@2 := move (@10)
        storage_dead(@8)
        storage_dead(@9)
        @11 := copy (i@3) panic.+ const (1 : usize)
        i@3 := move (@11)
        storage_dead(@4)
        continue 0
    }
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    @0 := copy (sum@2)
    storage_dead(i@3)
    storage_dead(sum@2)
    return
}

// Full name: test_crate::sum2
pub fn sum2<'_0, '_1>(@1: &'_0 ([u32]), @2: &'_1 ([u32])) -> u32
{
    let @0: u32; // return
    let s@1: &'0 ([u32]); // arg #1
    let s2@2: &'0 ([u32]); // arg #2
    let sum@3: u32; // local
    let @4: bool; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'0 ([u32]); // anonymous local
    let @7: usize; // anonymous local
    let @8: &'0 ([u32]); // anonymous local
    let i@9: usize; // local
    let @10: bool; // anonymous local
    let @11: usize; // anonymous local
    let @12: usize; // anonymous local
    let @13: &'0 ([u32]); // anonymous local
    let @14: u32; // anonymous local
    let @15: u32; // anonymous local
    let @16: usize; // anonymous local
    let @17: u32; // anonymous local
    let @18: usize; // anonymous local
    let @19: u32; // anonymous local
    let @20: u32; // anonymous local
    let @21: usize; // anonymous local
    let @22: &'_ ([u32]); // anonymous local
    let @23: &'_ (u32); // anonymous local
    let @24: &'_ ([u32]); // anonymous local
    let @25: &'_ (u32); // anonymous local

    storage_live(@19)
    storage_live(@20)
    storage_live(@21)
    storage_live(sum@3)
    sum@3 := const (0 : u32)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(s@1) with_metadata(copy (s@1.metadata))
    @5 := len<'_, u32>[{built_in impl Sized for u32}](move (@6))
    storage_dead(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := &*(s2@2) with_metadata(copy (s2@2.metadata))
    @7 := len<'_, u32>[{built_in impl Sized for u32}](move (@8))
    storage_dead(@8)
    @4 := move (@5) == move (@7)
    if move (@4) {
    } else {
        storage_dead(@7)
        storage_dead(@5)
        panic(core::panicking::panic)
    }
    storage_dead(@7)
    storage_dead(@5)
    storage_dead(@4)
    storage_live(i@9)
    i@9 := const (0 : usize)
    loop {
        storage_live(@10)
        storage_live(@11)
        @11 := copy (i@9)
        storage_live(@12)
        storage_live(@13)
        @13 := &*(s@1) with_metadata(copy (s@1.metadata))
        @12 := len<'_, u32>[{built_in impl Sized for u32}](move (@13))
        storage_dead(@13)
        @10 := move (@11) < move (@12)
        if move (@10) {
        } else {
            break 0
        }
        storage_dead(@12)
        storage_dead(@11)
        storage_live(@14)
        storage_live(@15)
        storage_live(@16)
        @16 := copy (i@9)
        storage_live(@22)
        @22 := &*(s@1) with_metadata(copy (s@1.metadata))
        storage_live(@23)
        @23 := @SliceIndexShared<'_, u32>(move (@22), copy (@16))
        @15 := copy (*(@23))
        storage_live(@17)
        storage_live(@18)
        @18 := copy (i@9)
        storage_live(@24)
        @24 := &*(s2@2) with_metadata(copy (s2@2.metadata))
        storage_live(@25)
        @25 := @SliceIndexShared<'_, u32>(move (@24), copy (@18))
        @17 := copy (*(@25))
        @19 := copy (@15) panic.+ copy (@17)
        @14 := move (@19)
        storage_dead(@17)
        storage_dead(@15)
        @20 := copy (sum@3) panic.+ copy (@14)
        sum@3 := move (@20)
        storage_dead(@14)
        storage_dead(@18)
        storage_dead(@16)
        @21 := copy (i@9) panic.+ const (1 : usize)
        i@9 := move (@21)
        storage_dead(@10)
        continue 0
    }
    storage_dead(@12)
    storage_dead(@11)
    storage_dead(@10)
    @0 := copy (sum@3)
    storage_dead(i@9)
    storage_dead(sum@3)
    return
}

// Full name: test_crate::f0
pub fn f0()
{
    let @0: (); // return
    let s@1: &'0 mut ([u32]); // local
    let @2: &'1 mut ([u32; 2 : usize]); // anonymous local
    let @3: &'1 mut ([u32; 2 : usize]); // anonymous local
    let @4: [u32; 2 : usize]; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut ([u32]); // anonymous local
    let @7: &'_ mut (u32); // anonymous local

    @0 := ()
    storage_live(s@1)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := [const (1 : u32), const (2 : u32)]
    @3 := &mut @4
    @2 := &mut *(@3)
    s@1 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@2))
    storage_dead(@2)
    storage_dead(@3)
    storage_live(@5)
    @5 := const (0 : usize)
    storage_live(@6)
    @6 := &mut *(s@1) with_metadata(copy (s@1.metadata))
    storage_live(@7)
    @7 := @SliceIndexMut<'_, u32>(move (@6), copy (@5))
    *(@7) := const (1 : u32)
    storage_dead(@5)
    @0 := ()
    storage_dead(@4)
    storage_dead(s@1)
    return
}

// Full name: test_crate::f1
pub fn f1()
{
    let @0: (); // return
    let s@1: [u32; 2 : usize]; // local
    let @2: usize; // anonymous local
    let @3: &'_ mut ([u32; 2 : usize]); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    @0 := ()
    storage_live(s@1)
    s@1 := [const (1 : u32), const (2 : u32)]
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut s@1
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    storage_dead(@2)
    @0 := ()
    storage_dead(s@1)
    return
}

// Full name: test_crate::f2
pub fn f2(@1: u32)
{
    let @0: (); // return
    let @1: u32; // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::f4
pub fn f4<'_0>(@1: &'_0 ([u32; 32 : usize]), @2: usize, @3: usize) -> &'_0 ([u32])
{
    let @0: &'0 ([u32]); // return
    let x@1: &'1 ([u32; 32 : usize]); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'0 ([u32]); // anonymous local
    let @5: &'0 ([u32]); // anonymous local
    let @6: &'1 ([u32; 32 : usize]); // anonymous local
    let @7: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := {impl Index<I, Clause2_Output> for [T; N]}::index<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32], 32 : usize>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl Index<I, Clause2_Output> for [T]}<u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5) with_metadata(copy (@5.metadata))
    @0 := &*(@4) with_metadata(copy (@4.metadata))
    storage_dead(@5)
    storage_dead(@4)
    return
}

// Full name: test_crate::f3
pub fn f3() -> u32
{
    let @0: u32; // return
    let a@1: [u32; 2 : usize]; // local
    let @2: (); // anonymous local
    let @3: u32; // anonymous local
    let @4: usize; // anonymous local
    let b@5: [u32; 32 : usize]; // local
    let @6: &'0 ([u32]); // anonymous local
    let @7: &'1 ([u32; 2 : usize]); // anonymous local
    let @8: &'1 ([u32; 2 : usize]); // anonymous local
    let @9: &'0 ([u32]); // anonymous local
    let @10: &'0 ([u32]); // anonymous local
    let @11: &'2 ([u32; 32 : usize]); // anonymous local
    let @12: &'2 ([u32; 32 : usize]); // anonymous local
    let @13: &'_ ([u32; 2 : usize]); // anonymous local
    let @14: &'_ (u32); // anonymous local

    storage_live(a@1)
    a@1 := [const (1 : u32), const (2 : u32)]
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := const (0 : usize)
    storage_live(@13)
    @13 := &a@1
    storage_live(@14)
    @14 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@13), copy (@4))
    @3 := copy (*(@14))
    @2 := f2(move (@3))
    storage_dead(@3)
    storage_dead(@4)
    storage_dead(@2)
    storage_live(b@5)
    b@5 := @ArrayRepeat<'_, u32, 32 : usize>(const (0 : u32))
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := &a@1
    @7 := &*(@8)
    @6 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@7))
    storage_dead(@7)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := &b@5
    @11 := &*(@12)
    @10 := f4<'_>(move (@11), const (16 : usize), const (18 : usize))
    @9 := &*(@10) with_metadata(copy (@10.metadata))
    storage_dead(@11)
    @0 := sum2<'_, '_>(move (@6), move (@9))
    storage_dead(@9)
    storage_dead(@6)
    storage_dead(b@5)
    storage_dead(a@1)
    storage_dead(@12)
    storage_dead(@10)
    storage_dead(@8)
    return
}

// Full name: test_crate::SZ
pub fn SZ() -> usize
{
    let @0: usize; // return

    @0 := const (32 : usize)
    return
}

// Full name: test_crate::SZ
pub const SZ: usize = SZ()

// Full name: test_crate::f5
pub fn f5<'_0>(@1: &'_0 ([u32; 32 : usize])) -> u32
{
    let @0: u32; // return
    let x@1: &'0 ([u32; 32 : usize]); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ ([u32; 32 : usize]); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

// Full name: test_crate::ite
pub fn ite()
{
    let @0: (); // return
    let x@1: [u32; 2 : usize]; // local
    let @2: bool; // anonymous local
    let y@3: [u32; 2 : usize]; // local
    let @4: u32; // anonymous local
    let @5: &'0 mut ([u32]); // anonymous local
    let @6: &'1 mut ([u32; 2 : usize]); // anonymous local
    let @7: &'1 mut ([u32; 2 : usize]); // anonymous local
    let @8: u32; // anonymous local
    let @9: &'0 mut ([u32]); // anonymous local
    let @10: &'1 mut ([u32; 2 : usize]); // anonymous local
    let @11: &'1 mut ([u32; 2 : usize]); // anonymous local

    @0 := ()
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    @2 := const (true)
    if move (@2) {
        storage_live(y@3)
        y@3 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
        storage_live(@4)
        storage_live(@5)
        storage_live(@6)
        storage_live(@7)
        @7 := &mut x@1
        @6 := &mut *(@7)
        @5 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@6))
        storage_dead(@6)
        @4 := index_mut_slice_u32_0<'_>(move (@5))
        storage_dead(@5)
        storage_dead(@7)
        storage_dead(@4)
        storage_live(@8)
        storage_live(@9)
        storage_live(@10)
        storage_live(@11)
        @11 := &mut y@3
        @10 := &mut *(@11)
        @9 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@10))
        storage_dead(@10)
        @8 := index_mut_slice_u32_0<'_>(move (@9))
        storage_dead(@9)
        storage_dead(@11)
        storage_dead(@8)
        @0 := ()
        storage_dead(y@3)
    } else {
        @0 := ()
    }
    storage_dead(@2)
    storage_dead(x@1)
    return
}

// Full name: test_crate::zero_slice
pub fn zero_slice<'_0>(@1: &'_0 mut ([u8]))
{
    let @0: (); // return
    let a@1: &'0 mut ([u8]); // arg #1
    let i@2: usize; // local
    let len@3: usize; // local
    let @4: &'1 ([u8]); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local
    let @10: &'_ mut ([u8]); // anonymous local
    let @11: &'_ mut (u8); // anonymous local

    storage_live(@9)
    @0 := ()
    storage_live(i@2)
    i@2 := const (0 : usize)
    storage_live(len@3)
    storage_live(@4)
    @4 := &*(a@1) with_metadata(copy (a@1.metadata))
    len@3 := len<'_, u8>[{built_in impl Sized for u8}](move (@4))
    storage_dead(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        @7 := copy (len@3)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@8)
            @8 := copy (i@2)
            storage_live(@10)
            @10 := &mut *(a@1) with_metadata(copy (a@1.metadata))
            storage_live(@11)
            @11 := @SliceIndexMut<'_, u8>(move (@10), copy (@8))
            *(@11) := const (0 : u8)
            storage_dead(@8)
            @9 := copy (i@2) panic.+ const (1 : usize)
            i@2 := move (@9)
            storage_dead(@5)
            continue 0
        } else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    @0 := ()
    storage_dead(@5)
    storage_dead(len@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::iter_mut_slice
pub fn iter_mut_slice<'_0>(@1: &'_0 mut ([u8]))
{
    let @0: (); // return
    let a@1: &'0 mut ([u8]); // arg #1
    let len@2: usize; // local
    let @3: &'1 ([u8]); // anonymous local
    let i@4: usize; // local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: usize; // anonymous local

    storage_live(@8)
    @0 := ()
    storage_live(len@2)
    storage_live(@3)
    @3 := &*(a@1) with_metadata(copy (a@1.metadata))
    len@2 := len<'_, u8>[{built_in impl Sized for u8}](move (@3))
    storage_dead(@3)
    storage_live(i@4)
    i@4 := const (0 : usize)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@4)
        storage_live(@7)
        @7 := copy (len@2)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            @8 := copy (i@4) panic.+ const (1 : usize)
            i@4 := move (@8)
            storage_dead(@5)
            continue 0
        } else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    @0 := ()
    storage_dead(@5)
    storage_dead(i@4)
    storage_dead(len@2)
    return
}

// Full name: test_crate::sum_mut_slice
pub fn sum_mut_slice<'_0>(@1: &'_0 mut ([u32])) -> u32
{
    let @0: u32; // return
    let a@1: &'0 mut ([u32]); // arg #1
    let i@2: usize; // local
    let s@3: u32; // local
    let @4: bool; // anonymous local
    let @5: usize; // anonymous local
    let @6: usize; // anonymous local
    let @7: &'1 ([u32]); // anonymous local
    let @8: u32; // anonymous local
    let @9: usize; // anonymous local
    let @10: u32; // anonymous local
    let @11: usize; // anonymous local
    let @12: &'_ ([u32]); // anonymous local
    let @13: &'_ (u32); // anonymous local

    storage_live(@10)
    storage_live(@11)
    storage_live(i@2)
    i@2 := const (0 : usize)
    storage_live(s@3)
    s@3 := const (0 : u32)
    loop {
        storage_live(@4)
        storage_live(@5)
        @5 := copy (i@2)
        storage_live(@6)
        storage_live(@7)
        @7 := &*(a@1) with_metadata(copy (a@1.metadata))
        @6 := len<'_, u32>[{built_in impl Sized for u32}](move (@7))
        storage_dead(@7)
        @4 := move (@5) < move (@6)
        if move (@4) {
        } else {
            break 0
        }
        storage_dead(@6)
        storage_dead(@5)
        storage_live(@8)
        storage_live(@9)
        @9 := copy (i@2)
        storage_live(@12)
        @12 := &*(a@1) with_metadata(copy (a@1.metadata))
        storage_live(@13)
        @13 := @SliceIndexShared<'_, u32>(move (@12), copy (@9))
        @8 := copy (*(@13))
        @10 := copy (s@3) panic.+ copy (@8)
        s@3 := move (@10)
        storage_dead(@8)
        storage_dead(@9)
        @11 := copy (i@2) panic.+ const (1 : usize)
        i@2 := move (@11)
        storage_dead(@4)
        continue 0
    }
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

// Full name: test_crate::slice_pattern_1
fn slice_pattern_1(@1: [(); 1 : usize])
{
    let @0: (); // return
    let x@1: [(); 1 : usize]; // arg #1
    let _named@2: (); // local
    let @3: &'_ ([(); 1 : usize]); // anonymous local
    let @4: &'_ (()); // anonymous local

    @0 := ()
    storage_live(_named@2)
    storage_live(@3)
    @3 := &x@1
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, (), 1 : usize>(move (@3), const (0 : usize))
    _named@2 := copy (*(@4))
    @0 := ()
    storage_dead(_named@2)
    return
}

// Full name: test_crate::slice_pattern_2
fn slice_pattern_2<'_0, T>(@1: [&'_0 mut (T); 3 : usize])
where
    [@TraitClause0]: Sized<T>,
{
    let @0: (); // return
    let x@1: [&'0 mut (T); 3 : usize]; // arg #1
    let _a@2: &'0 mut (T); // local
    let _b@3: &'0 mut (T); // local
    let _c@4: &'0 mut (T); // local
    let @5: &'_ mut ([&'0 mut (T); 3 : usize]); // anonymous local
    let @6: &'_ mut (&'0 mut (T)); // anonymous local
    let @7: &'_ mut ([&'0 mut (T); 3 : usize]); // anonymous local
    let @8: &'_ mut (&'0 mut (T)); // anonymous local
    let @9: &'_ mut ([&'0 mut (T); 3 : usize]); // anonymous local
    let @10: &'_ mut (&'0 mut (T)); // anonymous local

    @0 := ()
    storage_live(_a@2)
    storage_live(@5)
    @5 := &mut x@1
    storage_live(@6)
    @6 := @ArrayIndexMut<'_, &'0 mut (T), 3 : usize>(move (@5), const (0 : usize))
    _a@2 := move (*(@6))
    storage_live(_b@3)
    storage_live(@7)
    @7 := &mut x@1
    storage_live(@8)
    @8 := @ArrayIndexMut<'_, &'0 mut (T), 3 : usize>(move (@7), const (1 : usize))
    _b@3 := move (*(@8))
    storage_live(_c@4)
    storage_live(@9)
    @9 := &mut x@1
    storage_live(@10)
    @10 := @ArrayIndexMut<'_, &'0 mut (T), 3 : usize>(move (@9), const (2 : usize))
    _c@4 := move (*(@10))
    @0 := ()
    storage_dead(_c@4)
    storage_dead(_b@3)
    storage_dead(_a@2)
    return
}

// Full name: test_crate::slice_pattern_3
fn slice_pattern_3<'_0>(@1: &'_0 ([(); 1 : usize]))
{
    let @0: (); // return
    let x@1: &'0 ([(); 1 : usize]); // arg #1
    let _named@2: &'1 (()); // local
    let @3: &'_ ([(); 1 : usize]); // anonymous local
    let @4: &'_ (()); // anonymous local

    @0 := ()
    storage_live(_named@2)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, (), 1 : usize>(move (@3), const (0 : usize))
    _named@2 := &*(@4)
    @0 := ()
    storage_dead(_named@2)
    return
}

// Full name: test_crate::slice_pattern_4
fn slice_pattern_4<'_0>(@1: &'_0 ([()]))
{
    let @0: (); // return
    let x@1: &'0 ([()]); // arg #1
    let @2: usize; // anonymous local
    let @3: usize; // anonymous local
    let @4: usize; // anonymous local
    let @5: bool; // anonymous local
    let _named@6: &'1 (()); // local
    let @7: &'_ ([()]); // anonymous local
    let @8: &'_ (()); // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @0 := ()
    @3 := copy (x@1.metadata)
    @2 := move (@3)
    @4 := const (1 : usize)
    @5 := move (@2) == move (@4)
    if move (@5) {
    } else {
        @0 := ()
        return
    }
    storage_live(_named@6)
    storage_live(@7)
    @7 := &*(x@1) with_metadata(copy (x@1.metadata))
    storage_live(@8)
    @8 := @SliceIndexShared<'_, ()>(move (@7), const (0 : usize))
    _named@6 := &*(@8)
    @0 := ()
    storage_dead(_named@6)
    return
}



