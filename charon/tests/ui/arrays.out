# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::ops::index::Index
#[lang_item("index")]
pub trait Index<Self, Idx, Self_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: MetaSized<Idx>
    parent_clause2 : [@TraitClause2]: MetaSized<Self_Output>
    fn index<'_0_1> = core::ops::index::Index::index<'_0_1, Self, Idx, Self_Output>[Self]
    vtable: core::ops::index::Index::{vtable}<Idx, Self_Output>
}

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::array::{impl Index<I, Clause2_Output> for [T; N]}::index
pub fn {impl Index<I, Clause2_Output> for [T; N]}::index<'_0, T, I, Clause2_Output, const N : usize>(@1: &'_0 [T; N], @2: I) -> &'_0 Clause2_Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Index<[T], I, Clause2_Output>,
= <opaque>

// Full name: core::array::{impl Index<I, Clause2_Output> for [T; N]}
impl<T, I, Clause2_Output, const N : usize> Index<I, Clause2_Output> for [T; N]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Index<[T], I, Clause2_Output>,
{
    parent_clause0 = {built_in impl MetaSized for [T; N]}
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause2
    fn index<'_0_1> = {impl Index<I, Clause2_Output> for [T; N]}::index<'_0_1, T, I, Clause2_Output, N>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl Index<I, Clause2_Output> for [T; N]}::{vtable}<T, I, N>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::ops::index::IndexMut
#[lang_item("index_mut")]
pub trait IndexMut<Self, Idx, Self_Clause1_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Index<Self, Idx, Self_Clause1_Output>
    parent_clause2 : [@TraitClause2]: MetaSized<Idx>
    fn index_mut<'_0_1> = core::ops::index::IndexMut::index_mut<'_0_1, Self, Idx, Self_Clause1_Output>[Self]
    vtable: core::ops::index::IndexMut::{vtable}<Idx, Self_Clause1_Output>
}

// Full name: core::array::{impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut
pub fn {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut<'_0, T, I, Clause2_Clause1_Output, const N : usize>(@1: &'_0 mut [T; N], @2: I) -> &'_0 mut Clause2_Clause1_Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: IndexMut<[T], I, Clause2_Clause1_Output>,
= <opaque>

// Full name: core::array::{impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}
impl<T, I, Clause2_Clause1_Output, const N : usize> IndexMut<I, Clause2_Clause1_Output> for [T; N]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: IndexMut<[T], I, Clause2_Clause1_Output>,
{
    parent_clause0 = {built_in impl MetaSized for [T; N]}
    parent_clause1 = {impl Index<I, Clause2_Output> for [T; N]}<T, I, Clause2_Clause1_Output, N>[@TraitClause0, @TraitClause1, @TraitClause2::parent_clause1]
    parent_clause2 = @TraitClause1::parent_clause0
    fn index_mut<'_0_1> = {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut<'_0_1, T, I, Clause2_Clause1_Output, N>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::{vtable}<T, I, N>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

pub fn core::ops::index::Index::index<'_0, Self, Idx, Clause0_Output>(@1: &'_0 Self, @2: Idx) -> &'_0 Clause0_Output
where
    [@TraitClause0]: Index<Self, Idx, Clause0_Output>,
= <opaque>

pub fn core::ops::index::IndexMut::index_mut<'_0, Self, Idx, Clause0_Clause1_Output>(@1: &'_0 mut Self, @2: Idx) -> &'_0 mut Clause0_Clause1_Output
where
    [@TraitClause0]: IndexMut<Self, Idx, Clause0_Clause1_Output>,
= <opaque>

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::slice::index::private_slice_index::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::slice::index::private_slice_index::Sealed::{vtable}
}

// Full name: core::slice::index::SliceIndex
#[lang_item("SliceIndex")]
pub trait SliceIndex<Self, T, Self_Output>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sealed<Self>
    parent_clause2 : [@TraitClause2]: MetaSized<T>
    parent_clause3 : [@TraitClause3]: MetaSized<Self_Output>
    fn get<'_0_1> = core::slice::index::SliceIndex::get<'_0_1, Self, T, Self_Output>[Self]
    fn get_mut<'_0_1> = core::slice::index::SliceIndex::get_mut<'_0_1, Self, T, Self_Output>[Self]
    fn get_unchecked = core::slice::index::SliceIndex::get_unchecked<Self, T, Self_Output>[Self]
    fn get_unchecked_mut = core::slice::index::SliceIndex::get_unchecked_mut<Self, T, Self_Output>[Self]
    fn index<'_0_1> = core::slice::index::SliceIndex::index<'_0_1, Self, T, Self_Output>[Self]
    fn index_mut<'_0_1> = core::slice::index::SliceIndex::index_mut<'_0_1, Self, T, Self_Output>[Self]
    vtable: core::slice::index::SliceIndex::{vtable}<T, Self_Output>
}

// Full name: core::slice::index::{impl Index<I, Clause2_Output> for [T]}::index
pub fn {impl Index<I, Clause2_Output> for [T]}::index<'_0, T, I, Clause2_Output>(@1: &'_0 [T], @2: I) -> &'_0 Clause2_Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T], Clause2_Output>,
= <opaque>

// Full name: core::slice::index::{impl Index<I, Clause2_Output> for [T]}
impl<T, I, Clause2_Output> Index<I, Clause2_Output> for [T]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T], Clause2_Output>,
{
    parent_clause0 = {built_in impl MetaSized for [T]}
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause3
    fn index<'_0_1> = {impl Index<I, Clause2_Output> for [T]}::index<'_0_1, T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl Index<I, Clause2_Output> for [T]}::{vtable}<T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::slice::index::{impl IndexMut<I, Clause2_Output> for [T]}::index_mut
pub fn {impl IndexMut<I, Clause2_Output> for [T]}::index_mut<'_0, T, I, Clause2_Output>(@1: &'_0 mut [T], @2: I) -> &'_0 mut Clause2_Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T], Clause2_Output>,
= <opaque>

// Full name: core::slice::index::{impl IndexMut<I, Clause2_Output> for [T]}
impl<T, I, Clause2_Output> IndexMut<I, Clause2_Output> for [T]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T], Clause2_Output>,
{
    parent_clause0 = {built_in impl MetaSized for [T]}
    parent_clause1 = {impl Index<I, Clause2_Output> for [T]}<T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    parent_clause2 = @TraitClause1::parent_clause0
    fn index_mut<'_0_1> = {impl IndexMut<I, Clause2_Output> for [T]}::index_mut<'_0_1, T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl IndexMut<I, Clause2_Output> for [T]}::{vtable}<T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::slice::index::private_slice_index::{impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
impl Sealed for Range<usize>[{built_in impl Sized for usize}] {
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    vtable: {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}::{vtable}
}

pub fn core::slice::index::SliceIndex::get<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 T) -> Option<&'_0 Clause0_Output>[{built_in impl Sized for &'_0 Clause0_Output}]
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub fn core::slice::index::SliceIndex::get_mut<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 mut T) -> Option<&'_0 mut Clause0_Output>[{built_in impl Sized for &'_0 mut Clause0_Output}]
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T, Clause0_Output>(@1: Self, @2: *const T) -> *const Clause0_Output
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T, Clause0_Output>(@1: Self, @2: *mut T) -> *mut Clause0_Output
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub fn core::slice::index::SliceIndex::index<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 T) -> &'_0 Clause0_Output
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

pub fn core::slice::index::SliceIndex::index_mut<'_0, Self, T, Clause0_Output>(@1: Self, @2: &'_0 mut T) -> &'_0 mut Clause0_Output
where
    [@TraitClause0]: SliceIndex<Self, T, Clause0_Output>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get
pub fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> Option<&'_0 [T]>[{built_in impl Sized for &'_0 [T]}]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut
pub fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> Option<&'_0 mut [T]>[{built_in impl Sized for &'_0 mut [T]}]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked
pub unsafe fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *const [T]) -> *const [T]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut
pub unsafe fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *mut [T]) -> *mut [T]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index
pub fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> &'_0 [T]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut
pub fn {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> &'_0 mut [T]
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::slice::index::{impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}
impl<T> SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause1 = {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause2 = {built_in impl MetaSized for [T]}
    parent_clause3 = {built_in impl MetaSized for [T]}
    fn get<'_0_1> = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0_1, T>[@TraitClause0]
    fn get_mut<'_0_1> = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0_1, T>[@TraitClause0]
    fn get_unchecked = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0_1> = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0_1, T>[@TraitClause0]
    fn index_mut<'_0_1> = {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0_1, T>[@TraitClause0]
    vtable: {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}::{vtable}<T>[@TraitClause0]
}

// Full name: core::slice::{[T]}::len
#[lang_item("slice_len_fn")]
pub fn len<'_0, T>(@1: &'_0 [T]) -> usize
where
    [@TraitClause0]: Sized<T>,
= <opaque>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::<array>::{impl Destruct for [T; N]}::drop_in_place
unsafe fn {impl Destruct for [T; N]}::drop_in_place<T, const N : usize>(@1: *mut [T; N])
where
    [@TraitClause0]: Sized<T>,
{
    let _0: (); // return
    let _1: *mut [T; N]; // arg #1
    let _2: &'0 mut [T; N]; // anonymous local
    let _3: *mut [T; N]; // anonymous local
    let _4: *mut [T]; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: *mut T; // anonymous local
    let _8: bool; // anonymous local
    let _9: &'_ mut [T]; // anonymous local
    let _10: &'_ mut T; // anonymous local

    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    _0 = ()
    _2 = &mut *(_1)
    _3 = &raw mut *(_2)
    _4 = unsize_cast<*mut [T; N], *mut [T], N>(move (_3))
    _5 = copy (_4.metadata)
    _6 = const (0 : usize)
    loop {
        _8 = copy (_6) == copy (_5)
        if move (_8) {
            break 0
        } else {
            storage_live(_9)
            _9 = &mut *(_4) with_metadata(copy (_4.metadata))
            storage_live(_10)
            _10 = @SliceIndexMut<'_, T>(move (_9), copy (_6))
            _7 = &raw mut *(_10)
            _6 = move (_6) wrap.+ const (1 : usize)
            drop[{built_in impl Destruct for T}] *(_7)
            continue 0
        }
    }
    return
}

// Full name: test_crate::<array>::{impl Destruct for [T; N]}
impl<T, const N : usize> Destruct for [T; N]
where
    [@TraitClause0]: Sized<T>,
{
    fn drop_in_place = {impl Destruct for [T; N]}::drop_in_place<T, N>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::AB
pub enum AB {
  A,
  B,
}

// Full name: test_crate::incr
pub fn incr<'_0>(@1: &'_0 mut u32)
{
    let _0: (); // return
    let x_1: &'0 mut u32; // arg #1
    let _2: u32; // anonymous local

    storage_live(_2)
    _0 = ()
    _2 = copy (*(x_1)) panic.+ const (1 : u32)
    *(x_1) = move (_2)
    _0 = ()
    return
}

// Full name: test_crate::array_to_shared_slice_
pub fn array_to_shared_slice_<'_0, T>(@1: &'_0 [T; 32 : usize]) -> &'_0 [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 [T]; // return
    let s_1: &'1 [T; 32 : usize]; // arg #1
    let _2: &'1 [T; 32 : usize]; // anonymous local

    storage_live(_2)
    _2 = &*(s_1)
    _0 = @ArrayToSliceShared<'_, T, 32 : usize>(move (_2))
    storage_dead(_2)
    return
}

// Full name: test_crate::array_to_mut_slice_
pub fn array_to_mut_slice_<'_0, T>(@1: &'_0 mut [T; 32 : usize]) -> &'_0 mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut [T]; // return
    let s_1: &'1 mut [T; 32 : usize]; // arg #1
    let _2: &'0 mut [T]; // anonymous local
    let _3: &'1 mut [T; 32 : usize]; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = &mut *(s_1)
    _2 = @ArrayToSliceMut<'_, T, 32 : usize>(move (_3))
    storage_dead(_3)
    _0 = &mut *(_2) with_metadata(copy (_2.metadata))
    storage_dead(_2)
    return
}

// Full name: test_crate::array_len
pub fn array_len<T>(@1: [T; 32 : usize]) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return
    let s_1: [T; 32 : usize]; // arg #1
    let _2: &'0 [T]; // anonymous local
    let _3: &'1 [T; 32 : usize]; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = &s_1
    _2 = @ArrayToSliceShared<'_, T, 32 : usize>(move (_3))
    storage_dead(_3)
    _0 = len<'_, T>[@TraitClause0](move (_2))
    storage_dead(_2)
    conditional_drop[{impl Destruct for [T; N]}<T, 32 : usize>[@TraitClause0]] s_1
    return
}

// Full name: test_crate::shared_array_len
pub fn shared_array_len<'_0, T>(@1: &'_0 [T; 32 : usize]) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return
    let s_1: &'0 [T; 32 : usize]; // arg #1
    let _2: &'1 [T]; // anonymous local
    let _3: &'0 [T; 32 : usize]; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = &*(s_1)
    _2 = @ArrayToSliceShared<'_, T, 32 : usize>(move (_3))
    storage_dead(_3)
    _0 = len<'_, T>[@TraitClause0](move (_2))
    storage_dead(_2)
    return
}

// Full name: test_crate::shared_slice_len
pub fn shared_slice_len<'_0, T>(@1: &'_0 [T]) -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return
    let s_1: &'0 [T]; // arg #1
    let _2: &'0 [T]; // anonymous local

    storage_live(_2)
    _2 = &*(s_1) with_metadata(copy (s_1.metadata))
    _0 = len<'_, T>[@TraitClause0](move (_2))
    storage_dead(_2)
    return
}

// Full name: test_crate::index_array_shared
pub fn index_array_shared<'_0, T>(@1: &'_0 [T; 32 : usize], @2: usize) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 T; // return
    let s_1: &'1 [T; 32 : usize]; // arg #1
    let i_2: usize; // arg #2
    let _3: &'0 T; // anonymous local
    let _4: usize; // anonymous local
    let _5: &'_ [T; 32 : usize]; // anonymous local
    let _6: &'_ T; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy (i_2)
    storage_live(_5)
    _5 = &*(s_1)
    storage_live(_6)
    _6 = @ArrayIndexShared<'_, T, 32 : usize>(move (_5), copy (_4))
    _3 = &*(_6)
    _0 = &*(_3)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::index_array_u32
pub fn index_array_u32(@1: [u32; 32 : usize], @2: usize) -> u32
{
    let _0: u32; // return
    let s_1: [u32; 32 : usize]; // arg #1
    let i_2: usize; // arg #2
    let _3: usize; // anonymous local
    let _4: &'_ [u32; 32 : usize]; // anonymous local
    let _5: &'_ u32; // anonymous local

    storage_live(_3)
    _3 = copy (i_2)
    storage_live(_4)
    _4 = &s_1
    storage_live(_5)
    _5 = @ArrayIndexShared<'_, u32, 32 : usize>(move (_4), copy (_3))
    _0 = copy (*(_5))
    storage_dead(_3)
    return
}

// Full name: test_crate::index_array_copy
pub fn index_array_copy<'_0>(@1: &'_0 [u32; 32 : usize]) -> u32
{
    let _0: u32; // return
    let x_1: &'0 [u32; 32 : usize]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ [u32; 32 : usize]; // anonymous local
    let _4: &'_ u32; // anonymous local

    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &*(x_1)
    storage_live(_4)
    _4 = @ArrayIndexShared<'_, u32, 32 : usize>(move (_3), copy (_2))
    _0 = copy (*(_4))
    storage_dead(_2)
    return
}

// Full name: test_crate::index_mut_array
pub fn index_mut_array<'_0, T>(@1: &'_0 mut [T; 32 : usize], @2: usize) -> &'_0 mut T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut T; // return
    let s_1: &'1 mut [T; 32 : usize]; // arg #1
    let i_2: usize; // arg #2
    let _3: &'0 mut T; // anonymous local
    let _4: &'0 mut T; // anonymous local
    let _5: usize; // anonymous local
    let _6: &'_ mut [T; 32 : usize]; // anonymous local
    let _7: &'_ mut T; // anonymous local

    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = copy (i_2)
    storage_live(_6)
    _6 = &mut *(s_1)
    storage_live(_7)
    _7 = @ArrayIndexMut<'_, T, 32 : usize>(move (_6), copy (_5))
    _4 = &mut *(_7)
    _3 = &mut *(_4)
    _0 = &mut *(_3)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::index_slice
pub fn index_slice<'_0, T>(@1: &'_0 [T], @2: usize) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 T; // return
    let s_1: &'1 [T]; // arg #1
    let i_2: usize; // arg #2
    let _3: &'0 T; // anonymous local
    let _4: usize; // anonymous local
    let _5: &'_ [T]; // anonymous local
    let _6: &'_ T; // anonymous local

    storage_live(_3)
    storage_live(_4)
    _4 = copy (i_2)
    storage_live(_5)
    _5 = &*(s_1) with_metadata(copy (s_1.metadata))
    storage_live(_6)
    _6 = @SliceIndexShared<'_, T>(move (_5), copy (_4))
    _3 = &*(_6)
    _0 = &*(_3)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::index_mut_slice
pub fn index_mut_slice<'_0, T>(@1: &'_0 mut [T], @2: usize) -> &'_0 mut T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut T; // return
    let s_1: &'1 mut [T]; // arg #1
    let i_2: usize; // arg #2
    let _3: &'0 mut T; // anonymous local
    let _4: &'0 mut T; // anonymous local
    let _5: usize; // anonymous local
    let _6: &'_ mut [T]; // anonymous local
    let _7: &'_ mut T; // anonymous local

    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = copy (i_2)
    storage_live(_6)
    _6 = &mut *(s_1) with_metadata(copy (s_1.metadata))
    storage_live(_7)
    _7 = @SliceIndexMut<'_, T>(move (_6), copy (_5))
    _4 = &mut *(_7)
    _3 = &mut *(_4)
    _0 = &mut *(_3)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::slice_subslice_shared_
pub fn slice_subslice_shared_<'_0>(@1: &'_0 [u32], @2: usize, @3: usize) -> &'_0 [u32]
{
    let _0: &'0 [u32]; // return
    let x_1: &'0 [u32]; // arg #1
    let y_2: usize; // arg #2
    let z_3: usize; // arg #3
    let _4: &'0 [u32]; // anonymous local
    let _5: &'0 [u32]; // anonymous local
    let _6: &'0 [u32]; // anonymous local
    let _7: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local

    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _6 = &*(x_1) with_metadata(copy (x_1.metadata))
    storage_live(_7)
    storage_live(_8)
    _8 = copy (y_2)
    storage_live(_9)
    _9 = copy (z_3)
    _7 = Range { start: move (_8), end: move (_9) }
    storage_dead(_9)
    storage_dead(_8)
    _5 = {impl Index<I, Clause2_Output> for [T]}::index<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]](move (_6), move (_7))
    storage_dead(_7)
    storage_dead(_6)
    _4 = &*(_5) with_metadata(copy (_5.metadata))
    _0 = &*(_4) with_metadata(copy (_4.metadata))
    storage_dead(_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::slice_subslice_mut_
pub fn slice_subslice_mut_<'_0>(@1: &'_0 mut [u32], @2: usize, @3: usize) -> &'_0 mut [u32]
{
    let _0: &'0 mut [u32]; // return
    let x_1: &'0 mut [u32]; // arg #1
    let y_2: usize; // arg #2
    let z_3: usize; // arg #3
    let _4: &'0 mut [u32]; // anonymous local
    let _5: &'0 mut [u32]; // anonymous local
    let _6: &'0 mut [u32]; // anonymous local
    let _7: &'0 mut [u32]; // anonymous local
    let _8: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local

    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    _7 = &mut *(x_1) with_metadata(copy (x_1.metadata))
    storage_live(_8)
    storage_live(_9)
    _9 = copy (y_2)
    storage_live(_10)
    _10 = copy (z_3)
    _8 = Range { start: move (_9), end: move (_10) }
    storage_dead(_10)
    storage_dead(_9)
    _6 = {impl IndexMut<I, Clause2_Output> for [T]}::index_mut<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]](move (_7), move (_8))
    storage_dead(_8)
    storage_dead(_7)
    _5 = &mut *(_6) with_metadata(copy (_6.metadata))
    _4 = &mut *(_5) with_metadata(copy (_5.metadata))
    _0 = &mut *(_4) with_metadata(copy (_4.metadata))
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::array_to_slice_shared_
pub fn array_to_slice_shared_<'_0>(@1: &'_0 [u32; 32 : usize]) -> &'_0 [u32]
{
    let _0: &'0 [u32]; // return
    let x_1: &'1 [u32; 32 : usize]; // arg #1
    let _2: &'1 [u32; 32 : usize]; // anonymous local

    storage_live(_2)
    _2 = &*(x_1)
    _0 = @ArrayToSliceShared<'_, u32, 32 : usize>(move (_2))
    storage_dead(_2)
    return
}

// Full name: test_crate::array_to_slice_mut_
pub fn array_to_slice_mut_<'_0>(@1: &'_0 mut [u32; 32 : usize]) -> &'_0 mut [u32]
{
    let _0: &'0 mut [u32]; // return
    let x_1: &'1 mut [u32; 32 : usize]; // arg #1
    let _2: &'0 mut [u32]; // anonymous local
    let _3: &'1 mut [u32; 32 : usize]; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = &mut *(x_1)
    _2 = @ArrayToSliceMut<'_, u32, 32 : usize>(move (_3))
    storage_dead(_3)
    _0 = &mut *(_2) with_metadata(copy (_2.metadata))
    storage_dead(_2)
    return
}

// Full name: test_crate::array_subslice_shared_
pub fn array_subslice_shared_<'_0>(@1: &'_0 [u32; 32 : usize], @2: usize, @3: usize) -> &'_0 [u32]
{
    let _0: &'0 [u32]; // return
    let x_1: &'1 [u32; 32 : usize]; // arg #1
    let y_2: usize; // arg #2
    let z_3: usize; // arg #3
    let _4: &'0 [u32]; // anonymous local
    let _5: &'0 [u32]; // anonymous local
    let _6: &'1 [u32; 32 : usize]; // anonymous local
    let _7: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local

    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _6 = &*(x_1)
    storage_live(_7)
    storage_live(_8)
    _8 = copy (y_2)
    storage_live(_9)
    _9 = copy (z_3)
    _7 = Range { start: move (_8), end: move (_9) }
    storage_dead(_9)
    storage_dead(_8)
    _5 = {impl Index<I, Clause2_Output> for [T; N]}::index<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32], 32 : usize>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl Index<I, Clause2_Output> for [T]}<u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]]](move (_6), move (_7))
    storage_dead(_7)
    storage_dead(_6)
    _4 = &*(_5) with_metadata(copy (_5.metadata))
    _0 = &*(_4) with_metadata(copy (_4.metadata))
    storage_dead(_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::array_subslice_mut_
pub fn array_subslice_mut_<'_0>(@1: &'_0 mut [u32; 32 : usize], @2: usize, @3: usize) -> &'_0 mut [u32]
{
    let _0: &'0 mut [u32]; // return
    let x_1: &'1 mut [u32; 32 : usize]; // arg #1
    let y_2: usize; // arg #2
    let z_3: usize; // arg #3
    let _4: &'0 mut [u32]; // anonymous local
    let _5: &'0 mut [u32]; // anonymous local
    let _6: &'0 mut [u32]; // anonymous local
    let _7: &'1 mut [u32; 32 : usize]; // anonymous local
    let _8: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _9: usize; // anonymous local
    let _10: usize; // anonymous local

    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    _7 = &mut *(x_1)
    storage_live(_8)
    storage_live(_9)
    _9 = copy (y_2)
    storage_live(_10)
    _10 = copy (z_3)
    _8 = Range { start: move (_9), end: move (_10) }
    storage_dead(_10)
    storage_dead(_9)
    _6 = {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32], 32 : usize>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl IndexMut<I, Clause2_Output> for [T]}<u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]]](move (_7), move (_8))
    storage_dead(_8)
    storage_dead(_7)
    _5 = &mut *(_6) with_metadata(copy (_6.metadata))
    _4 = &mut *(_5) with_metadata(copy (_5.metadata))
    _0 = &mut *(_4) with_metadata(copy (_4.metadata))
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::index_slice_0
pub fn index_slice_0<'_0, T>(@1: &'_0 [T]) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 T; // return
    let s_1: &'1 [T]; // arg #1
    let _2: &'0 T; // anonymous local
    let _3: usize; // anonymous local
    let _4: &'_ [T]; // anonymous local
    let _5: &'_ T; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = const (0 : usize)
    storage_live(_4)
    _4 = &*(s_1) with_metadata(copy (s_1.metadata))
    storage_live(_5)
    _5 = @SliceIndexShared<'_, T>(move (_4), copy (_3))
    _2 = &*(_5)
    _0 = &*(_2)
    storage_dead(_3)
    storage_dead(_2)
    return
}

// Full name: test_crate::index_array_0
pub fn index_array_0<'_0, T>(@1: &'_0 [T; 32 : usize]) -> &'_0 T
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 T; // return
    let s_1: &'1 [T; 32 : usize]; // arg #1
    let _2: &'0 T; // anonymous local
    let _3: usize; // anonymous local
    let _4: &'_ [T; 32 : usize]; // anonymous local
    let _5: &'_ T; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = const (0 : usize)
    storage_live(_4)
    _4 = &*(s_1)
    storage_live(_5)
    _5 = @ArrayIndexShared<'_, T, 32 : usize>(move (_4), copy (_3))
    _2 = &*(_5)
    _0 = &*(_2)
    storage_dead(_3)
    storage_dead(_2)
    return
}

// Full name: test_crate::index_index_array
pub fn index_index_array(@1: [[u32; 32 : usize]; 32 : usize], @2: usize, @3: usize) -> u32
{
    let _0: u32; // return
    let s_1: [[u32; 32 : usize]; 32 : usize]; // arg #1
    let i_2: usize; // arg #2
    let j_3: usize; // arg #3
    let _4: usize; // anonymous local
    let _5: usize; // anonymous local
    let _6: &'_ [[u32; 32 : usize]; 32 : usize]; // anonymous local
    let _7: &'_ [u32; 32 : usize]; // anonymous local
    let _8: &'_ [u32; 32 : usize]; // anonymous local
    let _9: &'_ u32; // anonymous local

    storage_live(_4)
    _4 = copy (i_2)
    storage_live(_5)
    _5 = copy (j_3)
    storage_live(_6)
    _6 = &s_1
    storage_live(_7)
    _7 = @ArrayIndexShared<'_, [u32; 32 : usize], 32 : usize>(move (_6), copy (_4))
    storage_live(_8)
    _8 = &*(_7)
    storage_live(_9)
    _9 = @ArrayIndexShared<'_, u32, 32 : usize>(move (_8), copy (_5))
    _0 = copy (*(_9))
    storage_dead(_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::update_update_array
pub fn update_update_array(@1: [[u32; 32 : usize]; 32 : usize], @2: usize, @3: usize)
{
    let _0: (); // return
    let s_1: [[u32; 32 : usize]; 32 : usize]; // arg #1
    let i_2: usize; // arg #2
    let j_3: usize; // arg #3
    let _4: usize; // anonymous local
    let _5: usize; // anonymous local
    let _6: &'_ mut [[u32; 32 : usize]; 32 : usize]; // anonymous local
    let _7: &'_ mut [u32; 32 : usize]; // anonymous local
    let _8: &'_ mut [u32; 32 : usize]; // anonymous local
    let _9: &'_ mut u32; // anonymous local

    _0 = ()
    storage_live(_4)
    _4 = copy (i_2)
    storage_live(_5)
    _5 = copy (j_3)
    storage_live(_6)
    _6 = &mut s_1
    storage_live(_7)
    _7 = @ArrayIndexMut<'_, [u32; 32 : usize], 32 : usize>(move (_6), copy (_4))
    storage_live(_8)
    _8 = &mut *(_7)
    storage_live(_9)
    _9 = @ArrayIndexMut<'_, u32, 32 : usize>(move (_8), copy (_5))
    *(_9) = const (0 : u32)
    storage_dead(_5)
    storage_dead(_4)
    _0 = ()
    return
}

// Full name: test_crate::incr_array_self
pub fn incr_array_self<'_0>(@1: &'_0 mut [u32; 2 : usize])
{
    let _0: (); // return
    let s_1: &'0 mut [u32; 2 : usize]; // arg #1
    let _2: usize; // anonymous local
    let _3: u32; // anonymous local
    let _4: &'_ [u32; 2 : usize]; // anonymous local
    let _5: &'_ u32; // anonymous local
    let _6: &'_ mut [u32; 2 : usize]; // anonymous local
    let _7: &'_ mut u32; // anonymous local

    storage_live(_3)
    _0 = ()
    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_4)
    _4 = &*(s_1)
    storage_live(_5)
    _5 = @ArrayIndexShared<'_, u32, 2 : usize>(move (_4), copy (_2))
    _3 = copy (*(_5)) panic.+ const (1 : u32)
    storage_live(_6)
    _6 = &mut *(s_1)
    storage_live(_7)
    _7 = @ArrayIndexMut<'_, u32, 2 : usize>(move (_6), copy (_2))
    *(_7) = move (_3)
    storage_dead(_2)
    _0 = ()
    return
}

// Full name: test_crate::incr_slice_self
pub fn incr_slice_self<'_0>(@1: &'_0 mut [u32])
{
    let _0: (); // return
    let s_1: &'0 mut [u32]; // arg #1
    let _2: usize; // anonymous local
    let _3: u32; // anonymous local
    let _4: &'_ [u32]; // anonymous local
    let _5: &'_ u32; // anonymous local
    let _6: &'_ mut [u32]; // anonymous local
    let _7: &'_ mut u32; // anonymous local

    storage_live(_3)
    _0 = ()
    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_4)
    _4 = &*(s_1) with_metadata(copy (s_1.metadata))
    storage_live(_5)
    _5 = @SliceIndexShared<'_, u32>(move (_4), copy (_2))
    _3 = copy (*(_5)) panic.+ const (1 : u32)
    storage_live(_6)
    _6 = &mut *(s_1) with_metadata(copy (s_1.metadata))
    storage_live(_7)
    _7 = @SliceIndexMut<'_, u32>(move (_6), copy (_2))
    *(_7) = move (_3)
    storage_dead(_2)
    _0 = ()
    return
}

// Full name: test_crate::array_local_deep_copy
pub fn array_local_deep_copy<'_0>(@1: &'_0 [u32; 32 : usize])
{
    let _0: (); // return
    let x_1: &'0 [u32; 32 : usize]; // arg #1
    let _y_2: [u32; 32 : usize]; // local

    _0 = ()
    storage_live(_y_2)
    _y_2 = copy (*(x_1))
    _0 = ()
    storage_dead(_y_2)
    return
}

// Full name: test_crate::take_array
pub fn take_array(@1: [u32; 2 : usize])
{
    let _0: (); // return
    let _1: [u32; 2 : usize]; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::take_array_borrow
pub fn take_array_borrow<'_0>(@1: &'_0 [u32; 2 : usize])
{
    let _0: (); // return
    let _1: &'0 [u32; 2 : usize]; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::take_slice
pub fn take_slice<'_0>(@1: &'_0 [u32])
{
    let _0: (); // return
    let _1: &'0 [u32]; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::take_mut_slice
pub fn take_mut_slice<'_0>(@1: &'_0 mut [u32])
{
    let _0: (); // return
    let _1: &'0 mut [u32]; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::const_array
pub fn const_array() -> [u32; 2 : usize]
{
    let _0: [u32; 2 : usize]; // return

    _0 = @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    return
}

// Full name: test_crate::const_slice
pub fn const_slice()
{
    let _0: (); // return
    let _1: &'0 [u32]; // anonymous local
    let _2: &'1 [u32; 2 : usize]; // anonymous local
    let _3: &'1 [u32; 2 : usize]; // anonymous local
    let _4: &'1 [u32; 2 : usize]; // anonymous local
    let _5: &'_ [u32; 2 : usize]; // anonymous local
    let _6: [u32; 2 : usize]; // anonymous local

    storage_live(_5)
    storage_live(_6)
    _6 = @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    _5 = &_6
    storage_live(_4)
    _0 = ()
    storage_live(_1)
    storage_live(_2)
    storage_live(_3)
    _4 = move (_5)
    _3 = &*(_4)
    _2 = &*(_3)
    _1 = @ArrayToSliceShared<'_, u32, 2 : usize>(move (_2))
    storage_dead(_2)
    storage_dead(_3)
    storage_dead(_1)
    _0 = ()
    return
}

// Full name: test_crate::take_all
pub fn take_all()
{
    let _0: (); // return
    let x_1: [u32; 2 : usize]; // local
    let _2: (); // anonymous local
    let _3: [u32; 2 : usize]; // anonymous local
    let _4: (); // anonymous local
    let _5: [u32; 2 : usize]; // anonymous local
    let _6: (); // anonymous local
    let _7: &'0 [u32; 2 : usize]; // anonymous local
    let _8: &'0 [u32; 2 : usize]; // anonymous local
    let _9: (); // anonymous local
    let _10: &'1 [u32]; // anonymous local
    let _11: &'0 [u32; 2 : usize]; // anonymous local
    let _12: &'0 [u32; 2 : usize]; // anonymous local
    let _13: (); // anonymous local
    let _14: &'2 mut [u32]; // anonymous local
    let _15: &'3 mut [u32; 2 : usize]; // anonymous local
    let _16: &'3 mut [u32; 2 : usize]; // anonymous local

    _0 = ()
    storage_live(x_1)
    x_1 = @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(_2)
    storage_live(_3)
    // x is deep copied (copy node appears in Charon, followed by a move)
    _3 = copy (x_1)
    _2 = take_array(move (_3))
    storage_dead(_3)
    storage_dead(_2)
    storage_live(_4)
    storage_live(_5)
    _5 = copy (x_1)
    _4 = take_array(move (_5))
    storage_dead(_5)
    storage_dead(_4)
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    // x passed by address, there is a reborrow here
    _8 = &x_1
    _7 = &*(_8)
    _6 = take_array_borrow<'_>(move (_7))
    storage_dead(_7)
    storage_dead(_8)
    storage_dead(_6)
    storage_live(_9)
    storage_live(_10)
    storage_live(_11)
    storage_live(_12)
    // automatic cast from array to slice (spanning entire array)
    _12 = &x_1
    _11 = &*(_12)
    _10 = @ArrayToSliceShared<'_, u32, 2 : usize>(move (_11))
    storage_dead(_11)
    _9 = take_slice<'_>(move (_10))
    storage_dead(_10)
    storage_dead(_12)
    storage_dead(_9)
    storage_live(_13)
    storage_live(_14)
    storage_live(_15)
    storage_live(_16)
    // note that both appear as SliceNew expressions, meaning the SliceNew UnOp is overloaded for
    // mut and non-mut cases
    _16 = &mut x_1
    _15 = &mut *(_16)
    _14 = @ArrayToSliceMut<'_, u32, 2 : usize>(move (_15))
    storage_dead(_15)
    _13 = take_mut_slice<'_>(move (_14))
    storage_dead(_14)
    storage_dead(_16)
    storage_dead(_13)
    _0 = ()
    storage_dead(x_1)
    return
}

// Full name: test_crate::index_array
pub fn index_array(@1: [u32; 2 : usize]) -> u32
{
    let _0: u32; // return
    let x_1: [u32; 2 : usize]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ [u32; 2 : usize]; // anonymous local
    let _4: &'_ u32; // anonymous local

    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &x_1
    storage_live(_4)
    _4 = @ArrayIndexShared<'_, u32, 2 : usize>(move (_3), copy (_2))
    _0 = copy (*(_4))
    storage_dead(_2)
    return
}

// Full name: test_crate::index_array_borrow
pub fn index_array_borrow<'_0>(@1: &'_0 [u32; 2 : usize]) -> u32
{
    let _0: u32; // return
    let x_1: &'0 [u32; 2 : usize]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ [u32; 2 : usize]; // anonymous local
    let _4: &'_ u32; // anonymous local

    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &*(x_1)
    storage_live(_4)
    _4 = @ArrayIndexShared<'_, u32, 2 : usize>(move (_3), copy (_2))
    _0 = copy (*(_4))
    storage_dead(_2)
    return
}

// Full name: test_crate::index_slice_u32_0
pub fn index_slice_u32_0<'_0>(@1: &'_0 [u32]) -> u32
{
    let _0: u32; // return
    let x_1: &'0 [u32]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ [u32]; // anonymous local
    let _4: &'_ u32; // anonymous local

    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &*(x_1) with_metadata(copy (x_1.metadata))
    storage_live(_4)
    _4 = @SliceIndexShared<'_, u32>(move (_3), copy (_2))
    _0 = copy (*(_4))
    storage_dead(_2)
    return
}

// Full name: test_crate::index_mut_slice_u32_0
pub fn index_mut_slice_u32_0<'_0>(@1: &'_0 mut [u32]) -> u32
{
    let _0: u32; // return
    let x_1: &'0 mut [u32]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ [u32]; // anonymous local
    let _4: &'_ u32; // anonymous local

    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &*(x_1) with_metadata(copy (x_1.metadata))
    storage_live(_4)
    _4 = @SliceIndexShared<'_, u32>(move (_3), copy (_2))
    _0 = copy (*(_4))
    storage_dead(_2)
    return
}

// Full name: test_crate::index_all
pub fn index_all() -> u32
{
    let _0: u32; // return
    let x_1: [u32; 2 : usize]; // local
    let _2: bool; // anonymous local
    let _y_3: [u32; 2 : usize]; // local
    let _z_4: [u32; 1 : usize]; // local
    let _5: u32; // anonymous local
    let _6: u32; // anonymous local
    let _7: u32; // anonymous local
    let _8: u32; // anonymous local
    let _9: [u32; 2 : usize]; // anonymous local
    let _10: u32; // anonymous local
    let _11: [u32; 2 : usize]; // anonymous local
    let _12: u32; // anonymous local
    let _13: u32; // anonymous local
    let _14: &'0 [u32; 2 : usize]; // anonymous local
    let _15: &'0 [u32; 2 : usize]; // anonymous local
    let _16: u32; // anonymous local
    let _17: u32; // anonymous local
    let _18: &'1 [u32]; // anonymous local
    let _19: &'0 [u32; 2 : usize]; // anonymous local
    let _20: &'0 [u32; 2 : usize]; // anonymous local
    let _21: u32; // anonymous local
    let _22: u32; // anonymous local
    let _23: &'2 mut [u32]; // anonymous local
    let _24: &'3 mut [u32; 2 : usize]; // anonymous local
    let _25: &'3 mut [u32; 2 : usize]; // anonymous local
    let _26: u32; // anonymous local

    storage_live(_12)
    storage_live(_16)
    storage_live(_21)
    storage_live(_26)
    storage_live(x_1)
    x_1 = @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(_2)
    _2 = const (true)
    if move (_2) {
        storage_live(_y_3)
        _y_3 = @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
        storage_dead(_y_3)
    } else {
        storage_live(_z_4)
        _z_4 = [const (0 : u32)]
        storage_dead(_z_4)
    }
    storage_dead(_2)
    storage_live(_5)
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    storage_live(_9)
    _9 = copy (x_1)
    _8 = index_array(move (_9))
    storage_dead(_9)
    storage_live(_10)
    storage_live(_11)
    _11 = copy (x_1)
    _10 = index_array(move (_11))
    storage_dead(_11)
    _12 = copy (_8) panic.+ copy (_10)
    _7 = move (_12)
    storage_dead(_10)
    storage_dead(_8)
    storage_live(_13)
    storage_live(_14)
    storage_live(_15)
    _15 = &x_1
    _14 = &*(_15)
    _13 = index_array_borrow<'_>(move (_14))
    storage_dead(_14)
    _16 = copy (_7) panic.+ copy (_13)
    _6 = move (_16)
    storage_dead(_13)
    storage_dead(_7)
    storage_live(_17)
    storage_live(_18)
    storage_live(_19)
    storage_live(_20)
    _20 = &x_1
    _19 = &*(_20)
    _18 = @ArrayToSliceShared<'_, u32, 2 : usize>(move (_19))
    storage_dead(_19)
    _17 = index_slice_u32_0<'_>(move (_18))
    storage_dead(_18)
    _21 = copy (_6) panic.+ copy (_17)
    _5 = move (_21)
    storage_dead(_17)
    storage_dead(_6)
    storage_live(_22)
    storage_live(_23)
    storage_live(_24)
    storage_live(_25)
    _25 = &mut x_1
    _24 = &mut *(_25)
    _23 = @ArrayToSliceMut<'_, u32, 2 : usize>(move (_24))
    storage_dead(_24)
    _22 = index_mut_slice_u32_0<'_>(move (_23))
    storage_dead(_23)
    _26 = copy (_5) panic.+ copy (_22)
    _0 = move (_26)
    storage_dead(_22)
    storage_dead(_5)
    storage_dead(x_1)
    storage_dead(_25)
    storage_dead(_20)
    storage_dead(_15)
    return
}

// Full name: test_crate::update_array
pub fn update_array(@1: [u32; 2 : usize])
{
    let _0: (); // return
    let x_1: [u32; 2 : usize]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ mut [u32; 2 : usize]; // anonymous local
    let _4: &'_ mut u32; // anonymous local

    _0 = ()
    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &mut x_1
    storage_live(_4)
    _4 = @ArrayIndexMut<'_, u32, 2 : usize>(move (_3), copy (_2))
    *(_4) = const (1 : u32)
    _0 = ()
    storage_dead(_2)
    return
}

// Full name: test_crate::update_array_mut_borrow
pub fn update_array_mut_borrow<'_0>(@1: &'_0 mut [u32; 2 : usize])
{
    let _0: (); // return
    let x_1: &'0 mut [u32; 2 : usize]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ mut [u32; 2 : usize]; // anonymous local
    let _4: &'_ mut u32; // anonymous local

    _0 = ()
    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &mut *(x_1)
    storage_live(_4)
    _4 = @ArrayIndexMut<'_, u32, 2 : usize>(move (_3), copy (_2))
    *(_4) = const (1 : u32)
    _0 = ()
    storage_dead(_2)
    return
}

// Full name: test_crate::update_mut_slice
pub fn update_mut_slice<'_0>(@1: &'_0 mut [u32])
{
    let _0: (); // return
    let x_1: &'0 mut [u32]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ mut [u32]; // anonymous local
    let _4: &'_ mut u32; // anonymous local

    _0 = ()
    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &mut *(x_1) with_metadata(copy (x_1.metadata))
    storage_live(_4)
    _4 = @SliceIndexMut<'_, u32>(move (_3), copy (_2))
    *(_4) = const (1 : u32)
    _0 = ()
    storage_dead(_2)
    return
}

// Full name: test_crate::update_all
pub fn update_all()
{
    let _0: (); // return
    let x_1: [u32; 2 : usize]; // local
    let _2: (); // anonymous local
    let _3: [u32; 2 : usize]; // anonymous local
    let _4: (); // anonymous local
    let _5: [u32; 2 : usize]; // anonymous local
    let _6: (); // anonymous local
    let _7: &'0 mut [u32; 2 : usize]; // anonymous local
    let _8: &'0 mut [u32; 2 : usize]; // anonymous local
    let _9: (); // anonymous local
    let _10: &'1 mut [u32]; // anonymous local
    let _11: &'0 mut [u32; 2 : usize]; // anonymous local
    let _12: &'0 mut [u32; 2 : usize]; // anonymous local

    _0 = ()
    storage_live(x_1)
    x_1 = @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(_2)
    storage_live(_3)
    _3 = copy (x_1)
    _2 = update_array(move (_3))
    storage_dead(_3)
    storage_dead(_2)
    storage_live(_4)
    storage_live(_5)
    _5 = copy (x_1)
    _4 = update_array(move (_5))
    storage_dead(_5)
    storage_dead(_4)
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    _8 = &mut x_1
    _7 = &two-phase-mut *(_8)
    _6 = update_array_mut_borrow<'_>(move (_7))
    storage_dead(_7)
    storage_dead(_8)
    storage_dead(_6)
    storage_live(_9)
    storage_live(_10)
    storage_live(_11)
    storage_live(_12)
    _12 = &mut x_1
    _11 = &mut *(_12)
    _10 = @ArrayToSliceMut<'_, u32, 2 : usize>(move (_11))
    storage_dead(_11)
    _9 = update_mut_slice<'_>(move (_10))
    storage_dead(_10)
    storage_dead(_12)
    storage_dead(_9)
    _0 = ()
    storage_dead(x_1)
    return
}

// Full name: test_crate::range_all
pub fn range_all()
{
    let _0: (); // return
    let x_1: [u32; 4 : usize]; // local
    let _2: (); // anonymous local
    let _3: &'0 mut [u32]; // anonymous local
    let _4: &'0 mut [u32]; // anonymous local
    let _5: &'0 mut [u32]; // anonymous local
    let _6: &'1 mut [u32; 4 : usize]; // anonymous local
    let _7: Range<usize>[{built_in impl Sized for usize}]; // anonymous local

    _0 = ()
    storage_live(x_1)
    x_1 = @ArrayRepeat<'_, u32, 4 : usize>(const (0 : u32))
    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    // CONFIRM: there is no way to shrink [T;N] into [T;M] with M<N?
    _6 = &mut x_1
    storage_live(_7)
    _7 = Range { start: const (1 : usize), end: const (3 : usize) }
    _5 = {impl IndexMut<I, Clause2_Clause1_Output> for [T; N]}::index_mut<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32], 4 : usize>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl IndexMut<I, Clause2_Output> for [T]}<u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]]](move (_6), move (_7))
    storage_dead(_7)
    storage_dead(_6)
    _4 = &mut *(_5) with_metadata(copy (_5.metadata))
    _3 = &two-phase-mut *(_4) with_metadata(copy (_4.metadata))
    _2 = update_mut_slice<'_>(move (_3))
    storage_dead(_3)
    storage_dead(_5)
    storage_dead(_4)
    storage_dead(_2)
    _0 = ()
    storage_dead(x_1)
    return
}

// Full name: test_crate::deref_array_borrow
pub fn deref_array_borrow<'_0>(@1: &'_0 [u32; 2 : usize]) -> u32
{
    let _0: u32; // return
    let x_1: &'0 [u32; 2 : usize]; // arg #1
    let x_2: [u32; 2 : usize]; // local
    let _3: usize; // anonymous local
    let _4: &'_ [u32; 2 : usize]; // anonymous local
    let _5: &'_ u32; // anonymous local

    storage_live(x_2)
    x_2 = copy (*(x_1))
    storage_live(_3)
    _3 = const (0 : usize)
    storage_live(_4)
    _4 = &x_2
    storage_live(_5)
    _5 = @ArrayIndexShared<'_, u32, 2 : usize>(move (_4), copy (_3))
    _0 = copy (*(_5))
    storage_dead(x_2)
    storage_dead(_3)
    return
}

// Full name: test_crate::deref_array_mut_borrow
pub fn deref_array_mut_borrow<'_0>(@1: &'_0 mut [u32; 2 : usize]) -> u32
{
    let _0: u32; // return
    let x_1: &'0 mut [u32; 2 : usize]; // arg #1
    let x_2: [u32; 2 : usize]; // local
    let _3: usize; // anonymous local
    let _4: &'_ [u32; 2 : usize]; // anonymous local
    let _5: &'_ u32; // anonymous local

    storage_live(x_2)
    x_2 = copy (*(x_1))
    storage_live(_3)
    _3 = const (0 : usize)
    storage_live(_4)
    _4 = &x_2
    storage_live(_5)
    _5 = @ArrayIndexShared<'_, u32, 2 : usize>(move (_4), copy (_3))
    _0 = copy (*(_5))
    storage_dead(x_2)
    storage_dead(_3)
    return
}

// Full name: test_crate::take_array_t
pub fn take_array_t(@1: [AB; 2 : usize])
{
    let _0: (); // return
    let _1: [AB; 2 : usize]; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::non_copyable_array
pub fn non_copyable_array()
{
    let _0: (); // return
    let x_1: [AB; 2 : usize]; // local
    let _2: AB; // anonymous local
    let _3: AB; // anonymous local
    let _4: (); // anonymous local
    let _5: [AB; 2 : usize]; // anonymous local

    _0 = ()
    storage_live(x_1)
    storage_live(_2)
    _2 = AB::A {  }
    storage_live(_3)
    _3 = AB::B {  }
    x_1 = [move (_2), move (_3)]
    storage_dead(_3)
    storage_dead(_2)
    storage_live(_4)
    storage_live(_5)
    // x is moved (not deep copied!)
    // TODO: determine whether the translation needs to be aware of that and pass by ref instead of by copy
    _5 = move (x_1)
    _4 = take_array_t(move (_5))
    storage_dead(_5)
    storage_dead(_4)
    _0 = ()
    // this fails, naturally:
    // take_array_t(x);
    storage_dead(x_1)
    return
}

// Full name: test_crate::sum
pub fn sum<'_0>(@1: &'_0 [u32]) -> u32
{
    let _0: u32; // return
    let s_1: &'0 [u32]; // arg #1
    let sum_2: u32; // local
    let i_3: usize; // local
    let _4: bool; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: &'0 [u32]; // anonymous local
    let _8: u32; // anonymous local
    let _9: usize; // anonymous local
    let _10: u32; // anonymous local
    let _11: usize; // anonymous local
    let _12: &'_ [u32]; // anonymous local
    let _13: &'_ u32; // anonymous local

    storage_live(_10)
    storage_live(_11)
    storage_live(sum_2)
    sum_2 = const (0 : u32)
    storage_live(i_3)
    i_3 = const (0 : usize)
    loop {
        storage_live(_4)
        storage_live(_5)
        _5 = copy (i_3)
        storage_live(_6)
        storage_live(_7)
        _7 = &*(s_1) with_metadata(copy (s_1.metadata))
        _6 = len<'_, u32>[{built_in impl Sized for u32}](move (_7))
        storage_dead(_7)
        _4 = move (_5) < move (_6)
        if move (_4) {
        } else {
            break 0
        }
        storage_dead(_6)
        storage_dead(_5)
        storage_live(_8)
        storage_live(_9)
        _9 = copy (i_3)
        storage_live(_12)
        _12 = &*(s_1) with_metadata(copy (s_1.metadata))
        storage_live(_13)
        _13 = @SliceIndexShared<'_, u32>(move (_12), copy (_9))
        _8 = copy (*(_13))
        _10 = copy (sum_2) panic.+ copy (_8)
        sum_2 = move (_10)
        storage_dead(_8)
        storage_dead(_9)
        _11 = copy (i_3) panic.+ const (1 : usize)
        i_3 = move (_11)
        storage_dead(_4)
        continue 0
    }
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_4)
    _0 = copy (sum_2)
    storage_dead(i_3)
    storage_dead(sum_2)
    return
}

// Full name: test_crate::sum2
pub fn sum2<'_0, '_1>(@1: &'_0 [u32], @2: &'_1 [u32]) -> u32
{
    let _0: u32; // return
    let s_1: &'0 [u32]; // arg #1
    let s2_2: &'0 [u32]; // arg #2
    let sum_3: u32; // local
    let _4: bool; // anonymous local
    let _5: usize; // anonymous local
    let _6: &'0 [u32]; // anonymous local
    let _7: usize; // anonymous local
    let _8: &'0 [u32]; // anonymous local
    let i_9: usize; // local
    let _10: bool; // anonymous local
    let _11: usize; // anonymous local
    let _12: usize; // anonymous local
    let _13: &'0 [u32]; // anonymous local
    let _14: u32; // anonymous local
    let _15: u32; // anonymous local
    let _16: usize; // anonymous local
    let _17: u32; // anonymous local
    let _18: usize; // anonymous local
    let _19: u32; // anonymous local
    let _20: u32; // anonymous local
    let _21: usize; // anonymous local
    let _22: &'_ [u32]; // anonymous local
    let _23: &'_ u32; // anonymous local
    let _24: &'_ [u32]; // anonymous local
    let _25: &'_ u32; // anonymous local

    storage_live(_19)
    storage_live(_20)
    storage_live(_21)
    storage_live(sum_3)
    sum_3 = const (0 : u32)
    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _6 = &*(s_1) with_metadata(copy (s_1.metadata))
    _5 = len<'_, u32>[{built_in impl Sized for u32}](move (_6))
    storage_dead(_6)
    storage_live(_7)
    storage_live(_8)
    _8 = &*(s2_2) with_metadata(copy (s2_2.metadata))
    _7 = len<'_, u32>[{built_in impl Sized for u32}](move (_8))
    storage_dead(_8)
    _4 = move (_5) == move (_7)
    if move (_4) {
    } else {
        storage_dead(_7)
        storage_dead(_5)
        panic(core::panicking::panic)
    }
    storage_dead(_7)
    storage_dead(_5)
    storage_dead(_4)
    storage_live(i_9)
    i_9 = const (0 : usize)
    loop {
        storage_live(_10)
        storage_live(_11)
        _11 = copy (i_9)
        storage_live(_12)
        storage_live(_13)
        _13 = &*(s_1) with_metadata(copy (s_1.metadata))
        _12 = len<'_, u32>[{built_in impl Sized for u32}](move (_13))
        storage_dead(_13)
        _10 = move (_11) < move (_12)
        if move (_10) {
        } else {
            break 0
        }
        storage_dead(_12)
        storage_dead(_11)
        storage_live(_14)
        storage_live(_15)
        storage_live(_16)
        _16 = copy (i_9)
        storage_live(_22)
        _22 = &*(s_1) with_metadata(copy (s_1.metadata))
        storage_live(_23)
        _23 = @SliceIndexShared<'_, u32>(move (_22), copy (_16))
        _15 = copy (*(_23))
        storage_live(_17)
        storage_live(_18)
        _18 = copy (i_9)
        storage_live(_24)
        _24 = &*(s2_2) with_metadata(copy (s2_2.metadata))
        storage_live(_25)
        _25 = @SliceIndexShared<'_, u32>(move (_24), copy (_18))
        _17 = copy (*(_25))
        _19 = copy (_15) panic.+ copy (_17)
        _14 = move (_19)
        storage_dead(_17)
        storage_dead(_15)
        _20 = copy (sum_3) panic.+ copy (_14)
        sum_3 = move (_20)
        storage_dead(_14)
        storage_dead(_18)
        storage_dead(_16)
        _21 = copy (i_9) panic.+ const (1 : usize)
        i_9 = move (_21)
        storage_dead(_10)
        continue 0
    }
    storage_dead(_12)
    storage_dead(_11)
    storage_dead(_10)
    _0 = copy (sum_3)
    storage_dead(i_9)
    storage_dead(sum_3)
    return
}

// Full name: test_crate::f0
pub fn f0()
{
    let _0: (); // return
    let s_1: &'0 mut [u32]; // local
    let _2: &'1 mut [u32; 2 : usize]; // anonymous local
    let _3: &'1 mut [u32; 2 : usize]; // anonymous local
    let _4: [u32; 2 : usize]; // anonymous local
    let _5: usize; // anonymous local
    let _6: &'_ mut [u32]; // anonymous local
    let _7: &'_ mut u32; // anonymous local

    _0 = ()
    storage_live(s_1)
    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    _4 = [const (1 : u32), const (2 : u32)]
    _3 = &mut _4
    _2 = &mut *(_3)
    s_1 = @ArrayToSliceMut<'_, u32, 2 : usize>(move (_2))
    storage_dead(_2)
    storage_dead(_3)
    storage_live(_5)
    _5 = const (0 : usize)
    storage_live(_6)
    _6 = &mut *(s_1) with_metadata(copy (s_1.metadata))
    storage_live(_7)
    _7 = @SliceIndexMut<'_, u32>(move (_6), copy (_5))
    *(_7) = const (1 : u32)
    storage_dead(_5)
    _0 = ()
    storage_dead(_4)
    storage_dead(s_1)
    return
}

// Full name: test_crate::f1
pub fn f1()
{
    let _0: (); // return
    let s_1: [u32; 2 : usize]; // local
    let _2: usize; // anonymous local
    let _3: &'_ mut [u32; 2 : usize]; // anonymous local
    let _4: &'_ mut u32; // anonymous local

    _0 = ()
    storage_live(s_1)
    s_1 = [const (1 : u32), const (2 : u32)]
    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &mut s_1
    storage_live(_4)
    _4 = @ArrayIndexMut<'_, u32, 2 : usize>(move (_3), copy (_2))
    *(_4) = const (1 : u32)
    storage_dead(_2)
    _0 = ()
    storage_dead(s_1)
    return
}

// Full name: test_crate::f2
pub fn f2(@1: u32)
{
    let _0: (); // return
    let _1: u32; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::f4
pub fn f4<'_0>(@1: &'_0 [u32; 32 : usize], @2: usize, @3: usize) -> &'_0 [u32]
{
    let _0: &'0 [u32]; // return
    let x_1: &'1 [u32; 32 : usize]; // arg #1
    let y_2: usize; // arg #2
    let z_3: usize; // arg #3
    let _4: &'0 [u32]; // anonymous local
    let _5: &'0 [u32]; // anonymous local
    let _6: &'1 [u32; 32 : usize]; // anonymous local
    let _7: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local

    storage_live(_4)
    storage_live(_5)
    storage_live(_6)
    _6 = &*(x_1)
    storage_live(_7)
    storage_live(_8)
    _8 = copy (y_2)
    storage_live(_9)
    _9 = copy (z_3)
    _7 = Range { start: move (_8), end: move (_9) }
    storage_dead(_9)
    storage_dead(_8)
    _5 = {impl Index<I, Clause2_Output> for [T; N]}::index<'_, u32, Range<usize>[{built_in impl Sized for usize}], [u32], 32 : usize>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl Index<I, Clause2_Output> for [T]}<u32, Range<usize>[{built_in impl Sized for usize}], [u32]>[{built_in impl Sized for u32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T], [T]> for Range<usize>[{built_in impl Sized for usize}]}<u32>[{built_in impl Sized for u32}]]](move (_6), move (_7))
    storage_dead(_7)
    storage_dead(_6)
    _4 = &*(_5) with_metadata(copy (_5.metadata))
    _0 = &*(_4) with_metadata(copy (_4.metadata))
    storage_dead(_5)
    storage_dead(_4)
    return
}

// Full name: test_crate::f3
pub fn f3() -> u32
{
    let _0: u32; // return
    let a_1: [u32; 2 : usize]; // local
    let _2: (); // anonymous local
    let _3: u32; // anonymous local
    let _4: usize; // anonymous local
    let b_5: [u32; 32 : usize]; // local
    let _6: &'0 [u32]; // anonymous local
    let _7: &'1 [u32; 2 : usize]; // anonymous local
    let _8: &'1 [u32; 2 : usize]; // anonymous local
    let _9: &'0 [u32]; // anonymous local
    let _10: &'0 [u32]; // anonymous local
    let _11: &'2 [u32; 32 : usize]; // anonymous local
    let _12: &'2 [u32; 32 : usize]; // anonymous local
    let _13: &'_ [u32; 2 : usize]; // anonymous local
    let _14: &'_ u32; // anonymous local

    storage_live(a_1)
    a_1 = [const (1 : u32), const (2 : u32)]
    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    _4 = const (0 : usize)
    storage_live(_13)
    _13 = &a_1
    storage_live(_14)
    _14 = @ArrayIndexShared<'_, u32, 2 : usize>(move (_13), copy (_4))
    _3 = copy (*(_14))
    _2 = f2(move (_3))
    storage_dead(_3)
    storage_dead(_4)
    storage_dead(_2)
    storage_live(b_5)
    b_5 = @ArrayRepeat<'_, u32, 32 : usize>(const (0 : u32))
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    _8 = &a_1
    _7 = &*(_8)
    _6 = @ArrayToSliceShared<'_, u32, 2 : usize>(move (_7))
    storage_dead(_7)
    storage_live(_9)
    storage_live(_10)
    storage_live(_11)
    storage_live(_12)
    _12 = &b_5
    _11 = &*(_12)
    _10 = f4<'_>(move (_11), const (16 : usize), const (18 : usize))
    _9 = &*(_10) with_metadata(copy (_10.metadata))
    storage_dead(_11)
    _0 = sum2<'_, '_>(move (_6), move (_9))
    storage_dead(_9)
    storage_dead(_6)
    storage_dead(b_5)
    storage_dead(a_1)
    storage_dead(_12)
    storage_dead(_10)
    storage_dead(_8)
    return
}

// Full name: test_crate::SZ
pub fn SZ() -> usize
{
    let _0: usize; // return

    _0 = const (32 : usize)
    return
}

// Full name: test_crate::SZ
pub const SZ: usize = SZ()

// Full name: test_crate::f5
pub fn f5<'_0>(@1: &'_0 [u32; 32 : usize]) -> u32
{
    let _0: u32; // return
    let x_1: &'0 [u32; 32 : usize]; // arg #1
    let _2: usize; // anonymous local
    let _3: &'_ [u32; 32 : usize]; // anonymous local
    let _4: &'_ u32; // anonymous local

    storage_live(_2)
    _2 = const (0 : usize)
    storage_live(_3)
    _3 = &*(x_1)
    storage_live(_4)
    _4 = @ArrayIndexShared<'_, u32, 32 : usize>(move (_3), copy (_2))
    _0 = copy (*(_4))
    storage_dead(_2)
    return
}

// Full name: test_crate::ite
pub fn ite()
{
    let _0: (); // return
    let x_1: [u32; 2 : usize]; // local
    let _2: bool; // anonymous local
    let y_3: [u32; 2 : usize]; // local
    let _4: u32; // anonymous local
    let _5: &'0 mut [u32]; // anonymous local
    let _6: &'1 mut [u32; 2 : usize]; // anonymous local
    let _7: &'1 mut [u32; 2 : usize]; // anonymous local
    let _8: u32; // anonymous local
    let _9: &'0 mut [u32]; // anonymous local
    let _10: &'1 mut [u32; 2 : usize]; // anonymous local
    let _11: &'1 mut [u32; 2 : usize]; // anonymous local

    _0 = ()
    storage_live(x_1)
    x_1 = @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(_2)
    _2 = const (true)
    if move (_2) {
        storage_live(y_3)
        y_3 = @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
        storage_live(_4)
        storage_live(_5)
        storage_live(_6)
        storage_live(_7)
        _7 = &mut x_1
        _6 = &mut *(_7)
        _5 = @ArrayToSliceMut<'_, u32, 2 : usize>(move (_6))
        storage_dead(_6)
        _4 = index_mut_slice_u32_0<'_>(move (_5))
        storage_dead(_5)
        storage_dead(_7)
        storage_dead(_4)
        storage_live(_8)
        storage_live(_9)
        storage_live(_10)
        storage_live(_11)
        _11 = &mut y_3
        _10 = &mut *(_11)
        _9 = @ArrayToSliceMut<'_, u32, 2 : usize>(move (_10))
        storage_dead(_10)
        _8 = index_mut_slice_u32_0<'_>(move (_9))
        storage_dead(_9)
        storage_dead(_11)
        storage_dead(_8)
        _0 = ()
        storage_dead(y_3)
    } else {
        _0 = ()
    }
    storage_dead(_2)
    storage_dead(x_1)
    return
}

// Full name: test_crate::zero_slice
pub fn zero_slice<'_0>(@1: &'_0 mut [u8])
{
    let _0: (); // return
    let a_1: &'0 mut [u8]; // arg #1
    let i_2: usize; // local
    let len_3: usize; // local
    let _4: &'1 [u8]; // anonymous local
    let _5: bool; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: &'_ mut [u8]; // anonymous local
    let _11: &'_ mut u8; // anonymous local

    storage_live(_9)
    _0 = ()
    storage_live(i_2)
    i_2 = const (0 : usize)
    storage_live(len_3)
    storage_live(_4)
    _4 = &*(a_1) with_metadata(copy (a_1.metadata))
    len_3 = len<'_, u8>[{built_in impl Sized for u8}](move (_4))
    storage_dead(_4)
    loop {
        storage_live(_5)
        storage_live(_6)
        _6 = copy (i_2)
        storage_live(_7)
        _7 = copy (len_3)
        _5 = move (_6) < move (_7)
        if move (_5) {
            storage_dead(_7)
            storage_dead(_6)
            storage_live(_8)
            _8 = copy (i_2)
            storage_live(_10)
            _10 = &mut *(a_1) with_metadata(copy (a_1.metadata))
            storage_live(_11)
            _11 = @SliceIndexMut<'_, u8>(move (_10), copy (_8))
            *(_11) = const (0 : u8)
            storage_dead(_8)
            _9 = copy (i_2) panic.+ const (1 : usize)
            i_2 = move (_9)
            storage_dead(_5)
            continue 0
        } else {
            break 0
        }
    }
    storage_dead(_7)
    storage_dead(_6)
    _0 = ()
    storage_dead(_5)
    storage_dead(len_3)
    storage_dead(i_2)
    return
}

// Full name: test_crate::iter_mut_slice
pub fn iter_mut_slice<'_0>(@1: &'_0 mut [u8])
{
    let _0: (); // return
    let a_1: &'0 mut [u8]; // arg #1
    let len_2: usize; // local
    let _3: &'1 [u8]; // anonymous local
    let i_4: usize; // local
    let _5: bool; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let _8: usize; // anonymous local

    storage_live(_8)
    _0 = ()
    storage_live(len_2)
    storage_live(_3)
    _3 = &*(a_1) with_metadata(copy (a_1.metadata))
    len_2 = len<'_, u8>[{built_in impl Sized for u8}](move (_3))
    storage_dead(_3)
    storage_live(i_4)
    i_4 = const (0 : usize)
    loop {
        storage_live(_5)
        storage_live(_6)
        _6 = copy (i_4)
        storage_live(_7)
        _7 = copy (len_2)
        _5 = move (_6) < move (_7)
        if move (_5) {
            storage_dead(_7)
            storage_dead(_6)
            _8 = copy (i_4) panic.+ const (1 : usize)
            i_4 = move (_8)
            storage_dead(_5)
            continue 0
        } else {
            break 0
        }
    }
    storage_dead(_7)
    storage_dead(_6)
    _0 = ()
    storage_dead(_5)
    storage_dead(i_4)
    storage_dead(len_2)
    return
}

// Full name: test_crate::sum_mut_slice
pub fn sum_mut_slice<'_0>(@1: &'_0 mut [u32]) -> u32
{
    let _0: u32; // return
    let a_1: &'0 mut [u32]; // arg #1
    let i_2: usize; // local
    let s_3: u32; // local
    let _4: bool; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: &'1 [u32]; // anonymous local
    let _8: u32; // anonymous local
    let _9: usize; // anonymous local
    let _10: u32; // anonymous local
    let _11: usize; // anonymous local
    let _12: &'_ [u32]; // anonymous local
    let _13: &'_ u32; // anonymous local

    storage_live(_10)
    storage_live(_11)
    storage_live(i_2)
    i_2 = const (0 : usize)
    storage_live(s_3)
    s_3 = const (0 : u32)
    loop {
        storage_live(_4)
        storage_live(_5)
        _5 = copy (i_2)
        storage_live(_6)
        storage_live(_7)
        _7 = &*(a_1) with_metadata(copy (a_1.metadata))
        _6 = len<'_, u32>[{built_in impl Sized for u32}](move (_7))
        storage_dead(_7)
        _4 = move (_5) < move (_6)
        if move (_4) {
        } else {
            break 0
        }
        storage_dead(_6)
        storage_dead(_5)
        storage_live(_8)
        storage_live(_9)
        _9 = copy (i_2)
        storage_live(_12)
        _12 = &*(a_1) with_metadata(copy (a_1.metadata))
        storage_live(_13)
        _13 = @SliceIndexShared<'_, u32>(move (_12), copy (_9))
        _8 = copy (*(_13))
        _10 = copy (s_3) panic.+ copy (_8)
        s_3 = move (_10)
        storage_dead(_8)
        storage_dead(_9)
        _11 = copy (i_2) panic.+ const (1 : usize)
        i_2 = move (_11)
        storage_dead(_4)
        continue 0
    }
    storage_dead(_6)
    storage_dead(_5)
    storage_dead(_4)
    _0 = copy (s_3)
    storage_dead(s_3)
    storage_dead(i_2)
    return
}

// Full name: test_crate::slice_pattern_1
fn slice_pattern_1(@1: [(); 1 : usize])
{
    let _0: (); // return
    let x_1: [(); 1 : usize]; // arg #1
    let _named_2: (); // local
    let _3: &'_ [(); 1 : usize]; // anonymous local
    let _4: &'_ (); // anonymous local

    _0 = ()
    storage_live(_named_2)
    storage_live(_3)
    _3 = &x_1
    storage_live(_4)
    _4 = @ArrayIndexShared<'_, (), 1 : usize>(move (_3), const (0 : usize))
    _named_2 = copy (*(_4))
    _0 = ()
    storage_dead(_named_2)
    return
}

// Full name: test_crate::slice_pattern_2
fn slice_pattern_2<'_0, T>(@1: [&'_0 mut T; 3 : usize])
where
    [@TraitClause0]: Sized<T>,
{
    let _0: (); // return
    let x_1: [&'0 mut T; 3 : usize]; // arg #1
    let _a_2: &'0 mut T; // local
    let _b_3: &'0 mut T; // local
    let _c_4: &'0 mut T; // local
    let _5: &'_ mut [&'0 mut T; 3 : usize]; // anonymous local
    let _6: &'_ mut &'0 mut T; // anonymous local
    let _7: &'_ mut [&'0 mut T; 3 : usize]; // anonymous local
    let _8: &'_ mut &'0 mut T; // anonymous local
    let _9: &'_ mut [&'0 mut T; 3 : usize]; // anonymous local
    let _10: &'_ mut &'0 mut T; // anonymous local

    _0 = ()
    storage_live(_a_2)
    storage_live(_5)
    _5 = &mut x_1
    storage_live(_6)
    _6 = @ArrayIndexMut<'_, &'0 mut T, 3 : usize>(move (_5), const (0 : usize))
    _a_2 = move (*(_6))
    storage_live(_b_3)
    storage_live(_7)
    _7 = &mut x_1
    storage_live(_8)
    _8 = @ArrayIndexMut<'_, &'0 mut T, 3 : usize>(move (_7), const (1 : usize))
    _b_3 = move (*(_8))
    storage_live(_c_4)
    storage_live(_9)
    _9 = &mut x_1
    storage_live(_10)
    _10 = @ArrayIndexMut<'_, &'0 mut T, 3 : usize>(move (_9), const (2 : usize))
    _c_4 = move (*(_10))
    _0 = ()
    storage_dead(_c_4)
    storage_dead(_b_3)
    storage_dead(_a_2)
    return
}

// Full name: test_crate::slice_pattern_3
fn slice_pattern_3<'_0>(@1: &'_0 [(); 1 : usize])
{
    let _0: (); // return
    let x_1: &'0 [(); 1 : usize]; // arg #1
    let _named_2: &'1 (); // local
    let _3: &'_ [(); 1 : usize]; // anonymous local
    let _4: &'_ (); // anonymous local

    _0 = ()
    storage_live(_named_2)
    storage_live(_3)
    _3 = &*(x_1)
    storage_live(_4)
    _4 = @ArrayIndexShared<'_, (), 1 : usize>(move (_3), const (0 : usize))
    _named_2 = &*(_4)
    _0 = ()
    storage_dead(_named_2)
    return
}

// Full name: test_crate::slice_pattern_4
fn slice_pattern_4<'_0>(@1: &'_0 [()])
{
    let _0: (); // return
    let x_1: &'0 [()]; // arg #1
    let _2: usize; // anonymous local
    let _3: usize; // anonymous local
    let _4: usize; // anonymous local
    let _5: bool; // anonymous local
    let _named_6: &'1 (); // local
    let _7: &'_ [()]; // anonymous local
    let _8: &'_ (); // anonymous local

    storage_live(_2)
    storage_live(_3)
    storage_live(_4)
    storage_live(_5)
    _0 = ()
    _3 = copy (x_1.metadata)
    _2 = move (_3)
    _4 = const (1 : usize)
    _5 = move (_2) == move (_4)
    if move (_5) {
    } else {
        _0 = ()
        return
    }
    storage_live(_named_6)
    storage_live(_7)
    _7 = &*(x_1) with_metadata(copy (x_1.metadata))
    storage_live(_8)
    _8 = @SliceIndexShared<'_, ()>(move (_7), const (0 : usize))
    _named_6 = &*(_8)
    _0 = ()
    storage_dead(_named_6)
    return
}



