# Final LLBC before serialization:

pub enum test_crate::AB =
|  A()
|  B()


pub fn test_crate::incr<'_0>(@1: &'_0 mut (u32))
{
    let @0: (); // return
    let x@1: &'_ mut (u32); // arg #1

    *(x@1) := copy (*(x@1)) + const (1 : u32)
    @0 := ()
    @0 := ()
    return
}

#[lang_item("sized")]
pub trait core::marker::Sized<Self>

pub fn test_crate::array_to_shared_slice_<'_0, T>(@1: &'_0 (Array<T, 32 : usize>)) -> &'_0 (Slice<T>)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ (Slice<T>); // return
    let s@1: &'_ (Array<T, 32 : usize>); // arg #1
    let @2: &'_ (Array<T, 32 : usize>); // anonymous local

    storage_live(@2)
    @2 := &*(s@1)
    @0 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@2))
    storage_dead(@2)
    return
}

pub fn test_crate::array_to_mut_slice_<'_0, T>(@1: &'_0 mut (Array<T, 32 : usize>)) -> &'_0 mut (Slice<T>)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (Slice<T>); // return
    let s@1: &'_ mut (Array<T, 32 : usize>); // arg #1
    let @2: &'_ mut (Slice<T>); // anonymous local
    let @3: &'_ mut (Array<T, 32 : usize>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &mut *(s@1)
    @2 := @ArrayToSliceMut<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := &mut *(@2)
    storage_dead(@2)
    return
}

#[lang_item("slice_len_fn")]
pub fn core::slice::{Slice<T>}::len<'_0, T>(@1: &'_0 (Slice<T>)) -> usize
where
    [@TraitClause0]: core::marker::Sized<T>,

pub fn test_crate::array_len<T>(@1: Array<T, 32 : usize>) -> usize
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: usize; // return
    let s@1: Array<T, 32 : usize>; // arg #1
    let @2: &'_ (Slice<T>); // anonymous local
    let @3: &'_ (Array<T, 32 : usize>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &s@1
    @2 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := core::slice::{Slice<T>}::len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    drop s@1
    return
}

pub fn test_crate::shared_array_len<'_0, T>(@1: &'_0 (Array<T, 32 : usize>)) -> usize
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: usize; // return
    let s@1: &'_ (Array<T, 32 : usize>); // arg #1
    let @2: &'_ (Slice<T>); // anonymous local
    let @3: &'_ (Array<T, 32 : usize>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &*(s@1)
    @2 := @ArrayToSliceShared<'_, T, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := core::slice::{Slice<T>}::len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    return
}

pub fn test_crate::shared_slice_len<'_0, T>(@1: &'_0 (Slice<T>)) -> usize
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: usize; // return
    let s@1: &'_ (Slice<T>); // arg #1
    let @2: &'_ (Slice<T>); // anonymous local

    storage_live(@2)
    @2 := &*(s@1)
    @0 := core::slice::{Slice<T>}::len<'_, T>[@TraitClause0](move (@2))
    storage_dead(@2)
    return
}

pub fn test_crate::index_array_shared<'_0, T>(@1: &'_0 (Array<T, 32 : usize>), @2: usize) -> &'_0 (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ (T); // return
    let s@1: &'_ (Array<T, 32 : usize>); // arg #1
    let i@2: usize; // arg #2
    let @3: &'_ (T); // anonymous local
    let @4: usize; // anonymous local
    let @5: &'_ (Array<T, 32 : usize>); // anonymous local
    let @6: &'_ (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := &*(s@1)
    storage_live(@6)
    @6 := @ArrayIndexShared<'_, T, 32 : usize>(move (@5), copy (@4))
    @3 := &*(@6)
    @0 := &*(@3)
    storage_dead(@4)
    storage_dead(@3)
    return
}

pub fn test_crate::index_array_u32(@1: Array<u32, 32 : usize>, @2: usize) -> u32
{
    let @0: u32; // return
    let s@1: Array<u32, 32 : usize>; // arg #1
    let i@2: usize; // arg #2
    let @3: usize; // anonymous local
    let @4: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(@3)
    @3 := copy (i@2)
    storage_live(@4)
    @4 := &s@1
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(@3)
    return
}

pub fn test_crate::index_array_copy<'_0>(@1: &'_0 (Array<u32, 32 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

pub fn test_crate::index_mut_array<'_0, T>(@1: &'_0 mut (Array<T, 32 : usize>), @2: usize) -> &'_0 mut (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (T); // return
    let s@1: &'_ mut (Array<T, 32 : usize>); // arg #1
    let i@2: usize; // arg #2
    let @3: &'_ mut (T); // anonymous local
    let @4: &'_ mut (T); // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut (Array<T, 32 : usize>); // anonymous local
    let @7: &'_ mut (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (i@2)
    storage_live(@6)
    @6 := &mut *(s@1)
    storage_live(@7)
    @7 := @ArrayIndexMut<'_, T, 32 : usize>(move (@6), copy (@5))
    @4 := &mut *(@7)
    @3 := &mut *(@4)
    @0 := &mut *(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

pub fn test_crate::index_slice<'_0, T>(@1: &'_0 (Slice<T>), @2: usize) -> &'_0 (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ (T); // return
    let s@1: &'_ (Slice<T>); // arg #1
    let i@2: usize; // arg #2
    let @3: &'_ (T); // anonymous local
    let @4: usize; // anonymous local
    let @5: &'_ (Slice<T>); // anonymous local
    let @6: &'_ (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := &*(s@1)
    storage_live(@6)
    @6 := @SliceIndexShared<'_, T>(move (@5), copy (@4))
    @3 := &*(@6)
    @0 := &*(@3)
    storage_dead(@4)
    storage_dead(@3)
    return
}

pub fn test_crate::index_mut_slice<'_0, T>(@1: &'_0 mut (Slice<T>), @2: usize) -> &'_0 mut (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ mut (T); // return
    let s@1: &'_ mut (Slice<T>); // arg #1
    let i@2: usize; // arg #2
    let @3: &'_ mut (T); // anonymous local
    let @4: &'_ mut (T); // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut (Slice<T>); // anonymous local
    let @7: &'_ mut (T); // anonymous local

    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (i@2)
    storage_live(@6)
    @6 := &mut *(s@1)
    storage_live(@7)
    @7 := @SliceIndexMut<'_, T>(move (@6), copy (@5))
    @4 := &mut *(@7)
    @3 := &mut *(@4)
    @0 := &mut *(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@3)
    return
}

#[lang_item("Range")]
pub struct core::ops::range::Range<Idx>
  where
      [@TraitClause0]: core::marker::Sized<Idx>,
 =
{
  start: Idx,
  end: Idx,
}

pub trait core::slice::index::private_slice_index::Sealed<Self>

#[lang_item("Option")]
pub enum core::option::Option<T>
  where
      [@TraitClause0]: core::marker::Sized<T>,
 =
|  None()
|  Some(T)


#[lang_item("SliceIndex")]
pub trait core::slice::index::SliceIndex<Self, T, Self_Output>
{
    parent_clause0 : [@TraitClause0]: core::slice::index::private_slice_index::Sealed<Self>
    fn get<'_0> = core::slice::index::SliceIndex::get<'_0_0, Self, T, Self_Output>
    fn get_mut<'_0> = core::slice::index::SliceIndex::get_mut<'_0_0, Self, T, Self_Output>
    fn get_unchecked = core::slice::index::SliceIndex::get_unchecked<Self, T, Self_Output>
    fn get_unchecked_mut = core::slice::index::SliceIndex::get_unchecked_mut<Self, T, Self_Output>
    fn index<'_0> = core::slice::index::SliceIndex::index<'_0_0, Self, T, Self_Output>
    fn index_mut<'_0> = core::slice::index::SliceIndex::index_mut<'_0_0, Self, T, Self_Output>
}

pub fn core::slice::index::{impl core::ops::index::Index<I, Clause2_Output> for Slice<T>}::index<'_0, T, I, Clause2_Output>(@1: &'_0 (Slice<T>), @2: I) -> &'_0 (Clause2_Output)
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::slice::index::SliceIndex<I, Slice<T>, Clause2_Output>,

impl core::slice::index::private_slice_index::{impl core::slice::index::private_slice_index::Sealed for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#1 : core::slice::index::private_slice_index::Sealed<core::ops::range::Range<usize>[core::marker::Sized<usize>]>

pub fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::get<'_0, T>(@1: core::ops::range::Range<usize>[core::marker::Sized<usize>], @2: &'_0 (Slice<T>)) -> core::option::Option<&'_0 (Slice<T>)>[core::marker::Sized<&'_0 (Slice<T>)>]
where
    [@TraitClause0]: core::marker::Sized<T>,

pub fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::get_mut<'_0, T>(@1: core::ops::range::Range<usize>[core::marker::Sized<usize>], @2: &'_0 mut (Slice<T>)) -> core::option::Option<&'_0 mut (Slice<T>)>[core::marker::Sized<&'_0 mut (Slice<T>)>]
where
    [@TraitClause0]: core::marker::Sized<T>,

pub unsafe fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::get_unchecked<T>(@1: core::ops::range::Range<usize>[core::marker::Sized<usize>], @2: *const Slice<T>) -> *const Slice<T>
where
    [@TraitClause0]: core::marker::Sized<T>,

pub unsafe fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::get_unchecked_mut<T>(@1: core::ops::range::Range<usize>[core::marker::Sized<usize>], @2: *mut Slice<T>) -> *mut Slice<T>
where
    [@TraitClause0]: core::marker::Sized<T>,

pub fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::index<'_0, T>(@1: core::ops::range::Range<usize>[core::marker::Sized<usize>], @2: &'_0 (Slice<T>)) -> &'_0 (Slice<T>)
where
    [@TraitClause0]: core::marker::Sized<T>,

pub fn core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::index_mut<'_0, T>(@1: core::ops::range::Range<usize>[core::marker::Sized<usize>], @2: &'_0 mut (Slice<T>)) -> &'_0 mut (Slice<T>)
where
    [@TraitClause0]: core::marker::Sized<T>,

impl core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4<T> : core::slice::index::SliceIndex<core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<T>, Slice<T>>
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    parent_clause0 = core::slice::index::private_slice_index::{impl core::slice::index::private_slice_index::Sealed for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#1
    fn get<'_0> = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::get<'_0_0, T>[@TraitClause0]
    fn get_mut<'_0> = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::get_mut<'_0_0, T>[@TraitClause0]
    fn get_unchecked = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0> = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::index<'_0_0, T>[@TraitClause0]
    fn index_mut<'_0> = core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4::index_mut<'_0_0, T>[@TraitClause0]
}

pub fn test_crate::slice_subslice_shared_<'_0>(@1: &'_0 (Slice<u32>), @2: usize, @3: usize) -> &'_0 (Slice<u32>)
{
    let @0: &'_ (Slice<u32>); // return
    let x@1: &'_ (Slice<u32>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ (Slice<u32>); // anonymous local
    let @5: &'_ (Slice<u32>); // anonymous local
    let @6: &'_ (Slice<u32>); // anonymous local
    let @7: core::ops::range::Range<usize>[core::marker::Sized<usize>]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := core::ops::range::Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := core::slice::index::{impl core::ops::index::Index<I, Clause2_Output> for Slice<T>}::index<'_, u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4<u32>[core::marker::Sized<u32>]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5)
    @0 := &*(@4)
    storage_dead(@5)
    storage_dead(@4)
    return
}

pub fn core::slice::index::{impl core::ops::index::IndexMut<I, Clause2_Output> for Slice<T>}#1::index_mut<'_0, T, I, Clause2_Output>(@1: &'_0 mut (Slice<T>), @2: I) -> &'_0 mut (Clause2_Output)
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::slice::index::SliceIndex<I, Slice<T>, Clause2_Output>,

pub fn test_crate::slice_subslice_mut_<'_0>(@1: &'_0 mut (Slice<u32>), @2: usize, @3: usize) -> &'_0 mut (Slice<u32>)
{
    let @0: &'_ mut (Slice<u32>); // return
    let x@1: &'_ mut (Slice<u32>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ mut (Slice<u32>); // anonymous local
    let @5: &'_ mut (Slice<u32>); // anonymous local
    let @6: &'_ mut (Slice<u32>); // anonymous local
    let @7: &'_ mut (Slice<u32>); // anonymous local
    let @8: core::ops::range::Range<usize>[core::marker::Sized<usize>]; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &mut *(x@1)
    storage_live(@8)
    storage_live(@9)
    @9 := copy (y@2)
    storage_live(@10)
    @10 := copy (z@3)
    @8 := core::ops::range::Range { start: move (@9), end: move (@10) }
    storage_dead(@10)
    storage_dead(@9)
    @6 := core::slice::index::{impl core::ops::index::IndexMut<I, Clause2_Output> for Slice<T>}#1::index_mut<'_, u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4<u32>[core::marker::Sized<u32>]](move (@7), move (@8))
    storage_dead(@8)
    storage_dead(@7)
    @5 := &mut *(@6)
    @4 := &mut *(@5)
    @0 := &mut *(@4)
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    return
}

pub fn test_crate::array_to_slice_shared_<'_0>(@1: &'_0 (Array<u32, 32 : usize>)) -> &'_0 (Slice<u32>)
{
    let @0: &'_ (Slice<u32>); // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let @2: &'_ (Array<u32, 32 : usize>); // anonymous local

    storage_live(@2)
    @2 := &*(x@1)
    @0 := @ArrayToSliceShared<'_, u32, 32 : usize>(move (@2))
    storage_dead(@2)
    return
}

pub fn test_crate::array_to_slice_mut_<'_0>(@1: &'_0 mut (Array<u32, 32 : usize>)) -> &'_0 mut (Slice<u32>)
{
    let @0: &'_ mut (Slice<u32>); // return
    let x@1: &'_ mut (Array<u32, 32 : usize>); // arg #1
    let @2: &'_ mut (Slice<u32>); // anonymous local
    let @3: &'_ mut (Array<u32, 32 : usize>); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := &mut *(x@1)
    @2 := @ArrayToSliceMut<'_, u32, 32 : usize>(move (@3))
    storage_dead(@3)
    @0 := &mut *(@2)
    storage_dead(@2)
    return
}

#[lang_item("index")]
pub trait core::ops::index::Index<Self, Idx, Self_Output>
{
    fn index<'_0> = core::ops::index::Index::index<'_0_0, Self, Idx, Self_Output>
}

pub fn core::array::{impl core::ops::index::Index<I, Clause2_Output> for Array<T, const N : usize>}#15::index<'_0, T, I, Clause2_Output, const N : usize>(@1: &'_0 (Array<T, const N : usize>), @2: I) -> &'_0 (Clause2_Output)
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::ops::index::Index<Slice<T>, I, Clause2_Output>,

impl core::slice::index::{impl core::ops::index::Index<I, Clause2_Output> for Slice<T>}<T, I, Clause2_Output> : core::ops::index::Index<Slice<T>, I, Clause2_Output>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::slice::index::SliceIndex<I, Slice<T>, Clause2_Output>,
{
    fn index<'_0> = core::slice::index::{impl core::ops::index::Index<I, Clause2_Output> for Slice<T>}::index<'_0_0, T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
}

pub fn test_crate::array_subslice_shared_<'_0>(@1: &'_0 (Array<u32, 32 : usize>), @2: usize, @3: usize) -> &'_0 (Slice<u32>)
{
    let @0: &'_ (Slice<u32>); // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ (Slice<u32>); // anonymous local
    let @5: &'_ (Slice<u32>); // anonymous local
    let @6: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @7: core::ops::range::Range<usize>[core::marker::Sized<usize>]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := core::ops::range::Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := core::array::{impl core::ops::index::Index<I, Clause2_Output> for Array<T, const N : usize>}#15::index<'_, u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>, 32 : usize>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::ops::index::Index<I, Clause2_Output> for Slice<T>}<u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4<u32>[core::marker::Sized<u32>]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5)
    @0 := &*(@4)
    storage_dead(@5)
    storage_dead(@4)
    return
}

#[lang_item("index_mut")]
pub trait core::ops::index::IndexMut<Self, Idx, Self_Clause0_Output>
{
    parent_clause0 : [@TraitClause0]: core::ops::index::Index<Self, Idx, Self_Clause0_Output>
    fn index_mut<'_0> = core::ops::index::IndexMut::index_mut<'_0_0, Self, Idx, Self_Clause0_Output>
}

pub fn core::array::{impl core::ops::index::IndexMut<I, Clause2_Clause0_Output> for Array<T, const N : usize>}#16::index_mut<'_0, T, I, Clause2_Clause0_Output, const N : usize>(@1: &'_0 mut (Array<T, const N : usize>), @2: I) -> &'_0 mut (Clause2_Clause0_Output)
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::ops::index::IndexMut<Slice<T>, I, Clause2_Clause0_Output>,

impl core::slice::index::{impl core::ops::index::IndexMut<I, Clause2_Output> for Slice<T>}#1<T, I, Clause2_Output> : core::ops::index::IndexMut<Slice<T>, I, Clause2_Output>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::slice::index::SliceIndex<I, Slice<T>, Clause2_Output>,
{
    parent_clause0 = core::slice::index::{impl core::ops::index::Index<I, Clause2_Output> for Slice<T>}<T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
    fn index_mut<'_0> = core::slice::index::{impl core::ops::index::IndexMut<I, Clause2_Output> for Slice<T>}#1::index_mut<'_0_0, T, I, Clause2_Output>[@TraitClause0, @TraitClause1, @TraitClause2]
}

pub fn test_crate::array_subslice_mut_<'_0>(@1: &'_0 mut (Array<u32, 32 : usize>), @2: usize, @3: usize) -> &'_0 mut (Slice<u32>)
{
    let @0: &'_ mut (Slice<u32>); // return
    let x@1: &'_ mut (Array<u32, 32 : usize>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ mut (Slice<u32>); // anonymous local
    let @5: &'_ mut (Slice<u32>); // anonymous local
    let @6: &'_ mut (Slice<u32>); // anonymous local
    let @7: &'_ mut (Array<u32, 32 : usize>); // anonymous local
    let @8: core::ops::range::Range<usize>[core::marker::Sized<usize>]; // anonymous local
    let @9: usize; // anonymous local
    let @10: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &mut *(x@1)
    storage_live(@8)
    storage_live(@9)
    @9 := copy (y@2)
    storage_live(@10)
    @10 := copy (z@3)
    @8 := core::ops::range::Range { start: move (@9), end: move (@10) }
    storage_dead(@10)
    storage_dead(@9)
    @6 := core::array::{impl core::ops::index::IndexMut<I, Clause2_Clause0_Output> for Array<T, const N : usize>}#16::index_mut<'_, u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>, 32 : usize>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::ops::index::IndexMut<I, Clause2_Output> for Slice<T>}#1<u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4<u32>[core::marker::Sized<u32>]]](move (@7), move (@8))
    storage_dead(@8)
    storage_dead(@7)
    @5 := &mut *(@6)
    @4 := &mut *(@5)
    @0 := &mut *(@4)
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    return
}

pub fn test_crate::index_slice_0<'_0, T>(@1: &'_0 (Slice<T>)) -> &'_0 (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ (T); // return
    let s@1: &'_ (Slice<T>); // arg #1
    let @2: &'_ (T); // anonymous local
    let @3: usize; // anonymous local
    let @4: &'_ (Slice<T>); // anonymous local
    let @5: &'_ (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &*(s@1)
    storage_live(@5)
    @5 := @SliceIndexShared<'_, T>(move (@4), copy (@3))
    @2 := &*(@5)
    @0 := &*(@2)
    storage_dead(@3)
    storage_dead(@2)
    return
}

pub fn test_crate::index_array_0<'_0, T>(@1: &'_0 (Array<T, 32 : usize>)) -> &'_0 (T)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: &'_ (T); // return
    let s@1: &'_ (Array<T, 32 : usize>); // arg #1
    let @2: &'_ (T); // anonymous local
    let @3: usize; // anonymous local
    let @4: &'_ (Array<T, 32 : usize>); // anonymous local
    let @5: &'_ (T); // anonymous local

    storage_live(@2)
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &*(s@1)
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, T, 32 : usize>(move (@4), copy (@3))
    @2 := &*(@5)
    @0 := &*(@2)
    storage_dead(@3)
    storage_dead(@2)
    return
}

pub fn test_crate::index_index_array(@1: Array<Array<u32, 32 : usize>, 32 : usize>, @2: usize, @3: usize) -> u32
{
    let @0: u32; // return
    let s@1: Array<Array<u32, 32 : usize>, 32 : usize>; // arg #1
    let i@2: usize; // arg #2
    let j@3: usize; // arg #3
    let @4: usize; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ (Array<Array<u32, 32 : usize>, 32 : usize>); // anonymous local
    let @7: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @8: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @9: &'_ (u32); // anonymous local

    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := copy (j@3)
    storage_live(@6)
    @6 := &s@1
    storage_live(@7)
    @7 := @ArrayIndexShared<'_, Array<u32, 32 : usize>, 32 : usize>(move (@6), copy (@4))
    storage_live(@8)
    @8 := &*(@7)
    storage_live(@9)
    @9 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@8), copy (@5))
    @0 := copy (*(@9))
    storage_dead(@5)
    storage_dead(@4)
    return
}

pub fn test_crate::update_update_array(@1: Array<Array<u32, 32 : usize>, 32 : usize>, @2: usize, @3: usize)
{
    let @0: (); // return
    let s@1: Array<Array<u32, 32 : usize>, 32 : usize>; // arg #1
    let i@2: usize; // arg #2
    let j@3: usize; // arg #3
    let @4: usize; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut (Array<Array<u32, 32 : usize>, 32 : usize>); // anonymous local
    let @7: &'_ mut (Array<u32, 32 : usize>); // anonymous local
    let @8: &'_ mut (Array<u32, 32 : usize>); // anonymous local
    let @9: &'_ mut (u32); // anonymous local

    storage_live(@4)
    @4 := copy (i@2)
    storage_live(@5)
    @5 := copy (j@3)
    storage_live(@6)
    @6 := &mut s@1
    storage_live(@7)
    @7 := @ArrayIndexMut<'_, Array<u32, 32 : usize>, 32 : usize>(move (@6), copy (@4))
    storage_live(@8)
    @8 := &mut *(@7)
    storage_live(@9)
    @9 := @ArrayIndexMut<'_, u32, 32 : usize>(move (@8), copy (@5))
    *(@9) := const (0 : u32)
    storage_dead(@5)
    storage_dead(@4)
    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::incr_array_self<'_0>(@1: &'_0 mut (Array<u32, 2 : usize>))
{
    let @0: (); // return
    let s@1: &'_ mut (Array<u32, 2 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: u32; // anonymous local
    let @4: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @5: &'_ mut (u32); // anonymous local
    let @6: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @7: &'_ (u32); // anonymous local

    storage_live(@3)
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@6)
    @6 := &*(s@1)
    storage_live(@7)
    @7 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@6), copy (@2))
    @3 := copy (*(@7)) + const (1 : u32)
    storage_live(@4)
    @4 := &mut *(s@1)
    storage_live(@5)
    @5 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@4), copy (@2))
    *(@5) := move (@3)
    storage_dead(@2)
    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::incr_slice_self<'_0>(@1: &'_0 mut (Slice<u32>))
{
    let @0: (); // return
    let s@1: &'_ mut (Slice<u32>); // arg #1
    let @2: usize; // anonymous local
    let @3: u32; // anonymous local
    let @4: &'_ mut (Slice<u32>); // anonymous local
    let @5: &'_ mut (u32); // anonymous local
    let @6: &'_ (Slice<u32>); // anonymous local
    let @7: &'_ (u32); // anonymous local

    storage_live(@3)
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@6)
    @6 := &*(s@1)
    storage_live(@7)
    @7 := @SliceIndexShared<'_, u32>(move (@6), copy (@2))
    @3 := copy (*(@7)) + const (1 : u32)
    storage_live(@4)
    @4 := &mut *(s@1)
    storage_live(@5)
    @5 := @SliceIndexMut<'_, u32>(move (@4), copy (@2))
    *(@5) := move (@3)
    storage_dead(@2)
    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::array_local_deep_copy<'_0>(@1: &'_0 (Array<u32, 32 : usize>))
{
    let @0: (); // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let _y@2: Array<u32, 32 : usize>; // local

    storage_live(_y@2)
    _y@2 := copy (*(x@1))
    @0 := ()
    storage_dead(_y@2)
    @0 := ()
    return
}

pub fn test_crate::take_array(@1: Array<u32, 2 : usize>)
{
    let @0: (); // return
    let @1: Array<u32, 2 : usize>; // arg #1

    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::take_array_borrow<'_0>(@1: &'_0 (Array<u32, 2 : usize>))
{
    let @0: (); // return
    let @1: &'_ (Array<u32, 2 : usize>); // arg #1

    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::take_slice<'_0>(@1: &'_0 (Slice<u32>))
{
    let @0: (); // return
    let @1: &'_ (Slice<u32>); // arg #1

    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::take_mut_slice<'_0>(@1: &'_0 mut (Slice<u32>))
{
    let @0: (); // return
    let @1: &'_ mut (Slice<u32>); // arg #1

    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::const_array() -> Array<u32, 2 : usize>
{
    let @0: Array<u32, 2 : usize>; // return

    @0 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    return
}

pub fn test_crate::const_slice()
{
    let @0: (); // return
    let @1: &'_ (Slice<u32>); // anonymous local
    let @2: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @3: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @4: Array<u32, 2 : usize>; // anonymous local

    storage_live(@1)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    @3 := &@4
    @2 := &*(@3)
    @1 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@2))
    storage_dead(@2)
    storage_dead(@3)
    storage_dead(@1)
    @0 := ()
    storage_dead(@4)
    @0 := ()
    return
}

pub fn test_crate::take_all()
{
    let @0: (); // return
    let x@1: Array<u32, 2 : usize>; // local
    let @2: (); // anonymous local
    let @3: Array<u32, 2 : usize>; // anonymous local
    let @4: (); // anonymous local
    let @5: Array<u32, 2 : usize>; // anonymous local
    let @6: (); // anonymous local
    let @7: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @8: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @9: (); // anonymous local
    let @10: &'_ (Slice<u32>); // anonymous local
    let @11: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @12: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @13: (); // anonymous local
    let @14: &'_ mut (Slice<u32>); // anonymous local
    let @15: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @16: &'_ mut (Array<u32, 2 : usize>); // anonymous local

    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    // x is deep copied (copy node appears in Charon, followed by a move)
    @3 := copy (x@1)
    @2 := test_crate::take_array(move (@3))
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (x@1)
    @4 := test_crate::take_array(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    // x passed by address, there is a reborrow here
    @8 := &x@1
    @7 := &*(@8)
    @6 := test_crate::take_array_borrow<'_>(move (@7))
    storage_dead(@7)
    storage_dead(@8)
    storage_dead(@6)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    // automatic cast from array to slice (spanning entire array)
    @12 := &x@1
    @11 := &*(@12)
    @10 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@11))
    storage_dead(@11)
    @9 := test_crate::take_slice<'_>(move (@10))
    storage_dead(@10)
    storage_dead(@12)
    storage_dead(@9)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    storage_live(@16)
    // note that both appear as SliceNew expressions, meaning the SliceNew UnOp is overloaded for
    // mut and non-mut cases
    @16 := &mut x@1
    @15 := &mut *(@16)
    @14 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@15))
    storage_dead(@15)
    @13 := test_crate::take_mut_slice<'_>(move (@14))
    storage_dead(@14)
    storage_dead(@16)
    storage_dead(@13)
    @0 := ()
    storage_dead(x@1)
    @0 := ()
    return
}

pub fn test_crate::index_array(@1: Array<u32, 2 : usize>) -> u32
{
    let @0: u32; // return
    let x@1: Array<u32, 2 : usize>; // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &x@1
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

pub fn test_crate::index_array_borrow<'_0>(@1: &'_0 (Array<u32, 2 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Array<u32, 2 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

pub fn test_crate::index_slice_u32_0<'_0>(@1: &'_0 (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Slice<u32>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Slice<u32>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @SliceIndexShared<'_, u32>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

pub fn test_crate::index_mut_slice_u32_0<'_0>(@1: &'_0 mut (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ mut (Slice<u32>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Slice<u32>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @SliceIndexShared<'_, u32>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

pub fn test_crate::index_all() -> u32
{
    let @0: u32; // return
    let x@1: Array<u32, 2 : usize>; // local
    let @2: (); // anonymous local
    let @3: bool; // anonymous local
    let _y@4: Array<u32, 2 : usize>; // local
    let _z@5: Array<u32, 1 : usize>; // local
    let @6: u32; // anonymous local
    let @7: u32; // anonymous local
    let @8: u32; // anonymous local
    let @9: u32; // anonymous local
    let @10: Array<u32, 2 : usize>; // anonymous local
    let @11: u32; // anonymous local
    let @12: Array<u32, 2 : usize>; // anonymous local
    let @13: u32; // anonymous local
    let @14: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @15: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @16: u32; // anonymous local
    let @17: &'_ (Slice<u32>); // anonymous local
    let @18: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @19: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @20: u32; // anonymous local
    let @21: &'_ mut (Slice<u32>); // anonymous local
    let @22: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @23: &'_ mut (Array<u32, 2 : usize>); // anonymous local

    storage_live(_y@4)
    storage_live(_z@5)
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    @3 := const (true)
    if move (@3) {
        storage_live(_y@4)
        _y@4 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
        storage_dead(_y@4)
    }
    else {
        storage_live(_z@5)
        _z@5 := [const (0 : u32)]
        storage_dead(_z@5)
    }
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    @10 := copy (x@1)
    @9 := test_crate::index_array(move (@10))
    storage_dead(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := copy (x@1)
    @11 := test_crate::index_array(move (@12))
    storage_dead(@12)
    @8 := move (@9) + move (@11)
    storage_dead(@11)
    storage_dead(@9)
    storage_live(@13)
    storage_live(@14)
    storage_live(@15)
    @15 := &x@1
    @14 := &*(@15)
    @13 := test_crate::index_array_borrow<'_>(move (@14))
    storage_dead(@14)
    @7 := move (@8) + move (@13)
    storage_dead(@13)
    storage_dead(@8)
    storage_live(@16)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    @19 := &x@1
    @18 := &*(@19)
    @17 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@18))
    storage_dead(@18)
    @16 := test_crate::index_slice_u32_0<'_>(move (@17))
    storage_dead(@17)
    @6 := move (@7) + move (@16)
    storage_dead(@16)
    storage_dead(@7)
    storage_live(@20)
    storage_live(@21)
    storage_live(@22)
    storage_live(@23)
    @23 := &mut x@1
    @22 := &mut *(@23)
    @21 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@22))
    storage_dead(@22)
    @20 := test_crate::index_mut_slice_u32_0<'_>(move (@21))
    storage_dead(@21)
    @0 := move (@6) + move (@20)
    storage_dead(@20)
    storage_dead(@6)
    storage_dead(x@1)
    storage_dead(@23)
    storage_dead(@19)
    storage_dead(@15)
    return
}

pub fn test_crate::update_array(@1: Array<u32, 2 : usize>)
{
    let @0: (); // return
    let x@1: Array<u32, 2 : usize>; // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut x@1
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    @0 := ()
    return
}

pub fn test_crate::update_array_mut_borrow<'_0>(@1: &'_0 mut (Array<u32, 2 : usize>))
{
    let @0: (); // return
    let x@1: &'_ mut (Array<u32, 2 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut *(x@1)
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    @0 := ()
    return
}

pub fn test_crate::update_mut_slice<'_0>(@1: &'_0 mut (Slice<u32>))
{
    let @0: (); // return
    let x@1: &'_ mut (Slice<u32>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ mut (Slice<u32>); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut *(x@1)
    storage_live(@4)
    @4 := @SliceIndexMut<'_, u32>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    @0 := ()
    storage_dead(@2)
    @0 := ()
    return
}

pub fn test_crate::update_all()
{
    let @0: (); // return
    let x@1: Array<u32, 2 : usize>; // local
    let @2: (); // anonymous local
    let @3: Array<u32, 2 : usize>; // anonymous local
    let @4: (); // anonymous local
    let @5: Array<u32, 2 : usize>; // anonymous local
    let @6: (); // anonymous local
    let @7: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @8: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @9: (); // anonymous local
    let @10: &'_ mut (Slice<u32>); // anonymous local
    let @11: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @12: &'_ mut (Array<u32, 2 : usize>); // anonymous local

    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    @3 := copy (x@1)
    @2 := test_crate::update_array(move (@3))
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    @5 := copy (x@1)
    @4 := test_crate::update_array(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := &mut x@1
    @7 := &two-phase-mut *(@8)
    @6 := test_crate::update_array_mut_borrow<'_>(move (@7))
    storage_dead(@7)
    storage_dead(@8)
    storage_dead(@6)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := &mut x@1
    @11 := &mut *(@12)
    @10 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@11))
    storage_dead(@11)
    @9 := test_crate::update_mut_slice<'_>(move (@10))
    storage_dead(@10)
    storage_dead(@12)
    storage_dead(@9)
    @0 := ()
    storage_dead(x@1)
    @0 := ()
    return
}

pub fn test_crate::range_all()
{
    let @0: (); // return
    let x@1: Array<u32, 4 : usize>; // local
    let @2: (); // anonymous local
    let @3: &'_ mut (Slice<u32>); // anonymous local
    let @4: &'_ mut (Slice<u32>); // anonymous local
    let @5: &'_ mut (Slice<u32>); // anonymous local
    let @6: &'_ mut (Array<u32, 4 : usize>); // anonymous local
    let @7: core::ops::range::Range<usize>[core::marker::Sized<usize>]; // anonymous local

    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 4 : usize>(const (0 : u32))
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    // CONFIRM: there is no way to shrink [T;N] into [T;M] with M<N?
    @6 := &mut x@1
    storage_live(@7)
    @7 := core::ops::range::Range { start: const (1 : usize), end: const (3 : usize) }
    @5 := core::array::{impl core::ops::index::IndexMut<I, Clause2_Clause0_Output> for Array<T, const N : usize>}#16::index_mut<'_, u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>, 4 : usize>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::ops::index::IndexMut<I, Clause2_Output> for Slice<T>}#1<u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4<u32>[core::marker::Sized<u32>]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &mut *(@5)
    @3 := &two-phase-mut *(@4)
    @2 := test_crate::update_mut_slice<'_>(move (@3))
    storage_dead(@3)
    storage_dead(@5)
    storage_dead(@4)
    storage_dead(@2)
    @0 := ()
    storage_dead(x@1)
    @0 := ()
    return
}

pub fn test_crate::deref_array_borrow<'_0>(@1: &'_0 (Array<u32, 2 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Array<u32, 2 : usize>); // arg #1
    let x@2: Array<u32, 2 : usize>; // local
    let @3: usize; // anonymous local
    let @4: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(x@2)
    x@2 := copy (*(x@1))
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &x@2
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(x@2)
    storage_dead(@3)
    return
}

pub fn test_crate::deref_array_mut_borrow<'_0>(@1: &'_0 mut (Array<u32, 2 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ mut (Array<u32, 2 : usize>); // arg #1
    let x@2: Array<u32, 2 : usize>; // local
    let @3: usize; // anonymous local
    let @4: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @5: &'_ (u32); // anonymous local

    storage_live(x@2)
    x@2 := copy (*(x@1))
    storage_live(@3)
    @3 := const (0 : usize)
    storage_live(@4)
    @4 := &x@2
    storage_live(@5)
    @5 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@4), copy (@3))
    @0 := copy (*(@5))
    storage_dead(x@2)
    storage_dead(@3)
    return
}

pub fn test_crate::take_array_t(@1: Array<test_crate::AB, 2 : usize>)
{
    let @0: (); // return
    let @1: Array<test_crate::AB, 2 : usize>; // arg #1

    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::non_copyable_array()
{
    let @0: (); // return
    let x@1: Array<test_crate::AB, 2 : usize>; // local
    let @2: test_crate::AB; // anonymous local
    let @3: test_crate::AB; // anonymous local
    let @4: (); // anonymous local
    let @5: Array<test_crate::AB, 2 : usize>; // anonymous local

    storage_live(x@1)
    storage_live(@2)
    @2 := test_crate::AB::A {  }
    storage_live(@3)
    @3 := test_crate::AB::B {  }
    x@1 := [move (@2), move (@3)]
    storage_dead(@3)
    storage_dead(@2)
    storage_live(@4)
    storage_live(@5)
    // x is moved (not deep copied!)
    // TODO: determine whether the translation needs to be aware of that and pass by ref instead of by copy
    @5 := move (x@1)
    @4 := test_crate::take_array_t(move (@5))
    storage_dead(@5)
    storage_dead(@4)
    @0 := ()
    // this fails, naturally:
    // take_array_t(x);
    storage_dead(x@1)
    @0 := ()
    return
}

pub fn test_crate::sum<'_0>(@1: &'_0 (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let s@1: &'_ (Slice<u32>); // arg #1
    let sum@2: u32; // local
    let i@3: usize; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: &'_ (Slice<u32>); // anonymous local
    let @9: u32; // anonymous local
    let @10: usize; // anonymous local
    let @11: (); // anonymous local
    let @12: &'_ (Slice<u32>); // anonymous local
    let @13: &'_ (u32); // anonymous local

    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@12)
    storage_live(@13)
    storage_live(sum@2)
    sum@2 := const (0 : u32)
    storage_live(i@3)
    i@3 := const (0 : usize)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@3)
        storage_live(@7)
        storage_live(@8)
        @8 := &*(s@1)
        @7 := core::slice::{Slice<T>}::len<'_, u32>[core::marker::Sized<u32>](move (@8))
        storage_dead(@8)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@9)
            storage_live(@10)
            @10 := copy (i@3)
            storage_live(@12)
            @12 := &*(s@1)
            storage_live(@13)
            @13 := @SliceIndexShared<'_, u32>(move (@12), copy (@10))
            @9 := copy (*(@13))
            sum@2 := copy (sum@2) + move (@9)
            storage_dead(@9)
            storage_dead(@10)
            i@3 := copy (i@3) + const (1 : usize)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@11)
    storage_dead(@11)
    storage_dead(@5)
    storage_dead(@4)
    @0 := copy (sum@2)
    storage_dead(i@3)
    storage_dead(sum@2)
    return
}

pub fn test_crate::sum2<'_0, '_1>(@1: &'_0 (Slice<u32>), @2: &'_1 (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let s@1: &'_ (Slice<u32>); // arg #1
    let s2@2: &'_ (Slice<u32>); // arg #2
    let sum@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: &'_ (Slice<u32>); // anonymous local
    let @8: usize; // anonymous local
    let @9: &'_ (Slice<u32>); // anonymous local
    let i@10: usize; // local
    let @11: (); // anonymous local
    let @12: bool; // anonymous local
    let @13: usize; // anonymous local
    let @14: usize; // anonymous local
    let @15: &'_ (Slice<u32>); // anonymous local
    let @16: u32; // anonymous local
    let @17: u32; // anonymous local
    let @18: usize; // anonymous local
    let @19: u32; // anonymous local
    let @20: usize; // anonymous local
    let @21: (); // anonymous local
    let @22: &'_ (Slice<u32>); // anonymous local
    let @23: &'_ (u32); // anonymous local
    let @24: &'_ (Slice<u32>); // anonymous local
    let @25: &'_ (u32); // anonymous local

    storage_live(@15)
    storage_live(@16)
    storage_live(@17)
    storage_live(@18)
    storage_live(@19)
    storage_live(@20)
    storage_live(@22)
    storage_live(@23)
    storage_live(@24)
    storage_live(@25)
    storage_live(sum@3)
    sum@3 := const (0 : u32)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    @7 := &*(s@1)
    @6 := core::slice::{Slice<T>}::len<'_, u32>[core::marker::Sized<u32>](move (@7))
    storage_dead(@7)
    storage_live(@8)
    storage_live(@9)
    @9 := &*(s2@2)
    @8 := core::slice::{Slice<T>}::len<'_, u32>[core::marker::Sized<u32>](move (@9))
    storage_dead(@9)
    @5 := move (@6) == move (@8)
    if move (@5) {
    }
    else {
        storage_dead(@8)
        storage_dead(@6)
        panic(core::panicking::panic)
    }
    storage_dead(@8)
    storage_dead(@6)
    storage_dead(@5)
    storage_dead(@4)
    storage_live(i@10)
    i@10 := const (0 : usize)
    storage_live(@11)
    loop {
        storage_live(@12)
        storage_live(@13)
        @13 := copy (i@10)
        storage_live(@14)
        storage_live(@15)
        @15 := &*(s@1)
        @14 := core::slice::{Slice<T>}::len<'_, u32>[core::marker::Sized<u32>](move (@15))
        storage_dead(@15)
        @12 := move (@13) < move (@14)
        if move (@12) {
            storage_dead(@14)
            storage_dead(@13)
            storage_live(@16)
            storage_live(@17)
            storage_live(@18)
            @18 := copy (i@10)
            storage_live(@24)
            @24 := &*(s@1)
            storage_live(@25)
            @25 := @SliceIndexShared<'_, u32>(move (@24), copy (@18))
            @17 := copy (*(@25))
            storage_live(@19)
            storage_live(@20)
            @20 := copy (i@10)
            storage_live(@22)
            @22 := &*(s2@2)
            storage_live(@23)
            @23 := @SliceIndexShared<'_, u32>(move (@22), copy (@20))
            @19 := copy (*(@23))
            @16 := move (@17) + move (@19)
            storage_dead(@19)
            storage_dead(@17)
            sum@3 := copy (sum@3) + move (@16)
            storage_dead(@16)
            storage_dead(@20)
            storage_dead(@18)
            i@10 := copy (i@10) + const (1 : usize)
            storage_dead(@12)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@14)
    storage_dead(@13)
    storage_live(@21)
    storage_dead(@21)
    storage_dead(@12)
    storage_dead(@11)
    @0 := copy (sum@3)
    storage_dead(i@10)
    storage_dead(sum@3)
    return
}

pub fn test_crate::f0()
{
    let @0: (); // return
    let s@1: &'_ mut (Slice<u32>); // local
    let @2: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @3: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @4: Array<u32, 2 : usize>; // anonymous local
    let @5: usize; // anonymous local
    let @6: &'_ mut (Slice<u32>); // anonymous local
    let @7: &'_ mut (u32); // anonymous local

    storage_live(s@1)
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := [const (1 : u32), const (2 : u32)]
    @3 := &mut @4
    @2 := &mut *(@3)
    s@1 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@2))
    storage_dead(@2)
    storage_dead(@3)
    storage_live(@5)
    @5 := const (0 : usize)
    storage_live(@6)
    @6 := &mut *(s@1)
    storage_live(@7)
    @7 := @SliceIndexMut<'_, u32>(move (@6), copy (@5))
    *(@7) := const (1 : u32)
    storage_dead(@5)
    @0 := ()
    storage_dead(@4)
    storage_dead(s@1)
    @0 := ()
    return
}

pub fn test_crate::f1()
{
    let @0: (); // return
    let s@1: Array<u32, 2 : usize>; // local
    let @2: usize; // anonymous local
    let @3: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @4: &'_ mut (u32); // anonymous local

    storage_live(s@1)
    s@1 := [const (1 : u32), const (2 : u32)]
    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &mut s@1
    storage_live(@4)
    @4 := @ArrayIndexMut<'_, u32, 2 : usize>(move (@3), copy (@2))
    *(@4) := const (1 : u32)
    storage_dead(@2)
    @0 := ()
    storage_dead(s@1)
    @0 := ()
    return
}

pub fn test_crate::f2(@1: u32)
{
    let @0: (); // return
    let @1: u32; // arg #1

    @0 := ()
    @0 := ()
    return
}

pub fn test_crate::f4<'_0>(@1: &'_0 (Array<u32, 32 : usize>), @2: usize, @3: usize) -> &'_0 (Slice<u32>)
{
    let @0: &'_ (Slice<u32>); // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let y@2: usize; // arg #2
    let z@3: usize; // arg #3
    let @4: &'_ (Slice<u32>); // anonymous local
    let @5: &'_ (Slice<u32>); // anonymous local
    let @6: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @7: core::ops::range::Range<usize>[core::marker::Sized<usize>]; // anonymous local
    let @8: usize; // anonymous local
    let @9: usize; // anonymous local

    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    storage_live(@8)
    @8 := copy (y@2)
    storage_live(@9)
    @9 := copy (z@3)
    @7 := core::ops::range::Range { start: move (@8), end: move (@9) }
    storage_dead(@9)
    storage_dead(@8)
    @5 := core::array::{impl core::ops::index::Index<I, Clause2_Output> for Array<T, const N : usize>}#15::index<'_, u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>, 32 : usize>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::ops::index::Index<I, Clause2_Output> for Slice<T>}<u32, core::ops::range::Range<usize>[core::marker::Sized<usize>], Slice<u32>>[core::marker::Sized<u32>, core::marker::Sized<core::ops::range::Range<usize>[core::marker::Sized<usize>]>, core::slice::index::{impl core::slice::index::SliceIndex<Slice<T>, Slice<T>> for core::ops::range::Range<usize>[core::marker::Sized<usize>]}#4<u32>[core::marker::Sized<u32>]]](move (@6), move (@7))
    storage_dead(@7)
    storage_dead(@6)
    @4 := &*(@5)
    @0 := &*(@4)
    storage_dead(@5)
    storage_dead(@4)
    return
}

pub fn test_crate::f3() -> u32
{
    let @0: u32; // return
    let a@1: Array<u32, 2 : usize>; // local
    let @2: (); // anonymous local
    let @3: u32; // anonymous local
    let @4: usize; // anonymous local
    let b@5: Array<u32, 32 : usize>; // local
    let @6: &'_ (Slice<u32>); // anonymous local
    let @7: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @8: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @9: &'_ (Slice<u32>); // anonymous local
    let @10: &'_ (Slice<u32>); // anonymous local
    let @11: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @12: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @13: &'_ (Array<u32, 2 : usize>); // anonymous local
    let @14: &'_ (u32); // anonymous local

    storage_live(a@1)
    a@1 := [const (1 : u32), const (2 : u32)]
    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @4 := const (0 : usize)
    storage_live(@13)
    @13 := &a@1
    storage_live(@14)
    @14 := @ArrayIndexShared<'_, u32, 2 : usize>(move (@13), copy (@4))
    @3 := copy (*(@14))
    @2 := test_crate::f2(move (@3))
    storage_dead(@3)
    storage_dead(@4)
    storage_dead(@2)
    storage_live(b@5)
    b@5 := @ArrayRepeat<'_, u32, 32 : usize>(const (0 : u32))
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    @8 := &a@1
    @7 := &*(@8)
    @6 := @ArrayToSliceShared<'_, u32, 2 : usize>(move (@7))
    storage_dead(@7)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(@12)
    @12 := &b@5
    @11 := &*(@12)
    @10 := test_crate::f4<'_>(move (@11), const (16 : usize), const (18 : usize))
    @9 := &*(@10)
    storage_dead(@11)
    @0 := test_crate::sum2<'_, '_>(move (@6), move (@9))
    storage_dead(@9)
    storage_dead(@6)
    storage_dead(b@5)
    storage_dead(a@1)
    storage_dead(@12)
    storage_dead(@10)
    storage_dead(@8)
    return
}

pub fn test_crate::SZ() -> usize
{
    let @0: usize; // return

    @0 := const (32 : usize)
    return
}

pub global test_crate::SZ: usize = test_crate::SZ()

pub fn test_crate::f5<'_0>(@1: &'_0 (Array<u32, 32 : usize>)) -> u32
{
    let @0: u32; // return
    let x@1: &'_ (Array<u32, 32 : usize>); // arg #1
    let @2: usize; // anonymous local
    let @3: &'_ (Array<u32, 32 : usize>); // anonymous local
    let @4: &'_ (u32); // anonymous local

    storage_live(@2)
    @2 := const (0 : usize)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, u32, 32 : usize>(move (@3), copy (@2))
    @0 := copy (*(@4))
    storage_dead(@2)
    return
}

pub fn test_crate::ite()
{
    let @0: (); // return
    let x@1: Array<u32, 2 : usize>; // local
    let @2: bool; // anonymous local
    let y@3: Array<u32, 2 : usize>; // local
    let @4: u32; // anonymous local
    let @5: &'_ mut (Slice<u32>); // anonymous local
    let @6: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @7: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @8: u32; // anonymous local
    let @9: &'_ mut (Slice<u32>); // anonymous local
    let @10: &'_ mut (Array<u32, 2 : usize>); // anonymous local
    let @11: &'_ mut (Array<u32, 2 : usize>); // anonymous local

    storage_live(y@3)
    storage_live(@4)
    storage_live(@5)
    storage_live(@6)
    storage_live(@7)
    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@11)
    storage_live(x@1)
    x@1 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
    storage_live(@2)
    @2 := const (true)
    if move (@2) {
        storage_live(y@3)
        y@3 := @ArrayRepeat<'_, u32, 2 : usize>(const (0 : u32))
        storage_live(@4)
        storage_live(@5)
        storage_live(@6)
        storage_live(@7)
        @7 := &mut x@1
        @6 := &mut *(@7)
        @5 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@6))
        storage_dead(@6)
        @4 := test_crate::index_mut_slice_u32_0<'_>(move (@5))
        storage_dead(@5)
        storage_dead(@7)
        storage_dead(@4)
        storage_live(@8)
        storage_live(@9)
        storage_live(@10)
        storage_live(@11)
        @11 := &mut y@3
        @10 := &mut *(@11)
        @9 := @ArrayToSliceMut<'_, u32, 2 : usize>(move (@10))
        storage_dead(@10)
        @8 := test_crate::index_mut_slice_u32_0<'_>(move (@9))
        storage_dead(@9)
        storage_dead(@11)
        storage_dead(@8)
        @0 := ()
        storage_dead(y@3)
    }
    else {
        @0 := ()
    }
    storage_dead(@2)
    storage_dead(x@1)
    @0 := ()
    return
}

pub fn test_crate::zero_slice<'_0>(@1: &'_0 mut (Slice<u8>))
{
    let @0: (); // return
    let a@1: &'_ mut (Slice<u8>); // arg #1
    let i@2: usize; // local
    let len@3: usize; // local
    let @4: &'_ (Slice<u8>); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: usize; // anonymous local
    let @9: (); // anonymous local
    let @10: &'_ mut (Slice<u8>); // anonymous local
    let @11: &'_ mut (u8); // anonymous local

    storage_live(@8)
    storage_live(@10)
    storage_live(@11)
    storage_live(i@2)
    i@2 := const (0 : usize)
    storage_live(len@3)
    storage_live(@4)
    @4 := &*(a@1)
    len@3 := core::slice::{Slice<T>}::len<'_, u8>[core::marker::Sized<u8>](move (@4))
    storage_dead(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        @7 := copy (len@3)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@8)
            @8 := copy (i@2)
            storage_live(@10)
            @10 := &mut *(a@1)
            storage_live(@11)
            @11 := @SliceIndexMut<'_, u8>(move (@10), copy (@8))
            *(@11) := const (0 : u8)
            storage_dead(@8)
            i@2 := copy (i@2) + const (1 : usize)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@9)
    @0 := ()
    storage_dead(@9)
    storage_dead(@5)
    storage_dead(len@3)
    storage_dead(i@2)
    @0 := ()
    return
}

pub fn test_crate::iter_mut_slice<'_0>(@1: &'_0 mut (Slice<u8>))
{
    let @0: (); // return
    let a@1: &'_ mut (Slice<u8>); // arg #1
    let len@2: usize; // local
    let @3: &'_ (Slice<u8>); // anonymous local
    let i@4: usize; // local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: (); // anonymous local

    storage_live(len@2)
    storage_live(@3)
    @3 := &*(a@1)
    len@2 := core::slice::{Slice<T>}::len<'_, u8>[core::marker::Sized<u8>](move (@3))
    storage_dead(@3)
    storage_live(i@4)
    i@4 := const (0 : usize)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@4)
        storage_live(@7)
        @7 := copy (len@2)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            i@4 := copy (i@4) + const (1 : usize)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@8)
    @0 := ()
    storage_dead(@8)
    storage_dead(@5)
    storage_dead(i@4)
    storage_dead(len@2)
    @0 := ()
    return
}

pub fn test_crate::sum_mut_slice<'_0>(@1: &'_0 mut (Slice<u32>)) -> u32
{
    let @0: u32; // return
    let a@1: &'_ mut (Slice<u32>); // arg #1
    let i@2: usize; // local
    let s@3: u32; // local
    let @4: (); // anonymous local
    let @5: bool; // anonymous local
    let @6: usize; // anonymous local
    let @7: usize; // anonymous local
    let @8: &'_ (Slice<u32>); // anonymous local
    let @9: u32; // anonymous local
    let @10: usize; // anonymous local
    let @11: (); // anonymous local
    let @12: &'_ (Slice<u32>); // anonymous local
    let @13: &'_ (u32); // anonymous local

    storage_live(@8)
    storage_live(@9)
    storage_live(@10)
    storage_live(@12)
    storage_live(@13)
    storage_live(i@2)
    i@2 := const (0 : usize)
    storage_live(s@3)
    s@3 := const (0 : u32)
    storage_live(@4)
    loop {
        storage_live(@5)
        storage_live(@6)
        @6 := copy (i@2)
        storage_live(@7)
        storage_live(@8)
        @8 := &*(a@1)
        @7 := core::slice::{Slice<T>}::len<'_, u32>[core::marker::Sized<u32>](move (@8))
        storage_dead(@8)
        @5 := move (@6) < move (@7)
        if move (@5) {
            storage_dead(@7)
            storage_dead(@6)
            storage_live(@9)
            storage_live(@10)
            @10 := copy (i@2)
            storage_live(@12)
            @12 := &*(a@1)
            storage_live(@13)
            @13 := @SliceIndexShared<'_, u32>(move (@12), copy (@10))
            @9 := copy (*(@13))
            s@3 := copy (s@3) + move (@9)
            storage_dead(@9)
            storage_dead(@10)
            i@2 := copy (i@2) + const (1 : usize)
            storage_dead(@5)
            continue 0
        }
        else {
            break 0
        }
    }
    storage_dead(@7)
    storage_dead(@6)
    storage_live(@11)
    storage_dead(@11)
    storage_dead(@5)
    storage_dead(@4)
    @0 := copy (s@3)
    storage_dead(s@3)
    storage_dead(i@2)
    return
}

fn test_crate::slice_pattern_1(@1: Array<(), 1 : usize>)
{
    let @0: (); // return
    let x@1: Array<(), 1 : usize>; // arg #1
    let _named@2: (); // local
    let @3: &'_ (Array<(), 1 : usize>); // anonymous local
    let @4: &'_ (()); // anonymous local

    storage_live(_named@2)
    storage_live(@3)
    @3 := &x@1
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, (), 1 : usize>(move (@3), const (0 : usize))
    _named@2 := copy (*(@4))
    @0 := ()
    storage_dead(_named@2)
    @0 := ()
    return
}

fn test_crate::slice_pattern_2<'_0, T>(@1: Array<&'_0 mut (T), 3 : usize>)
where
    [@TraitClause0]: core::marker::Sized<T>,
{
    let @0: (); // return
    let x@1: Array<&'_ mut (T), 3 : usize>; // arg #1
    let _a@2: &'_ mut (T); // local
    let _b@3: &'_ mut (T); // local
    let _c@4: &'_ mut (T); // local
    let @5: &'_ mut (Array<&'_ mut (T), 3 : usize>); // anonymous local
    let @6: &'_ mut (&'_ mut (T)); // anonymous local
    let @7: &'_ mut (Array<&'_ mut (T), 3 : usize>); // anonymous local
    let @8: &'_ mut (&'_ mut (T)); // anonymous local
    let @9: &'_ mut (Array<&'_ mut (T), 3 : usize>); // anonymous local
    let @10: &'_ mut (&'_ mut (T)); // anonymous local

    storage_live(_a@2)
    storage_live(@9)
    @9 := &mut x@1
    storage_live(@10)
    @10 := @ArrayIndexMut<'_, &'_ mut (T), 3 : usize>(move (@9), const (0 : usize))
    _a@2 := move (*(@10))
    storage_live(_b@3)
    storage_live(@7)
    @7 := &mut x@1
    storage_live(@8)
    @8 := @ArrayIndexMut<'_, &'_ mut (T), 3 : usize>(move (@7), const (1 : usize))
    _b@3 := move (*(@8))
    storage_live(_c@4)
    storage_live(@5)
    @5 := &mut x@1
    storage_live(@6)
    @6 := @ArrayIndexMut<'_, &'_ mut (T), 3 : usize>(move (@5), const (2 : usize))
    _c@4 := move (*(@6))
    @0 := ()
    storage_dead(_c@4)
    storage_dead(_b@3)
    storage_dead(_a@2)
    @0 := ()
    return
}

fn test_crate::slice_pattern_3<'_0>(@1: &'_0 (Array<(), 1 : usize>))
{
    let @0: (); // return
    let x@1: &'_ (Array<(), 1 : usize>); // arg #1
    let _named@2: &'_ (()); // local
    let @3: &'_ (Array<(), 1 : usize>); // anonymous local
    let @4: &'_ (()); // anonymous local

    storage_live(_named@2)
    storage_live(@3)
    @3 := &*(x@1)
    storage_live(@4)
    @4 := @ArrayIndexShared<'_, (), 1 : usize>(move (@3), const (0 : usize))
    _named@2 := &*(@4)
    @0 := ()
    storage_dead(_named@2)
    @0 := ()
    return
}

fn test_crate::slice_pattern_4<'_0>(@1: &'_0 (Slice<()>))
{
    let @0: (); // return
    let x@1: &'_ (Slice<()>); // arg #1
    let @2: usize; // anonymous local
    let @3: usize; // anonymous local
    let @4: bool; // anonymous local
    let _named@5: &'_ (()); // local
    let @6: &'_ (Slice<()>); // anonymous local
    let @7: &'_ (()); // anonymous local

    storage_live(@2)
    storage_live(@3)
    storage_live(@4)
    @2 := len(*(x@1))
    @3 := const (1 : usize)
    @4 := move (@2) == move (@3)
    if move (@4) {
    }
    else {
        @0 := ()
        @0 := ()
        return
    }
    storage_live(_named@5)
    storage_live(@6)
    @6 := &*(x@1)
    storage_live(@7)
    @7 := @SliceIndexShared<'_, ()>(move (@6), const (0 : usize))
    _named@5 := &*(@7)
    @0 := ()
    storage_dead(_named@5)
    @0 := ()
    return
}

pub fn core::ops::index::Index::index<'_0, Self, Idx, Self_Output>(@1: &'_0 (Self), @2: Idx) -> &'_0 (Self_Output)

pub fn core::ops::index::IndexMut::index_mut<'_0, Self, Idx, Self_Clause0_Output>(@1: &'_0 mut (Self), @2: Idx) -> &'_0 mut (Self_Clause0_Output)

impl core::array::{impl core::ops::index::Index<I, Clause2_Output> for Array<T, const N : usize>}#15<T, I, Clause2_Output, const N : usize> : core::ops::index::Index<Array<T, const N : usize>, I, Clause2_Output>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::ops::index::Index<Slice<T>, I, Clause2_Output>,
{
    fn index<'_0> = core::array::{impl core::ops::index::Index<I, Clause2_Output> for Array<T, const N : usize>}#15::index<'_0_0, T, I, Clause2_Output, const N : usize>[@TraitClause0, @TraitClause1, @TraitClause2]
}

impl core::array::{impl core::ops::index::IndexMut<I, Clause2_Clause0_Output> for Array<T, const N : usize>}#16<T, I, Clause2_Clause0_Output, const N : usize> : core::ops::index::IndexMut<Array<T, const N : usize>, I, Clause2_Clause0_Output>
where
    [@TraitClause0]: core::marker::Sized<T>,
    [@TraitClause1]: core::marker::Sized<I>,
    [@TraitClause2]: core::ops::index::IndexMut<Slice<T>, I, Clause2_Clause0_Output>,
{
    parent_clause0 = core::array::{impl core::ops::index::Index<I, Clause2_Output> for Array<T, const N : usize>}#15<T, I, Clause2_Clause0_Output, const N : usize>[@TraitClause0, @TraitClause1, @TraitClause2::parent_clause0]
    fn index_mut<'_0> = core::array::{impl core::ops::index::IndexMut<I, Clause2_Clause0_Output> for Array<T, const N : usize>}#16::index_mut<'_0_0, T, I, Clause2_Clause0_Output, const N : usize>[@TraitClause0, @TraitClause1, @TraitClause2]
}

pub fn core::slice::index::SliceIndex::get<'_0, Self, T, Self_Output>(@1: Self, @2: &'_0 (T)) -> core::option::Option<&'_0 (Self_Output)>[core::marker::Sized<&'_0 (Self_Output)>]

pub fn core::slice::index::SliceIndex::get_mut<'_0, Self, T, Self_Output>(@1: Self, @2: &'_0 mut (T)) -> core::option::Option<&'_0 mut (Self_Output)>[core::marker::Sized<&'_0 mut (Self_Output)>]

pub unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T, Self_Output>(@1: Self, @2: *const T) -> *const Self_Output

pub unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T, Self_Output>(@1: Self, @2: *mut T) -> *mut Self_Output

pub fn core::slice::index::SliceIndex::index<'_0, Self, T, Self_Output>(@1: Self, @2: &'_0 (T)) -> &'_0 (Self_Output)

pub fn core::slice::index::SliceIndex::index_mut<'_0, Self, T, Self_Output>(@1: Self, @2: &'_0 mut (T)) -> &'_0 mut (Self_Output)



