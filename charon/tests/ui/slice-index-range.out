# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::ops::index::Index
#[lang_item("index")]
pub trait Index<Self, Idx>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: MetaSized<Idx>
    parent_clause2 : [@TraitClause2]: MetaSized<Self::Output>
    type Output
    fn index<'_0_1> = core::ops::index::Index::index<'_0_1, Self, Idx>[Self]
    vtable: core::ops::index::Index::{vtable}<Idx, Self::Output>
}

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::array::{impl#0}::index
pub fn {impl#0}::index<'_0, T, I, const N : usize>(@1: &'_0 [T; N], @2: I) -> &'_0 @TraitClause2::Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Index<[T], I>,
= <opaque>

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub opaque type Argument<'a>

fn core::slice::index::slice_index_fail::do_panic::runtime(@1: usize, @2: usize) -> !
= <missing>

fn core::slice::index::slice_index_fail::do_panic#1::runtime(@1: usize, @2: usize) -> !
= <missing>

fn core::slice::index::slice_index_fail::do_panic#2::runtime(@1: usize, @2: usize) -> !
= <missing>

fn core::slice::index::slice_index_fail::do_panic#3::runtime(@1: usize, @2: usize) -> !
= <missing>

pub fn core::ops::index::Index::index<'_0, Self, Idx>(@1: &'_0 Self, @2: Idx) -> &'_0 @TraitClause0::Output
where
    [@TraitClause0]: Index<Self, Idx>,
= <opaque>

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

fn core::slice::index::slice_index_fail::do_panic(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic::runtime(move start_1, move len_2)
}

fn core::slice::index::slice_index_fail::do_panic#1(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let end_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#1::runtime(move end_1, move len_2)
}

fn core::slice::index::slice_index_fail::do_panic#2(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#2::runtime(move start_1, move end_2)
}

fn core::slice::index::slice_index_fail::do_panic#3(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let end_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#3::runtime(move end_1, move len_2)
}

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
= <opaque>

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub opaque type NonNull<T>

// Full name: core::slice::index::private_slice_index::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::slice::index::private_slice_index::Sealed::{vtable}
}

// Full name: core::slice::index::SliceIndex
#[lang_item("SliceIndex")]
pub trait SliceIndex<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sealed<Self>
    parent_clause2 : [@TraitClause2]: MetaSized<T>
    parent_clause3 : [@TraitClause3]: MetaSized<Self::Output>
    type Output
    fn get<'_0_1> = core::slice::index::SliceIndex::get<'_0_1, Self, T>[Self]
    fn get_mut<'_0_1> = core::slice::index::SliceIndex::get_mut<'_0_1, Self, T>[Self]
    fn get_unchecked = core::slice::index::SliceIndex::get_unchecked<Self, T>[Self]
    fn get_unchecked_mut = core::slice::index::SliceIndex::get_unchecked_mut<Self, T>[Self]
    fn index<'_0_1> = core::slice::index::SliceIndex::index<'_0_1, Self, T>[Self]
    fn index_mut<'_0_1> = core::slice::index::SliceIndex::index_mut<'_0_1, Self, T>[Self]
    vtable: core::slice::index::SliceIndex::{vtable}<T, Self::Output>
}

pub fn core::slice::index::SliceIndex::index<'_0, Self, T>(@1: Self, @2: &'_0 T) -> &'_0 @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

// Full name: core::slice::index::{impl Index<I> for [T]}::index
pub fn {impl Index<I> for [T]}::index<'_0, T, I>(@1: &'_0 [T], @2: I) -> &'_0 @TraitClause2::Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T]>,
{
    let _0: &'0 @TraitClause2::Output; // return
    let self_1: &'1 [T]; // arg #1
    let index_2: I; // arg #2

    _0 = @TraitClause2::index<'3>(move index_2, move self_1)
    return
}

// Full name: core::slice::index::{impl Index<I> for [T]}
impl<T, I> Index<I> for [T]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T]>,
{
    parent_clause0 = {built_in impl MetaSized for [T]}
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause3
    type Output = @TraitClause2::Output
    fn index<'_0_1> = {impl Index<I> for [T]}::index<'_0_1, T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl Index<I> for [T]}::{vtable}<T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::slice::index::slice_index_fail
fn slice_index_fail(@1: usize, @2: usize, @3: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: !; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: bool; // anonymous local
    let _11: usize; // anonymous local
    let _12: usize; // anonymous local
    let _13: !; // anonymous local
    let _14: usize; // anonymous local
    let _15: usize; // anonymous local
    let _16: bool; // anonymous local
    let _17: usize; // anonymous local
    let _18: usize; // anonymous local
    let _19: !; // anonymous local
    let _20: usize; // anonymous local
    let _21: usize; // anonymous local
    let _22: usize; // anonymous local
    let _23: usize; // anonymous local

    storage_live(_4)
    storage_live(_5)
    _5 = copy start_1
    storage_live(_6)
    _6 = copy len_3
    _4 = move _5 > move _6
    if move _4 {
    } else {
        storage_dead(_6)
        storage_dead(_5)
        storage_dead(_4)
        storage_live(_10)
        storage_live(_11)
        _11 = copy end_2
        storage_live(_12)
        _12 = copy len_3
        _10 = move _11 > move _12
        if move _10 {
        } else {
            storage_dead(_12)
            storage_dead(_11)
            storage_dead(_10)
            storage_live(_16)
            storage_live(_17)
            _17 = copy start_1
            storage_live(_18)
            _18 = copy end_2
            _16 = move _17 > move _18
            if move _16 {
            } else {
                storage_dead(_18)
                storage_dead(_17)
                storage_dead(_16)
                storage_live(_22)
                _22 = copy end_2
                storage_live(_23)
                _23 = copy len_3
                _0 = core::slice::index::slice_index_fail::do_panic#3(move _22, move _23)
            }
            storage_dead(_18)
            storage_dead(_17)
            storage_live(_19)
            storage_live(_20)
            _20 = copy start_1
            storage_live(_21)
            _21 = copy end_2
            _19 = core::slice::index::slice_index_fail::do_panic#2(move _20, move _21)
        }
        storage_dead(_12)
        storage_dead(_11)
        storage_live(_13)
        storage_live(_14)
        _14 = copy end_2
        storage_live(_15)
        _15 = copy len_3
        _13 = core::slice::index::slice_index_fail::do_panic#1(move _14, move _15)
    }
    storage_dead(_6)
    storage_dead(_5)
    storage_live(_7)
    storage_live(_8)
    _8 = copy start_1
    storage_live(_9)
    _9 = copy len_3
    _7 = core::slice::index::slice_index_fail::do_panic(move _8, move _9)
}

// Full name: core::slice::index::private_slice_index::{impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
impl Sealed for Range<usize>[{built_in impl Sized for usize}] {
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    vtable: {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}::{vtable}
}

pub fn core::slice::index::SliceIndex::get<'_0, Self, T>(@1: Self, @2: &'_0 T) -> Option<&'_0 @TraitClause0::Output>[{built_in impl Sized for &'_0 @TraitClause0::Output}]
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub fn core::slice::index::SliceIndex::get_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut T) -> Option<&'_0 mut @TraitClause0::Output>[{built_in impl Sized for &'_0 mut @TraitClause0::Output}]
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T>(@1: Self, @2: *const T) -> *const @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T>(@1: Self, @2: *mut T) -> *mut @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub fn core::slice::index::SliceIndex::index_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut T) -> &'_0 mut @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> &'_0 mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 mut [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 mut [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: *mut [T]; // anonymous local
    let ptr_10: *mut [T]; // local
    let _11: !; // anonymous local
    let _12: usize; // anonymous local
    let _13: bool; // anonymous local
    let _14: usize; // anonymous local
    let _15: *mut T; // anonymous local
    let _16: *mut T; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_11)
    storage_live(_3)
    self_4 = copy (self_1).end
    rhs_5 = copy (self_1).start
    storage_live(_13)
    _13 = copy self_4 < copy rhs_5
    if move _13 {
        storage_dead(_13)
    } else {
        storage_live(_14)
        _14 = copy self_4 ub.- copy rhs_5
        _3 = Option::Some { 0: move _14 }
        storage_dead(_14)
        storage_dead(_13)
        new_len_6 = copy (_3 as variant Option::Some).0
        storage_live(_7)
        storage_live(_8)
        _8 = copy slice_2.metadata
        _7 = copy self_4 <= move _8
        if move _7 {
            storage_dead(_8)
            storage_live(_9)
            storage_live(ptr_10)
            ptr_10 = &raw mut (*slice_2) with_metadata(copy slice_2.metadata)
            storage_live(_15)
            storage_live(_16)
            _15 = cast<*mut [T], *mut T>(copy ptr_10)
            _16 = copy _15 offset copy rhs_5
            _9 = @PtrFromPartsMut<'_, [T]>(copy _16, copy new_len_6)
            storage_dead(_16)
            storage_dead(_15)
            storage_dead(ptr_10)
            _0 = &mut (*_9) with_metadata(copy _9.metadata)
            storage_dead(_9)
            storage_dead(_3)
            storage_dead(_7)
            return
        } else {
            storage_dead(_8)
        }
    }
    storage_dead(_3)
    storage_live(_12)
    _12 = copy slice_2.metadata
    _11 = slice_index_fail(move rhs_5, move self_4, move _12)
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> &'_0 [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'0 [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: *const [T]; // anonymous local
    let _10: *const [T]; // anonymous local
    let _11: !; // anonymous local
    let _12: usize; // anonymous local
    let _13: bool; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const T; // anonymous local
    let _16: *const T; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_11)
    storage_live(_3)
    self_4 = copy (self_1).end
    rhs_5 = copy (self_1).start
    storage_live(_13)
    _13 = copy self_4 < copy rhs_5
    if move _13 {
        storage_dead(_13)
    } else {
        storage_live(_14)
        _14 = copy self_4 ub.- copy rhs_5
        _3 = Option::Some { 0: move _14 }
        storage_dead(_14)
        storage_dead(_13)
        new_len_6 = copy (_3 as variant Option::Some).0
        storage_live(_7)
        storage_live(_8)
        _8 = copy slice_2.metadata
        _7 = copy self_4 <= move _8
        if move _7 {
            storage_dead(_8)
            storage_live(_9)
            storage_live(_10)
            _10 = &raw const (*slice_2) with_metadata(copy slice_2.metadata)
            storage_live(_15)
            storage_live(_16)
            _15 = cast<*const [T], *const T>(copy _10)
            _16 = copy _15 offset copy rhs_5
            _9 = @PtrFromPartsShared<'_, [T]>(copy _16, copy new_len_6)
            storage_dead(_16)
            storage_dead(_15)
            storage_dead(_10)
            _0 = &(*_9) with_metadata(copy _9.metadata)
            storage_dead(_9)
            storage_dead(_3)
            storage_dead(_7)
            return
        } else {
            storage_dead(_8)
        }
    }
    storage_dead(_3)
    storage_live(_12)
    _12 = copy slice_2.metadata
    _11 = slice_index_fail(move rhs_5, move self_4, move _12)
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check
fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check(@1: usize, @2: usize, @3: usize)
{
    let _0: (); // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: bool; // anonymous local
    let msg_6: &'0 Str; // local
    let _7: !; // anonymous local
    let _8: Arguments<'1>; // anonymous local
    let _9: NonNull<u8>; // anonymous local
    let _10: *const u8; // anonymous local
    let _11: NonNull<Argument<'2>>; // anonymous local
    let _12: usize; // anonymous local
    let _13: usize; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const Str; // anonymous local
    let _16: &'3 [u8]; // anonymous local

    storage_live(msg_6)
    storage_live(_7)
    _0 = ()
    storage_live(_4)
    _4 = copy end_2 >= copy start_1
    if move _4 {
        storage_live(_5)
        _5 = copy end_2 <= copy len_3
        if move _5 {
            storage_dead(_5)
            storage_dead(_4)
            return
        } else {
        }
    } else {
    }
    msg_6 = const "unsafe precondition(s) violated: slice::get_unchecked_mut requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    storage_live(_15)
    _15 = &raw const (*msg_6) with_metadata(copy msg_6.metadata)
    _10 = cast<*const Str, *const u8>(copy _15)
    storage_dead(_15)
    _9 = transmute<*const u8, NonNull<u8>>(copy _10)
    storage_dead(_10)
    storage_live(_11)
    storage_live(_12)
    storage_live(_13)
    storage_live(_14)
    storage_live(_16)
    _16 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: slice::get_unchecked_mut requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    _14 = copy _16.metadata
    storage_dead(_16)
    _13 = move _14 wrap.<< const 1 : i32
    storage_dead(_14)
    _12 = move _13 | const 1 : usize
    storage_dead(_13)
    _11 = transmute<usize, NonNull<Argument<'2>>>(move _12)
    storage_dead(_12)
    _8 = Arguments { 0: move _9, 1: move _11 }
    storage_dead(_11)
    storage_dead(_9)
    _7 = panic_nounwind_fmt<'6>(move _8, const false)
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut
pub unsafe fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *mut [T]) -> *mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *mut [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: *mut [T]; // arg #2
    let _3: bool; // anonymous local
    let _4: (); // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let new_len_8: usize; // local
    let _9: usize; // anonymous local
    let offset_10: usize; // local
    let _11: *mut T; // anonymous local
    let _12: *mut T; // anonymous local

    storage_live(_4)
    storage_live(new_len_8)
    storage_live(offset_10)
    storage_live(_3)
    _3 = ub_checks<bool>
    if move _3 {
        storage_live(_5)
        _5 = copy (self_1).start
        storage_live(_6)
        _6 = copy (self_1).end
        storage_live(_7)
        _7 = copy slice_2.metadata
        _4 = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check(move _5, move _6, move _7)
        storage_dead(_7)
        storage_dead(_6)
        storage_dead(_5)
    } else {
    }
    storage_dead(_3)
    storage_live(_9)
    _9 = copy (self_1).end
    offset_10 = copy (self_1).start
    new_len_8 = move _9 ub.- copy offset_10
    storage_dead(_9)
    storage_live(_11)
    storage_live(_12)
    _11 = cast<*mut [T], *mut T>(copy slice_2)
    _12 = copy _11 offset copy offset_10
    _0 = @PtrFromPartsMut<'_, [T]>(copy _12, copy new_len_8)
    storage_dead(_12)
    storage_dead(_11)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check
fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check(@1: usize, @2: usize, @3: usize)
{
    let _0: (); // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: bool; // anonymous local
    let msg_6: &'0 Str; // local
    let _7: !; // anonymous local
    let _8: Arguments<'1>; // anonymous local
    let _9: NonNull<u8>; // anonymous local
    let _10: *const u8; // anonymous local
    let _11: NonNull<Argument<'2>>; // anonymous local
    let _12: usize; // anonymous local
    let _13: usize; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const Str; // anonymous local
    let _16: &'3 [u8]; // anonymous local

    storage_live(msg_6)
    storage_live(_7)
    _0 = ()
    storage_live(_4)
    _4 = copy end_2 >= copy start_1
    if move _4 {
        storage_live(_5)
        _5 = copy end_2 <= copy len_3
        if move _5 {
            storage_dead(_5)
            storage_dead(_4)
            return
        } else {
        }
    } else {
    }
    msg_6 = const "unsafe precondition(s) violated: slice::get_unchecked requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    storage_live(_15)
    _15 = &raw const (*msg_6) with_metadata(copy msg_6.metadata)
    _10 = cast<*const Str, *const u8>(copy _15)
    storage_dead(_15)
    _9 = transmute<*const u8, NonNull<u8>>(copy _10)
    storage_dead(_10)
    storage_live(_11)
    storage_live(_12)
    storage_live(_13)
    storage_live(_14)
    storage_live(_16)
    _16 = transmute<&'0 Str, &'3 [u8]>(const "unsafe precondition(s) violated: slice::get_unchecked requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    _14 = copy _16.metadata
    storage_dead(_16)
    _13 = move _14 wrap.<< const 1 : i32
    storage_dead(_14)
    _12 = move _13 | const 1 : usize
    storage_dead(_13)
    _11 = transmute<usize, NonNull<Argument<'2>>>(move _12)
    storage_dead(_12)
    _8 = Arguments { 0: move _9, 1: move _11 }
    storage_dead(_11)
    storage_dead(_9)
    _7 = panic_nounwind_fmt<'6>(move _8, const false)
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked
pub unsafe fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *const [T]) -> *const [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *const [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: *const [T]; // arg #2
    let _3: bool; // anonymous local
    let _4: (); // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: usize; // anonymous local
    let new_len_8: usize; // local
    let _9: usize; // anonymous local
    let offset_10: usize; // local
    let _11: *const T; // anonymous local
    let _12: *const T; // anonymous local

    storage_live(_4)
    storage_live(new_len_8)
    storage_live(offset_10)
    storage_live(_3)
    _3 = ub_checks<bool>
    if move _3 {
        storage_live(_5)
        _5 = copy (self_1).start
        storage_live(_6)
        _6 = copy (self_1).end
        storage_live(_7)
        _7 = copy slice_2.metadata
        _4 = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check(move _5, move _6, move _7)
        storage_dead(_7)
        storage_dead(_6)
        storage_dead(_5)
    } else {
    }
    storage_dead(_3)
    storage_live(_9)
    _9 = copy (self_1).end
    offset_10 = copy (self_1).start
    new_len_8 = move _9 ub.- copy offset_10
    storage_dead(_9)
    storage_live(_11)
    storage_live(_12)
    _11 = cast<*const [T], *const T>(copy slice_2)
    _12 = copy _11 offset copy offset_10
    _0 = @PtrFromPartsShared<'_, [T]>(copy _12, copy new_len_8)
    storage_dead(_12)
    storage_dead(_11)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> Option<&'_0 mut [T]>[{built_in impl Sized for &'_0 mut [T]}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<&'0 mut [T]>[{built_in impl Sized for &'0 mut [T]}]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 mut [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'0 mut [T]; // anonymous local
    let _10: *mut [T]; // anonymous local
    let ptr_11: *mut [T]; // local
    let _12: bool; // anonymous local
    let _13: usize; // anonymous local
    let _14: *mut T; // anonymous local
    let _15: *mut T; // anonymous local
    let _16: Option<&'0 mut [T]>[{built_in impl Sized for &'0 mut [T]}]; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_9)
    storage_live(_3)
    self_4 = copy (self_1).end
    rhs_5 = copy (self_1).start
    storage_live(_12)
    _12 = copy self_4 < copy rhs_5
    if move _12 {
        storage_dead(_12)
        storage_dead(_3)
        storage_live(_16)
        _16 = Option::None {  }
        _0 = move _16
    } else {
        storage_live(_13)
        _13 = copy self_4 ub.- copy rhs_5
        _3 = Option::Some { 0: move _13 }
        storage_dead(_13)
        storage_dead(_12)
        new_len_6 = copy (_3 as variant Option::Some).0
        storage_live(_7)
        storage_live(_8)
        _8 = copy slice_2.metadata
        _7 = copy self_4 <= move _8
        if move _7 {
            storage_dead(_8)
            storage_live(_10)
            storage_live(ptr_11)
            ptr_11 = &raw mut (*slice_2) with_metadata(copy slice_2.metadata)
            storage_live(_14)
            storage_live(_15)
            _14 = cast<*mut [T], *mut T>(copy ptr_11)
            _15 = copy _14 offset copy rhs_5
            _10 = @PtrFromPartsMut<'_, [T]>(copy _15, copy new_len_6)
            storage_dead(_15)
            storage_dead(_14)
            storage_dead(ptr_11)
            _9 = &mut (*_10) with_metadata(copy _10.metadata)
            _0 = Option::Some { 0: copy _9 }
            storage_dead(_10)
            storage_dead(_3)
        } else {
            storage_dead(_8)
            storage_dead(_3)
            storage_live(_16)
            _16 = Option::None {  }
            _0 = move _16
        }
    }
    storage_dead(_7)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> Option<&'_0 [T]>[{built_in impl Sized for &'_0 [T]}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<&'0 [T]>[{built_in impl Sized for &'0 [T]}]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'0 [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'0 [T]; // anonymous local
    let _10: *const [T]; // anonymous local
    let _11: *const [T]; // anonymous local
    let _12: bool; // anonymous local
    let _13: usize; // anonymous local
    let _14: *const T; // anonymous local
    let _15: *const T; // anonymous local
    let _16: Option<&'0 [T]>[{built_in impl Sized for &'0 [T]}]; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_9)
    storage_live(_3)
    self_4 = copy (self_1).end
    rhs_5 = copy (self_1).start
    storage_live(_12)
    _12 = copy self_4 < copy rhs_5
    if move _12 {
        storage_dead(_12)
        storage_dead(_3)
        storage_live(_16)
        _16 = Option::None {  }
        _0 = move _16
    } else {
        storage_live(_13)
        _13 = copy self_4 ub.- copy rhs_5
        _3 = Option::Some { 0: move _13 }
        storage_dead(_13)
        storage_dead(_12)
        new_len_6 = copy (_3 as variant Option::Some).0
        storage_live(_7)
        storage_live(_8)
        _8 = copy slice_2.metadata
        _7 = copy self_4 <= move _8
        if move _7 {
            storage_dead(_8)
            storage_live(_10)
            storage_live(_11)
            _11 = &raw const (*slice_2) with_metadata(copy slice_2.metadata)
            storage_live(_14)
            storage_live(_15)
            _14 = cast<*const [T], *const T>(copy _11)
            _15 = copy _14 offset copy rhs_5
            _10 = @PtrFromPartsShared<'_, [T]>(copy _15, copy new_len_6)
            storage_dead(_15)
            storage_dead(_14)
            storage_dead(_11)
            _9 = &(*_10) with_metadata(copy _10.metadata)
            _0 = Option::Some { 0: copy _9 }
            storage_dead(_10)
            storage_dead(_3)
        } else {
            storage_dead(_8)
            storage_dead(_3)
            storage_live(_16)
            _16 = Option::None {  }
            _0 = move _16
        }
    }
    storage_dead(_7)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}
impl<T> SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause1 = {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause2 = {built_in impl MetaSized for [T]}
    parent_clause3 = {built_in impl MetaSized for [T]}
    type Output = [T]
    fn get<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0_1, T>[@TraitClause0]
    fn get_mut<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0_1, T>[@TraitClause0]
    fn get_unchecked = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0_1, T>[@TraitClause0]
    fn index_mut<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0_1, T>[@TraitClause0]
    vtable: {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::{vtable}<T>[@TraitClause0]
}

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let array_1: [i32; 6 : usize]; // local
    let slice_2: &'0 [i32]; // local
    let _3: &'0 [i32]; // anonymous local
    let _4: &'1 [i32; 6 : usize]; // anonymous local
    let _5: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _6: bool; // anonymous local
    let _7: i32; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'_ [i32]; // anonymous local
    let _10: &'_ i32; // anonymous local

    _0 = ()
    storage_live(array_1)
    array_1 = [const 1 : i32, const 2 : i32, const 3 : i32, const 4 : i32, const 5 : i32, const 6 : i32]
    storage_live(slice_2)
    storage_live(_3)
    storage_live(_4)
    _4 = &array_1
    storage_live(_5)
    _5 = Range { start: const 2 : usize, end: const 5 : usize }
    _3 = {impl#0}::index<'3, i32, Range<usize>[{built_in impl Sized for usize}], 6 : usize>[{built_in impl Sized for i32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl Index<I> for [T]}<i32, Range<usize>[{built_in impl Sized for usize}]>[{built_in impl Sized for i32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}<i32>[{built_in impl Sized for i32}]]](move _4, move _5)
    storage_dead(_5)
    storage_dead(_4)
    slice_2 = &(*_3) with_metadata(copy _3.metadata)
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    _8 = const 0 : usize
    storage_live(_9)
    _9 = &(*slice_2) with_metadata(copy slice_2.metadata)
    storage_live(_10)
    _10 = @SliceIndexShared<'_, i32>(move _9, copy _8)
    _7 = copy (*_10)
    _6 = move _7 == const 3 : i32
    if move _6 {
    } else {
        storage_dead(_7)
        storage_dead(_8)
        panic(core::panicking::panic)
    }
    storage_dead(_7)
    storage_dead(_8)
    storage_dead(_6)
    _0 = ()
    storage_dead(_3)
    storage_dead(slice_2)
    storage_dead(array_1)
    return
}



