# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::ops::index::Index
#[lang_item("index")]
pub trait Index<Self, Idx>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: MetaSized<Idx>
    parent_clause2 : [@TraitClause2]: MetaSized<Self::Output>
    type Output
    fn index<'_0_1> = core::ops::index::Index::index<'_0_1, Self, Idx>[Self]
    vtable: core::ops::index::Index::{vtable}<Idx, Self::Output>
}

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::array::{impl Index<I> for [T; N]}::index
pub fn {impl Index<I> for [T; N]}::index<'_0, T, I, const N : usize>(@1: &'_0 [T; N], @2: I) -> &'_0 @TraitClause2::Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Index<[T], I>,
= <opaque>

// Full name: core::fmt::Error
pub struct Error {}

// Full name: core::fmt::Arguments
#[lang_item("format_arguments")]
pub opaque type Arguments<'a>

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: core::fmt::num::imp::{impl Display for usize}::fmt
pub fn {impl Display for usize}::fmt<'_0, '_1, '_2>(@1: &'_0 usize, @2: &'_1 mut Formatter<'_2>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]
= <opaque>

// Full name: core::ptr::non_null::NonNull
#[lang_item("NonNull")]
pub opaque type NonNull<T>

// Full name: core::marker::PhantomData
#[lang_item("phantom_data")]
pub struct PhantomData<T> {}

// Full name: core::fmt::rt::ArgumentType
enum ArgumentType<'a> {
  Placeholder(value: NonNull<()>, formatter: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], _lifetime: PhantomData<&'a ()>),
  Count(u16),
}

// Full name: core::fmt::rt::Argument
#[lang_item("format_argument")]
pub opaque type Argument<'a>

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

fn core::slice::index::slice_index_fail::do_panic::runtime(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let len_2: usize; // arg #2
    let _3: Arguments<'1>; // anonymous local
    let args_4: &'3 usize; // local
    let args_5: &'4 usize; // local
    let args_6: [Argument<'7>; 2 : usize]; // local
    let _7: Argument<'8>; // anonymous local
    let _8: Argument<'9>; // anonymous local
    let args_9: &'12 [Argument<'13>; 2 : usize]; // local
    let _10: ArgumentType<'15>; // anonymous local
    let _11: NonNull<()>; // anonymous local
    let _12: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _13: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _14: *const usize; // anonymous local
    let _15: *const (); // anonymous local
    let _16: ArgumentType<'16>; // anonymous local
    let _17: NonNull<()>; // anonymous local
    let _18: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _19: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _20: *const usize; // anonymous local
    let _21: *const (); // anonymous local
    let _22: NonNull<u8>; // anonymous local
    let _23: NonNull<Argument<'18>>; // anonymous local
    let _24: PhantomData<&'30 ()>; // anonymous local
    let _25: PhantomData<&'39 ()>; // anonymous local
    let _26: [u8; 57 : usize]; // anonymous local
    let _27: &'44 [u8; 57 : usize]; // anonymous local

    storage_live(args_4)
    storage_live(args_5)
    storage_live(args_9)
    storage_live(_3)
    args_4 = &start_1
    args_5 = &len_2
    storage_live(args_6)
    storage_live(_7)
    storage_live(_13)
    storage_live(_14)
    storage_live(_10)
    storage_live(_11)
    _14 = &raw const (*args_4)
    storage_live(_15)
    _15 = cast<*const usize, *const ()>(copy _14)
    _11 = NonNull { 0: copy _15 }
    storage_dead(_15)
    storage_live(_12)
    _13 = cast<for<'_0_1, '_1_1, '_2_1> {impl Display for usize}::fmt<'_0_1, '_1_1, '_2_1>, fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(const {impl Display for usize}::fmt<'25, '26, '27>)
    _12 = transmute<fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(copy _13)
    storage_live(_24)
    _24 = PhantomData {  }
    _10 = ArgumentType::Placeholder { value: move _11, formatter: copy _12, _lifetime: move _24 }
    storage_dead(_12)
    storage_dead(_11)
    _7 = Argument { 0: move _10 }
    storage_dead(_10)
    storage_dead(_14)
    storage_dead(_13)
    storage_live(_8)
    storage_live(_19)
    storage_live(_20)
    storage_live(_16)
    storage_live(_17)
    _20 = &raw const (*args_5)
    storage_live(_21)
    _21 = cast<*const usize, *const ()>(copy _20)
    _17 = NonNull { 0: copy _21 }
    storage_dead(_21)
    storage_live(_18)
    _19 = cast<for<'_0_1, '_1_1, '_2_1> {impl Display for usize}::fmt<'_0_1, '_1_1, '_2_1>, fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(const {impl Display for usize}::fmt<'36, '37, '38>)
    _18 = transmute<fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(copy _19)
    storage_live(_25)
    _25 = PhantomData {  }
    _16 = ArgumentType::Placeholder { value: move _17, formatter: copy _18, _lifetime: move _25 }
    storage_dead(_18)
    storage_dead(_17)
    _8 = Argument { 0: move _16 }
    storage_dead(_16)
    storage_dead(_20)
    storage_dead(_19)
    args_6 = [move _7, move _8]
    storage_dead(_8)
    storage_dead(_7)
    args_9 = &args_6
    storage_live(_22)
    storage_live(_26)
    _26 = [const 18 : u8, const 114 : u8, const 97 : u8, const 110 : u8, const 103 : u8, const 101 : u8, const 32 : u8, const 115 : u8, const 116 : u8, const 97 : u8, const 114 : u8, const 116 : u8, const 32 : u8, const 105 : u8, const 110 : u8, const 100 : u8, const 101 : u8, const 120 : u8, const 32 : u8, const 192 : u8, const 34 : u8, const 32 : u8, const 111 : u8, const 117 : u8, const 116 : u8, const 32 : u8, const 111 : u8, const 102 : u8, const 32 : u8, const 114 : u8, const 97 : u8, const 110 : u8, const 103 : u8, const 101 : u8, const 32 : u8, const 102 : u8, const 111 : u8, const 114 : u8, const 32 : u8, const 115 : u8, const 108 : u8, const 105 : u8, const 99 : u8, const 101 : u8, const 32 : u8, const 111 : u8, const 102 : u8, const 32 : u8, const 108 : u8, const 101 : u8, const 110 : u8, const 103 : u8, const 116 : u8, const 104 : u8, const 32 : u8, const 192 : u8, const 0 : u8]
    storage_live(_27)
    _27 = &_26
    _22 = transmute<&'44 [u8; 57 : usize], NonNull<u8>>(move _27)
    storage_live(_23)
    _23 = transmute<&'12 [Argument<'13>; 2 : usize], NonNull<Argument<'45>>>(copy args_9)
    _3 = Arguments { 0: move _22, 1: move _23 }
    storage_dead(_23)
    storage_dead(_22)
    panic(core::panicking::panic_fmt)
}

fn core::slice::index::slice_index_fail::do_panic#1::runtime(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let end_1: usize; // arg #1
    let len_2: usize; // arg #2
    let _3: Arguments<'1>; // anonymous local
    let args_4: &'3 usize; // local
    let args_5: &'4 usize; // local
    let args_6: [Argument<'7>; 2 : usize]; // local
    let _7: Argument<'8>; // anonymous local
    let _8: Argument<'9>; // anonymous local
    let args_9: &'12 [Argument<'13>; 2 : usize]; // local
    let _10: ArgumentType<'15>; // anonymous local
    let _11: NonNull<()>; // anonymous local
    let _12: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _13: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _14: *const usize; // anonymous local
    let _15: *const (); // anonymous local
    let _16: ArgumentType<'16>; // anonymous local
    let _17: NonNull<()>; // anonymous local
    let _18: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _19: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _20: *const usize; // anonymous local
    let _21: *const (); // anonymous local
    let _22: NonNull<u8>; // anonymous local
    let _23: NonNull<Argument<'18>>; // anonymous local
    let _24: PhantomData<&'30 ()>; // anonymous local
    let _25: PhantomData<&'39 ()>; // anonymous local
    let _26: [u8; 55 : usize]; // anonymous local
    let _27: &'44 [u8; 55 : usize]; // anonymous local

    storage_live(args_4)
    storage_live(args_5)
    storage_live(args_9)
    storage_live(_3)
    args_4 = &end_1
    args_5 = &len_2
    storage_live(args_6)
    storage_live(_7)
    storage_live(_13)
    storage_live(_14)
    storage_live(_10)
    storage_live(_11)
    _14 = &raw const (*args_4)
    storage_live(_15)
    _15 = cast<*const usize, *const ()>(copy _14)
    _11 = NonNull { 0: copy _15 }
    storage_dead(_15)
    storage_live(_12)
    _13 = cast<for<'_0_1, '_1_1, '_2_1> {impl Display for usize}::fmt<'_0_1, '_1_1, '_2_1>, fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(const {impl Display for usize}::fmt<'25, '26, '27>)
    _12 = transmute<fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(copy _13)
    storage_live(_24)
    _24 = PhantomData {  }
    _10 = ArgumentType::Placeholder { value: move _11, formatter: copy _12, _lifetime: move _24 }
    storage_dead(_12)
    storage_dead(_11)
    _7 = Argument { 0: move _10 }
    storage_dead(_10)
    storage_dead(_14)
    storage_dead(_13)
    storage_live(_8)
    storage_live(_19)
    storage_live(_20)
    storage_live(_16)
    storage_live(_17)
    _20 = &raw const (*args_5)
    storage_live(_21)
    _21 = cast<*const usize, *const ()>(copy _20)
    _17 = NonNull { 0: copy _21 }
    storage_dead(_21)
    storage_live(_18)
    _19 = cast<for<'_0_1, '_1_1, '_2_1> {impl Display for usize}::fmt<'_0_1, '_1_1, '_2_1>, fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(const {impl Display for usize}::fmt<'36, '37, '38>)
    _18 = transmute<fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(copy _19)
    storage_live(_25)
    _25 = PhantomData {  }
    _16 = ArgumentType::Placeholder { value: move _17, formatter: copy _18, _lifetime: move _25 }
    storage_dead(_18)
    storage_dead(_17)
    _8 = Argument { 0: move _16 }
    storage_dead(_16)
    storage_dead(_20)
    storage_dead(_19)
    args_6 = [move _7, move _8]
    storage_dead(_8)
    storage_dead(_7)
    args_9 = &args_6
    storage_live(_22)
    storage_live(_26)
    _26 = [const 16 : u8, const 114 : u8, const 97 : u8, const 110 : u8, const 103 : u8, const 101 : u8, const 32 : u8, const 101 : u8, const 110 : u8, const 100 : u8, const 32 : u8, const 105 : u8, const 110 : u8, const 100 : u8, const 101 : u8, const 120 : u8, const 32 : u8, const 192 : u8, const 34 : u8, const 32 : u8, const 111 : u8, const 117 : u8, const 116 : u8, const 32 : u8, const 111 : u8, const 102 : u8, const 32 : u8, const 114 : u8, const 97 : u8, const 110 : u8, const 103 : u8, const 101 : u8, const 32 : u8, const 102 : u8, const 111 : u8, const 114 : u8, const 32 : u8, const 115 : u8, const 108 : u8, const 105 : u8, const 99 : u8, const 101 : u8, const 32 : u8, const 111 : u8, const 102 : u8, const 32 : u8, const 108 : u8, const 101 : u8, const 110 : u8, const 103 : u8, const 116 : u8, const 104 : u8, const 32 : u8, const 192 : u8, const 0 : u8]
    storage_live(_27)
    _27 = &_26
    _22 = transmute<&'44 [u8; 55 : usize], NonNull<u8>>(move _27)
    storage_live(_23)
    _23 = transmute<&'12 [Argument<'13>; 2 : usize], NonNull<Argument<'45>>>(copy args_9)
    _3 = Arguments { 0: move _22, 1: move _23 }
    storage_dead(_23)
    storage_dead(_22)
    panic(core::panicking::panic_fmt)
}

fn core::slice::index::slice_index_fail::do_panic#2::runtime(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let _3: Arguments<'1>; // anonymous local
    let args_4: &'3 usize; // local
    let args_5: &'4 usize; // local
    let args_6: [Argument<'7>; 2 : usize]; // local
    let _7: Argument<'8>; // anonymous local
    let _8: Argument<'9>; // anonymous local
    let args_9: &'12 [Argument<'13>; 2 : usize]; // local
    let _10: ArgumentType<'15>; // anonymous local
    let _11: NonNull<()>; // anonymous local
    let _12: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _13: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _14: *const usize; // anonymous local
    let _15: *const (); // anonymous local
    let _16: ArgumentType<'16>; // anonymous local
    let _17: NonNull<()>; // anonymous local
    let _18: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _19: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _20: *const usize; // anonymous local
    let _21: *const (); // anonymous local
    let _22: NonNull<u8>; // anonymous local
    let _23: NonNull<Argument<'18>>; // anonymous local
    let _24: PhantomData<&'30 ()>; // anonymous local
    let _25: PhantomData<&'39 ()>; // anonymous local
    let _26: [u8; 40 : usize]; // anonymous local
    let _27: &'44 [u8; 40 : usize]; // anonymous local

    storage_live(args_4)
    storage_live(args_5)
    storage_live(args_9)
    storage_live(_3)
    args_4 = &start_1
    args_5 = &end_2
    storage_live(args_6)
    storage_live(_7)
    storage_live(_13)
    storage_live(_14)
    storage_live(_10)
    storage_live(_11)
    _14 = &raw const (*args_4)
    storage_live(_15)
    _15 = cast<*const usize, *const ()>(copy _14)
    _11 = NonNull { 0: copy _15 }
    storage_dead(_15)
    storage_live(_12)
    _13 = cast<for<'_0_1, '_1_1, '_2_1> {impl Display for usize}::fmt<'_0_1, '_1_1, '_2_1>, fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(const {impl Display for usize}::fmt<'25, '26, '27>)
    _12 = transmute<fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(copy _13)
    storage_live(_24)
    _24 = PhantomData {  }
    _10 = ArgumentType::Placeholder { value: move _11, formatter: copy _12, _lifetime: move _24 }
    storage_dead(_12)
    storage_dead(_11)
    _7 = Argument { 0: move _10 }
    storage_dead(_10)
    storage_dead(_14)
    storage_dead(_13)
    storage_live(_8)
    storage_live(_19)
    storage_live(_20)
    storage_live(_16)
    storage_live(_17)
    _20 = &raw const (*args_5)
    storage_live(_21)
    _21 = cast<*const usize, *const ()>(copy _20)
    _17 = NonNull { 0: copy _21 }
    storage_dead(_21)
    storage_live(_18)
    _19 = cast<for<'_0_1, '_1_1, '_2_1> {impl Display for usize}::fmt<'_0_1, '_1_1, '_2_1>, fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(const {impl Display for usize}::fmt<'36, '37, '38>)
    _18 = transmute<fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(copy _19)
    storage_live(_25)
    _25 = PhantomData {  }
    _16 = ArgumentType::Placeholder { value: move _17, formatter: copy _18, _lifetime: move _25 }
    storage_dead(_18)
    storage_dead(_17)
    _8 = Argument { 0: move _16 }
    storage_dead(_16)
    storage_dead(_20)
    storage_dead(_19)
    args_6 = [move _7, move _8]
    storage_dead(_8)
    storage_dead(_7)
    args_9 = &args_6
    storage_live(_22)
    storage_live(_26)
    _26 = [const 22 : u8, const 115 : u8, const 108 : u8, const 105 : u8, const 99 : u8, const 101 : u8, const 32 : u8, const 105 : u8, const 110 : u8, const 100 : u8, const 101 : u8, const 120 : u8, const 32 : u8, const 115 : u8, const 116 : u8, const 97 : u8, const 114 : u8, const 116 : u8, const 115 : u8, const 32 : u8, const 97 : u8, const 116 : u8, const 32 : u8, const 192 : u8, const 13 : u8, const 32 : u8, const 98 : u8, const 117 : u8, const 116 : u8, const 32 : u8, const 101 : u8, const 110 : u8, const 100 : u8, const 115 : u8, const 32 : u8, const 97 : u8, const 116 : u8, const 32 : u8, const 192 : u8, const 0 : u8]
    storage_live(_27)
    _27 = &_26
    _22 = transmute<&'44 [u8; 40 : usize], NonNull<u8>>(move _27)
    storage_live(_23)
    _23 = transmute<&'12 [Argument<'13>; 2 : usize], NonNull<Argument<'45>>>(copy args_9)
    _3 = Arguments { 0: move _22, 1: move _23 }
    storage_dead(_23)
    storage_dead(_22)
    panic(core::panicking::panic_fmt)
}

fn core::slice::index::slice_index_fail::do_panic#3::runtime(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let end_1: usize; // arg #1
    let len_2: usize; // arg #2
    let _3: Arguments<'1>; // anonymous local
    let args_4: &'3 usize; // local
    let args_5: &'4 usize; // local
    let args_6: [Argument<'7>; 2 : usize]; // local
    let _7: Argument<'8>; // anonymous local
    let _8: Argument<'9>; // anonymous local
    let args_9: &'12 [Argument<'13>; 2 : usize]; // local
    let _10: ArgumentType<'15>; // anonymous local
    let _11: NonNull<()>; // anonymous local
    let _12: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _13: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _14: *const usize; // anonymous local
    let _15: *const (); // anonymous local
    let _16: ArgumentType<'16>; // anonymous local
    let _17: NonNull<()>; // anonymous local
    let _18: unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _19: fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]; // anonymous local
    let _20: *const usize; // anonymous local
    let _21: *const (); // anonymous local
    let _22: NonNull<u8>; // anonymous local
    let _23: NonNull<Argument<'18>>; // anonymous local
    let _24: PhantomData<&'30 ()>; // anonymous local
    let _25: PhantomData<&'39 ()>; // anonymous local
    let _26: [u8; 55 : usize]; // anonymous local
    let _27: &'44 [u8; 55 : usize]; // anonymous local

    storage_live(args_4)
    storage_live(args_5)
    storage_live(args_9)
    storage_live(_3)
    args_4 = &end_1
    args_5 = &len_2
    storage_live(args_6)
    storage_live(_7)
    storage_live(_13)
    storage_live(_14)
    storage_live(_10)
    storage_live(_11)
    _14 = &raw const (*args_4)
    storage_live(_15)
    _15 = cast<*const usize, *const ()>(copy _14)
    _11 = NonNull { 0: copy _15 }
    storage_dead(_15)
    storage_live(_12)
    _13 = cast<for<'_0_1, '_1_1, '_2_1> {impl Display for usize}::fmt<'_0_1, '_1_1, '_2_1>, fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(const {impl Display for usize}::fmt<'25, '26, '27>)
    _12 = transmute<fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(copy _13)
    storage_live(_24)
    _24 = PhantomData {  }
    _10 = ArgumentType::Placeholder { value: move _11, formatter: copy _12, _lifetime: move _24 }
    storage_dead(_12)
    storage_dead(_11)
    _7 = Argument { 0: move _10 }
    storage_dead(_10)
    storage_dead(_14)
    storage_dead(_13)
    storage_live(_8)
    storage_live(_19)
    storage_live(_20)
    storage_live(_16)
    storage_live(_17)
    _20 = &raw const (*args_5)
    storage_live(_21)
    _21 = cast<*const usize, *const ()>(copy _20)
    _17 = NonNull { 0: copy _21 }
    storage_dead(_21)
    storage_live(_18)
    _19 = cast<for<'_0_1, '_1_1, '_2_1> {impl Display for usize}::fmt<'_0_1, '_1_1, '_2_1>, fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(const {impl Display for usize}::fmt<'36, '37, '38>)
    _18 = transmute<fn<'_0_1, '_1_1, '_2_1>(&'_0_1 usize, &'_1_1 mut Formatter<'_2_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}], unsafe fn<'_0_1, '_1_1>(NonNull<()>, &'_0_1 mut Formatter<'_1_1>) -> Result<(), Error>[{built_in impl Sized for ()}, {built_in impl Sized for Error}]>(copy _19)
    storage_live(_25)
    _25 = PhantomData {  }
    _16 = ArgumentType::Placeholder { value: move _17, formatter: copy _18, _lifetime: move _25 }
    storage_dead(_18)
    storage_dead(_17)
    _8 = Argument { 0: move _16 }
    storage_dead(_16)
    storage_dead(_20)
    storage_dead(_19)
    args_6 = [move _7, move _8]
    storage_dead(_8)
    storage_dead(_7)
    args_9 = &args_6
    storage_live(_22)
    storage_live(_26)
    _26 = [const 16 : u8, const 114 : u8, const 97 : u8, const 110 : u8, const 103 : u8, const 101 : u8, const 32 : u8, const 101 : u8, const 110 : u8, const 100 : u8, const 32 : u8, const 105 : u8, const 110 : u8, const 100 : u8, const 101 : u8, const 120 : u8, const 32 : u8, const 192 : u8, const 34 : u8, const 32 : u8, const 111 : u8, const 117 : u8, const 116 : u8, const 32 : u8, const 111 : u8, const 102 : u8, const 32 : u8, const 114 : u8, const 97 : u8, const 110 : u8, const 103 : u8, const 101 : u8, const 32 : u8, const 102 : u8, const 111 : u8, const 114 : u8, const 32 : u8, const 115 : u8, const 108 : u8, const 105 : u8, const 99 : u8, const 101 : u8, const 32 : u8, const 111 : u8, const 102 : u8, const 32 : u8, const 108 : u8, const 101 : u8, const 110 : u8, const 103 : u8, const 116 : u8, const 104 : u8, const 32 : u8, const 192 : u8, const 0 : u8]
    storage_live(_27)
    _27 = &_26
    _22 = transmute<&'44 [u8; 55 : usize], NonNull<u8>>(move _27)
    storage_live(_23)
    _23 = transmute<&'12 [Argument<'13>; 2 : usize], NonNull<Argument<'45>>>(copy args_9)
    _3 = Arguments { 0: move _22, 1: move _23 }
    storage_dead(_23)
    storage_dead(_22)
    panic(core::panicking::panic_fmt)
}

pub fn core::ops::index::Index::index<'_0, Self, Idx>(@1: &'_0 Self, @2: Idx) -> &'_0 @TraitClause0::Output
where
    [@TraitClause0]: Index<Self, Idx>,
= <opaque>

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

fn core::slice::index::slice_index_fail::do_panic(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic::runtime(move start_1, move len_2)
}

fn core::slice::index::slice_index_fail::do_panic#1(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let end_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#1::runtime(move end_1, move len_2)
}

fn core::slice::index::slice_index_fail::do_panic#2(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#2::runtime(move start_1, move end_2)
}

fn core::slice::index::slice_index_fail::do_panic#3(@1: usize, @2: usize) -> !
{
    let _0: !; // return
    let end_1: usize; // arg #1
    let len_2: usize; // arg #2

    _0 = core::slice::index::slice_index_fail::do_panic#3::runtime(move end_1, move len_2)
}

// Full name: core::panicking::panic_nounwind_fmt
pub fn panic_nounwind_fmt<'_0>(@1: Arguments<'_0>, @2: bool) -> !
= <opaque>

// Full name: core::slice::index::private_slice_index::Sealed
pub trait Sealed<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::slice::index::private_slice_index::Sealed::{vtable}
}

// Full name: core::slice::index::SliceIndex
#[lang_item("SliceIndex")]
pub trait SliceIndex<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sealed<Self>
    parent_clause2 : [@TraitClause2]: MetaSized<T>
    parent_clause3 : [@TraitClause3]: MetaSized<Self::Output>
    type Output
    fn get<'_0_1> = core::slice::index::SliceIndex::get<'_0_1, Self, T>[Self]
    fn get_mut<'_0_1> = core::slice::index::SliceIndex::get_mut<'_0_1, Self, T>[Self]
    fn get_unchecked = core::slice::index::SliceIndex::get_unchecked<Self, T>[Self]
    fn get_unchecked_mut = core::slice::index::SliceIndex::get_unchecked_mut<Self, T>[Self]
    fn index<'_0_1> = core::slice::index::SliceIndex::index<'_0_1, Self, T>[Self]
    fn index_mut<'_0_1> = core::slice::index::SliceIndex::index_mut<'_0_1, Self, T>[Self]
    vtable: core::slice::index::SliceIndex::{vtable}<T, Self::Output>
}

pub fn core::slice::index::SliceIndex::index<'_0, Self, T>(@1: Self, @2: &'_0 T) -> &'_0 @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

// Full name: core::slice::index::{impl Index<I> for [T]}::index
pub fn {impl Index<I> for [T]}::index<'_0, T, I>(@1: &'_0 [T], @2: I) -> &'_0 @TraitClause2::Output
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T]>,
{
    let _0: &'1 @TraitClause2::Output; // return
    let self_1: &'3 [T]; // arg #1
    let index_2: I; // arg #2

    _0 = @TraitClause2::index<'5>(move index_2, move self_1)
    return
}

// Full name: core::slice::index::{impl Index<I> for [T]}
impl<T, I> Index<I> for [T]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: SliceIndex<I, [T]>,
{
    parent_clause0 = {built_in impl MetaSized for [T]}
    parent_clause1 = @TraitClause1::parent_clause0
    parent_clause2 = @TraitClause2::parent_clause3
    type Output = @TraitClause2::Output
    fn index<'_0_1> = {impl Index<I> for [T]}::index<'_0_1, T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
    vtable: {impl Index<I> for [T]}::{vtable}<T, I>[@TraitClause0, @TraitClause1, @TraitClause2]
}

// Full name: core::slice::index::slice_index_fail
fn slice_index_fail(@1: usize, @2: usize, @3: usize) -> !
{
    let _0: !; // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let _7: !; // anonymous local
    let _8: usize; // anonymous local
    let _9: usize; // anonymous local
    let _10: bool; // anonymous local
    let _11: usize; // anonymous local
    let _12: usize; // anonymous local
    let _13: !; // anonymous local
    let _14: usize; // anonymous local
    let _15: usize; // anonymous local
    let _16: bool; // anonymous local
    let _17: usize; // anonymous local
    let _18: usize; // anonymous local
    let _19: !; // anonymous local
    let _20: usize; // anonymous local
    let _21: usize; // anonymous local
    let _22: usize; // anonymous local
    let _23: usize; // anonymous local

    storage_live(_4)
    storage_live(_5)
    _5 = copy start_1
    storage_live(_6)
    _6 = copy len_3
    _4 = move _5 > move _6
    if move _4 {
    } else {
        storage_dead(_6)
        storage_dead(_5)
        storage_dead(_4)
        storage_live(_10)
        storage_live(_11)
        _11 = copy end_2
        storage_live(_12)
        _12 = copy len_3
        _10 = move _11 > move _12
        if move _10 {
        } else {
            storage_dead(_12)
            storage_dead(_11)
            storage_dead(_10)
            storage_live(_16)
            storage_live(_17)
            _17 = copy start_1
            storage_live(_18)
            _18 = copy end_2
            _16 = move _17 > move _18
            if move _16 {
            } else {
                storage_dead(_18)
                storage_dead(_17)
                storage_dead(_16)
                storage_live(_22)
                _22 = copy end_2
                storage_live(_23)
                _23 = copy len_3
                _0 = core::slice::index::slice_index_fail::do_panic#3(move _22, move _23)
            }
            storage_dead(_18)
            storage_dead(_17)
            storage_live(_19)
            storage_live(_20)
            _20 = copy start_1
            storage_live(_21)
            _21 = copy end_2
            _19 = core::slice::index::slice_index_fail::do_panic#2(move _20, move _21)
        }
        storage_dead(_12)
        storage_dead(_11)
        storage_live(_13)
        storage_live(_14)
        _14 = copy end_2
        storage_live(_15)
        _15 = copy len_3
        _13 = core::slice::index::slice_index_fail::do_panic#1(move _14, move _15)
    }
    storage_dead(_6)
    storage_dead(_5)
    storage_live(_7)
    storage_live(_8)
    _8 = copy start_1
    storage_live(_9)
    _9 = copy len_3
    _7 = core::slice::index::slice_index_fail::do_panic(move _8, move _9)
}

// Full name: core::slice::index::private_slice_index::{impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
impl Sealed for Range<usize>[{built_in impl Sized for usize}] {
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    vtable: {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}::{vtable}
}

pub fn core::slice::index::SliceIndex::get<'_0, Self, T>(@1: Self, @2: &'_0 T) -> Option<&'_0 @TraitClause0::Output>[{built_in impl Sized for &'_0 @TraitClause0::Output}]
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub fn core::slice::index::SliceIndex::get_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut T) -> Option<&'_0 mut @TraitClause0::Output>[{built_in impl Sized for &'_0 mut @TraitClause0::Output}]
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked<Self, T>(@1: Self, @2: *const T) -> *const @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub unsafe fn core::slice::index::SliceIndex::get_unchecked_mut<Self, T>(@1: Self, @2: *mut T) -> *mut @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

pub fn core::slice::index::SliceIndex::index_mut<'_0, Self, T>(@1: Self, @2: &'_0 mut T) -> &'_0 mut @TraitClause0::Output
where
    [@TraitClause0]: SliceIndex<Self, T>,
= <method_without_default_body>

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> &'_0 mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'1 mut [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'2 mut [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: *mut [T]; // anonymous local
    let ptr_10: *mut [T]; // local
    let _11: !; // anonymous local
    let _12: usize; // anonymous local
    let _13: bool; // anonymous local
    let _14: usize; // anonymous local
    let _15: *mut T; // anonymous local
    let _16: *mut T; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_11)
    storage_live(_3)
    self_4 = copy (self_1).end
    rhs_5 = copy (self_1).start
    storage_live(_13)
    _13 = copy self_4 < copy rhs_5
    if move _13 {
        storage_dead(_13)
    } else {
        storage_live(_14)
        _14 = copy self_4 ub.- copy rhs_5
        _3 = Option::Some { 0: move _14 }
        storage_dead(_14)
        storage_dead(_13)
        new_len_6 = copy (_3 as variant Option::Some).0
        storage_live(_7)
        storage_live(_8)
        _8 = copy slice_2.metadata
        _7 = copy self_4 <= move _8
        if move _7 {
            storage_dead(_8)
            storage_live(_9)
            storage_live(ptr_10)
            ptr_10 = &raw mut (*slice_2) with_metadata(copy slice_2.metadata)
            storage_live(_15)
            storage_live(_16)
            _15 = cast<*mut [T], *mut T>(copy ptr_10)
            _16 = copy _15 offset copy rhs_5
            _9 = @PtrFromPartsMut<'_, [T]>(copy _16, copy new_len_6)
            storage_dead(_16)
            storage_dead(_15)
            storage_dead(ptr_10)
            _0 = &mut (*_9) with_metadata(copy _9.metadata)
            storage_dead(_9)
            storage_dead(_3)
            storage_dead(_7)
            return
        } else {
            storage_dead(_8)
        }
    }
    storage_dead(_3)
    storage_live(_12)
    _12 = copy slice_2.metadata
    _11 = slice_index_fail(move rhs_5, move self_4, move _12)
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> &'_0 [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: &'1 [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'2 [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: *const [T]; // anonymous local
    let _10: *const [T]; // anonymous local
    let _11: !; // anonymous local
    let _12: usize; // anonymous local
    let _13: bool; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const T; // anonymous local
    let _16: *const T; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_11)
    storage_live(_3)
    self_4 = copy (self_1).end
    rhs_5 = copy (self_1).start
    storage_live(_13)
    _13 = copy self_4 < copy rhs_5
    if move _13 {
        storage_dead(_13)
    } else {
        storage_live(_14)
        _14 = copy self_4 ub.- copy rhs_5
        _3 = Option::Some { 0: move _14 }
        storage_dead(_14)
        storage_dead(_13)
        new_len_6 = copy (_3 as variant Option::Some).0
        storage_live(_7)
        storage_live(_8)
        _8 = copy slice_2.metadata
        _7 = copy self_4 <= move _8
        if move _7 {
            storage_dead(_8)
            storage_live(_9)
            storage_live(_10)
            _10 = &raw const (*slice_2) with_metadata(copy slice_2.metadata)
            storage_live(_15)
            storage_live(_16)
            _15 = cast<*const [T], *const T>(copy _10)
            _16 = copy _15 offset copy rhs_5
            _9 = @PtrFromPartsShared<'_, [T]>(copy _16, copy new_len_6)
            storage_dead(_16)
            storage_dead(_15)
            storage_dead(_10)
            _0 = &(*_9) with_metadata(copy _9.metadata)
            storage_dead(_9)
            storage_dead(_3)
            storage_dead(_7)
            return
        } else {
            storage_dead(_8)
        }
    }
    storage_dead(_3)
    storage_live(_12)
    _12 = copy slice_2.metadata
    _11 = slice_index_fail(move rhs_5, move self_4, move _12)
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check
fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check(@1: usize, @2: usize, @3: usize)
{
    let _0: (); // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: bool; // anonymous local
    let msg_6: &'1 Str; // local
    let _7: !; // anonymous local
    let _8: Arguments<'3>; // anonymous local
    let _9: NonNull<u8>; // anonymous local
    let _10: *const u8; // anonymous local
    let _11: NonNull<Argument<'6>>; // anonymous local
    let _12: usize; // anonymous local
    let _13: usize; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const Str; // anonymous local
    let _16: &'8 [u8]; // anonymous local

    storage_live(msg_6)
    storage_live(_7)
    _0 = ()
    storage_live(_4)
    _4 = copy end_2 >= copy start_1
    if move _4 {
        storage_live(_5)
        _5 = copy end_2 <= copy len_3
        if move _5 {
            storage_dead(_5)
            storage_dead(_4)
            return
        } else {
        }
    } else {
    }
    msg_6 = const "unsafe precondition(s) violated: slice::get_unchecked_mut requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    storage_live(_15)
    _15 = &raw const (*msg_6) with_metadata(copy msg_6.metadata)
    _10 = cast<*const Str, *const u8>(copy _15)
    storage_dead(_15)
    _9 = transmute<*const u8, NonNull<u8>>(copy _10)
    storage_dead(_10)
    storage_live(_11)
    storage_live(_12)
    storage_live(_13)
    storage_live(_14)
    storage_live(_16)
    _16 = transmute<&'11 Str, &'10 [u8]>(const "unsafe precondition(s) violated: slice::get_unchecked_mut requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    _14 = copy _16.metadata
    storage_dead(_16)
    _13 = move _14 wrap.<< const 1 : i32
    storage_dead(_14)
    _12 = move _13 | const 1 : usize
    storage_dead(_13)
    _11 = transmute<usize, NonNull<Argument<'12>>>(move _12)
    storage_dead(_12)
    _8 = Arguments { 0: move _9, 1: move _11 }
    storage_dead(_11)
    storage_dead(_9)
    _7 = panic_nounwind_fmt<'15>(move _8, const false)
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut
pub unsafe fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *mut [T]) -> *mut [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *mut [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: *mut [T]; // arg #2
    let _3: (); // anonymous local
    let _4: usize; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let new_len_7: usize; // local
    let _8: usize; // anonymous local
    let offset_9: usize; // local
    let _10: *mut T; // anonymous local
    let _11: *mut T; // anonymous local
    let _12: bool; // anonymous local

    storage_live(_3)
    storage_live(new_len_7)
    storage_live(offset_9)
    storage_live(_12)
    _12 = ub_checks<bool>
    if move _12 {
        storage_live(_4)
        _4 = copy (self_1).start
        storage_live(_5)
        _5 = copy (self_1).end
        storage_live(_6)
        _6 = copy slice_2.metadata
        _3 = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut::precondition_check(move _4, move _5, move _6)
        storage_dead(_6)
        storage_dead(_5)
        storage_dead(_4)
    } else {
    }
    storage_live(_8)
    _8 = copy (self_1).end
    offset_9 = copy (self_1).start
    new_len_7 = move _8 ub.- copy offset_9
    storage_dead(_8)
    storage_live(_10)
    storage_live(_11)
    _10 = cast<*mut [T], *mut T>(copy slice_2)
    _11 = copy _10 offset copy offset_9
    _0 = @PtrFromPartsMut<'_, [T]>(copy _11, copy new_len_7)
    storage_dead(_11)
    storage_dead(_10)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check
fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check(@1: usize, @2: usize, @3: usize)
{
    let _0: (); // return
    let start_1: usize; // arg #1
    let end_2: usize; // arg #2
    let len_3: usize; // arg #3
    let _4: bool; // anonymous local
    let _5: bool; // anonymous local
    let msg_6: &'1 Str; // local
    let _7: !; // anonymous local
    let _8: Arguments<'3>; // anonymous local
    let _9: NonNull<u8>; // anonymous local
    let _10: *const u8; // anonymous local
    let _11: NonNull<Argument<'6>>; // anonymous local
    let _12: usize; // anonymous local
    let _13: usize; // anonymous local
    let _14: usize; // anonymous local
    let _15: *const Str; // anonymous local
    let _16: &'8 [u8]; // anonymous local

    storage_live(msg_6)
    storage_live(_7)
    _0 = ()
    storage_live(_4)
    _4 = copy end_2 >= copy start_1
    if move _4 {
        storage_live(_5)
        _5 = copy end_2 <= copy len_3
        if move _5 {
            storage_dead(_5)
            storage_dead(_4)
            return
        } else {
        }
    } else {
    }
    msg_6 = const "unsafe precondition(s) violated: slice::get_unchecked requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety."
    storage_live(_8)
    storage_live(_9)
    storage_live(_10)
    storage_live(_15)
    _15 = &raw const (*msg_6) with_metadata(copy msg_6.metadata)
    _10 = cast<*const Str, *const u8>(copy _15)
    storage_dead(_15)
    _9 = transmute<*const u8, NonNull<u8>>(copy _10)
    storage_dead(_10)
    storage_live(_11)
    storage_live(_12)
    storage_live(_13)
    storage_live(_14)
    storage_live(_16)
    _16 = transmute<&'11 Str, &'10 [u8]>(const "unsafe precondition(s) violated: slice::get_unchecked requires that the range is within the slice\n\nThis indicates a bug in the program. This Undefined Behavior check is optional, and cannot be relied on for safety.")
    _14 = copy _16.metadata
    storage_dead(_16)
    _13 = move _14 wrap.<< const 1 : i32
    storage_dead(_14)
    _12 = move _13 | const 1 : usize
    storage_dead(_13)
    _11 = transmute<usize, NonNull<Argument<'12>>>(move _12)
    storage_dead(_12)
    _8 = Arguments { 0: move _9, 1: move _11 }
    storage_dead(_11)
    storage_dead(_9)
    _7 = panic_nounwind_fmt<'15>(move _8, const false)
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked
pub unsafe fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: *const [T]) -> *const [T]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: *const [T]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: *const [T]; // arg #2
    let _3: (); // anonymous local
    let _4: usize; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local
    let new_len_7: usize; // local
    let _8: usize; // anonymous local
    let offset_9: usize; // local
    let _10: *const T; // anonymous local
    let _11: *const T; // anonymous local
    let _12: bool; // anonymous local

    storage_live(_3)
    storage_live(new_len_7)
    storage_live(offset_9)
    storage_live(_12)
    _12 = ub_checks<bool>
    if move _12 {
        storage_live(_4)
        _4 = copy (self_1).start
        storage_live(_5)
        _5 = copy (self_1).end
        storage_live(_6)
        _6 = copy slice_2.metadata
        _3 = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked::precondition_check(move _4, move _5, move _6)
        storage_dead(_6)
        storage_dead(_5)
        storage_dead(_4)
    } else {
    }
    storage_live(_8)
    _8 = copy (self_1).end
    offset_9 = copy (self_1).start
    new_len_7 = move _8 ub.- copy offset_9
    storage_dead(_8)
    storage_live(_10)
    storage_live(_11)
    _10 = cast<*const [T], *const T>(copy slice_2)
    _11 = copy _10 offset copy offset_9
    _0 = @PtrFromPartsShared<'_, [T]>(copy _11, copy new_len_7)
    storage_dead(_11)
    storage_dead(_10)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 mut [T]) -> Option<&'_0 mut [T]>[{built_in impl Sized for &'_0 mut [T]}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<&'6 mut [T]>[{built_in impl Sized for &'6 mut [T]}]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'9 mut [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'10 mut [T]; // anonymous local
    let _10: *mut [T]; // anonymous local
    let ptr_11: *mut [T]; // local
    let _12: bool; // anonymous local
    let _13: usize; // anonymous local
    let _14: *mut T; // anonymous local
    let _15: *mut T; // anonymous local
    let _16: Option<&'11 mut [T]>[{built_in impl Sized for &'13 mut [T]}]; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_9)
    storage_live(_3)
    self_4 = copy (self_1).end
    rhs_5 = copy (self_1).start
    storage_live(_12)
    _12 = copy self_4 < copy rhs_5
    if move _12 {
        storage_dead(_12)
        storage_dead(_3)
        storage_live(_16)
        _16 = Option::None {  }
        _0 = move _16
    } else {
        storage_live(_13)
        _13 = copy self_4 ub.- copy rhs_5
        _3 = Option::Some { 0: move _13 }
        storage_dead(_13)
        storage_dead(_12)
        new_len_6 = copy (_3 as variant Option::Some).0
        storage_live(_7)
        storage_live(_8)
        _8 = copy slice_2.metadata
        _7 = copy self_4 <= move _8
        if move _7 {
            storage_dead(_8)
            storage_live(_10)
            storage_live(ptr_11)
            ptr_11 = &raw mut (*slice_2) with_metadata(copy slice_2.metadata)
            storage_live(_14)
            storage_live(_15)
            _14 = cast<*mut [T], *mut T>(copy ptr_11)
            _15 = copy _14 offset copy rhs_5
            _10 = @PtrFromPartsMut<'_, [T]>(copy _15, copy new_len_6)
            storage_dead(_15)
            storage_dead(_14)
            storage_dead(ptr_11)
            _9 = &mut (*_10) with_metadata(copy _10.metadata)
            _0 = Option::Some { 0: copy _9 }
            storage_dead(_10)
            storage_dead(_3)
        } else {
            storage_dead(_8)
            storage_dead(_3)
            storage_live(_16)
            _16 = Option::None {  }
            _0 = move _16
        }
    }
    storage_dead(_7)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get
pub fn {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0, T>(@1: Range<usize>[{built_in impl Sized for usize}], @2: &'_0 [T]) -> Option<&'_0 [T]>[{built_in impl Sized for &'_0 [T]}]
where
    [@TraitClause0]: Sized<T>,
{
    let _0: Option<&'6 [T]>[{built_in impl Sized for &'6 [T]}]; // return
    let self_1: Range<usize>[{built_in impl Sized for usize}]; // arg #1
    let slice_2: &'9 [T]; // arg #2
    let _3: Option<usize>[{built_in impl Sized for usize}]; // anonymous local
    let self_4: usize; // local
    let rhs_5: usize; // local
    let new_len_6: usize; // local
    let _7: bool; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'10 [T]; // anonymous local
    let _10: *const [T]; // anonymous local
    let _11: *const [T]; // anonymous local
    let _12: bool; // anonymous local
    let _13: usize; // anonymous local
    let _14: *const T; // anonymous local
    let _15: *const T; // anonymous local
    let _16: Option<&'11 [T]>[{built_in impl Sized for &'13 [T]}]; // anonymous local

    storage_live(self_4)
    storage_live(rhs_5)
    storage_live(new_len_6)
    storage_live(_9)
    storage_live(_3)
    self_4 = copy (self_1).end
    rhs_5 = copy (self_1).start
    storage_live(_12)
    _12 = copy self_4 < copy rhs_5
    if move _12 {
        storage_dead(_12)
        storage_dead(_3)
        storage_live(_16)
        _16 = Option::None {  }
        _0 = move _16
    } else {
        storage_live(_13)
        _13 = copy self_4 ub.- copy rhs_5
        _3 = Option::Some { 0: move _13 }
        storage_dead(_13)
        storage_dead(_12)
        new_len_6 = copy (_3 as variant Option::Some).0
        storage_live(_7)
        storage_live(_8)
        _8 = copy slice_2.metadata
        _7 = copy self_4 <= move _8
        if move _7 {
            storage_dead(_8)
            storage_live(_10)
            storage_live(_11)
            _11 = &raw const (*slice_2) with_metadata(copy slice_2.metadata)
            storage_live(_14)
            storage_live(_15)
            _14 = cast<*const [T], *const T>(copy _11)
            _15 = copy _14 offset copy rhs_5
            _10 = @PtrFromPartsShared<'_, [T]>(copy _15, copy new_len_6)
            storage_dead(_15)
            storage_dead(_14)
            storage_dead(_11)
            _9 = &(*_10) with_metadata(copy _10.metadata)
            _0 = Option::Some { 0: copy _9 }
            storage_dead(_10)
            storage_dead(_3)
        } else {
            storage_dead(_8)
            storage_dead(_3)
            storage_live(_16)
            _16 = Option::None {  }
            _0 = move _16
        }
    }
    storage_dead(_7)
    return
}

// Full name: core::slice::index::{impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}
impl<T> SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause1 = {impl Sealed for Range<usize>[{built_in impl Sized for usize}]}
    parent_clause2 = {built_in impl MetaSized for [T]}
    parent_clause3 = {built_in impl MetaSized for [T]}
    type Output = [T]
    fn get<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get<'_0_1, T>[@TraitClause0]
    fn get_mut<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_mut<'_0_1, T>[@TraitClause0]
    fn get_unchecked = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked<T>[@TraitClause0]
    fn get_unchecked_mut = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::get_unchecked_mut<T>[@TraitClause0]
    fn index<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index<'_0_1, T>[@TraitClause0]
    fn index_mut<'_0_1> = {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::index_mut<'_0_1, T>[@TraitClause0]
    vtable: {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}::{vtable}<T>[@TraitClause0]
}

// Full name: test_crate::main
fn main()
{
    let _0: (); // return
    let array_1: [i32; 6 : usize]; // local
    let slice_2: &'1 [i32]; // local
    let _3: &'2 [i32]; // anonymous local
    let _4: &'4 [i32; 6 : usize]; // anonymous local
    let _5: Range<usize>[{built_in impl Sized for usize}]; // anonymous local
    let _6: bool; // anonymous local
    let _7: i32; // anonymous local
    let _8: usize; // anonymous local
    let _9: &'_ [i32]; // anonymous local
    let _10: &'_ i32; // anonymous local

    _0 = ()
    storage_live(array_1)
    array_1 = [const 1 : i32, const 2 : i32, const 3 : i32, const 4 : i32, const 5 : i32, const 6 : i32]
    storage_live(slice_2)
    storage_live(_3)
    storage_live(_4)
    _4 = &array_1
    storage_live(_5)
    _5 = Range { start: const 2 : usize, end: const 5 : usize }
    _3 = {impl Index<I> for [T; N]}::index<'6, i32, Range<usize>[{built_in impl Sized for usize}], 6 : usize>[{built_in impl Sized for i32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl Index<I> for [T]}<i32, Range<usize>[{built_in impl Sized for usize}]>[{built_in impl Sized for i32}, {built_in impl Sized for Range<usize>[{built_in impl Sized for usize}]}, {impl SliceIndex<[T]> for Range<usize>[{built_in impl Sized for usize}]}<i32>[{built_in impl Sized for i32}]]](move _4, move _5)
    storage_dead(_5)
    storage_dead(_4)
    slice_2 = &(*_3) with_metadata(copy _3.metadata)
    storage_live(_6)
    storage_live(_7)
    storage_live(_8)
    _8 = const 0 : usize
    storage_live(_9)
    _9 = &(*slice_2) with_metadata(copy slice_2.metadata)
    storage_live(_10)
    _10 = @SliceIndexShared<'_, i32>(move _9, copy _8)
    _7 = copy (*_10)
    _6 = move _7 == const 3 : i32
    if move _6 {
    } else {
        storage_dead(_7)
        storage_dead(_8)
        panic(core::panicking::panic)
    }
    storage_dead(_7)
    storage_dead(_8)
    storage_dead(_6)
    _0 = ()
    storage_dead(_3)
    storage_dead(slice_2)
    storage_dead(array_1)
    return
}



