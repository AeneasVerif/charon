# Final LLBC before serialization:

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 := ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::shift_u32
pub fn shift_u32(@1: u32) -> u32
{
    let _0: u32; // return
    let a_1: u32; // arg #1
    let i_2: usize; // local
    let t_3: u32; // local
    let _4: u32; // anonymous local
    let _5: usize; // anonymous local
    let _6: usize; // anonymous local

    storage_live(i_2)
    i_2 := const (16 : usize)
    storage_live(t_3)
    storage_live(_4)
    _4 := copy (a_1)
    storage_live(_5)
    _5 := copy (i_2)
    t_3 := move (_4) panic.>> move (_5)
    storage_dead(_5)
    storage_dead(_4)
    storage_live(_6)
    _6 := copy (i_2)
    t_3 := copy (t_3) panic.<< move (_6)
    storage_dead(_6)
    _0 := copy (t_3)
    storage_dead(t_3)
    storage_dead(i_2)
    return
}

// Full name: test_crate::shift_i32
pub fn shift_i32(@1: i32) -> i32
{
    let _0: i32; // return
    let a_1: i32; // arg #1
    let i_2: isize; // local
    let t_3: i32; // local
    let _4: i32; // anonymous local
    let _5: isize; // anonymous local
    let _6: isize; // anonymous local

    storage_live(i_2)
    i_2 := const (16 : isize)
    storage_live(t_3)
    storage_live(_4)
    _4 := copy (a_1)
    storage_live(_5)
    _5 := copy (i_2)
    t_3 := move (_4) panic.>> move (_5)
    storage_dead(_5)
    storage_dead(_4)
    storage_live(_6)
    _6 := copy (i_2)
    t_3 := copy (t_3) panic.<< move (_6)
    storage_dead(_6)
    _0 := copy (t_3)
    storage_dead(t_3)
    storage_dead(i_2)
    return
}

// Full name: test_crate::xor_u32
pub fn xor_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let a_1: u32; // arg #1
    let b_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 := copy (a_1)
    storage_live(_4)
    _4 := copy (b_2)
    _0 := move (_3) ^ move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::or_u32
pub fn or_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let a_1: u32; // arg #1
    let b_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 := copy (a_1)
    storage_live(_4)
    _4 := copy (b_2)
    _0 := move (_3) | move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}

// Full name: test_crate::and_u32
pub fn and_u32(@1: u32, @2: u32) -> u32
{
    let _0: u32; // return
    let a_1: u32; // arg #1
    let b_2: u32; // arg #2
    let _3: u32; // anonymous local
    let _4: u32; // anonymous local

    storage_live(_3)
    _3 := copy (a_1)
    storage_live(_4)
    _4 := copy (b_2)
    _0 := move (_3) & move (_4)
    storage_dead(_4)
    storage_dead(_3)
    return
}



