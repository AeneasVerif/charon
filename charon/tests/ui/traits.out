# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::drop::Drop
#[lang_item("drop")]
pub trait Drop<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn drop<'_0> = core::ops::drop::Drop::drop<'_0_0, Self>[Self]
    vtable: core::ops::drop::Drop::{vtable}
}

pub fn core::ops::drop::Drop::drop<'_0, Self>(@1: &'_0 mut (Self))
where
    [@TraitClause0]: Drop<Self>,

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args>[Self]
    non-dyn-compatible
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0> = core::ops::function::FnMut::call_mut<'_0_0, Self, Args>[Self]
    non-dyn-compatible
}

// Full name: core::ops::function::Fn
#[lang_item("r#fn")]
pub trait Fn<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnMut<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call<'_0> = core::ops::function::Fn::call<'_0_0, Self, Args>[Self]
    non-dyn-compatible
}

pub fn core::ops::function::Fn::call<'_0, Self, Args>(@1: &'_0 (Self), @2: Args) -> @TraitClause0::parent_clause1::parent_clause1::Output
where
    [@TraitClause0]: Fn<Self, Args>,

pub fn core::ops::function::FnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut (Self), @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,

pub fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::option::Option::{impl Drop for Option<T>[@TraitClause0]}::drop
fn {impl Drop for Option<T>[@TraitClause0]}::drop<'_0, T>(@1: &'_0 mut (Option<T>[@TraitClause0]))
where
    [@TraitClause0]: Sized<T>,

// Full name: core::option::Option::{impl Drop for Option<T>[@TraitClause0]}
impl<T> Drop for Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = MetaSized<Option<T>[@TraitClause0]>
    fn drop<'_0> = {impl Drop for Option<T>[@TraitClause0]}::drop<'_0_0, T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: test_crate::BoolTrait
pub trait BoolTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn get_bool<'_0> = test_crate::BoolTrait::get_bool<'_0_0, Self>[Self]
    fn ret_true<'_0> = ret_true<'_0_0, Self>[Self]
    vtable: test_crate::BoolTrait::{vtable}
}

pub fn test_crate::BoolTrait::get_bool<'_0, Self>(@1: &'_0 (Self)) -> bool
where
    [@TraitClause0]: BoolTrait<Self>,

// Full name: test_crate::BoolTrait::ret_true
pub fn ret_true<'_0, Self>(@1: &'_0 (Self)) -> bool
where
    [@TraitClause0]: BoolTrait<Self>,
{
    let @0: bool; // return
    let self@1: &'_ (Self); // arg #1

    @0 := const (true)
    return
}

// Full name: test_crate::{impl BoolTrait for bool}::get_bool
pub fn {impl BoolTrait for bool}::get_bool<'_0>(@1: &'_0 (bool)) -> bool
{
    let @0: bool; // return
    let self@1: &'_ (bool); // arg #1

    @0 := copy (*(self@1))
    return
}

pub fn test_crate::{impl BoolTrait for bool}::ret_true<'_0>(@1: &'_0 (bool)) -> bool
{
    let @0: bool; // return
    let self@1: &'_ (bool); // arg #1

    @0 := const (true)
    return
}

// Full name: test_crate::{impl BoolTrait for bool}
impl BoolTrait for bool {
    parent_clause0 = MetaSized<bool>
    fn get_bool<'_0> = {impl BoolTrait for bool}::get_bool<'_0_0>
    fn ret_true<'_0> = test_crate::{impl BoolTrait for bool}::ret_true<'_0_0>
    vtable: {impl BoolTrait for bool}::{vtable}
}

// Full name: test_crate::test_bool_trait_bool
pub fn test_bool_trait_bool(@1: bool) -> bool
{
    let @0: bool; // return
    let x@1: bool; // arg #1
    let @2: bool; // anonymous local
    let @3: &'_ (bool); // anonymous local
    let @4: &'_ (bool); // anonymous local

    storage_live(@4)
    storage_live(@2)
    storage_live(@3)
    @3 := &x@1
    @2 := {impl BoolTrait for bool}::get_bool<'_>(move (@3))
    if move (@2) {
        storage_dead(@3)
        storage_live(@4)
        @4 := &x@1
        @0 := test_crate::{impl BoolTrait for bool}::ret_true<'_>(move (@4))
        storage_dead(@4)
    }
    else {
        storage_dead(@3)
        @0 := const (false)
    }
    storage_dead(@2)
    return
}

// Full name: test_crate::{impl BoolTrait for Option<T>[@TraitClause0]}::get_bool
pub fn {impl BoolTrait for Option<T>[@TraitClause0]}::get_bool<'_0, T>(@1: &'_0 (Option<T>[@TraitClause0])) -> bool
where
    [@TraitClause0]: Sized<T>,
{
    let @0: bool; // return
    let self@1: &'_ (Option<T>[@TraitClause0]); // arg #1

    match *(self@1) {
        Option::None => {
        },
        Option::Some => {
            @0 := const (true)
            return
        },
    }
    @0 := const (false)
    return
}

pub fn test_crate::{impl BoolTrait for Option<T>[@TraitClause0]}::ret_true<'_0, T>(@1: &'_0 (Option<T>[@TraitClause0])) -> bool
where
    [@TraitClause0]: Sized<T>,
{
    let @0: bool; // return
    let self@1: &'_ (Option<T>[@TraitClause0]); // arg #1

    @0 := const (true)
    return
}

// Full name: test_crate::{impl BoolTrait for Option<T>[@TraitClause0]}
impl<T> BoolTrait for Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = MetaSized<Option<T>[@TraitClause0]>
    fn get_bool<'_0> = {impl BoolTrait for Option<T>[@TraitClause0]}::get_bool<'_0_0, T>[@TraitClause0]
    fn ret_true<'_0> = test_crate::{impl BoolTrait for Option<T>[@TraitClause0]}::ret_true<'_0_0, T>[@TraitClause0]
    vtable: {impl BoolTrait for Option<T>[@TraitClause0]}::{vtable}<T>[@TraitClause0]
}

// Full name: test_crate::test_bool_trait_option
pub fn test_bool_trait_option<T>(@1: Option<T>[@TraitClause0]) -> bool
where
    [@TraitClause0]: Sized<T>,
{
    let @0: bool; // return
    let x@1: Option<T>[@TraitClause0]; // arg #1
    let @2: bool; // anonymous local
    let @3: &'_ (Option<T>[@TraitClause0]); // anonymous local
    let @4: &'_ (Option<T>[@TraitClause0]); // anonymous local

    storage_live(@4)
    storage_live(@2)
    storage_live(@3)
    @3 := &x@1
    @2 := {impl BoolTrait for Option<T>[@TraitClause0]}::get_bool<'_, T>[@TraitClause0](move (@3))
    if move (@2) {
        storage_dead(@3)
        storage_live(@4)
        @4 := &x@1
        @0 := test_crate::{impl BoolTrait for Option<T>[@TraitClause0]}::ret_true<'_, T>[@TraitClause0](move (@4))
        storage_dead(@4)
    }
    else {
        storage_dead(@3)
        @0 := const (false)
    }
    storage_dead(@2)
    drop[{impl Drop for Option<T>[@TraitClause0]}<T>[@TraitClause0]] x@1
    return
}

// Full name: test_crate::test_bool_trait
pub fn test_bool_trait<T>(@1: T) -> bool
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: BoolTrait<T>,
{
    let @0: bool; // return
    let x@1: T; // arg #1
    let @2: &'_ (T); // anonymous local

    storage_live(@2)
    @2 := &x@1
    @0 := @TraitClause1::get_bool<'_>(move (@2))
    storage_dead(@2)
    drop[Drop<T>] x@1
    return
}

// Full name: test_crate::ToU64
pub trait ToU64<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn to_u64 = test_crate::ToU64::to_u64<Self>[Self]
    vtable: test_crate::ToU64::{vtable}
}

pub fn test_crate::ToU64::to_u64<Self>(@1: Self) -> u64
where
    [@TraitClause0]: ToU64<Self>,

// Full name: test_crate::{impl ToU64 for u64}::to_u64
pub fn {impl ToU64 for u64}::to_u64(@1: u64) -> u64
{
    let @0: u64; // return
    let self@1: u64; // arg #1

    @0 := copy (self@1)
    return
}

// Full name: test_crate::{impl ToU64 for u64}
impl ToU64 for u64 {
    parent_clause0 = MetaSized<u64>
    fn to_u64 = {impl ToU64 for u64}::to_u64
    vtable: {impl ToU64 for u64}::{vtable}
}

// Full name: test_crate::{impl ToU64 for (A, A)}::to_u64
pub fn {impl ToU64 for (A, A)}::to_u64<A>(@1: (A, A)) -> u64
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: ToU64<A>,
{
    let @0: u64; // return
    let self@1: (A, A); // arg #1
    let @2: u64; // anonymous local
    let @3: A; // anonymous local
    let @4: u64; // anonymous local
    let @5: A; // anonymous local
    let @6: u64; // anonymous local

    storage_live(@6)
    storage_live(@2)
    storage_live(@3)
    @3 := move ((self@1).0)
    @2 := @TraitClause1::to_u64(move (@3))
    storage_dead(@3)
    storage_live(@4)
    storage_live(@5)
    @5 := move ((self@1).1)
    @4 := @TraitClause1::to_u64(move (@5))
    storage_dead(@5)
    @6 := copy (@2) panic.+ copy (@4)
    @0 := move (@6)
    storage_dead(@4)
    storage_dead(@2)
    drop[Drop<(A, A)>] self@1
    return
}

// Full name: test_crate::{impl ToU64 for (A, A)}
impl<A> ToU64 for (A, A)
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: ToU64<A>,
{
    parent_clause0 = MetaSized<(A, A)>
    fn to_u64 = {impl ToU64 for (A, A)}::to_u64<A>[@TraitClause0, @TraitClause1]
    vtable: {impl ToU64 for (A, A)}::{vtable}<A>[@TraitClause0, @TraitClause1]
}

pub fn test_crate::f<T>(@1: (T, T)) -> u64
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    let @0: u64; // return
    let x@1: (T, T); // arg #1
    let @2: (T, T); // anonymous local

    storage_live(@2)
    @2 := move (x@1)
    @0 := {impl ToU64 for (A, A)}::to_u64<T>[@TraitClause0, @TraitClause1](move (@2))
    storage_dead(@2)
    drop[Drop<(T, T)>] x@1
    return
}

// Full name: test_crate::g
pub fn g<T>(@1: (T, T)) -> u64
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<(T, T)>,
{
    let @0: u64; // return
    let x@1: (T, T); // arg #1
    let @2: (T, T); // anonymous local

    storage_live(@2)
    @2 := move (x@1)
    @0 := @TraitClause1::to_u64(move (@2))
    storage_dead(@2)
    drop[Drop<(T, T)>] x@1
    return
}

// Full name: test_crate::h0
pub fn h0(@1: u64) -> u64
{
    let @0: u64; // return
    let x@1: u64; // arg #1
    let @2: u64; // anonymous local

    storage_live(@2)
    @2 := copy (x@1)
    @0 := {impl ToU64 for u64}::to_u64(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::Wrapper
pub struct Wrapper<T>
where
    [@TraitClause0]: Sized<T>,
{
  x: T,
}

// Full name: test_crate::Wrapper::{impl Drop for Wrapper<T>[@TraitClause0]}::drop
fn {impl Drop for Wrapper<T>[@TraitClause0]}::drop<'_0, T>(@1: &'_0 mut (Wrapper<T>[@TraitClause0]))
where
    [@TraitClause0]: Sized<T>,

// Full name: test_crate::Wrapper::{impl Drop for Wrapper<T>[@TraitClause0]}
impl<T> Drop for Wrapper<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = MetaSized<Wrapper<T>[@TraitClause0]>
    fn drop<'_0> = {impl Drop for Wrapper<T>[@TraitClause0]}::drop<'_0_0, T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::{impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64
pub fn {impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64<T>(@1: Wrapper<T>[@TraitClause0]) -> u64
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    let @0: u64; // return
    let self@1: Wrapper<T>[@TraitClause0]; // arg #1
    let @2: T; // anonymous local

    storage_live(@2)
    @2 := move ((self@1).x)
    @0 := @TraitClause1::to_u64(move (@2))
    storage_dead(@2)
    drop[{impl Drop for Wrapper<T>[@TraitClause0]}<T>[@TraitClause0]] self@1
    return
}

// Full name: test_crate::{impl ToU64 for Wrapper<T>[@TraitClause0]}
impl<T> ToU64 for Wrapper<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    parent_clause0 = MetaSized<Wrapper<T>[@TraitClause0]>
    fn to_u64 = {impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64<T>[@TraitClause0, @TraitClause1]
    vtable: {impl ToU64 for Wrapper<T>[@TraitClause0]}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

// Full name: test_crate::h1
pub fn h1(@1: Wrapper<u64>[Sized<u64>]) -> u64
{
    let @0: u64; // return
    let x@1: Wrapper<u64>[Sized<u64>]; // arg #1
    let @2: Wrapper<u64>[Sized<u64>]; // anonymous local

    storage_live(@2)
    @2 := move (x@1)
    @0 := {impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64<u64>[Sized<u64>, {impl ToU64 for u64}](move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::h2
pub fn h2<T>(@1: Wrapper<T>[@TraitClause0]) -> u64
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    let @0: u64; // return
    let x@1: Wrapper<T>[@TraitClause0]; // arg #1
    let @2: Wrapper<T>[@TraitClause0]; // anonymous local

    storage_live(@2)
    @2 := move (x@1)
    @0 := {impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64<T>[@TraitClause0, @TraitClause1](move (@2))
    storage_dead(@2)
    drop[{impl Drop for Wrapper<T>[@TraitClause0]}<T>[@TraitClause0]] x@1
    return
}

// Full name: test_crate::ToType
pub trait ToType<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn to_type = test_crate::ToType::to_type<Self, T>[Self]
    vtable: test_crate::ToType::{vtable}<T>
}

pub fn test_crate::ToType::to_type<Self, T>(@1: Self) -> T
where
    [@TraitClause0]: ToType<Self, T>,

// Full name: test_crate::{impl ToType<bool> for u64}::to_type
pub fn {impl ToType<bool> for u64}::to_type(@1: u64) -> bool
{
    let @0: bool; // return
    let self@1: u64; // arg #1
    let @2: u64; // anonymous local

    storage_live(@2)
    @2 := copy (self@1)
    @0 := move (@2) > const (0 : u64)
    storage_dead(@2)
    return
}

// Full name: test_crate::{impl ToType<bool> for u64}
impl ToType<bool> for u64 {
    parent_clause0 = MetaSized<u64>
    parent_clause1 = Sized<bool>
    fn to_type = {impl ToType<bool> for u64}::to_type
    vtable: {impl ToType<bool> for u64}::{vtable}
}

// Full name: test_crate::OfType
pub trait OfType<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn of_type<T, [@TraitClause0]: Sized<T>, [@TraitClause1]: ToType<T, Self>, [@TraitClause2]: Sized<Self>> = test_crate::OfType::of_type<Self, T>[Self, @TraitClause0_0, @TraitClause0_1, @TraitClause0_2]
    vtable: test_crate::OfType::{vtable}
}

pub fn test_crate::OfType::of_type<Self, T>(@1: T) -> Self
where
    [@TraitClause0]: OfType<Self>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: ToType<T, Self>,
    [@TraitClause3]: Sized<Self>,

// Full name: test_crate::h3
pub fn h3<T1, T2>(@1: T2) -> T1
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
    [@TraitClause2]: OfType<T1>,
    [@TraitClause3]: ToType<T2, T1>,
{
    let @0: T1; // return
    let y@1: T2; // arg #1
    let @2: T2; // anonymous local

    storage_live(@2)
    @2 := move (y@1)
    @0 := @TraitClause2::of_type<T2>[@TraitClause1, @TraitClause3, @TraitClause0](move (@2))
    storage_dead(@2)
    drop[Drop<T2>] y@1
    return
}

// Full name: test_crate::OfTypeBis
pub trait OfTypeBis<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    parent_clause2 : [@TraitClause2]: ToType<T, Self>
    parent_clause3 : [@TraitClause3]: Sized<Self>
    fn of_type<[@TraitClause0]: Sized<Self>> = test_crate::OfTypeBis::of_type<Self, T>[Self, @TraitClause0_0]
    non-dyn-compatible
}

pub fn test_crate::OfTypeBis::of_type<Self, T>(@1: T) -> Self
where
    [@TraitClause0]: OfTypeBis<Self, T>,
    [@TraitClause1]: Sized<Self>,

// Full name: test_crate::h4
pub fn h4<T1, T2>(@1: T2) -> T1
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
    [@TraitClause2]: OfTypeBis<T1, T2>,
    [@TraitClause3]: ToType<T2, T1>,
{
    let @0: T1; // return
    let y@1: T2; // arg #1
    let @2: T2; // anonymous local

    storage_live(@2)
    @2 := move (y@1)
    @0 := @TraitClause2::of_type[@TraitClause0](move (@2))
    storage_dead(@2)
    drop[Drop<T2>] y@1
    return
}

// Full name: test_crate::TestType
pub struct TestType<T>
where
    [@TraitClause0]: Sized<T>,
{
  T,
}

// Full name: test_crate::{TestType<T>[@TraitClause0]}::test::TestType1
struct TestType1 {
  u64,
}

// Full name: test_crate::{TestType<T>[@TraitClause0]}::test::{impl TestTrait for TestType1}::test
fn {impl TestTrait for TestType1}::test<'_0>(@1: &'_0 (TestType1)) -> bool
{
    let @0: bool; // return
    let self@1: &'_ (TestType1); // arg #1
    let @2: u64; // anonymous local

    storage_live(@2)
    @2 := copy ((*(self@1)).0)
    @0 := move (@2) > const (1 : u64)
    storage_dead(@2)
    return
}

pub fn test_crate::{TestType<T>[@TraitClause0]}::test<'_0, T>(@1: &'_0 (TestType<T>[@TraitClause0]), @2: T) -> bool
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    let @0: bool; // return
    let self@1: &'_ (TestType<T>[@TraitClause0]); // arg #1
    let x@2: T; // arg #2
    let x@3: u64; // local
    let @4: T; // anonymous local
    let y@5: TestType1; // local
    let @6: bool; // anonymous local
    let @7: u64; // anonymous local
    let @8: &'_ (TestType1); // anonymous local

    storage_live(@8)
    storage_live(x@3)
    storage_live(@4)
    // Remark: we can't write: impl TestTrait for TestType<T>,
    // we have to use a *local* parameter (can't use the outer T).
    // In other words: the parameters used in the items inside
    // an impl must be bound by the impl block (can't come from outer
    // blocks).
    @4 := move (x@2)
    x@3 := @TraitClause1::to_u64(move (@4))
    storage_dead(@4)
    storage_live(y@5)
    y@5 := TestType1 { 0: const (0 : u64) }
    storage_live(@6)
    storage_live(@7)
    @7 := copy (x@3)
    @6 := move (@7) > const (0 : u64)
    if move (@6) {
        storage_dead(@7)
        storage_live(@8)
        @8 := &y@5
        @0 := {impl TestTrait for TestType1}::test<'_>(move (@8))
        storage_dead(@8)
    }
    else {
        storage_dead(@7)
        @0 := const (false)
    }
    storage_dead(@6)
    storage_dead(y@5)
    storage_dead(x@3)
    drop[Drop<T>] x@2
    return
}

// Full name: test_crate::{TestType<T>[@TraitClause0]}::test::TestTrait
trait TestTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn test<'_0> = test_crate::{TestType<T>[@TraitClause0]}::test::TestTrait::test<'_0_0, Self>[Self]
    vtable: test_crate::{TestType<T>[@TraitClause0]}::test::TestTrait::{vtable}
}

fn test_crate::{TestType<T>[@TraitClause0]}::test::TestTrait::test<'_0, Self>(@1: &'_0 (Self)) -> bool
where
    [@TraitClause0]: TestTrait<Self>,

// Full name: test_crate::{TestType<T>[@TraitClause0]}::test::{impl TestTrait for TestType1}
impl TestTrait for TestType1 {
    parent_clause0 = MetaSized<TestType1>
    fn test<'_0> = {impl TestTrait for TestType1}::test<'_0_0>
    vtable: {impl TestTrait for TestType1}::{vtable}
}

// Full name: test_crate::BoolWrapper
pub struct BoolWrapper {
  bool,
}

// Full name: test_crate::{impl ToType<T> for BoolWrapper}::to_type
pub fn {impl ToType<T> for BoolWrapper}::to_type<T>(@1: BoolWrapper) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToType<bool, T>,
{
    let @0: T; // return
    let self@1: BoolWrapper; // arg #1
    let @2: bool; // anonymous local

    storage_live(@2)
    @2 := copy ((self@1).0)
    @0 := @TraitClause1::to_type(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::{impl ToType<T> for BoolWrapper}
impl<T> ToType<T> for BoolWrapper
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToType<bool, T>,
{
    parent_clause0 = MetaSized<BoolWrapper>
    parent_clause1 = @TraitClause0
    fn to_type = {impl ToType<T> for BoolWrapper}::to_type<T>[@TraitClause0, @TraitClause1]
    vtable: {impl ToType<T> for BoolWrapper}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

// Full name: test_crate::WithConstTy
pub trait WithConstTy<Self, const LEN : usize>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::V>
    parent_clause2 : [@TraitClause2]: Sized<Self::W>
    parent_clause3 : [@TraitClause3]: ToU64<Self::W>
    const LEN1 : usize
    const LEN2 : usize
    type V
    type W
    fn f<'_0, '_1> = test_crate::WithConstTy::f<'_0_0, '_0_1, Self, const LEN : usize>[Self]
    non-dyn-compatible
}

// Full name: test_crate::WithConstTy::LEN2
pub fn LEN2<Self, const LEN : usize>() -> usize
where
    [@TraitClause0]: WithConstTy<Self, const LEN : usize>,
{
    let @0: usize; // return

    @0 := const (32 : usize)
    return
}

// Full name: test_crate::WithConstTy::LEN2
pub const LEN2<Self, const LEN : usize>: usize
where
    [@TraitClause0]: WithConstTy<Self, const LEN : usize>,
 = LEN2()

pub fn test_crate::WithConstTy::f<'_0, '_1, Self, const LEN : usize>(@1: &'_0 mut (@TraitClause0::W), @2: &'_1 (Array<u8, const LEN : usize>))
where
    [@TraitClause0]: WithConstTy<Self, const LEN : usize>,

// Full name: test_crate::{impl WithConstTy<32 : usize> for bool}::LEN1
pub fn LEN1() -> usize
{
    let @0: usize; // return

    @0 := const (12 : usize)
    return
}

// Full name: test_crate::{impl WithConstTy<32 : usize> for bool}::LEN1
pub const LEN1: usize = LEN1()

// Full name: test_crate::{impl WithConstTy<32 : usize> for bool}::f
pub fn {impl WithConstTy<32 : usize> for bool}::f<'_0, '_1>(@1: &'_0 mut (u64), @2: &'_1 (Array<u8, 32 : usize>))
{
    let @0: (); // return
    let @1: &'_ mut (u64); // arg #1
    let @2: &'_ (Array<u8, 32 : usize>); // arg #2

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::{impl WithConstTy<32 : usize> for bool}
impl WithConstTy<32 : usize> for bool {
    parent_clause0 = MetaSized<bool>
    parent_clause1 = Sized<u8>
    parent_clause2 = Sized<u64>
    parent_clause3 = {impl ToU64 for u64}
    const LEN1 = LEN1
    const LEN2 = LEN2<bool, 32 : usize>[{impl WithConstTy<32 : usize> for bool}]
    type V = u8
    type W = u64
    fn f<'_0, '_1> = {impl WithConstTy<32 : usize> for bool}::f<'_0_0, '_0_1>
    non-dyn-compatible
}

// Full name: test_crate::use_with_const_ty1
pub fn use_with_const_ty1<H, const LEN : usize>() -> usize
where
    [@TraitClause0]: Sized<H>,
    [@TraitClause1]: WithConstTy<H, const LEN : usize>,
{
    let @0: usize; // return

    @0 := const (@TraitClause1::LEN1)
    return
}

// Full name: test_crate::use_with_const_ty2
pub fn use_with_const_ty2<H, const LEN : usize>(@1: @TraitClause1::W)
where
    [@TraitClause0]: Sized<H>,
    [@TraitClause1]: WithConstTy<H, const LEN : usize>,
{
    let @0: (); // return
    let @1: @TraitClause1::W; // arg #1

    @0 := ()
    drop[Drop<@TraitClause1::W>] @1
    @0 := ()
    return
}

// Full name: test_crate::use_with_const_ty3
pub fn use_with_const_ty3<H, const LEN : usize>(@1: @TraitClause1::W) -> u64
where
    [@TraitClause0]: Sized<H>,
    [@TraitClause1]: WithConstTy<H, const LEN : usize>,
{
    let @0: u64; // return
    let x@1: @TraitClause1::W; // arg #1
    let @2: @TraitClause1::W; // anonymous local

    storage_live(@2)
    @2 := move (x@1)
    @0 := @TraitClause1::parent_clause3::to_u64(move (@2))
    storage_dead(@2)
    drop[Drop<@TraitClause1::W>] x@1
    return
}

// Full name: test_crate::test_where1
pub fn test_where1<'a, T>(@1: &'a (T))
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
{
    let @0: (); // return
    let _x@1: &'_ (T); // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::test_where2
pub fn test_where2<T>(@1: u32)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: WithConstTy<T, 32 : usize>,
    @TraitClause1::V = u32,
{
    let @0: (); // return
    let _x@1: u32; // arg #1

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::ParentTrait0
pub trait ParentTrait0<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::W>
    type W
    fn get_name<'_0> = get_name<'_0_0, Self>[Self]
    fn get_w<'_0> = test_crate::ParentTrait0::get_w<'_0_0, Self>[Self]
    non-dyn-compatible
}

// Full name: test_crate::ParentTrait0::get_name
pub fn get_name<'_0, Self>(@1: &'_0 (Self)) -> String
where
    [@TraitClause0]: ParentTrait0<Self>,

pub fn test_crate::ParentTrait0::get_w<'_0, Self>(@1: &'_0 (Self)) -> @TraitClause0::W
where
    [@TraitClause0]: ParentTrait0<Self>,

// Full name: test_crate::ParentTrait1
pub trait ParentTrait1<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: test_crate::ParentTrait1::{vtable}
}

// Full name: test_crate::ChildTrait
pub trait ChildTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: ParentTrait0<Self>
    parent_clause2 : [@TraitClause2]: ParentTrait1<Self>
    non-dyn-compatible
}

// Full name: test_crate::test_child_trait1
pub fn test_child_trait1<'_0, T>(@1: &'_0 (T)) -> String
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ChildTrait<T>,
{
    let @0: String; // return
    let x@1: &'_ (T); // arg #1
    let @2: &'_ (T); // anonymous local

    storage_live(@2)
    @2 := &*(x@1)
    @0 := @TraitClause1::parent_clause1::get_name<'_>(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::test_child_trait2
pub fn test_child_trait2<'_0, T>(@1: &'_0 (T)) -> @TraitClause1::parent_clause1::W
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ChildTrait<T>,
{
    let @0: @TraitClause1::parent_clause1::W; // return
    let x@1: &'_ (T); // arg #1
    let @2: &'_ (T); // anonymous local

    storage_live(@2)
    @2 := &*(x@1)
    @0 := @TraitClause1::parent_clause1::get_w<'_>(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::order1
pub fn order1<T, U>()
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: ParentTrait0<T>,
    [@TraitClause3]: ParentTrait0<U>,
    @TraitClause2::W = @TraitClause3::W,
{
    let @0: (); // return

    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::ChildTrait1
pub trait ChildTrait1<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: ParentTrait1<Self>
    vtable: test_crate::ChildTrait1::{vtable}
}

// Full name: test_crate::{impl ParentTrait1 for usize}
impl ParentTrait1 for usize {
    parent_clause0 = MetaSized<usize>
    vtable: {impl ParentTrait1 for usize}::{vtable}
}

// Full name: test_crate::{impl ChildTrait1 for usize}
impl ChildTrait1 for usize {
    parent_clause0 = MetaSized<usize>
    parent_clause1 = {impl ParentTrait1 for usize}
    vtable: {impl ChildTrait1 for usize}::{vtable}
}

// Full name: test_crate::Iterator
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    non-dyn-compatible
}

// Full name: test_crate::IntoIterator
pub trait IntoIterator<Self>
where
    Self::parent_clause3::Item = Self::Item,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: Sized<Self::IntoIter>
    parent_clause3 : [@TraitClause3]: Iterator<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter = into_iter<Self>[Self]
    non-dyn-compatible
}

// Full name: test_crate::IntoIterator::into_iter
pub fn into_iter<Self>(@1: Self) -> @TraitClause0::IntoIter
where
    [@TraitClause0]: IntoIterator<Self>,

// Full name: test_crate::FromResidual
trait FromResidual<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    vtable: test_crate::FromResidual::{vtable}<T>
}

// Full name: test_crate::Try
trait Try<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FromResidual<Self, Self::Residual>
    parent_clause2 : [@TraitClause2]: Sized<Self::Residual>
    type Residual
    non-dyn-compatible
}

// Full name: test_crate::WithTarget
pub trait WithTarget<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Target>
    type Target
    non-dyn-compatible
}

// Full name: test_crate::ParentTrait2
pub trait ParentTrait2<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::U>
    parent_clause2 : [@TraitClause2]: WithTarget<Self::U>
    type U
    non-dyn-compatible
}

// Full name: test_crate::ChildTrait2
pub trait ChildTrait2<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: ParentTrait2<Self>
    fn convert = test_crate::ChildTrait2::convert<Self>[Self]
    non-dyn-compatible
}

pub fn test_crate::ChildTrait2::convert<Self>(@1: @TraitClause0::parent_clause1::U) -> @TraitClause0::parent_clause1::parent_clause2::Target
where
    [@TraitClause0]: ChildTrait2<Self>,

// Full name: test_crate::{impl WithTarget for u32}
impl WithTarget for u32 {
    parent_clause0 = MetaSized<u32>
    parent_clause1 = Sized<u32>
    type Target = u32
    non-dyn-compatible
}

// Full name: test_crate::{impl ParentTrait2 for u32}
impl ParentTrait2 for u32 {
    parent_clause0 = MetaSized<u32>
    parent_clause1 = Sized<u32>
    parent_clause2 = {impl WithTarget for u32}
    type U = u32
    non-dyn-compatible
}

// Full name: test_crate::{impl ChildTrait2 for u32}::convert
pub fn {impl ChildTrait2 for u32}::convert(@1: u32) -> u32
{
    let @0: u32; // return
    let x@1: u32; // arg #1

    @0 := copy (x@1)
    return
}

// Full name: test_crate::{impl ChildTrait2 for u32}
impl ChildTrait2 for u32 {
    parent_clause0 = MetaSized<u32>
    parent_clause1 = {impl ParentTrait2 for u32}
    fn convert = {impl ChildTrait2 for u32}::convert
    non-dyn-compatible
}

// Full name: test_crate::CFnOnce
pub trait CFnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Sized<Self::Output>
    type Output
    fn call_once = test_crate::CFnOnce::call_once<Self, Args>[Self]
    non-dyn-compatible
}

pub fn test_crate::CFnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: CFnOnce<Self, Args>,

// Full name: test_crate::CFnMut
pub trait CFnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: CFnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    fn call_mut<'_0> = test_crate::CFnMut::call_mut<'_0_0, Self, Args>[Self]
    non-dyn-compatible
}

pub fn test_crate::CFnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut (Self), @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: CFnMut<Self, Args>,

// Full name: test_crate::CFn
pub trait CFn<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: CFnMut<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    fn call<'_0> = test_crate::CFn::call<'_0_0, Self, Args>[Self]
    non-dyn-compatible
}

pub fn test_crate::CFn::call<'_0, Self, Args>(@1: &'_0 (Self), @2: Args) -> @TraitClause0::parent_clause1::parent_clause1::Output
where
    [@TraitClause0]: CFn<Self, Args>,

// Full name: test_crate::GetTrait
pub trait GetTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::W>
    type W
    fn get_w<'_0> = test_crate::GetTrait::get_w<'_0_0, Self>[Self]
    non-dyn-compatible
}

pub fn test_crate::GetTrait::get_w<'_0, Self>(@1: &'_0 (Self)) -> @TraitClause0::W
where
    [@TraitClause0]: GetTrait<Self>,

// Full name: test_crate::test_get_trait
pub fn test_get_trait<'_0, T>(@1: &'_0 (T)) -> @TraitClause1::W
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: GetTrait<T>,
{
    let @0: @TraitClause1::W; // return
    let x@1: &'_ (T); // arg #1
    let @2: &'_ (T); // anonymous local

    storage_live(@2)
    @2 := &*(x@1)
    @0 := @TraitClause1::get_w<'_>(move (@2))
    storage_dead(@2)
    return
}

// Full name: test_crate::Trait
pub trait Trait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    const LEN : usize
    non-dyn-compatible
}

// Full name: test_crate::{impl Trait for Array<T, const N : usize>}::LEN
pub fn {impl Trait for Array<T, const N : usize>}::LEN<T, const N : usize>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let @0: usize; // return

    @0 := const (const N : usize)
    return
}

// Full name: test_crate::{impl Trait for Array<T, const N : usize>}::LEN
pub const {impl Trait for Array<T, const N : usize>}::LEN<T, const N : usize>: usize
where
    [@TraitClause0]: Sized<T>,
 = {impl Trait for Array<T, const N : usize>}::LEN()

// Full name: test_crate::{impl Trait for Array<T, const N : usize>}
impl<T, const N : usize> Trait for Array<T, const N : usize>
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = MetaSized<Array<T, const N : usize>>
    const LEN = {impl Trait for Array<T, const N : usize>}::LEN<T, const N : usize>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::{impl Trait for Wrapper<T>[@TraitClause0]}::LEN
pub fn {impl Trait for Wrapper<T>[@TraitClause0]}::LEN<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<T>,
{
    let @0: usize; // return

    @0 := const (0 : usize)
    return
}

// Full name: test_crate::{impl Trait for Wrapper<T>[@TraitClause0]}::LEN
pub const {impl Trait for Wrapper<T>[@TraitClause0]}::LEN<T>: usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<T>,
 = {impl Trait for Wrapper<T>[@TraitClause0]}::LEN()

// Full name: test_crate::{impl Trait for Wrapper<T>[@TraitClause0]}
impl<T> Trait for Wrapper<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<T>,
{
    parent_clause0 = MetaSized<Wrapper<T>[@TraitClause0]>
    const LEN = {impl Trait for Wrapper<T>[@TraitClause0]}::LEN<T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: test_crate::use_wrapper_len
pub fn use_wrapper_len<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<T>,
{
    let @0: usize; // return

    @0 := const ({impl Trait for Wrapper<T>[@TraitClause0]}<T>[@TraitClause0, @TraitClause1]::LEN)
    return
}

// Full name: test_crate::Foo
pub struct Foo<T, U>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
{
  x: T,
  y: U,
}

// Full name: test_crate::{Foo<T, U>[@TraitClause0, @TraitClause1]}::FOO
pub fn FOO<T, U>() -> Result<T, i32>[@TraitClause0, Sized<i32>]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: Trait<T>,
{
    let @0: Result<T, i32>[@TraitClause0, Sized<i32>]; // return

    @0 := Result::Err { 0: const (0 : i32) }
    return
}

// Full name: test_crate::{Foo<T, U>[@TraitClause0, @TraitClause1]}::FOO
pub const FOO<T, U>: Result<T, i32>[@TraitClause0, Sized<i32>]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: Trait<T>,
 = FOO()

// Full name: test_crate::use_foo1
pub fn use_foo1<T, U>() -> Result<T, i32>[@TraitClause0, Sized<i32>]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: Trait<T>,
{
    let @0: Result<T, i32>[@TraitClause0, Sized<i32>]; // return
    let @1: Result<T, i32>[@TraitClause0, Sized<i32>]; // anonymous local

    storage_live(@1)
    @1 := FOO<T, U>[@TraitClause0, @TraitClause1, @TraitClause2]
    @0 := move (@1)
    return
}

// Full name: test_crate::use_foo2
pub fn use_foo2<T, U>() -> Result<U, i32>[@TraitClause1, Sized<i32>]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: Trait<U>,
{
    let @0: Result<U, i32>[@TraitClause1, Sized<i32>]; // return
    let @1: Result<U, i32>[@TraitClause1, Sized<i32>]; // anonymous local

    storage_live(@1)
    @1 := FOO<U, T>[@TraitClause1, @TraitClause0, @TraitClause2]
    @0 := move (@1)
    return
}

// Full name: test_crate::RecursiveImpl
trait RecursiveImpl<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: RecursiveImpl<Self::Item>
    type Item
    non-dyn-compatible
}

// Full name: test_crate::{impl RecursiveImpl for ()}
impl RecursiveImpl for () {
    parent_clause0 = MetaSized<()>
    parent_clause1 = Sized<()>
    parent_clause2 = {impl RecursiveImpl for ()}
    type Item = ()
    non-dyn-compatible
}

// Full name: test_crate::flabada
pub fn flabada<'a>(@1: &'a (())) -> Wrapper<(bool, &'a (()))>[Sized<(bool, &'a (()))>]
{
    let @0: Wrapper<(bool, &'_ (()))>[Sized<(bool, &'_ (()))>]; // return
    let _x@1: &'_ (()); // arg #1

    panic(core::panicking::panic)
}

pub fn test_crate::call<'a, F>(@1: F)
where
    [@TraitClause0]: Sized<F>,
    [@TraitClause1]: Fn<F, (&'a (()))>,
    @TraitClause1::parent_clause1::parent_clause1::Output = Wrapper<(bool, &'a (()))>[Sized<(bool, &'_ (()))>],
{
    let @0: (); // return
    let @1: F; // arg #1

    @0 := ()
    drop[Drop<F>] @1
    @0 := ()
    return
}

// Full name: test_crate::flibidi
pub fn flibidi()
{
    let @0: (); // return
    let @1: (); // anonymous local

    storage_live(@1)
    @1 := test_crate::call<'_, for<'a> flabada<'a>>[Sized<for<'a> flabada<'a>>, Fn<for<'a> flabada<'a>, (&'_ (()))>](const (flabada<'_>))
    storage_dead(@1)
    @0 := ()
    @0 := ()
    return
}

// Full name: test_crate::assoc_ty_trait_ref::SliceIndex
trait SliceIndex<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Output>
    type Output
    non-dyn-compatible
}

// Full name: test_crate::assoc_ty_trait_ref::index
fn index<I>() -> @TraitClause1::Output
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: SliceIndex<I>,
{
    let @0: @TraitClause1::Output; // return

    panic(core::panicking::panic)
}



