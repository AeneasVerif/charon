# Final LLBC before serialization:

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    fn drop_in_place = core::marker::Destruct::drop_in_place<Self>
    vtable: core::marker::Destruct::{vtable}
}

unsafe fn core::marker::Destruct::drop_in_place<Self>(@1: *mut Self)
= <opaque>

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = core::ops::function::FnOnce::call_once<Self, Args>[Self]
    vtable: core::ops::function::FnOnce::{vtable}<Args, Self::Output>
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0_1> = core::ops::function::FnMut::call_mut<'_0_1, Self, Args>[Self]
    vtable: core::ops::function::FnMut::{vtable}<Args, Self::parent_clause1::Output>
}

// Full name: core::ops::function::Fn
#[lang_item("fn")]
pub trait Fn<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnMut<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call<'_0_1> = core::ops::function::Fn::call<'_0_1, Self, Args>[Self]
    vtable: core::ops::function::Fn::{vtable}<Args, Self::parent_clause1::parent_clause1::Output>
}

pub fn core::ops::function::Fn::call<'_0, Self, Args>(@1: &'_0 Self, @2: Args) -> @TraitClause0::parent_clause1::parent_clause1::Output
where
    [@TraitClause0]: Fn<Self, Args>,
= <opaque>

pub fn core::ops::function::FnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut Self, @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,
= <opaque>

pub fn core::ops::function::FnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,
= <opaque>

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::option::Option::{impl Destruct for Option<T>[@TraitClause0]}::drop_in_place
unsafe fn {impl Destruct for Option<T>[@TraitClause0]}::drop_in_place<T>(@1: *mut Option<T>[@TraitClause0])
where
    [@TraitClause0]: Sized<T>,
= <opaque>

// Full name: core::option::Option::{impl Destruct for Option<T>[@TraitClause0]}
impl<T> Destruct for Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    fn drop_in_place = {impl Destruct for Option<T>[@TraitClause0]}::drop_in_place<T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: core::result::Result
#[lang_item("Result")]
pub enum Result<T, E>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<E>,
{
  Ok(T),
  Err(E),
}

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

fn UNIT_METADATA()
{
    let _0: (); // return

    _0 = ()
    return
}

const UNIT_METADATA: () = @Fun0()

// Full name: test_crate::BoolTrait
pub trait BoolTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn get_bool<'_0_1> = test_crate::BoolTrait::get_bool<'_0_1, Self>[Self]
    fn ret_true<'_0_1> = test_crate::BoolTrait::ret_true<'_0_1, Self>[Self]
    vtable: test_crate::BoolTrait::{vtable}
}

// Full name: test_crate::<tuple_2>::{impl Destruct for (A, B)}::drop_in_place
unsafe fn {impl Destruct for (A, B)}::drop_in_place<A, B>(@1: *mut (A, B))
where
    [@TraitClause0]: Sized<A>,
{
    let _0: (); // return
    let _1: *mut (A, B); // arg #1
    let _2: &'1 mut (A, B); // anonymous local

    storage_live(_2)
    _0 = ()
    _2 = &mut (*_1) with_metadata(copy _1.metadata)
    drop[{built_in impl Destruct for A}] (*_2).0
    drop[{built_in impl Destruct for B}] (*_2).1
    return
}

// Full name: test_crate::<tuple_2>::{impl Destruct for (A, B)}
impl<A, B> Destruct for (A, B)
where
    [@TraitClause0]: Sized<A>,
{
    fn drop_in_place = {impl Destruct for (A, B)}::drop_in_place<A, B>[@TraitClause0]
    non-dyn-compatible
}

pub fn test_crate::BoolTrait::get_bool<'_0, Self>(@1: &'_0 Self) -> bool
where
    [@TraitClause0]: BoolTrait<Self>,
= <method_without_default_body>

pub fn test_crate::BoolTrait::ret_true<'_0, Self>(@1: &'_0 Self) -> bool
where
    [@TraitClause0]: BoolTrait<Self>,
{
    let _0: bool; // return
    let self_1: &'1 Self; // arg #1

    _0 = const true
    return
}

// Full name: test_crate::{impl BoolTrait for bool}::get_bool
pub fn {impl BoolTrait for bool}::get_bool<'_0>(@1: &'_0 bool) -> bool
{
    let _0: bool; // return
    let self_1: &'1 bool; // arg #1

    _0 = copy (*self_1)
    return
}

// Full name: test_crate::{impl BoolTrait for bool}::ret_true
pub fn {impl BoolTrait for bool}::ret_true<'_0>(@1: &'_0 bool) -> bool
{
    let _0: bool; // return
    let self_1: &'1 bool; // arg #1

    _0 = const true
    return
}

// Full name: test_crate::{impl BoolTrait for bool}
impl BoolTrait for bool {
    parent_clause0 = {built_in impl MetaSized for bool}
    fn get_bool<'_0_1> = {impl BoolTrait for bool}::get_bool<'_0_1>
    fn ret_true<'_0_1> = {impl BoolTrait for bool}::ret_true<'_0_1>
    vtable: {impl BoolTrait for bool}::{vtable}
}

// Full name: test_crate::test_bool_trait_bool
pub fn test_bool_trait_bool(@1: bool) -> bool
{
    let _0: bool; // return
    let x_1: bool; // arg #1
    let _2: bool; // anonymous local
    let _3: &'1 bool; // anonymous local
    let _4: &'2 bool; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = &x_1
    _2 = {impl BoolTrait for bool}::get_bool<'4>(move _3)
    if move _2 {
        storage_dead(_3)
        storage_live(_4)
        _4 = &x_1
        _0 = {impl BoolTrait for bool}::ret_true<'6>(move _4)
        storage_dead(_4)
    } else {
        storage_dead(_3)
        _0 = const false
    }
    storage_dead(_2)
    return
}

// Full name: test_crate::{impl BoolTrait for Option<T>[@TraitClause0]}::get_bool
pub fn {impl BoolTrait for Option<T>[@TraitClause0]}::get_bool<'_0, T>(@1: &'_0 Option<T>[@TraitClause0]) -> bool
where
    [@TraitClause0]: Sized<T>,
{
    let _0: bool; // return
    let self_1: &'1 Option<T>[@TraitClause0]; // arg #1

    match (*self_1) {
        Option::None => {
        },
        Option::Some => {
            _0 = const true
            return
        },
    }
    _0 = const false
    return
}

// Full name: test_crate::{impl BoolTrait for Option<T>[@TraitClause0]}::ret_true
pub fn {impl BoolTrait for Option<T>[@TraitClause0]}::ret_true<'_0, T>(@1: &'_0 Option<T>[@TraitClause0]) -> bool
where
    [@TraitClause0]: Sized<T>,
{
    let _0: bool; // return
    let self_1: &'1 Option<T>[@TraitClause0]; // arg #1

    _0 = const true
    return
}

// Full name: test_crate::{impl BoolTrait for Option<T>[@TraitClause0]}
impl<T> BoolTrait for Option<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for Option<T>[@TraitClause0]}
    fn get_bool<'_0_1> = {impl BoolTrait for Option<T>[@TraitClause0]}::get_bool<'_0_1, T>[@TraitClause0]
    fn ret_true<'_0_1> = {impl BoolTrait for Option<T>[@TraitClause0]}::ret_true<'_0_1, T>[@TraitClause0]
    vtable: {impl BoolTrait for Option<T>[@TraitClause0]}::{vtable}<T>[@TraitClause0]
}

// Full name: test_crate::test_bool_trait_option
pub fn test_bool_trait_option<T>(@1: Option<T>[@TraitClause0]) -> bool
where
    [@TraitClause0]: Sized<T>,
{
    let _0: bool; // return
    let x_1: Option<T>[@TraitClause0]; // arg #1
    let _2: bool; // anonymous local
    let _3: &'1 Option<T>[@TraitClause0]; // anonymous local
    let _4: &'2 Option<T>[@TraitClause0]; // anonymous local

    storage_live(_2)
    storage_live(_3)
    _3 = &x_1
    _2 = {impl BoolTrait for Option<T>[@TraitClause0]}::get_bool<'4, T>[@TraitClause0](move _3)
    if move _2 {
        storage_dead(_3)
        storage_live(_4)
        _4 = &x_1
        _0 = {impl BoolTrait for Option<T>[@TraitClause0]}::ret_true<'6, T>[@TraitClause0](move _4)
        storage_dead(_4)
    } else {
        storage_dead(_3)
        _0 = const false
    }
    storage_dead(_2)
    conditional_drop[{impl Destruct for Option<T>[@TraitClause0]}<T>[@TraitClause0]] x_1
    return
}

// Full name: test_crate::test_bool_trait
pub fn test_bool_trait<T>(@1: T) -> bool
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: BoolTrait<T>,
{
    let _0: bool; // return
    let x_1: T; // arg #1
    let _2: &'1 T; // anonymous local

    storage_live(_2)
    _2 = &x_1
    _0 = @TraitClause1::get_bool<'3>(move _2)
    storage_dead(_2)
    conditional_drop[{built_in impl Destruct for T}] x_1
    return
}

// Full name: test_crate::ToU64
pub trait ToU64<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn to_u64 = test_crate::ToU64::to_u64<Self>[Self]
    vtable: test_crate::ToU64::{vtable}
}

pub fn test_crate::ToU64::to_u64<Self>(@1: Self) -> u64
where
    [@TraitClause0]: ToU64<Self>,
= <method_without_default_body>

// Full name: test_crate::{impl ToU64 for u64}::to_u64
pub fn {impl ToU64 for u64}::to_u64(@1: u64) -> u64
{
    let _0: u64; // return
    let self_1: u64; // arg #1

    _0 = copy self_1
    return
}

// Full name: test_crate::{impl ToU64 for u64}
impl ToU64 for u64 {
    parent_clause0 = {built_in impl MetaSized for u64}
    fn to_u64 = {impl ToU64 for u64}::to_u64
    vtable: {impl ToU64 for u64}::{vtable}
}

// Full name: test_crate::{impl ToU64 for (A, A)}::to_u64
pub fn {impl ToU64 for (A, A)}::to_u64<A>(@1: (A, A)) -> u64
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: ToU64<A>,
{
    let _0: u64; // return
    let self_1: (A, A); // arg #1
    let _2: u64; // anonymous local
    let _3: A; // anonymous local
    let _4: u64; // anonymous local
    let _5: A; // anonymous local
    let _6: u64; // anonymous local

    storage_live(_6)
    storage_live(_2)
    storage_live(_3)
    _3 = move self_1.0
    _2 = @TraitClause1::to_u64(move _3)
    storage_dead(_3)
    storage_live(_4)
    storage_live(_5)
    _5 = move self_1.1
    _4 = @TraitClause1::to_u64(move _5)
    storage_dead(_5)
    _6 = copy _2 panic.+ copy _4
    _0 = move _6
    storage_dead(_4)
    storage_dead(_2)
    conditional_drop[{impl Destruct for (A, B)}<A, A>[@TraitClause0]] self_1
    return
}

// Full name: test_crate::{impl ToU64 for (A, A)}
impl<A> ToU64 for (A, A)
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: ToU64<A>,
{
    parent_clause0 = {built_in impl MetaSized for (A, A)}
    fn to_u64 = {impl ToU64 for (A, A)}::to_u64<A>[@TraitClause0, @TraitClause1]
    vtable: {impl ToU64 for (A, A)}::{vtable}<A>[@TraitClause0, @TraitClause1]
}

pub fn test_crate::f<T>(@1: (T, T)) -> u64
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    let _0: u64; // return
    let x_1: (T, T); // arg #1
    let _2: (T, T); // anonymous local

    storage_live(_2)
    _2 = move x_1
    _0 = {impl ToU64 for (A, A)}::to_u64<T>[@TraitClause0, @TraitClause1](move _2)
    storage_dead(_2)
    conditional_drop[{impl Destruct for (A, B)}<T, T>[@TraitClause0]] x_1
    return
}

// Full name: test_crate::g
pub fn g<T>(@1: (T, T)) -> u64
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<(T, T)>,
{
    let _0: u64; // return
    let x_1: (T, T); // arg #1
    let _2: (T, T); // anonymous local

    storage_live(_2)
    _2 = move x_1
    _0 = @TraitClause1::to_u64(move _2)
    storage_dead(_2)
    conditional_drop[{impl Destruct for (A, B)}<T, T>[@TraitClause0]] x_1
    return
}

// Full name: test_crate::h0
pub fn h0(@1: u64) -> u64
{
    let _0: u64; // return
    let x_1: u64; // arg #1
    let _2: u64; // anonymous local

    storage_live(_2)
    _2 = copy x_1
    _0 = {impl ToU64 for u64}::to_u64(move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::Wrapper
pub struct Wrapper<T>
where
    [@TraitClause0]: Sized<T>,
{
  x: T,
}

// Full name: test_crate::Wrapper::{impl Destruct for Wrapper<T>[@TraitClause0]}::drop_in_place
unsafe fn {impl Destruct for Wrapper<T>[@TraitClause0]}::drop_in_place<T>(@1: *mut Wrapper<T>[@TraitClause0])
where
    [@TraitClause0]: Sized<T>,
= <missing>

// Full name: test_crate::Wrapper::{impl Destruct for Wrapper<T>[@TraitClause0]}
impl<T> Destruct for Wrapper<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
{
    fn drop_in_place = {impl Destruct for Wrapper<T>[@TraitClause0]}::drop_in_place<T>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::{impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64
pub fn {impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64<T>(@1: Wrapper<T>[@TraitClause0]) -> u64
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    let _0: u64; // return
    let self_1: Wrapper<T>[@TraitClause0]; // arg #1
    let _2: T; // anonymous local

    storage_live(_2)
    _2 = move (self_1).x
    _0 = @TraitClause1::to_u64(move _2)
    storage_dead(_2)
    conditional_drop[{impl Destruct for Wrapper<T>[@TraitClause0]}<T>[@TraitClause0]] self_1
    return
}

// Full name: test_crate::{impl ToU64 for Wrapper<T>[@TraitClause0]}
impl<T> ToU64 for Wrapper<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    parent_clause0 = {built_in impl MetaSized for Wrapper<T>[@TraitClause0]}
    fn to_u64 = {impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64<T>[@TraitClause0, @TraitClause1]
    vtable: {impl ToU64 for Wrapper<T>[@TraitClause0]}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

// Full name: test_crate::h1
pub fn h1(@1: Wrapper<u64>[{built_in impl Sized for u64}]) -> u64
{
    let _0: u64; // return
    let x_1: Wrapper<u64>[{built_in impl Sized for u64}]; // arg #1
    let _2: Wrapper<u64>[{built_in impl Sized for u64}]; // anonymous local

    storage_live(_2)
    _2 = move x_1
    _0 = {impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64<u64>[{built_in impl Sized for u64}, {impl ToU64 for u64}](move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::h2
pub fn h2<T>(@1: Wrapper<T>[@TraitClause0]) -> u64
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    let _0: u64; // return
    let x_1: Wrapper<T>[@TraitClause0]; // arg #1
    let _2: Wrapper<T>[@TraitClause0]; // anonymous local

    storage_live(_2)
    _2 = move x_1
    _0 = {impl ToU64 for Wrapper<T>[@TraitClause0]}::to_u64<T>[@TraitClause0, @TraitClause1](move _2)
    storage_dead(_2)
    conditional_drop[{impl Destruct for Wrapper<T>[@TraitClause0]}<T>[@TraitClause0]] x_1
    return
}

// Full name: test_crate::ToType
pub trait ToType<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn to_type = test_crate::ToType::to_type<Self, T>[Self]
    vtable: test_crate::ToType::{vtable}<T>
}

pub fn test_crate::ToType::to_type<Self, T>(@1: Self) -> T
where
    [@TraitClause0]: ToType<Self, T>,
= <method_without_default_body>

// Full name: test_crate::{impl ToType<bool> for u64}::to_type
pub fn {impl ToType<bool> for u64}::to_type(@1: u64) -> bool
{
    let _0: bool; // return
    let self_1: u64; // arg #1
    let _2: u64; // anonymous local

    storage_live(_2)
    _2 = copy self_1
    _0 = move _2 > const 0 : u64
    storage_dead(_2)
    return
}

// Full name: test_crate::{impl ToType<bool> for u64}
impl ToType<bool> for u64 {
    parent_clause0 = {built_in impl MetaSized for u64}
    parent_clause1 = {built_in impl Sized for bool}
    fn to_type = {impl ToType<bool> for u64}::to_type
    vtable: {impl ToType<bool> for u64}::{vtable}
}

// Full name: test_crate::OfType
pub trait OfType<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn of_type<T, [@TraitClause0_1]: Sized<T>, [@TraitClause1_1]: ToType<T, Self>, [@TraitClause2_1]: Sized<Self>> = test_crate::OfType::of_type<Self, T>[Self, @TraitClause0_1, @TraitClause1_1, @TraitClause2_1]
    vtable: test_crate::OfType::{vtable}
}

pub fn test_crate::OfType::of_type<Self, T>(@1: T) -> Self
where
    [@TraitClause0]: OfType<Self>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: ToType<T, Self>,
    [@TraitClause3]: Sized<Self>,
= <method_without_default_body>

// Full name: test_crate::h3
pub fn h3<T1, T2>(@1: T2) -> T1
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
    [@TraitClause2]: OfType<T1>,
    [@TraitClause3]: ToType<T2, T1>,
{
    let _0: T1; // return
    let y_1: T2; // arg #1
    let _2: T2; // anonymous local

    storage_live(_2)
    _2 = move y_1
    _0 = @TraitClause2::of_type<T2>[@TraitClause1, @TraitClause3, @TraitClause0](move _2)
    storage_dead(_2)
    conditional_drop[{built_in impl Destruct for T2}] y_1
    return
}

// Full name: test_crate::OfTypeBis
pub trait OfTypeBis<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    parent_clause2 : [@TraitClause2]: ToType<T, Self>
    parent_clause3 : [@TraitClause3]: Sized<Self>
    fn of_type<[@TraitClause0_1]: Sized<Self>> = test_crate::OfTypeBis::of_type<Self, T>[Self, @TraitClause0_1]
    non-dyn-compatible
}

pub fn test_crate::OfTypeBis::of_type<Self, T>(@1: T) -> Self
where
    [@TraitClause0]: OfTypeBis<Self, T>,
    [@TraitClause1]: Sized<Self>,
= <method_without_default_body>

// Full name: test_crate::h4
pub fn h4<T1, T2>(@1: T2) -> T1
where
    [@TraitClause0]: Sized<T1>,
    [@TraitClause1]: Sized<T2>,
    [@TraitClause2]: OfTypeBis<T1, T2>,
    [@TraitClause3]: ToType<T2, T1>,
{
    let _0: T1; // return
    let y_1: T2; // arg #1
    let _2: T2; // anonymous local

    storage_live(_2)
    _2 = move y_1
    _0 = @TraitClause2::of_type[@TraitClause0](move _2)
    storage_dead(_2)
    conditional_drop[{built_in impl Destruct for T2}] y_1
    return
}

// Full name: test_crate::TestType
pub struct TestType<T>
where
    [@TraitClause0]: Sized<T>,
{
  T,
}

// Full name: test_crate::{TestType<T>[@TraitClause0]}::test::TestType1
struct TestType1 {
  u64,
}

// Full name: test_crate::{TestType<T>[@TraitClause0]}::test::{impl TestTrait for TestType1}::test
fn {impl TestTrait for TestType1}::test<'_0>(@1: &'_0 TestType1) -> bool
{
    let _0: bool; // return
    let self_1: &'1 TestType1; // arg #1
    let _2: u64; // anonymous local

    storage_live(_2)
    _2 = copy ((*self_1)).0
    _0 = move _2 > const 1 : u64
    storage_dead(_2)
    return
}

pub fn test_crate::{TestType<T>[@TraitClause0]}::test<'_0, T>(@1: &'_0 TestType<T>[@TraitClause0], @2: T) -> bool
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToU64<T>,
{
    let _0: bool; // return
    let self_1: &'1 TestType<T>[@TraitClause0]; // arg #1
    let x_2: T; // arg #2
    let x_3: u64; // local
    let _4: T; // anonymous local
    let y_5: TestType1; // local
    let _6: bool; // anonymous local
    let _7: u64; // anonymous local
    let _8: &'3 TestType1; // anonymous local

    storage_live(x_3)
    storage_live(_4)
    // Remark: we can't write: impl TestTrait for TestType<T>,
    // we have to use a *local* parameter (can't use the outer T).
    // In other words: the parameters used in the items inside
    // an impl must be bound by the impl block (can't come from outer
    // blocks).
    _4 = move x_2
    x_3 = @TraitClause1::to_u64(move _4)
    storage_dead(_4)
    storage_live(y_5)
    y_5 = TestType1 { 0: const 0 : u64 }
    storage_live(_6)
    storage_live(_7)
    _7 = copy x_3
    _6 = move _7 > const 0 : u64
    if move _6 {
        storage_dead(_7)
        storage_live(_8)
        _8 = &y_5
        _0 = {impl TestTrait for TestType1}::test<'5>(move _8)
        storage_dead(_8)
    } else {
        storage_dead(_7)
        _0 = const false
    }
    storage_dead(_6)
    storage_dead(y_5)
    storage_dead(x_3)
    conditional_drop[{built_in impl Destruct for T}] x_2
    return
}

// Full name: test_crate::{TestType<T>[@TraitClause0]}::test::TestTrait
trait TestTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn test<'_0_1> = test_crate::{TestType<T>[@TraitClause0]}::test::TestTrait::test<'_0_1, Self>[Self]
    vtable: test_crate::{TestType<T>[@TraitClause0]}::test::TestTrait::{vtable}
}

fn test_crate::{TestType<T>[@TraitClause0]}::test::TestTrait::test<'_0, Self>(@1: &'_0 Self) -> bool
where
    [@TraitClause0]: TestTrait<Self>,
= <method_without_default_body>

// Full name: test_crate::{TestType<T>[@TraitClause0]}::test::{impl TestTrait for TestType1}
impl TestTrait for TestType1 {
    parent_clause0 = {built_in impl MetaSized for TestType1}
    fn test<'_0_1> = {impl TestTrait for TestType1}::test<'_0_1>
    vtable: {impl TestTrait for TestType1}::{vtable}
}

// Full name: test_crate::BoolWrapper
pub struct BoolWrapper {
  bool,
}

// Full name: test_crate::{impl ToType<T> for BoolWrapper}::to_type
pub fn {impl ToType<T> for BoolWrapper}::to_type<T>(@1: BoolWrapper) -> T
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToType<bool, T>,
{
    let _0: T; // return
    let self_1: BoolWrapper; // arg #1
    let _2: bool; // anonymous local

    storage_live(_2)
    _2 = copy (self_1).0
    _0 = @TraitClause1::to_type(move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::{impl ToType<T> for BoolWrapper}
impl<T> ToType<T> for BoolWrapper
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ToType<bool, T>,
{
    parent_clause0 = {built_in impl MetaSized for BoolWrapper}
    parent_clause1 = @TraitClause0
    fn to_type = {impl ToType<T> for BoolWrapper}::to_type<T>[@TraitClause0, @TraitClause1]
    vtable: {impl ToType<T> for BoolWrapper}::{vtable}<T>[@TraitClause0, @TraitClause1]
}

// Full name: test_crate::WithConstTy
pub trait WithConstTy<Self, const LEN : usize>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::V>
    parent_clause2 : [@TraitClause2]: Sized<Self::W>
    parent_clause3 : [@TraitClause3]: ToU64<Self::W>
    const LEN1 : usize
    const LEN2 : usize
    type V
    type W
    fn f<'_0_1, '_1_1> = test_crate::WithConstTy::f<'_0_1, '_1_1, Self, LEN>[Self]
    non-dyn-compatible
}

// Full name: test_crate::WithConstTy::LEN2
pub fn LEN2<Self, const LEN : usize>() -> usize
where
    [@TraitClause0]: WithConstTy<Self, LEN>,
{
    let _0: usize; // return

    _0 = const 32 : usize
    return
}

// Full name: test_crate::WithConstTy::LEN2
pub const LEN2<Self, const LEN : usize>: usize
where
    [@TraitClause0]: WithConstTy<Self, LEN>,
 = LEN2()

pub fn test_crate::WithConstTy::f<'_0, '_1, Self, const LEN : usize>(@1: &'_0 mut @TraitClause0::W, @2: &'_1 [u8; LEN])
where
    [@TraitClause0]: WithConstTy<Self, LEN>,
= <method_without_default_body>

// Full name: test_crate::{impl WithConstTy<32 : usize> for bool}::f
pub fn {impl WithConstTy<32 : usize> for bool}::f<'_0, '_1>(@1: &'_0 mut u64, @2: &'_1 [u8; 32 : usize])
{
    let _0: (); // return
    let _1: &'1 mut u64; // arg #1
    let _2: &'3 [u8; 32 : usize]; // arg #2

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::{impl WithConstTy<32 : usize> for bool}::LEN1
pub fn LEN1() -> usize
{
    let _0: usize; // return

    _0 = const 12 : usize
    return
}

// Full name: test_crate::{impl WithConstTy<32 : usize> for bool}::LEN1
pub const LEN1: usize = LEN1()

// Full name: test_crate::{impl WithConstTy<32 : usize> for bool}
impl WithConstTy<32 : usize> for bool {
    parent_clause0 = {built_in impl MetaSized for bool}
    parent_clause1 = {built_in impl Sized for u8}
    parent_clause2 = {built_in impl Sized for u64}
    parent_clause3 = {impl ToU64 for u64}
    const LEN1 = LEN1
    const LEN2 = LEN2<bool, 32 : usize>[{impl WithConstTy<32 : usize> for bool}]
    type V = u8
    type W = u64
    fn f<'_0_1, '_1_1> = {impl WithConstTy<32 : usize> for bool}::f<'_0_1, '_1_1>
    non-dyn-compatible
}

// Full name: test_crate::use_with_const_ty1
pub fn use_with_const_ty1<H, const LEN : usize>() -> usize
where
    [@TraitClause0]: Sized<H>,
    [@TraitClause1]: WithConstTy<H, LEN>,
{
    let _0: usize; // return

    _0 = const @TraitClause1::LEN1
    return
}

// Full name: test_crate::use_with_const_ty2
pub fn use_with_const_ty2<H, const LEN : usize>(@1: @TraitClause1::W)
where
    [@TraitClause0]: Sized<H>,
    [@TraitClause1]: WithConstTy<H, LEN>,
{
    let _0: (); // return
    let _1: @TraitClause1::W; // arg #1

    _0 = ()
    _0 = ()
    conditional_drop[{built_in impl Destruct for @TraitClause1::W}] _1
    return
}

// Full name: test_crate::use_with_const_ty3
pub fn use_with_const_ty3<H, const LEN : usize>(@1: @TraitClause1::W) -> u64
where
    [@TraitClause0]: Sized<H>,
    [@TraitClause1]: WithConstTy<H, LEN>,
{
    let _0: u64; // return
    let x_1: @TraitClause1::W; // arg #1
    let _2: @TraitClause1::W; // anonymous local

    storage_live(_2)
    _2 = move x_1
    _0 = @TraitClause1::parent_clause3::to_u64(move _2)
    storage_dead(_2)
    conditional_drop[{built_in impl Destruct for @TraitClause1::W}] x_1
    return
}

// Full name: test_crate::test_where1
pub fn test_where1<'a, T>(@1: &'a T)
where
    [@TraitClause0]: Sized<T>,
    T : 'a,
{
    let _0: (); // return
    let _x_1: &'1 T; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::test_where2
pub fn test_where2<T>(@1: u32)
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: WithConstTy<T, 32 : usize>,
    @TraitClause1::V = u32,
{
    let _0: (); // return
    let _x_1: u32; // arg #1

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::ParentTrait0
pub trait ParentTrait0<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::W>
    type W
    fn get_name<'_0_1> = get_name<'_0_1, Self>[Self]
    fn get_w<'_0_1> = test_crate::ParentTrait0::get_w<'_0_1, Self>[Self]
    vtable: test_crate::ParentTrait0::{vtable}<Self::W>
}

// Full name: test_crate::ParentTrait0::get_name
pub fn get_name<'_0, Self>(@1: &'_0 Self) -> String
where
    [@TraitClause0]: ParentTrait0<Self>,
= <method_without_default_body>

pub fn test_crate::ParentTrait0::get_w<'_0, Self>(@1: &'_0 Self) -> @TraitClause0::W
where
    [@TraitClause0]: ParentTrait0<Self>,
= <method_without_default_body>

// Full name: test_crate::ParentTrait1
pub trait ParentTrait1<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: test_crate::ParentTrait1::{vtable}
}

// Full name: test_crate::ChildTrait
pub trait ChildTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: ParentTrait0<Self>
    parent_clause2 : [@TraitClause2]: ParentTrait1<Self>
    vtable: test_crate::ChildTrait::{vtable}<Self::parent_clause1::W>
}

// Full name: test_crate::test_child_trait1
pub fn test_child_trait1<'_0, T>(@1: &'_0 T) -> String
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ChildTrait<T>,
{
    let _0: String; // return
    let x_1: &'1 T; // arg #1
    let _2: &'2 T; // anonymous local

    storage_live(_2)
    _2 = &(*x_1)
    _0 = @TraitClause1::parent_clause1::get_name<'4>(move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::test_child_trait2
pub fn test_child_trait2<'_0, T>(@1: &'_0 T) -> @TraitClause1::parent_clause1::W
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: ChildTrait<T>,
{
    let _0: @TraitClause1::parent_clause1::W; // return
    let x_1: &'1 T; // arg #1
    let _2: &'2 T; // anonymous local

    storage_live(_2)
    _2 = &(*x_1)
    _0 = @TraitClause1::parent_clause1::get_w<'4>(move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::order1
pub fn order1<T, U>()
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: ParentTrait0<T>,
    [@TraitClause3]: ParentTrait0<U>,
    @TraitClause2::W = @TraitClause3::W,
{
    let _0: (); // return

    _0 = ()
    _0 = ()
    return
}

// Full name: test_crate::ChildTrait1
pub trait ChildTrait1<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: ParentTrait1<Self>
    vtable: test_crate::ChildTrait1::{vtable}
}

// Full name: test_crate::{impl ParentTrait1 for usize}
impl ParentTrait1 for usize {
    parent_clause0 = {built_in impl MetaSized for usize}
    vtable: {impl ParentTrait1 for usize}::{vtable}
}

// Full name: test_crate::{impl ChildTrait1 for usize}
impl ChildTrait1 for usize {
    parent_clause0 = {built_in impl MetaSized for usize}
    parent_clause1 = {impl ParentTrait1 for usize}
    vtable: {impl ChildTrait1 for usize}::{vtable}
}

// Full name: test_crate::Iterator
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    vtable: test_crate::Iterator::{vtable}<Self::Item>
}

// Full name: test_crate::IntoIterator
pub trait IntoIterator<Self>
where
    Self::parent_clause3::Item = Self::Item,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: Sized<Self::IntoIter>
    parent_clause3 : [@TraitClause3]: Iterator<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter = into_iter<Self>[Self]
    vtable: test_crate::IntoIterator::{vtable}<Self::Item, Self::IntoIter>
}

// Full name: test_crate::IntoIterator::into_iter
pub fn into_iter<Self>(@1: Self) -> @TraitClause0::IntoIter
where
    [@TraitClause0]: IntoIterator<Self>,
= <method_without_default_body>

// Full name: test_crate::FromResidual
trait FromResidual<Self, T>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    vtable: test_crate::FromResidual::{vtable}<T>
}

// Full name: test_crate::Try
trait Try<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FromResidual<Self, Self::Residual>
    parent_clause2 : [@TraitClause2]: Sized<Self::Residual>
    type Residual
    non-dyn-compatible
}

// Full name: test_crate::WithTarget
pub trait WithTarget<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Target>
    type Target
    vtable: test_crate::WithTarget::{vtable}<Self::Target>
}

// Full name: test_crate::ParentTrait2
pub trait ParentTrait2<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::U>
    parent_clause2 : [@TraitClause2]: WithTarget<Self::U>
    type U
    vtable: test_crate::ParentTrait2::{vtable}<Self::U>
}

// Full name: test_crate::ChildTrait2
pub trait ChildTrait2<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: ParentTrait2<Self>
    fn convert = test_crate::ChildTrait2::convert<Self>[Self]
    non-dyn-compatible
}

pub fn test_crate::ChildTrait2::convert<Self>(@1: @TraitClause0::parent_clause1::U) -> @TraitClause0::parent_clause1::parent_clause2::Target
where
    [@TraitClause0]: ChildTrait2<Self>,
= <method_without_default_body>

// Full name: test_crate::{impl WithTarget for u32}
impl WithTarget for u32 {
    parent_clause0 = {built_in impl MetaSized for u32}
    parent_clause1 = {built_in impl Sized for u32}
    type Target = u32
    vtable: {impl WithTarget for u32}::{vtable}
}

// Full name: test_crate::{impl ParentTrait2 for u32}
impl ParentTrait2 for u32 {
    parent_clause0 = {built_in impl MetaSized for u32}
    parent_clause1 = {built_in impl Sized for u32}
    parent_clause2 = {impl WithTarget for u32}
    type U = u32
    vtable: {impl ParentTrait2 for u32}::{vtable}
}

// Full name: test_crate::{impl ChildTrait2 for u32}::convert
pub fn {impl ChildTrait2 for u32}::convert(@1: u32) -> u32
{
    let _0: u32; // return
    let x_1: u32; // arg #1

    _0 = copy x_1
    return
}

// Full name: test_crate::{impl ChildTrait2 for u32}
impl ChildTrait2 for u32 {
    parent_clause0 = {built_in impl MetaSized for u32}
    parent_clause1 = {impl ParentTrait2 for u32}
    fn convert = {impl ChildTrait2 for u32}::convert
    non-dyn-compatible
}

// Full name: test_crate::CFnOnce
pub trait CFnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Sized<Self::Output>
    type Output
    fn call_once = test_crate::CFnOnce::call_once<Self, Args>[Self]
    vtable: test_crate::CFnOnce::{vtable}<Args, Self::Output>
}

pub fn test_crate::CFnOnce::call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: CFnOnce<Self, Args>,
= <method_without_default_body>

// Full name: test_crate::CFnMut
pub trait CFnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: CFnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    fn call_mut<'_0_1> = test_crate::CFnMut::call_mut<'_0_1, Self, Args>[Self]
    vtable: test_crate::CFnMut::{vtable}<Args, Self::parent_clause1::Output>
}

pub fn test_crate::CFnMut::call_mut<'_0, Self, Args>(@1: &'_0 mut Self, @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: CFnMut<Self, Args>,
= <method_without_default_body>

// Full name: test_crate::CFn
pub trait CFn<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: CFnMut<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    fn call<'_0_1> = test_crate::CFn::call<'_0_1, Self, Args>[Self]
    vtable: test_crate::CFn::{vtable}<Args, Self::parent_clause1::parent_clause1::Output>
}

pub fn test_crate::CFn::call<'_0, Self, Args>(@1: &'_0 Self, @2: Args) -> @TraitClause0::parent_clause1::parent_clause1::Output
where
    [@TraitClause0]: CFn<Self, Args>,
= <method_without_default_body>

// Full name: test_crate::GetTrait
pub trait GetTrait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::W>
    type W
    fn get_w<'_0_1> = test_crate::GetTrait::get_w<'_0_1, Self>[Self]
    vtable: test_crate::GetTrait::{vtable}<Self::W>
}

pub fn test_crate::GetTrait::get_w<'_0, Self>(@1: &'_0 Self) -> @TraitClause0::W
where
    [@TraitClause0]: GetTrait<Self>,
= <method_without_default_body>

// Full name: test_crate::test_get_trait
pub fn test_get_trait<'_0, T>(@1: &'_0 T) -> @TraitClause1::W
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: GetTrait<T>,
{
    let _0: @TraitClause1::W; // return
    let x_1: &'1 T; // arg #1
    let _2: &'2 T; // anonymous local

    storage_live(_2)
    _2 = &(*x_1)
    _0 = @TraitClause1::get_w<'4>(move _2)
    storage_dead(_2)
    return
}

// Full name: test_crate::Trait
pub trait Trait<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    const LEN : usize
    non-dyn-compatible
}

// Full name: test_crate::{impl Trait for [T; N]}::LEN
pub fn {impl Trait for [T; N]}::LEN<T, const N : usize>() -> usize
where
    [@TraitClause0]: Sized<T>,
{
    let _0: usize; // return

    _0 = const N
    return
}

// Full name: test_crate::{impl Trait for [T; N]}::LEN
pub const {impl Trait for [T; N]}::LEN<T, const N : usize>: usize
where
    [@TraitClause0]: Sized<T>,
 = {impl Trait for [T; N]}::LEN()

// Full name: test_crate::{impl Trait for [T; N]}
impl<T, const N : usize> Trait for [T; N]
where
    [@TraitClause0]: Sized<T>,
{
    parent_clause0 = {built_in impl MetaSized for [T; N]}
    const LEN = {impl Trait for [T; N]}::LEN<T, N>[@TraitClause0]
    non-dyn-compatible
}

// Full name: test_crate::{impl Trait for Wrapper<T>[@TraitClause0]}::LEN
pub fn {impl Trait for Wrapper<T>[@TraitClause0]}::LEN<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<T>,
{
    let _0: usize; // return

    _0 = const 0 : usize
    return
}

// Full name: test_crate::{impl Trait for Wrapper<T>[@TraitClause0]}::LEN
pub const {impl Trait for Wrapper<T>[@TraitClause0]}::LEN<T>: usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<T>,
 = {impl Trait for Wrapper<T>[@TraitClause0]}::LEN()

// Full name: test_crate::{impl Trait for Wrapper<T>[@TraitClause0]}
impl<T> Trait for Wrapper<T>[@TraitClause0]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<T>,
{
    parent_clause0 = {built_in impl MetaSized for Wrapper<T>[@TraitClause0]}
    const LEN = {impl Trait for Wrapper<T>[@TraitClause0]}::LEN<T>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: test_crate::use_wrapper_len
pub fn use_wrapper_len<T>() -> usize
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Trait<T>,
{
    let _0: usize; // return

    _0 = copy {impl Trait for Wrapper<T>[@TraitClause0]}::LEN<T>[@TraitClause0, @TraitClause1]
    return
}

// Full name: test_crate::Foo
pub struct Foo<T, U>
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
{
  x: T,
  y: U,
}

// Full name: test_crate::{Foo<T, U>[@TraitClause0, @TraitClause1]}::FOO
pub fn FOO<T, U>() -> Result<T, i32>[@TraitClause0, {built_in impl Sized for i32}]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: Trait<T>,
{
    let _0: Result<T, i32>[@TraitClause0, {built_in impl Sized for i32}]; // return

    _0 = Result::Err { 0: const 0 : i32 }
    return
}

// Full name: test_crate::{Foo<T, U>[@TraitClause0, @TraitClause1]}::FOO
pub const FOO<T, U>: Result<T, i32>[@TraitClause0, {built_in impl Sized for i32}]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: Trait<T>,
 = FOO()

// Full name: test_crate::use_foo1
pub fn use_foo1<T, U>() -> Result<T, i32>[@TraitClause0, {built_in impl Sized for i32}]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: Trait<T>,
{
    let _0: Result<T, i32>[@TraitClause0, {built_in impl Sized for i32}]; // return

    _0 = copy FOO<T, U>[@TraitClause0, @TraitClause1, @TraitClause2]
    return
}

// Full name: test_crate::use_foo2
pub fn use_foo2<T, U>() -> Result<U, i32>[@TraitClause1, {built_in impl Sized for i32}]
where
    [@TraitClause0]: Sized<T>,
    [@TraitClause1]: Sized<U>,
    [@TraitClause2]: Trait<U>,
{
    let _0: Result<U, i32>[@TraitClause1, {built_in impl Sized for i32}]; // return

    _0 = copy FOO<U, T>[@TraitClause1, @TraitClause0, @TraitClause2]
    return
}

// Full name: test_crate::RecursiveImpl
trait RecursiveImpl<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: RecursiveImpl<Self::Item>
    type Item
    vtable: test_crate::RecursiveImpl::{vtable}<Self::Item>
}

// Full name: test_crate::{impl RecursiveImpl for ()}
impl RecursiveImpl for () {
    parent_clause0 = {built_in impl MetaSized for ()}
    parent_clause1 = {built_in impl Sized for ()}
    parent_clause2 = {impl RecursiveImpl for ()}
    type Item = ()
    vtable: {impl RecursiveImpl for ()}::{vtable}
}

// Full name: test_crate::flabada
pub fn flabada<'a>(@1: &'a ()) -> Wrapper<(bool, &'a ())>[{built_in impl Sized for (bool, &'a ())}]
{
    let _0: Wrapper<(bool, &'9 ())>[{built_in impl Sized for (bool, &'9 ())}]; // return
    let _x_1: &'12 (); // arg #1

    panic(core::panicking::panic)
}

pub fn test_crate::call<'a, F>(@1: F)
where
    [@TraitClause0]: Sized<F>,
    [@TraitClause1]: Fn<F, (&'a (),)>,
    @TraitClause1::parent_clause1::parent_clause1::Output = Wrapper<(bool, &'a ())>[{built_in impl Sized for (bool, &'_ ())}],
{
    let _0: (); // return
    let _1: F; // arg #1

    _0 = ()
    _0 = ()
    conditional_drop[{built_in impl Destruct for F}] _1
    return
}

// Full name: test_crate::flibidi
pub fn flibidi()
{
    let _0: (); // return
    let _1: (); // anonymous local

    _0 = ()
    storage_live(_1)
    _1 = test_crate::call<'0, for<'a> flabada<'a>>[{built_in impl Sized for for<'a> flabada<'a>}, {built_in impl Fn<(&'0 (),)> for for<'a> flabada<'a>}](const flabada<'92>)
    storage_dead(_1)
    _0 = ()
    return
}

// Full name: test_crate::assoc_ty_trait_ref::SliceIndex
trait SliceIndex<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Output>
    type Output
    vtable: test_crate::assoc_ty_trait_ref::SliceIndex::{vtable}<Self::Output>
}

// Full name: test_crate::assoc_ty_trait_ref::index
fn index<I>() -> @TraitClause1::Output
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: SliceIndex<I>,
{
    let _0: @TraitClause1::Output; // return

    panic(core::panicking::panic)
}



